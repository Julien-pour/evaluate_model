[{"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 12\n\n    The sum of the numbers at indices 2 and 8 is 3 + 9 = 12.\n    Therefore, the function should return [2, 8].\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 12\n\nassert f(*g()) == [2, 8]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 12\n\n    The sum of the numbers at indices 2 and 8 is 3 + 9 = 12.\n    Therefore, the function should return [2, 8].\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 12", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of possible permutations of a string of length n, where each character can be 'A', 'B', or 'C',\n    and no two adjacent characters can be the same.\n\n    Example:\n    n = 3\n\n    The possible permutations are:\n    \"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\".\n    Therefore, the function should return 6.\n    \"\"\"\n\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 6\n    else:\n        return 2 * f(n-1) + f(n-2)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 300, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of possible permutations of a string of length n, where each character can be 'A', 'B', or 'C',\n    and no two adjacent characters can be the same.\n\n    Example:\n    n = 3\n\n    The possible permutations are:\n    \"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\".\n    Therefore, the function should return 6.\n    \"\"\"\n\n    if n == 1:\n        return 3\n    elif n == 2:\n        return 6\n    else:\n        return 2 * f(n-1) + f(n-2)", "solution_func": "def g():\n    return 3", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    The graph contains a cycle from node 0 to node 3.\n    Therefore, the function should return True.\n    \"\"\"\n\n    stack = []\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if visited[node]:\n            return True\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n        stack.pop()\n        return False\n\n    for node in range(len(graph)):\n        if dfs(node):\n            return True\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 300, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    The graph contains a cycle from node 0 to node 3.\n    Therefore, the function should return True.\n    \"\"\"\n\n    stack = []\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if visited[node]:\n            return True\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n        stack.pop()\n        return False\n\n    for node in range(len(graph)):\n        if dfs(node):\n            return True\n\n    return False", "solution_func": "def g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all even numbers whose binary representation has exactly 3 set bits.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: 14\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits (not exactly 3 set bits).\n    - The binary representation of 5 is 0101, which has 2 set bits (not exactly 3 set bits).\n    - The binary representation of 1 is 0001, which has 1 set bit (not exactly 3 set bits).\n    - The binary representation of 8 is 1000, which has 1 set bit (not exactly 3 set bits).\n    - The binary representation of 6 is 0110, which has 2 set bits (not exactly 3 set bits).\n    Therefore, the sum of all even numbers whose binary representation has exactly 3 set bits is 14.\n\n    Note: In this puzzle, the input list is guaranteed to contain at least one even number whose binary representation has exactly 3 set bits.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    even_numbers = [x for x in arr if x % 2 == 0]\n    sum_even_numbers = sum([x for x in even_numbers if count_set_bits(x) == 3])\n    return sum_even_numbers\n\ndef g():\n    arr = [3, 5, 1, 8, 6]\n    return arr\n\nassert f(g()) == 14\n\n", "emb": null, "idx_generation": 300, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all even numbers whose binary representation has exactly 3 set bits.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: 14\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits (not exactly 3 set bits).\n    - The binary representation of 5 is 0101, which has 2 set bits (not exactly 3 set bits).\n    - The binary representation of 1 is 0001, which has 1 set bit (not exactly 3 set bits).\n    - The binary representation of 8 is 1000, which has 1 set bit (not exactly 3 set bits).\n    - The binary representation of 6 is 0110, which has 2 set bits (not exactly 3 set bits).\n    Therefore, the sum of all even numbers whose binary representation has exactly 3 set bits is 14.\n\n    Note: In this puzzle, the input list is guaranteed to contain at least one even number whose binary representation has exactly 3 set bits.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    even_numbers = [x for x in arr if x % 2 == 0]\n    sum_even_numbers = sum([x for x in even_numbers if count_set_bits(x) == 3])\n    return sum_even_numbers", "solution_func": "def g():\n    arr = [3, 5, 1, 8, 6]\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the array in non-decreasing order based on the count of set bits in their binary representation.\n    If two numbers have the same count of set bits, sort them in non-increasing order.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: [5, 3, 1, 8, 6]\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits.\n    - The binary representation of 5 is 0101, which has 2 set bits.\n    - The binary representation of 1 is 0001, which has 1 set bit.\n    - The binary representation of 8 is 1000, which has 1 set bit.\n    - The binary representation of 6 is 0110, which has 2 set bits.\n    Therefore, the sorted array is [5, 3, 1, 8, 6].\n\n    Note: In this puzzle, the input list is guaranteed to contain at least one number with a binary representation having set bits.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    arr.sort(key=lambda x: (count_set_bits(x), -x))\n    return arr\n\ndef g():\n    arr = [3, 5, 1, 8, 6]\n    return arr\n\nassert f(g()) == [5, 3, 1, 8, 6]\n\n", "emb": null, "idx_generation": 300, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the array in non-decreasing order based on the count of set bits in their binary representation.\n    If two numbers have the same count of set bits, sort them in non-increasing order.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: [5, 3, 1, 8, 6]\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits.\n    - The binary representation of 5 is 0101, which has 2 set bits.\n    - The binary representation of 1 is 0001, which has 1 set bit.\n    - The binary representation of 8 is 1000, which has 1 set bit.\n    - The binary representation of 6 is 0110, which has 2 set bits.\n    Therefore, the sorted array is [5, 3, 1, 8, 6].\n\n    Note: In this puzzle, the input list is guaranteed to contain at least one number with a binary representation having set bits.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    arr.sort(key=lambda x: (count_set_bits(x), -x))\n    return arr", "solution_func": "def g():\n    arr = [3, 5, 1, 8, 6]\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers whose binary representation has an even number of set bits.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: 17\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits (even number of set bits).\n    - The binary representation of 5 is 0101, which has 2 set bits (even number of set bits).\n    - The binary representation of 1 is 0001, which has 1 set bit (odd number of set bits).\n    - The binary representation of 8 is 1000, which has 1 set bit (odd number of set bits).\n    - The binary representation of 6 is 0110, which has 2 set bits (even number of set bits).\n    Therefore, the sum of all numbers whose binary representation has an even number of set bits is 17.\n\n    Note: In this puzzle, the input list is guaranteed to contain at least one number whose binary representation has an even number of set bits.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    numbers_with_even_set_bits = [x for x in arr if count_set_bits(x) % 2 == 0]\n    sum_numbers_with_even_set_bits = sum(numbers_with_even_set_bits)\n    return sum_numbers_with_even_set_bits\n\ndef g():\n    arr = [3, 5, 1, 8, 6]\n    return arr\n\nassert f(g()) == 17\n\n", "emb": null, "idx_generation": 300, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers whose binary representation has an even number of set bits.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: 17\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits (even number of set bits).\n    - The binary representation of 5 is 0101, which has 2 set bits (even number of set bits).\n    - The binary representation of 1 is 0001, which has 1 set bit (odd number of set bits).\n    - The binary representation of 8 is 1000, which has 1 set bit (odd number of set bits).\n    - The binary representation of 6 is 0110, which has 2 set bits (even number of set bits).\n    Therefore, the sum of all numbers whose binary representation has an even number of set bits is 17.\n\n    Note: In this puzzle, the input list is guaranteed to contain at least one number whose binary representation has an even number of set bits.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    numbers_with_even_set_bits = [x for x in arr if count_set_bits(x) % 2 == 0]\n    sum_numbers_with_even_set_bits = sum(numbers_with_even_set_bits)\n    return sum_numbers_with_even_set_bits", "solution_func": "def g():\n    arr = [3, 5, 1, 8, 6]\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists two numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, otherwise False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    output: True\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists two numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, otherwise False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    output: True\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n    output: 8\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n    output: 8\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]", "solution_func": "def g() -> int:\n    n = 6\n    return n", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Each step can be either a move down or a move right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    output: 21\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    # Initialize first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Initialize first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    # Calculate maximum sum for each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g()) == 21\n\n", "emb": null, "idx_generation": 300, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    Each step can be either a move down or a move right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    output: 21\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    # Initialize first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Initialize first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    # Calculate maximum sum for each cell\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: [0, 1] (The numbers at indices 0 and 1, i.e. 2 and 7, sum up to 9)\n\n    Hint: Use a stack and dictionary to keep track of the numbers encountered so far.\n    \"\"\"\n\n    num_dict = {}\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[arr[i]] = i\n\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 300, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: [0, 1] (The numbers at indices 0 and 1, i.e. 2 and 7, sum up to 9)\n\n    Hint: Use a stack and dictionary to keep track of the numbers encountered so far.\n    \"\"\"\n\n    num_dict = {}\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[arr[i]] = i\n\n    return []", "solution_func": "def g():\n    return ([2, 7, 11, 15], 9)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 7\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 301, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g():\n    return [1, 2, 3, 4, 5], 7", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of unique paths from top-left to bottom-right in a grid of size n x n.\"\"\"\n    def count_paths(i: int, j: int, memo: dict) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        right_paths = count_paths(i, j+1, memo)\n        down_paths = count_paths(i+1, j, memo)\n        memo[(i, j)] = right_paths + down_paths\n        return memo[(i, j)]\n\n    memo = {}\n    return count_paths(0, 0, memo)\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of unique paths from top-left to bottom-right in a grid of size n x n.\"\"\"\n    def count_paths(i: int, j: int, memo: dict) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        right_paths = count_paths(i, j+1, memo)\n        down_paths = count_paths(i+1, j, memo)\n        memo[(i, j)] = right_paths + down_paths\n        return memo[(i, j)]\n\n    memo = {}\n    return count_paths(0, 0, memo)", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\"\"\"\n    def fibonacci(n: int, memo: dict) -> int:\n        if n <= 1:\n            return n\n        if n in memo:\n            return memo[n]\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)\n\ndef g(n: int = 5):\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\"\"\"\n    def fibonacci(n: int, memo: dict) -> int:\n        if n <= 1:\n            return n\n        if n in memo:\n            return memo[n]\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)", "solution_func": "def g(n: int = 5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of numbers in the array\n    that adds up to the target value.\n\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists a pair of numbers in the array\n    that adds up to the target value.\n\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 9", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, return the topological ordering of the graph.\n\n    The topological ordering is a linear ordering of the vertices such that for every directed edge (u, v),\n    vertex u comes before vertex v in the ordering.\n\n    If the graph is not a directed acyclic graph (DAG), return an empty list.\n\n    Example:\n    graph = [[1], [2, 3], [4], [4], []]\n\n    The topological ordering is [0, 1, 2, 3, 4].\n\n    Therefore, the function should return [0, 1, 2, 3, 4].\n    \"\"\"\n    n = len(graph)\n    indegree = [0] * n\n    for u in range(n):\n        for v in graph[u]:\n            indegree[v] += 1\n    \n    queue = []\n    for u in range(n):\n        if indegree[u] == 0:\n            queue.append(u)\n    \n    order = []\n    while queue:\n        u = queue.pop(0)\n        order.append(u)\n        for v in graph[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    if len(order) != n:\n        return []\n    \n    return order\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representation of a directed graph.\n    \"\"\"\n    return [[1, 2], [3], [], [4], [4]]\n\nassert f(g()) == [0, 1, 2, 3, 4]\n", "emb": null, "idx_generation": 301, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, return the topological ordering of the graph.\n\n    The topological ordering is a linear ordering of the vertices such that for every directed edge (u, v),\n    vertex u comes before vertex v in the ordering.\n\n    If the graph is not a directed acyclic graph (DAG), return an empty list.\n\n    Example:\n    graph = [[1], [2, 3], [4], [4], []]\n\n    The topological ordering is [0, 1, 2, 3, 4].\n\n    Therefore, the function should return [0, 1, 2, 3, 4].\n    \"\"\"\n    n = len(graph)\n    indegree = [0] * n\n    for u in range(n):\n        for v in graph[u]:\n            indegree[v] += 1\n    \n    queue = []\n    for u in range(n):\n        if indegree[u] == 0:\n            queue.append(u)\n    \n    order = []\n    while queue:\n        u = queue.pop(0)\n        order.append(u)\n        for v in graph[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    if len(order) != n:\n        return []\n    \n    return order", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representation of a directed graph.\n    \"\"\"\n    return [[1, 2], [3], [], [4], [4]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, calculate the amount of water that can be trapped\n    between the buildings.\n\n    The width of each building is 1 and the buildings are assumed to be of equal width.\n\n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n\n    The amount of water that can be trapped is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    n = len(heights)\n    if n < 3:\n        return 0\n    \n    left = 0\n    right = n - 1\n    left_max = 0\n    right_max = 0\n    water = 0\n\n    while left < right:\n        if heights[left] < heights[right]:\n            if heights[left] > left_max:\n                left_max = heights[left]\n            else:\n                water += left_max - heights[left]\n            left += 1\n        else:\n            if heights[right] > right_max:\n                right_max = heights[right]\n            else:\n                water += right_max - heights[right]\n            right -= 1\n    \n    return water\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers representing the heights of buildings.\n    \"\"\"\n    return [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, calculate the amount of water that can be trapped\n    between the buildings.\n\n    The width of each building is 1 and the buildings are assumed to be of equal width.\n\n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n\n    The amount of water that can be trapped is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    n = len(heights)\n    if n < 3:\n        return 0\n    \n    left = 0\n    right = n - 1\n    left_max = 0\n    right_max = 0\n    water = 0\n\n    while left < right:\n        if heights[left] < heights[right]:\n            if heights[left] > left_max:\n                left_max = heights[left]\n            else:\n                water += left_max - heights[left]\n            left += 1\n        else:\n            if heights[right] > right_max:\n                right_max = heights[right]\n            else:\n                water += right_max - heights[right]\n            right -= 1\n    \n    return water", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers representing the heights of buildings.\n    \"\"\"\n    return [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors.\n    \"\"\"\n\n    def get_proper_divisors(num):\n        divisors = []\n        for i in range(1, num):\n            if num % i == 0:\n                divisors.append(i)\n        return divisors\n\n    def is_perfect(num):\n        divisors = get_proper_divisors(num)\n        return sum(divisors) == num\n\n    return is_perfect(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that is a perfect number.\n    \"\"\"\n    return 28\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors.\n    \"\"\"\n\n    def get_proper_divisors(num):\n        divisors = []\n        for i in range(1, num):\n            if num % i == 0:\n                divisors.append(i)\n        return divisors\n\n    def is_perfect(num):\n        divisors = get_proper_divisors(num)\n        return sum(divisors) == num\n\n    return is_perfect(n)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n that is a perfect number.\n    \"\"\"\n    return 28", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a binary string s, return the decimal value represented by the string.\n    \"\"\"\n\n    def binary_to_decimal(binary):\n        decimal = 0\n        power = 0\n        for digit in binary[::-1]:\n            decimal += int(digit) * (2 ** power)\n            power += 1\n        return decimal\n\n    return binary_to_decimal(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a binary string s.\n    \"\"\"\n    return \"101101\"\n\nassert f(g()) == 45\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a binary string s, return the decimal value represented by the string.\n    \"\"\"\n\n    def binary_to_decimal(binary):\n        decimal = 0\n        power = 0\n        for digit in binary[::-1]:\n            decimal += int(digit) * (2 ** power)\n            power += 1\n        return decimal\n\n    return binary_to_decimal(s)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a binary string s.\n    \"\"\"\n    return \"101101\"", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s containing only lowercase English letters, return the length of the longest substring with the same letters.\n    \"\"\"\n\n    def longest_same_substring(s):\n        max_length = 0\n        current_length = 0\n        prev_letter = ''\n        for letter in s:\n            if letter == prev_letter:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n                prev_letter = letter\n        return max(max_length, current_length)\n\n    return longest_same_substring(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string s containing only lowercase English letters.\n    \"\"\"\n    return \"aaabbbbbccc\"\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 301, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s containing only lowercase English letters, return the length of the longest substring with the same letters.\n    \"\"\"\n\n    def longest_same_substring(s):\n        max_length = 0\n        current_length = 0\n        prev_letter = ''\n        for letter in s:\n            if letter == prev_letter:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n                prev_letter = letter\n        return max(max_length, current_length)\n\n    return longest_same_substring(s)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string s containing only lowercase English letters.\n    \"\"\"\n    return \"aaabbbbbccc\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, find the maximum sum of a subgrid where the subgrid has a size of at least 2x2.\n\n    Use the Kadane's algorithm to find the maximum subarray sum for each row in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, -1],\n        [-4, 5, 6],\n        [3, -2, 7]\n    ]\n\n    Output: 18\n\n    Explanation: The maximum sum of a subgrid is obtained by selecting the subgrid [5, 6], [-2, 7] with a sum of 18.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for left in range(cols - 1):\n        row_sums = [0] * rows\n\n        for right in range(left + 1, cols):\n            for i in range(rows):\n                row_sums[i] += grid[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, -1],\n        [-4, 5, 6],\n        [3, -2, 7]\n    ]\n\n\nassert f(g()) == 18\n\n", "emb": null, "idx_generation": 301, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, find the maximum sum of a subgrid where the subgrid has a size of at least 2x2.\n\n    Use the Kadane's algorithm to find the maximum subarray sum for each row in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, -1],\n        [-4, 5, 6],\n        [3, -2, 7]\n    ]\n\n    Output: 18\n\n    Explanation: The maximum sum of a subgrid is obtained by selecting the subgrid [5, 6], [-2, 7] with a sum of 18.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for left in range(cols - 1):\n        row_sums = [0] * rows\n\n        for right in range(left + 1, cols):\n            for i in range(rows):\n                row_sums[i] += grid[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 2, -1],\n        [-4, 5, 6],\n        [3, -2, 7]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: True\n    Explanation: The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers such that there exists a pair of numbers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(*g(nums, target)) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: True\n    Explanation: The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers such that there exists a pair of numbers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 6", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of pairs of numbers in the list whose bitwise XOR is equal to 0.\n\n    Example:\n    Input: nums = [1, 1, 2, 2, 3, 3, 4, 4]\n    Output: 4\n\n    Explanation:\n    The pairs (1, 1), (2, 2), (3, 3), and (4, 4) have a bitwise XOR equal to 0.\n    Therefore, there are four pairs whose bitwise XOR is equal to 0.\n    \"\"\"\n    count = 0\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == 0:\n            count += 1\n            left += 1\n            right -= 1\n        elif xor < 0:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers where there exists pairs of numbers in the list whose bitwise XOR is equal to 0.\n    \"\"\"\n    return [1, 1, 2, 2, 3, 3, 4, 4]\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 302, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of pairs of numbers in the list whose bitwise XOR is equal to 0.\n\n    Example:\n    Input: nums = [1, 1, 2, 2, 3, 3, 4, 4]\n    Output: 4\n\n    Explanation:\n    The pairs (1, 1), (2, 2), (3, 3), and (4, 4) have a bitwise XOR equal to 0.\n    Therefore, there are four pairs whose bitwise XOR is equal to 0.\n    \"\"\"\n    count = 0\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == 0:\n            count += 1\n            left += 1\n            right -= 1\n        elif xor < 0:\n            left += 1\n        else:\n            right -= 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers where there exists pairs of numbers in the list whose bitwise XOR is equal to 0.\n    \"\"\"\n    return [1, 1, 2, 2, 3, 3, 4, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next greater element for each element in the list.\n\n    Example:\n    Input: nums = [3, 1, 4, 2, 8, 5, 7, 6]\n    Output: [4, 4, 8, 8, -1, 7, -1, -1]\n\n    Explanation:\n    For each element in the list, the next greater element is the smallest element that comes after it and is greater than it. If there is no such element, the result is -1.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums, where there exists the next greater element for each element in the list.\n    \"\"\"\n    return [3, 1, 4, 2, 8, 5, 7, 6]\n\nassert f(g()) == [4, 4, 8, 8, -1, 7, -1, -1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 302, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next greater element for each element in the list.\n\n    Example:\n    Input: nums = [3, 1, 4, 2, 8, 5, 7, 6]\n    Output: [4, 4, 8, 8, -1, 7, -1, -1]\n\n    Explanation:\n    For each element in the list, the next greater element is the smallest element that comes after it and is greater than it. If there is no such element, the result is -1.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums, where there exists the next greater element for each element in the list.\n    \"\"\"\n    return [3, 1, 4, 2, 8, 5, 7, 6]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there exists a pair of numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums = [1, 3, 5, 7, 9, 11], target = 10):\n    return nums\n\nassert f(g(), 10)\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there exists a pair of numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g(nums = [1, 3, 5, 7, 9, 11], target = 10):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique permutations of the digits from 1 to n (inclusive) where no two consecutive digits are adjacent in the permutation.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 302, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of unique permutations of the digits from 1 to n (inclusive) where no two consecutive digits are adjacent in the permutation.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]", "solution_func": "def g(n = 4):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n    \n    def is_empty(self) -> bool:\n        return len(self.queue) == 0\n    \n    def enqueue(self, item):\n        self.queue.append(item)\n    \n    def dequeue(self):\n        if not self.is_empty():\n            return self.queue.pop(0)\n    \n    def size(self) -> int:\n        return len(self.queue)\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum number in each contiguous subarray of size k.\n    \"\"\"\n    result = []\n    queue = Queue()\n    \n    for i in range(k):\n        while not queue.is_empty() and nums[i] >= nums[queue.queue[-1]]:\n            queue.dequeue()\n        \n        queue.enqueue(i)\n    \n    for i in range(k, len(nums)):\n        result.append(nums[queue.queue[0]])\n        \n        while not queue.is_empty() and queue.queue[0] <= i - k:\n            queue.dequeue()\n        \n        while not queue.is_empty() and nums[i] >= nums[queue.queue[-1]]:\n            queue.dequeue()\n        \n        queue.enqueue(i)\n    \n    result.append(nums[queue.queue[0]])\n    \n    return result\n\ndef g(nums = [1, 3, 2, 4, 5, 7, 6, 8, 9], k = 3):\n    return nums, k\n\nassert f(*g()) == [3, 3, 4, 5, 7, 7, 8, 9]\n", "emb": null, "idx_generation": 302, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n    \n    def is_empty(self) -> bool:\n        return len(self.queue) == 0\n    \n    def enqueue(self, item):\n        self.queue.append(item)\n    \n    def dequeue(self):\n        if not self.is_empty():\n            return self.queue.pop(0)\n    \n    def size(self) -> int:\n        return len(self.queue)\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum number in each contiguous subarray of size k.\n    \"\"\"\n    result = []\n    queue = Queue()\n    \n    for i in range(k):\n        while not queue.is_empty() and nums[i] >= nums[queue.queue[-1]]:\n            queue.dequeue()\n        \n        queue.enqueue(i)\n    \n    for i in range(k, len(nums)):\n        result.append(nums[queue.queue[0]])\n        \n        while not queue.is_empty() and queue.queue[0] <= i - k:\n            queue.dequeue()\n        \n        while not queue.is_empty() and nums[i] >= nums[queue.queue[-1]]:\n            queue.dequeue()\n        \n        queue.enqueue(i)\n    \n    result.append(nums[queue.queue[0]])\n    \n    return result", "solution_func": "def g(nums = [1, 3, 2, 4, 5, 7, 6, 8, 9], k = 3):\n    return nums, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end in the graph.\n\n    Example:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n\n    There exists a path from 'A' to 'E': ['A', 'B', 'D', 'E'].\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 302, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end in the graph.\n\n    Example:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n\n    There exists a path from 'A' to 'E': ['A', 'B', 'D', 'E'].\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)", "solution_func": "def g() -> Tuple[Dict[str, List[str]], str, str]:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a new list of words that match the pattern. A word matches the pattern if it has the same length as the pattern and each character in the word corresponds to a unique character in the pattern.\n\n    Example:\n    words = ['abb', 'abc', 'xyz', 'pqr', 'def']\n    pattern = 'abb'\n\n    The words that match the pattern are: ['abb', 'abc'].\n\n    Therefore, the function should return ['abb', 'abc'].\n    \"\"\"\n    matches = []\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n\n        char_map = {}\n        is_match = True\n\n        for i in range(len(word)):\n            if pattern[i] not in char_map:\n                char_map[pattern[i]] = word[i]\n            elif char_map[pattern[i]] != word[i]:\n                is_match = False\n                break\n\n        if is_match:\n            matches.append(word)\n\n    return matches\n\n\ndef g() -> Tuple[List[str], str]:\n    words = ['abb', 'abc', 'xyz', 'pqr', 'def']\n    pattern = 'abb'\n    return words, pattern\n\n\nassert f(*g()) == ['abb', 'abc']\n\n", "emb": null, "idx_generation": 302, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a new list of words that match the pattern. A word matches the pattern if it has the same length as the pattern and each character in the word corresponds to a unique character in the pattern.\n\n    Example:\n    words = ['abb', 'abc', 'xyz', 'pqr', 'def']\n    pattern = 'abb'\n\n    The words that match the pattern are: ['abb', 'abc'].\n\n    Therefore, the function should return ['abb', 'abc'].\n    \"\"\"\n    matches = []\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n\n        char_map = {}\n        is_match = True\n\n        for i in range(len(word)):\n            if pattern[i] not in char_map:\n                char_map[pattern[i]] = word[i]\n            elif char_map[pattern[i]] != word[i]:\n                is_match = False\n                break\n\n        if is_match:\n            matches.append(word)\n\n    return matches", "solution_func": "def g() -> Tuple[List[str], str]:\n    words = ['abb', 'abc', 'xyz', 'pqr', 'def']\n    pattern = 'abb'\n    return words, pattern", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target word, return a new list of words that can be formed by rearranging the letters of the target word.\n\n    Example:\n    words = ['car', 'arc', 'rat', 'tar', 'cat']\n    target = 'act'\n\n    The words that can be formed from 'act' are: ['car', 'arc', 'cat'].\n\n    Therefore, the function should return ['car', 'arc', 'cat'].\n    \"\"\"\n    target_chars = sorted(list(target))\n    matches = []\n\n    for word in words:\n        if sorted(list(word)) == target_chars:\n            matches.append(word)\n\n    return matches\n\n\ndef g() -> Tuple[List[str], str]:\n    words = ['car', 'arc', 'rat', 'tar', 'cat']\n    target = 'act'\n    return words, target\n\n\nassert f(*g()) == ['car', 'arc', 'cat']\n\n", "emb": null, "idx_generation": 302, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target word, return a new list of words that can be formed by rearranging the letters of the target word.\n\n    Example:\n    words = ['car', 'arc', 'rat', 'tar', 'cat']\n    target = 'act'\n\n    The words that can be formed from 'act' are: ['car', 'arc', 'cat'].\n\n    Therefore, the function should return ['car', 'arc', 'cat'].\n    \"\"\"\n    target_chars = sorted(list(target))\n    matches = []\n\n    for word in words:\n        if sorted(list(word)) == target_chars:\n            matches.append(word)\n\n    return matches", "solution_func": "def g() -> Tuple[List[str], str]:\n    words = ['car', 'arc', 'rat', 'tar', 'cat']\n    target = 'act'\n    return words, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (i, j) such that i < j and nums[i] + nums[j] is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    5\n    Explanation: The distinct pairs (i, j) that satisfy the condition are (0, 2), (0, 5), (1, 3), (1, 4), (3, 5).\n\n    Sample Input:\n    nums = [3, 6, 9, 12, 15]\n\n    Sample Output:\n    10\n    Explanation: The distinct pairs (i, j) that satisfy the condition are (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4).\n\n    \"\"\"\n\n    count = 0\n    freq = [0] * 3\n\n    for num in nums:\n        freq[num % 3] += 1\n\n    count += (freq[0] * (freq[0] - 1)) // 2  # Count pairs with both elements divisible by 3\n    count += freq[1] * freq[2]  # Count pairs with one element divisible by 3 and the other divisible by 1\n    count += (freq[0] * (freq[0] - 1) * (freq[0] - 2)) // 6  # Count pairs with all elements divisible by 3\n\n    return count\n\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return (nums,)\n\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 302, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (i, j) such that i < j and nums[i] + nums[j] is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    5\n    Explanation: The distinct pairs (i, j) that satisfy the condition are (0, 2), (0, 5), (1, 3), (1, 4), (3, 5).\n\n    Sample Input:\n    nums = [3, 6, 9, 12, 15]\n\n    Sample Output:\n    10\n    Explanation: The distinct pairs (i, j) that satisfy the condition are (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4).\n\n    \"\"\"\n\n    count = 0\n    freq = [0] * 3\n\n    for num in nums:\n        freq[num % 3] += 1\n\n    count += (freq[0] * (freq[0] - 1)) // 2  # Count pairs with both elements divisible by 3\n    count += freq[1] * freq[2]  # Count pairs with one element divisible by 3 and the other divisible by 1\n    count += (freq[0] * (freq[0] - 1) * (freq[0] - 2)) // 6  # Count pairs with all elements divisible by 3\n\n    return count", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6]):\n    return (nums,)", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all prime numbers in the list.\n    \n    Example:\n    nums = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    f(nums) => 17\n    Explanation: The prime numbers in the list are 2, 3, 5, and 7. Their sum is 17.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n    \n    return prime_sum\n\ndef g():\n    return ([2, 3, 4, 5, 6, 7, 8, 9, 10],)\n\nassert f(*g()) == 17\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all prime numbers in the list.\n    \n    Example:\n    nums = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    f(nums) => 17\n    Explanation: The prime numbers in the list are 2, 3, 5, and 7. Their sum is 17.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n    \n    return prime_sum", "solution_func": "def g():\n    return ([2, 3, 4, 5, 6, 7, 8, 9, 10],)", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of the first n Fibonacci numbers.\n    \n    Example:\n    n = 5\n    \n    f(n) => 12\n    Explanation: The first 5 Fibonacci numbers are 1, 1, 2, 3, and 5. Their sum is 12.\n    \"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return []\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 1]\n        \n        fib_list = [1, 1]\n        while len(fib_list) < n:\n            fib_list.append(fib_list[-1] + fib_list[-2])\n        \n        return fib_list\n    \n    fib_nums = fibonacci(n)\n    fib_sum = sum(fib_nums)\n    \n    return fib_sum\n\ndef g():\n    return (5,)\n\nassert f(*g()) == 12\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of the first n Fibonacci numbers.\n    \n    Example:\n    n = 5\n    \n    f(n) => 12\n    Explanation: The first 5 Fibonacci numbers are 1, 1, 2, 3, and 5. Their sum is 12.\n    \"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return []\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 1]\n        \n        fib_list = [1, 1]\n        while len(fib_list) < n:\n            fib_list.append(fib_list[-1] + fib_list[-2])\n        \n        return fib_list\n    \n    fib_nums = fibonacci(n)\n    fib_sum = sum(fib_nums)\n    \n    return fib_sum", "solution_func": "def g():\n    return (5,)", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations of numbers in the list that add up to the target.\n    \n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    \n    f(nums, target) => 2\n    Explanation: There are two combinations that add up to 10: [2, 8] and [4, 6].\n    \"\"\"\n    def count_combinations(i, curr_sum):\n        if curr_sum == target:\n            return 1\n        if i >= len(nums) or curr_sum > target:\n            return 0\n        \n        return count_combinations(i+1, curr_sum + nums[i]) + count_combinations(i+1, curr_sum)\n    \n    num_combinations = count_combinations(0, 0)\n    \n    return num_combinations\n\ndef g():\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == 2\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations of numbers in the list that add up to the target.\n    \n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    \n    f(nums, target) => 2\n    Explanation: There are two combinations that add up to 10: [2, 8] and [4, 6].\n    \"\"\"\n    def count_combinations(i, curr_sum):\n        if curr_sum == target:\n            return 1\n        if i >= len(nums) or curr_sum > target:\n            return 0\n        \n        return count_combinations(i+1, curr_sum + nums[i]) + count_combinations(i+1, curr_sum)\n    \n    num_combinations = count_combinations(0, 0)\n    \n    return num_combinations", "solution_func": "def g():\n    return ([2, 4, 6, 8], 10)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum product of any two integers in the array.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5]\n    Output: 20\n\n    Explanation: The maximum product is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 303, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum product of any two integers in the array.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5]\n    Output: 20\n\n    Explanation: The maximum product is 4 * 5 = 20.\n    \"\"\"\n\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the smallest absolute difference between them.\n    Return the two numbers in ascending order.\n\n    Example:\n    Input: arr = [4, 2, 1, 3, 5]\n    Output: [2, 3]\n\n    Explanation: The two numbers with the smallest absolute difference are 2 and 3.\n    \"\"\"\n\n    arr.sort()\n    min_diff = float('inf')\n    result = []\n\n    for i in range(1, len(arr)):\n        diff = abs(arr[i] - arr[i-1])\n        if diff < min_diff:\n            min_diff = diff\n            result = [arr[i-1], arr[i]]\n\n    return result\n\ndef g():\n    return [4, 2, 1, 3, 5]\n\nassert f(g()) == [2, 3]\n\n", "emb": null, "idx_generation": 303, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the smallest absolute difference between them.\n    Return the two numbers in ascending order.\n\n    Example:\n    Input: arr = [4, 2, 1, 3, 5]\n    Output: [2, 3]\n\n    Explanation: The two numbers with the smallest absolute difference are 2 and 3.\n    \"\"\"\n\n    arr.sort()\n    min_diff = float('inf')\n    result = []\n\n    for i in range(1, len(arr)):\n        diff = abs(arr[i] - arr[i-1])\n        if diff < min_diff:\n            min_diff = diff\n            result = [arr[i-1], arr[i]]\n\n    return result", "solution_func": "def g():\n    return [4, 2, 1, 3, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any submatrix.\n    A submatrix is defined as a contiguous subregion of the matrix.\n\n    Example:\n    Input: matrix = [\n        [1, 2, -1],\n        [-3, 4, 2],\n        [5, 6, 0]\n    ]\n    Output: 14\n\n    Explanation: The submatrix with the maximum sum is:\n    [\n        [4, 2],\n        [6, 0]\n    ]\n    The sum of the submatrix is 4 + 2 + 6 + 0 = 12.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    max_sum = float('-inf')\n\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    submatrix_sum = 0\n                    for row in range(i, k+1):\n                        for col in range(j, l+1):\n                            submatrix_sum += matrix[row][col]\n                    max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum\n\ndef g():\n    return [\n        [1, 2, -1],\n        [-3, 4, 2],\n        [5, 6, 0]\n    ]\n\nassert f(g()) == 14\n\n", "emb": null, "idx_generation": 303, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any submatrix.\n    A submatrix is defined as a contiguous subregion of the matrix.\n\n    Example:\n    Input: matrix = [\n        [1, 2, -1],\n        [-3, 4, 2],\n        [5, 6, 0]\n    ]\n    Output: 14\n\n    Explanation: The submatrix with the maximum sum is:\n    [\n        [4, 2],\n        [6, 0]\n    ]\n    The sum of the submatrix is 4 + 2 + 6 + 0 = 12.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    max_sum = float('-inf')\n\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    submatrix_sum = 0\n                    for row in range(i, k+1):\n                        for col in range(j, l+1):\n                            submatrix_sum += matrix[row][col]\n                    max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [\n        [1, 2, -1],\n        [-3, 4, 2],\n        [5, 6, 0]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and end, determine if there is a path from\n    start to end in the graph.\n    \"\"\"\n    visited = set()  # Set to keep track of visited nodes\n\n    def dfs(node):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    return dfs(start)\n\ndef g(graph=[[1, 2], [3], [4], [], []], start=0, end=4):\n    # DFS traversal\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\nassert f(g())\n", "emb": null, "idx_generation": 303, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and end, determine if there is a path from\n    start to end in the graph.\n    \"\"\"\n    visited = set()  # Set to keep track of visited nodes\n\n    def dfs(node):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    return dfs(start)", "solution_func": "def g(graph=[[1, 2], [3], [4], [], []], start=0, end=4):\n    # DFS traversal\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers from 1 to n.\n    \"\"\"\n    combinations = []\n\n    def backtrack(start, curr_combination):\n        if len(curr_combination) == k:\n            combinations.append(curr_combination.copy())\n            return\n        for i in range(start, n + 1):\n            curr_combination.append(i)\n            backtrack(i + 1, curr_combination)\n            curr_combination.pop()\n\n    backtrack(1, [])\n    return combinations\n\ndef g(n=4, k=2):\n    # Using bit manipulation to generate combinations\n    combinations = []\n    for i in range(1 << n):\n        if bin(i).count('1') == k:\n            combination = [j + 1 for j in range(n) if (i >> j) & 1]\n            combinations.append(combination)\n    return combinations\n\nassert f(g())\n", "emb": null, "idx_generation": 303, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers from 1 to n.\n    \"\"\"\n    combinations = []\n\n    def backtrack(start, curr_combination):\n        if len(curr_combination) == k:\n            combinations.append(curr_combination.copy())\n            return\n        for i in range(start, n + 1):\n            curr_combination.append(i)\n            backtrack(i + 1, curr_combination)\n            curr_combination.pop()\n\n    backtrack(1, [])\n    return combinations", "solution_func": "def g(n=4, k=2):\n    # Using bit manipulation to generate combinations\n    combinations = []\n    for i in range(1 << n):\n        if bin(i).count('1') == k:\n            combination = [j + 1 for j in range(n) if (i >> j) & 1]\n            combinations.append(combination)\n    return combinations", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target number, find the minimum number of operations required to make all numbers\n    in the list equal to the target number. Each operation involves either adding or subtracting 1 from a number.\n    \"\"\"\n    total_ops = 0\n    for num in nums:\n        diff = abs(num - target)\n        total_ops += diff\n    return total_ops\n\ndef g(nums=[3, 2, 5, 4, 1], target=2):\n    # Using dynamic programming to find the minimum number of operations\n    n = len(nums)\n    dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - nums[i - 1]] + 1)\n            if j + nums[i - 1] <= target:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j + nums[i - 1]] + 1)\n    return dp[n][target]\n\nassert f(g())\n", "emb": null, "idx_generation": 303, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target number, find the minimum number of operations required to make all numbers\n    in the list equal to the target number. Each operation involves either adding or subtracting 1 from a number.\n    \"\"\"\n    total_ops = 0\n    for num in nums:\n        diff = abs(num - target)\n        total_ops += diff\n    return total_ops", "solution_func": "def g(nums=[3, 2, 5, 4, 1], target=2):\n    # Using dynamic programming to find the minimum number of operations\n    n = len(nums)\n    dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - nums[i - 1]] + 1)\n            if j + nums[i - 1] <= target:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j + nums[i - 1]] + 1)\n    return dp[n][target]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, return all pairs of numbers that sum up to k.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 7\n\n    Sample output:\n    [[1, 6], [2, 5], [3, 4]]\n\n    Explanation:\n    The pairs that sum up to 7 are [1, 6], [2, 5], and [3, 4].\n    \"\"\"\n    pairs = []\n    seen = set()\n\n    for num in nums:\n        complement = k - num\n        if complement in seen:\n            pairs.append([complement, num])\n        seen.add(num)\n\n    return pairs\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 7\n    return [nums, k]\n\nassert f(*g()) == [[1, 6], [2, 5], [3, 4]]\n", "emb": null, "idx_generation": 303, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, return all pairs of numbers that sum up to k.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 7\n\n    Sample output:\n    [[1, 6], [2, 5], [3, 4]]\n\n    Explanation:\n    The pairs that sum up to 7 are [1, 6], [2, 5], and [3, 4].\n    \"\"\"\n    pairs = []\n    seen = set()\n\n    for num in nums:\n        complement = k - num\n        if complement in seen:\n            pairs.append([complement, num])\n        seen.add(num)\n\n    return pairs", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 7\n    return [nums, k]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique subsets that can be formed from the elements of nums.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The subsets that can be formed from [1, 2, 3] are:\n    [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]\n\n    Therefore, the function should return 8.\n\n    Note:\n    - The input list nums may contain duplicates.\n    - The subsets should be unique, meaning that the same subset should not be counted multiple times.\n    \"\"\"\n    def backtrack(start, curr):\n        nonlocal count\n        count.add(tuple(curr))\n        for i in range(start, len(nums)):\n            backtrack(i + 1, curr + [nums[i]])\n\n    count = set()\n    backtrack(0, [])\n    return len(count)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == 8\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique subsets that can be formed from the elements of nums.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The subsets that can be formed from [1, 2, 3] are:\n    [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]\n\n    Therefore, the function should return 8.\n\n    Note:\n    - The input list nums may contain duplicates.\n    - The subsets should be unique, meaning that the same subset should not be counted multiple times.\n    \"\"\"\n    def backtrack(start, curr):\n        nonlocal count\n        count.add(tuple(curr))\n        for i in range(start, len(nums)):\n            backtrack(i + 1, curr + [nums[i]])\n\n    count = set()\n    backtrack(0, [])\n    return len(count)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, 2, 3]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import Any, List\n\nclass TreeNode:\n    def __init__(self, val: Any = 0, left: \"TreeNode\" = None, right: \"TreeNode\" = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum sum of any path in the tree.\n    A path is a sequence of nodes in the tree where no node is visited more than once.\n    The path does not necessarily need to go through the root.\n\n    Example:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n\n    The maximum sum of any path in the tree is 6 (the path is [2, 1, 3]).\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def max_path_sum_helper(node: TreeNode) -> int:\n        nonlocal max_sum\n        if not node:\n            return 0\n\n        left_sum = max(0, max_path_sum_helper(node.left))\n        right_sum = max(0, max_path_sum_helper(node.right))\n\n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n\n        return node.val + max(left_sum, right_sum)\n\n    max_sum = float(\"-inf\")\n    max_path_sum_helper(root)\n    return max_sum\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree with TreeNode objects.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import Any, List\n\nclass TreeNode:\n    def __init__(self, val: Any = 0, left: \"TreeNode\" = None, right: \"TreeNode\" = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum sum of any path in the tree.\n    A path is a sequence of nodes in the tree where no node is visited more than once.\n    The path does not necessarily need to go through the root.\n\n    Example:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n\n    The maximum sum of any path in the tree is 6 (the path is [2, 1, 3]).\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def max_path_sum_helper(node: TreeNode) -> int:\n        nonlocal max_sum\n        if not node:\n            return 0\n\n        left_sum = max(0, max_path_sum_helper(node.left))\n        right_sum = max(0, max_path_sum_helper(node.right))\n\n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n\n        return node.val + max(left_sum, right_sum)\n\n    max_sum = float(\"-inf\")\n    max_path_sum_helper(root)\n    return max_sum", "solution_func": "def g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree with TreeNode objects.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcdcba\"\n\n    The string \"abcdcba\" is a palindrome and does not require removing any character.\n\n    Therefore, the function should return True.\n\n    Note:\n    - The input string s will only contain lowercase letters.\n    \"\"\"\n    def is_palindrome(left: int, right: int, count: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if count == 1:\n                    return False\n                return is_palindrome(left + 1, right, count + 1) or is_palindrome(left, right - 1, count + 1)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s) - 1, 0)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return \"abcdcba\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcdcba\"\n\n    The string \"abcdcba\" is a palindrome and does not require removing any character.\n\n    Therefore, the function should return True.\n\n    Note:\n    - The input string s will only contain lowercase letters.\n    \"\"\"\n    def is_palindrome(left: int, right: int, count: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if count == 1:\n                    return False\n                return is_palindrome(left + 1, right, count + 1) or is_palindrome(left, right - 1, count + 1)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s) - 1, 0)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return \"abcdcba\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, determine if the target exists in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the indices of two numbers in the array that add up to the target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\nassert f(g([-2, 1, 2, 4, 7, 11], 13), 13)\n", "emb": null, "idx_generation": 304, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, determine if the target exists in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the indices of two numbers in the array that add up to the target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n\n    return count\n\ndef g(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return a list of prime numbers less than or equal to n.\n    \"\"\"\n    primes = []\n\n    for i in range(2, n + 1):\n        if f(i):\n            primes.append(i)\n\n    return primes\n\nassert f(g(20)) == 8\n", "emb": null, "idx_generation": 304, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n\n    return count", "solution_func": "def g(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return a list of prime numbers less than or equal to n.\n    \"\"\"\n    primes = []\n\n    for i in range(2, n + 1):\n        if f(i):\n            primes.append(i)\n\n    return primes", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return a list of the number of ways to climb to the top of a staircase with i steps, for i in the range [1, n].\n    \"\"\"\n    ways = []\n\n    for i in range(1, n + 1):\n        ways.append(f(i))\n\n    return ways\n\nassert f(g(5)[-1]) == 8\n", "emb": null, "idx_generation": 304, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return a list of the number of ways to climb to the top of a staircase with i steps, for i in the range [1, n].\n    \"\"\"\n    ways = []\n\n    for i in range(1, n + 1):\n        ways.append(f(i))\n\n    return ways", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is a palindrome, and False otherwise.\n    A palindrome is a sequence that reads the same forwards and backwards.\n\n    Sample Input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample Output:\n    True\n    \"\"\"\n\n    # Reverse the list using a stack\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reverse_nums = []\n    while stack:\n        reverse_nums.append(stack.pop())\n\n    # Check if the original list and reversed list are the same\n    return nums == reverse_nums\n\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 304, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is a palindrome, and False otherwise.\n    A palindrome is a sequence that reads the same forwards and backwards.\n\n    Sample Input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample Output:\n    True\n    \"\"\"\n\n    # Reverse the list using a stack\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reverse_nums = []\n    while stack:\n        reverse_nums.append(stack.pop())\n\n    # Check if the original list and reversed list are the same\n    return nums == reverse_nums", "solution_func": "def g():\n    nums = [1, 2, 3, 2, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray within the list.\n    Return the maximum sum.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        # Add the current number to the current sum\n        curr_sum += num\n\n        # If the current sum becomes negative, reset it to 0\n        if curr_sum < 0:\n            curr_sum = 0\n\n        # Update the maximum sum if the current sum is greater\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray within the list.\n    Return the maximum sum.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        # Add the current number to the current sum\n        curr_sum += num\n\n        # If the current sum becomes negative, reset it to 0\n        if curr_sum < 0:\n            curr_sum = 0\n\n        # Update the maximum sum if the current sum is greater\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n    \n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [0, 1]\n    Explanation: The numbers at indices 0 and 1, [2, 7], add up to the target value 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 304, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [0, 1]\n    Explanation: The numbers at indices 0 and 1, [2, 7], add up to the target value 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the bitwise AND of all the elements in the list.\n\n    Example:\n    nums = [5, 6, 7]\n\n    The bitwise AND of 5, 6, and 7 is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    result = nums[0]\n    for num in nums[1:]:\n        result &= num\n    return result\n\ndef g():\n    nums = [5, 6, 7]\n    return (nums,)\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 304, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the bitwise AND of all the elements in the list.\n\n    Example:\n    nums = [5, 6, 7]\n\n    The bitwise AND of 5, 6, and 7 is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    result = nums[0]\n    for num in nums[1:]:\n        result &= num\n    return result", "solution_func": "def g():\n    nums = [5, 6, 7]\n    return (nums,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists a pair of numbers in the list that add up to the target,\n    and False otherwise. You may not use the same element twice.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there exists a pair of numbers that add up to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 4, 7, 3, 9, 2]\ntarget = 6\nassert f(*g(nums, target))\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists a pair of numbers in the list that add up to the target,\n    and False otherwise. You may not use the same element twice.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there exists a pair of numbers that add up to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 4, 7, 3, 9, 2]\ntarget = 6", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int, bit_position: int) -> bool:\n    \"\"\"\n    Given a number and a bit position, return True if the bit at the given position is set (1), and False otherwise.\n    \"\"\"\n    return (num >> bit_position) & 1\n\ndef g(num: int, bit_position: int) -> List[int]:\n    \"\"\"\n    Generate a number and a bit position such that the bit at the given position is set (1).\n    \"\"\"\n    return num, bit_position\n\n# Test case\nnum = 10\nbit_position = 1\nassert f(*g(num, bit_position))\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(num: int, bit_position: int) -> bool:\n    \"\"\"\n    Given a number and a bit position, return True if the bit at the given position is set (1), and False otherwise.\n    \"\"\"\n    return (num >> bit_position) & 1", "solution_func": "def g(num: int, bit_position: int) -> List[int]:\n    \"\"\"\n    Generate a number and a bit position such that the bit at the given position is set (1).\n    \"\"\"\n    return num, bit_position\n\n# Test case\nnum = 10\nbit_position = 1", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(stack: List[int], target: int) -> bool:\n    \"\"\"\n    Given a stack of integers and a target value, return True if there exists a pair of numbers in the stack that add up to the target,\n    and False otherwise. You may not use the same element twice.\n    \"\"\"\n    stack.sort()\n    left, right = 0, len(stack) - 1\n    while left < right:\n        current_sum = stack[left] + stack[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(stack: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a stack of integers such that there exists a pair of numbers that add up to the target.\n    \"\"\"\n    stack.sort()\n    return stack, target\n\n# Test case\nstack = [1, 4, 7, 3, 9, 2]\ntarget = 6\nassert f(*g(stack, target))\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(stack: List[int], target: int) -> bool:\n    \"\"\"\n    Given a stack of integers and a target value, return True if there exists a pair of numbers in the stack that add up to the target,\n    and False otherwise. You may not use the same element twice.\n    \"\"\"\n    stack.sort()\n    left, right = 0, len(stack) - 1\n    while left < right:\n        current_sum = stack[left] + stack[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(stack: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a stack of integers such that there exists a pair of numbers that add up to the target.\n    \"\"\"\n    stack.sort()\n    return stack, target\n\n# Test case\nstack = [1, 4, 7, 3, 9, 2]\ntarget = 6", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] equals 2 + 7 = 9, so the answer is [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in num_dict:\n            return [num_dict[target - num], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] equals 2 + 7 = 9, so the answer is [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in num_dict:\n            return [num_dict[target - num], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:\n    \"\"\"\n    Given a directed graph, find a path from start to end using Breadth-First Search (BFS).\n\n    Example:\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n\n    Output:\n    [\"A\", \"C\", \"F\"]\n\n    Explanation:\n    A -> C -> F is a path from start to end.\n    \"\"\"\n    queue = [[start]]\n    visited = set()\n\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n\n        if node == end:\n            return path\n\n        if node not in visited:\n            neighbors = graph.get(node, [])\n            for neighbor in neighbors:\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n            visited.add(node)\n\n    return []\n\ndef g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n    return graph, start, end\n\nassert f(*g()) == [\"A\", \"C\", \"F\"]\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 305, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:\n    \"\"\"\n    Given a directed graph, find a path from start to end using Breadth-First Search (BFS).\n\n    Example:\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n\n    Output:\n    [\"A\", \"C\", \"F\"]\n\n    Explanation:\n    A -> C -> F is a path from start to end.\n    \"\"\"\n    queue = [[start]]\n    visited = set()\n\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n\n        if node == end:\n            return path\n\n        if node not in visited:\n            neighbors = graph.get(node, [])\n            for neighbor in neighbors:\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n            visited.add(node)\n\n    return []", "solution_func": "def g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, partition s such that every substring of the partition is a palindrome.\n    Return all possible palindrome partitioning of s.\n\n    Example:\n    s = \"aab\"\n\n    Output:\n    [\n        [\"a\", \"a\", \"b\"],\n        [\"aa\", \"b\"]\n    ]\n\n    Explanation:\n    There are two possible palindrome partitioning of \"aab\": [\"a\", \"a\", \"b\"] and [\"aa\", \"b\"].\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(list(path))\n            return\n\n        for i in range(start, len(s)):\n            if is_palindrome(s[start:i+1]):\n                path.append(s[start:i+1])\n                backtrack(i+1, path)\n                path.pop()\n\n    result = []\n    backtrack(0, [])\n    return result\n\ndef g():\n    s = \"aab\"\n    return s\n\nassert f(*g()) == [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]]\n", "emb": null, "idx_generation": 305, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, partition s such that every substring of the partition is a palindrome.\n    Return all possible palindrome partitioning of s.\n\n    Example:\n    s = \"aab\"\n\n    Output:\n    [\n        [\"a\", \"a\", \"b\"],\n        [\"aa\", \"b\"]\n    ]\n\n    Explanation:\n    There are two possible palindrome partitioning of \"aab\": [\"a\", \"a\", \"b\"] and [\"aa\", \"b\"].\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(list(path))\n            return\n\n        for i in range(start, len(s)):\n            if is_palindrome(s[start:i+1]):\n                path.append(s[start:i+1])\n                backtrack(i+1, path)\n                path.pop()\n\n    result = []\n    backtrack(0, [])\n    return result", "solution_func": "def g():\n    s = \"aab\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subsequence of the list where the product of all elements\n    is a perfect square, and False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subsequence [2, 4] has a product of 8, which is a perfect square, so the output is True.\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 1 if is_perfect_square(nums[0]) else 0\n\n    for i in range(1, n):\n        dp[i] = dp[i-1] + (1 if is_perfect_square(nums[i]) else 0)\n        if dp[i] > 1:\n            return True\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 305, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subsequence of the list where the product of all elements\n    is a perfect square, and False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subsequence [2, 4] has a product of 8, which is a perfect square, so the output is True.\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 1 if is_perfect_square(nums[0]) else 0\n\n    for i in range(1, n):\n        dp[i] = dp[i-1] + (1 if is_perfect_square(nums[i]) else 0)\n        if dp[i] > 1:\n            return True\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    An increasing path is defined as a path from a given cell to another cell such that all cells\n    along the path have increasing values. The path can start from any cell and move in any of the four\n    cardinal directions (up, down, left, or right), but a cell cannot be visited more than once.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    The longest increasing path is [1, 2, 6, 9], so the output is 4.\n    \"\"\"\n    def dfs(i: int, j: int) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_length = max(max_length, dfs(x, y) + 1)\n\n        memo[i][j] = max_length\n        return memo[i][j]\n\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    memo = [[0] * n for _ in range(m)]\n    max_length = 0\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    An increasing path is defined as a path from a given cell to another cell such that all cells\n    along the path have increasing values. The path can start from any cell and move in any of the four\n    cardinal directions (up, down, left, or right), but a cell cannot be visited more than once.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    The longest increasing path is [1, 2, 6, 9], so the output is 4.\n    \"\"\"\n    def dfs(i: int, j: int) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_length = max(max_length, dfs(x, y) + 1)\n\n        memo[i][j] = max_length\n        return memo[i][j]\n\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    memo = [[0] * n for _ in range(m)]\n    max_length = 0\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length", "solution_func": "def g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same\n    forward and backward. Substring means a contiguous sequence of characters within the string.\n\n    Example:\n    s = \"babad\"\n\n    The longest palindromic substring is \"bab\", so the output is \"bab\".\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    longest_palindrome = \"\"\n\n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j] and (j - i <= 2 or dp[i+1][j-1]):\n                dp[i][j] = True\n                if j - i + 1 > len(longest_palindrome):\n                    longest_palindrome = s[i:j+1]\n\n    return longest_palindrome\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(g()) == \"bab\"\n", "emb": null, "idx_generation": 305, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same\n    forward and backward. Substring means a contiguous sequence of characters within the string.\n\n    Example:\n    s = \"babad\"\n\n    The longest palindromic substring is \"bab\", so the output is \"bab\".\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    longest_palindrome = \"\"\n\n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j] and (j - i <= 2 or dp[i+1][j-1]):\n                dp[i][j] = True\n                if j - i + 1 > len(longest_palindrome):\n                    longest_palindrome = s[i:j+1]\n\n    return longest_palindrome", "solution_func": "def g():\n    s = \"babad\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an integer n and a 2D grid of size n x n, count the number of paths from the top-left cell to the bottom-right cell.\n    Each path can only move down or right.\n\n    Example:\n    Input: n = 3, grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    Output: 6\n\n    Explanation:\n    There are 6 paths from the top-left cell to the bottom-right cell:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Down -> Right -> Right\n    - Down -> Down -> Right\n    - Down -> Right -> Down\n    - Right -> Down -> Down\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[-1][-1]\n\ndef g(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of size n x n where the number of paths from the top-left cell to the bottom-right cell is required to solve the puzzle.\n    \"\"\"\n    grid = [[0] * n for _ in range(n)]\n    return grid\n\nassert f(3, g(3)) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 305, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an integer n and a 2D grid of size n x n, count the number of paths from the top-left cell to the bottom-right cell.\n    Each path can only move down or right.\n\n    Example:\n    Input: n = 3, grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    Output: 6\n\n    Explanation:\n    There are 6 paths from the top-left cell to the bottom-right cell:\n    - Right -> Right -> Down\n    - Right -> Down -> Right\n    - Down -> Right -> Right\n    - Down -> Down -> Right\n    - Down -> Right -> Down\n    - Right -> Down -> Down\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[-1][-1]", "solution_func": "def g(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of size n x n where the number of paths from the top-left cell to the bottom-right cell is required to solve the puzzle.\n    \"\"\"\n    grid = [[0] * n for _ in range(n)]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int, pattern=\"101\") -> bool:\n    \"\"\"\n    Given two positive integers n and m, determine if there exists a binary pattern of length m that occurs exactly\n    n times in the binary representation of the sum of all integers from 1 to m.\n    \"\"\"\n    binary_sum = bin(sum(range(1, m+1)))[2:]\n    return binary_sum.count(pattern) == n\n\ndef g(n = 2, m = 10, pattern = \"101\"):\n    \"\"\"\n    Generate the binary pattern that occurs n times in the binary representation of the sum of all integers from 1 to m.\n    \"\"\"\n    binary_sum = bin(sum(range(1, m+1)))[2:]\n    return pattern * n\n\nassert f(g())\n", "emb": null, "idx_generation": 306, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, m: int, pattern=\"101\") -> bool:\n    \"\"\"\n    Given two positive integers n and m, determine if there exists a binary pattern of length m that occurs exactly\n    n times in the binary representation of the sum of all integers from 1 to m.\n    \"\"\"\n    binary_sum = bin(sum(range(1, m+1)))[2:]\n    return binary_sum.count(pattern) == n", "solution_func": "def g(n = 2, m = 10, pattern = \"101\"):\n    \"\"\"\n    Generate the binary pattern that occurs n times in the binary representation of the sum of all integers from 1 to m.\n    \"\"\"\n    binary_sum = bin(sum(range(1, m+1)))[2:]\n    return pattern * n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(words: List[str], n=3) -> bool:\n    \"\"\"\n    Given a list of words, determine if there exists an n-letter word that can be formed by concatenating any two words\n    from the list.\n    \"\"\"\n    for word1 in words:\n        for word2 in words:\n            if len(word1) + len(word2) == n:\n                return True\n    return False\n\ndef g(n = 3):\n    \"\"\"\n    Generate an n-letter word that can be formed by concatenating two words.\n    \"\"\"\n    return \"ab\" * (n // 2)\n\nassert f(g())\n", "emb": null, "idx_generation": 306, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(words: List[str], n=3) -> bool:\n    \"\"\"\n    Given a list of words, determine if there exists an n-letter word that can be formed by concatenating any two words\n    from the list.\n    \"\"\"\n    for word1 in words:\n        for word2 in words:\n            if len(word1) + len(word2) == n:\n                return True\n    return False", "solution_func": "def g(n = 3):\n    \"\"\"\n    Generate an n-letter word that can be formed by concatenating two words.\n    \"\"\"\n    return \"ab\" * (n // 2)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"\n    Given a string s, determine if there exists a substring of length n that has the same number of '0's and '1's.\n    \"\"\"\n    for i in range(len(s) - n + 1):\n        substring = s[i:i+n]\n        if substring.count('0') == substring.count('1'):\n            return True\n    return False\n\ndef g(n = 3):\n    \"\"\"\n    Generate a string with a substring of length n that has the same number of '0's and '1's.\n    \"\"\"\n    return '01' * (n // 2)\n\nassert f(g())\n", "emb": null, "idx_generation": 306, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"\n    Given a string s, determine if there exists a substring of length n that has the same number of '0's and '1's.\n    \"\"\"\n    for i in range(len(s) - n + 1):\n        substring = s[i:i+n]\n        if substring.count('0') == substring.count('1'):\n            return True\n    return False", "solution_func": "def g(n = 3):\n    \"\"\"\n    Generate a string with a substring of length n that has the same number of '0's and '1's.\n    \"\"\"\n    return '01' * (n // 2)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers from the list that add up to the target value.\n    Return the indices of these two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to 9 are 2 and 7. Their indices in the list are 0 and 1, respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 306, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers from the list that add up to the target value.\n    Return the indices of these two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to 9 are 2 and 7. Their indices in the list are 0 and 1, respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the other elements in nums for each element is:\n    - For 1: 2 * 3 * 4 = 24\n    - For 2: 1 * 3 * 4 = 12\n    - For 3: 1 * 2 * 4 = 8\n    - For 4: 1 * 2 * 3 = 6\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n    output = []\n    \n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output.append(prefix_products[i] * suffix_products[i])\n    \n    return output\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the other elements in nums for each element is:\n    - For 1: 2 * 3 * 4 = 24\n    - For 2: 1 * 3 * 4 = 12\n    - For 3: 1 * 2 * 4 = 8\n    - For 4: 1 * 2 * 3 = 6\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n    output = []\n    \n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output.append(prefix_products[i] * suffix_products[i])\n    \n    return output", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray in nums is 6, which is the sum of the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 306, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray in nums is 6, which is the sum of the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number. The list is sorted in ascending order.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 5) has a bitwise XOR equal to 7 (2 ^ 5 = 7).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_xor = nums[left] ^ nums[right]\n\n        if current_xor == target:\n            return True\n        elif current_xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number. The list is sorted in ascending order.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 5) has a bitwise XOR equal to 7 (2 ^ 5 = 7).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_xor = nums[left] ^ nums[right]\n\n        if current_xor == target:\n            return True\n        elif current_xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            return True\n\n        complements.add(num)\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            return True\n\n        complements.add(num)\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number. The list is not sorted.\n\n    Sample Input:\n    nums = [5, 3, 2, 7, 1]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (5, 3) has a bitwise XOR equal to 6 (5 ^ 3 = 6).\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            return True\n\n        complements.add(num)\n\n    return False\n\ndef g():\n    nums = [5, 3, 2, 7, 1]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number. The list is not sorted.\n\n    Sample Input:\n    nums = [5, 3, 2, 7, 1]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (5, 3) has a bitwise XOR equal to 6 (5 ^ 3 = 6).\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            return True\n\n        complements.add(num)\n\n    return False", "solution_func": "def g():\n    nums = [5, 3, 2, 7, 1]\n    target = 6\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path (from a cell to its neighboring cell) where all cells along the path have increasing values.\n    The path can start from any cell and can move in any of the four directions (up, down, left, or right).\n    \"\"\"\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    max_length = 0\n\n    def dfs(i: int, j: int) -> int:\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        curr_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                curr_length = max(curr_length, 1 + dfs(x, y))\n\n        dp[i][j] = curr_length\n        return curr_length\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be used to find the length of the longest increasing path.\n    \"\"\"\n    return matrix\n\nmatrix = [\n    [9, 9, 4],\n    [6, 6, 8],\n    [2, 1, 1]\n]\nassert f(g(matrix)) == 4\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 306, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path (from a cell to its neighboring cell) where all cells along the path have increasing values.\n    The path can start from any cell and can move in any of the four directions (up, down, left, or right).\n    \"\"\"\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    max_length = 0\n\n    def dfs(i: int, j: int) -> int:\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        curr_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                curr_length = max(curr_length, 1 + dfs(x, y))\n\n        dp[i][j] = curr_length\n        return curr_length\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length", "solution_func": "def g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be used to find the length of the longest increasing path.\n    \"\"\"\n    return matrix\n\nmatrix = [\n    [9, 9, 4],\n    [6, 6, 8],\n    [2, 1, 1]\n]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Check if the binary representation of n has exactly k set bits.\n\n    Args:\n    n (int): The number to check.\n    k (int): The number of set bits to look for.\n\n    Returns:\n    bool: True if the binary representation has exactly k set bits, False otherwise.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count == k\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 3.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (15, 4)\n\nassert f(*g()) == False\n", "emb": null, "idx_generation": 307, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Check if the binary representation of n has exactly k set bits.\n\n    Args:\n    n (int): The number to check.\n    k (int): The number of set bits to look for.\n\n    Returns:\n    bool: True if the binary representation has exactly k set bits, False otherwise.\n    \"\"\"\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count == k", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 3.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (15, 4)", "map_ix": null}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the value of the binomial coefficient C(n, k) using the mathematical formula.\n\n    Args:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The value of the binomial coefficient C(n, k).\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    return result\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 4.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (10, 3)\n\nassert f(*g()) == 120\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "import math\nfrom typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the value of the binomial coefficient C(n, k) using the mathematical formula.\n\n    Args:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The value of the binomial coefficient C(n, k).\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    return result", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 4.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (10, 3)", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the value of the bitwise AND operation between all integers from 1 to n.\n\n    Args:\n    n (int): The upper limit.\n    k (int): The number of bits in the binary representation.\n\n    Returns:\n    int: The value of the bitwise AND operation.\n    \"\"\"\n    result = n\n    for i in range(n - 1, 0, -1):\n        result &= i\n    return result\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 5.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (10, 4)\n\nassert f(*g()) == 0\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the value of the bitwise AND operation between all integers from 1 to n.\n\n    Args:\n    n (int): The upper limit.\n    k (int): The number of bits in the binary representation.\n\n    Returns:\n    int: The value of the bitwise AND operation.\n    \"\"\"\n    result = n\n    for i in range(n - 1, 0, -1):\n        result &= i\n    return result", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 5.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (10, 4)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the sum of all the numbers that are powers of two.\n\n    Example:\n    Input: [1, 2, 3, 4, 5, 6, 7, 8]\n    Output: 15 (2 + 4 + 8 = 14)\n\n    Hint: Use bit manipulation to check if a number is a power of two.\n    \"\"\"\n    def is_power_of_two(num):\n        return num > 0 and (num & (num - 1)) == 0\n\n    power_of_two_sum = 0\n    for num in nums:\n        if is_power_of_two(num):\n            power_of_two_sum += num\n\n    return power_of_two_sum\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8]\n\nassert f(g()) == 14\n", "emb": null, "idx_generation": 307, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the sum of all the numbers that are powers of two.\n\n    Example:\n    Input: [1, 2, 3, 4, 5, 6, 7, 8]\n    Output: 15 (2 + 4 + 8 = 14)\n\n    Hint: Use bit manipulation to check if a number is a power of two.\n    \"\"\"\n    def is_power_of_two(num):\n        return num > 0 and (num & (num - 1)) == 0\n\n    power_of_two_sum = 0\n    for num in nums:\n        if is_power_of_two(num):\n            power_of_two_sum += num\n\n    return power_of_two_sum", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise AND of all the numbers in the list.\n\n    Example:\n    Input: [5, 6, 7, 8]\n    Output: 0 (5 & 6 & 7 & 8 = 0)\n\n    Hint: Use bit manipulation to perform the AND operation.\n    \"\"\"\n    result = nums[0]\n    for num in nums[1:]:\n        result &= num\n\n    return result\n\ndef g():\n    return [5, 6, 7, 8]\n\nassert f(g()) == 0\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise AND of all the numbers in the list.\n\n    Example:\n    Input: [5, 6, 7, 8]\n    Output: 0 (5 & 6 & 7 & 8 = 0)\n\n    Hint: Use bit manipulation to perform the AND operation.\n    \"\"\"\n    result = nums[0]\n    for num in nums[1:]:\n        result &= num\n\n    return result", "solution_func": "def g():\n    return [5, 6, 7, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise XOR of each number with the previous number in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [1, 3, 1, 7, 1] (1 ^ 2 = 3, 2 ^ 3 = 1, 3 ^ 4 = 7, 4 ^ 5 = 1)\n\n    Hint: Use bit manipulation to perform the XOR operation.\n    \"\"\"\n    xor_list = [nums[0]]\n    for i in range(1, len(nums)):\n        xor_list.append(nums[i] ^ nums[i-1])\n\n    return xor_list\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 1, 7, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 307, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise XOR of each number with the previous number in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [1, 3, 1, 7, 1] (1 ^ 2 = 3, 2 ^ 3 = 1, 3 ^ 4 = 7, 4 ^ 5 = 1)\n\n    Hint: Use bit manipulation to perform the XOR operation.\n    \"\"\"\n    xor_list = [nums[0]]\n    for i in range(1, len(nums)):\n        xor_list.append(nums[i] ^ nums[i-1])\n\n    return xor_list", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport heapq\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Args:\n    - grid: A 2D grid of size m x n, where each cell contains a non-negative integer.\n\n    Returns:\n    - The maximum XOR value that can be obtained.\n\n    Example:\n    f([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> 15\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    max_xor = 0\n    for col in range(n):\n        heap = []\n        for row in range(m):\n            heapq.heappush(heap, -grid[row][col])\n        xor = 0\n        while heap:\n            xor ^= -heapq.heappop(heap)\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of size m x n and a positive integer m and n.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nimport heapq\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Args:\n    - grid: A 2D grid of size m x n, where each cell contains a non-negative integer.\n\n    Returns:\n    - The maximum XOR value that can be obtained.\n\n    Example:\n    f([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> 15\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    max_xor = 0\n    for col in range(n):\n        heap = []\n        for row in range(m):\n            heapq.heappush(heap, -grid[row][col])\n        xor = 0\n        while heap:\n            xor ^= -heapq.heappop(heap)\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of size m x n and a positive integer m and n.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [1, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return a tuple (x, y) representing the position of the maximum value in the grid.\n\n    Args:\n    - n: An integer representing the size of the grid.\n    - grid: A 2D grid of size n x n, where each cell contains an integer.\n\n    Returns:\n    - A tuple (x, y) representing the position of the maximum value in the grid.\n\n    Example:\n    f(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> (2, 2)\n    \"\"\"\n\n    max_val = float('-inf')\n    max_pos = (0, 0)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] > max_val:\n                max_val = grid[i][j]\n                max_pos = (i, j)\n    return max_pos\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == (2, 2)\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return a tuple (x, y) representing the position of the maximum value in the grid.\n\n    Args:\n    - n: An integer representing the size of the grid.\n    - grid: A 2D grid of size n x n, where each cell contains an integer.\n\n    Returns:\n    - A tuple (x, y) representing the position of the maximum value in the grid.\n\n    Example:\n    f(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> (2, 2)\n    \"\"\"\n\n    max_val = float('-inf')\n    max_pos = (0, 0)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] > max_val:\n                max_val = grid[i][j]\n                max_pos = (i, j)\n    return max_pos", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, k: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, find the sum of the largest k numbers in the grid.\n\n    Args:\n    - n: An integer representing the size of the grid.\n    - k: An integer representing the number of largest numbers to sum.\n    - grid: A 2D grid of size n x n, where each cell contains an integer.\n\n    Returns:\n    - The sum of the largest k numbers in the grid.\n\n    Example:\n    f(3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> 17\n    \"\"\"\n\n    nums = []\n    for row in grid:\n        nums.extend(row)\n    nums.sort(reverse=True)\n    return sum(nums[:k])\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n, a positive integer n, and a positive integer k.\n    \"\"\"\n    return 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == 17\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, k: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, find the sum of the largest k numbers in the grid.\n\n    Args:\n    - n: An integer representing the size of the grid.\n    - k: An integer representing the number of largest numbers to sum.\n    - grid: A 2D grid of size n x n, where each cell contains an integer.\n\n    Returns:\n    - The sum of the largest k numbers in the grid.\n\n    Example:\n    f(3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> 17\n    \"\"\"\n\n    nums = []\n    for row in grid:\n        nums.extend(row)\n    nums.sort(reverse=True)\n    return sum(nums[:k])", "solution_func": "def g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n, a positive integer n, and a positive integer k.\n    \"\"\"\n    return 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the sum of each row and return the maximum sum.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    output: 24\n    Explanation: The sums of the rows are [6, 15, 24], and the maximum sum is 24.\n\n    Note: The input matrix will have at least one row and one column.\n    \"\"\"\n    row_sums = [sum(row) for row in matrix]\n    return max(row_sums)\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 24\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 307, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the sum of each row and return the maximum sum.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    output: 24\n    Explanation: The sums of the rows are [6, 15, 24], and the maximum sum is 24.\n\n    Note: The input matrix will have at least one row and one column.\n    \"\"\"\n    row_sums = [sum(row) for row in matrix]\n    return max(row_sums)", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if the target string can be formed by rearranging the characters of s.\n\n    Example:\n    s = \"listen\"\n    target = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The target string \"silent\" can be formed by rearranging the characters of s.\n    \"\"\"\n\n    def backtrack(s, target, path, result):\n        if len(path) == len(target):\n            result[0] = True\n            return\n\n        for i in range(len(s)):\n            if path + s[i] not in result:\n                path += s[i]\n                backtrack(s, target, path, result)\n                path = path[:-1]\n\n    result = [False]\n    backtrack(s, target, \"\", result)\n    return result[0]\n\ndef g() -> Tuple[str, str]:\n    s = \"listen\"\n    target = \"silent\"\n    return s, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 308, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if the target string can be formed by rearranging the characters of s.\n\n    Example:\n    s = \"listen\"\n    target = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The target string \"silent\" can be formed by rearranging the characters of s.\n    \"\"\"\n\n    def backtrack(s, target, path, result):\n        if len(path) == len(target):\n            result[0] = True\n            return\n\n        for i in range(len(s)):\n            if path + s[i] not in result:\n                path += s[i]\n                backtrack(s, target, path, result)\n                path = path[:-1]\n\n    result = [False]\n    backtrack(s, target, \"\", result)\n    return result[0]", "solution_func": "def g() -> Tuple[str, str]:\n    s = \"listen\"\n    target = \"silent\"\n    return s, target", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the maximum sum of a subarray that is less than or equal to the target value.\n    Return the maximum sum.\n\n    Example:\n    nums = [2, 5, 1, 3, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The subarray with the maximum sum that is less than or equal to the target value 6 is [2, 1, 3], which has a sum of 5.\n    \"\"\"\n\n    def backtrack(nums, target, start, path, result, max_sum):\n        if sum(path) <= target:\n            if sum(path) > max_sum[0]:\n                max_sum[0] = sum(path)\n                result[0] = path[:]\n        \n        if sum(path) > target:\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(nums, target, i + 1, path, result, max_sum)\n            path.pop()\n\n    result = [None]\n    max_sum = [float('-inf')]\n    nums.sort()\n    backtrack(nums, target, 0, [], result, max_sum)\n    return max_sum[0]\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 5, 1, 3, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 308, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the maximum sum of a subarray that is less than or equal to the target value.\n    Return the maximum sum.\n\n    Example:\n    nums = [2, 5, 1, 3, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The subarray with the maximum sum that is less than or equal to the target value 6 is [2, 1, 3], which has a sum of 5.\n    \"\"\"\n\n    def backtrack(nums, target, start, path, result, max_sum):\n        if sum(path) <= target:\n            if sum(path) > max_sum[0]:\n                max_sum[0] = sum(path)\n                result[0] = path[:]\n        \n        if sum(path) > target:\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(nums, target, i + 1, path, result, max_sum)\n            path.pop()\n\n    result = [None]\n    max_sum = [float('-inf')]\n    nums.sort()\n    backtrack(nums, target, 0, [], result, max_sum)\n    return max_sum[0]", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 5, 1, 3, 9]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers is 4 * 5 * 3 = 60.\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers is 4 * 5 * 3 = 60.\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_matrix: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, find the number of distinct paths from a given start node\n    to a given end node.\n\n    Example:\n    adjacency_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There are 2 distinct paths from node 0 to node 3: [0, 1, 2, 3] and [0, 1, 3].\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(adjacency_matrix)\n    dp = [0] * n\n    dp[start] = 1\n\n    for i in range(start, end+1):\n        for j in range(n):\n            if adjacency_matrix[j][i] == 1:\n                dp[i] += dp[j]\n\n    return dp[end]\n\ndef g() -> List[List[int]]:\n    adjacency_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return adjacency_matrix\n\nassert f(g(), 0, 3) == 2\n", "emb": null, "idx_generation": 308, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adjacency_matrix: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, find the number of distinct paths from a given start node\n    to a given end node.\n\n    Example:\n    adjacency_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There are 2 distinct paths from node 0 to node 3: [0, 1, 2, 3] and [0, 1, 3].\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(adjacency_matrix)\n    dp = [0] * n\n    dp[start] = 1\n\n    for i in range(start, end+1):\n        for j in range(n):\n            if adjacency_matrix[j][i] == 1:\n                dp[i] += dp[j]\n\n    return dp[end]", "solution_func": "def g() -> List[List[int]]:\n    adjacency_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return adjacency_matrix", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The minimum sum of a path from the top-left corner to the bottom-right corner is 1 + 4 + 7 + 8 + 9 = 29.\n\n    Therefore, the function should return 29.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 29\n", "emb": null, "idx_generation": 308, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The minimum sum of a path from the top-left corner to the bottom-right corner is 1 + 4 + 7 + 8 + 9 = 29.\n\n    Therefore, the function should return 29.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum that can be obtained by selecting a subarray with the constraint that no two numbers in the selected subarray are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 1]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum sum can be obtained by selecting the subarray [1, 3].\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 1]\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum that can be obtained by selecting a subarray with the constraint that no two numbers in the selected subarray are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 1]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum sum can be obtained by selecting the subarray [1, 3].\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[-1]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_path = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(x, y))\n\n        dp[i][j] = max_path\n        return max_path\n\n    result = 0\n\n    for i in range(m):\n        for j in range(n):\n            result = max(result, dfs(i, j))\n\n    return result\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_path = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(x, y))\n\n        dp[i][j] = max_path\n        return max_path\n\n    result = 0\n\n    for i in range(m):\n        for j in range(n):\n            result = max(result, dfs(i, j))\n\n    return result", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of set bits in its binary representation.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g():\n    n = 15\n    return n\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 308, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of set bits in its binary representation.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count", "solution_func": "def g():\n    n = 15\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum difference between two successive elements in its sorted form.\n\n    Example:\n    nums = [3, 9, 1, 2, 5]\n    output: 4\n    Explanation: The sorted form of the array is [1, 2, 3, 5, 9]. The maximum difference between two successive elements is 4 (between 5 and 9).\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum difference between two successive elements in the sorted form of the array.\n\n    Constraints:\n    - The array must contain at least two elements.\n    - The elements in the array are all non-negative integers.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    nums.sort()\n    max_diff = 0\n    for i in range(len(nums) - 1):\n        diff = nums[i+1] - nums[i]\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [3, 9, 1, 2, 5]\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 309, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum difference between two successive elements in its sorted form.\n\n    Example:\n    nums = [3, 9, 1, 2, 5]\n    output: 4\n    Explanation: The sorted form of the array is [1, 2, 3, 5, 9]. The maximum difference between two successive elements is 4 (between 5 and 9).\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The maximum difference between two successive elements in the sorted form of the array.\n\n    Constraints:\n    - The array must contain at least two elements.\n    - The elements in the array are all non-negative integers.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    nums.sort()\n    max_diff = 0\n    for i in range(len(nums) - 1):\n        diff = nums[i+1] - nums[i]\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [3, 9, 1, 2, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the total number of subarrays with an equal number of odd and even elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    output: 1\n    Explanation: The only subarray with an equal number of odd and even elements is [2, 3].\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The total number of subarrays with an equal number of odd and even elements.\n\n    Constraints:\n    - The list must contain at least two elements.\n    - The elements in the list are all positive integers.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n\n    for num in nums:\n        if num % 2 == 0:\n            prefix_sum += 1\n        else:\n            prefix_sum -= 1\n\n        if prefix_sum in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum]\n\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 309, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the total number of subarrays with an equal number of odd and even elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    output: 1\n    Explanation: The only subarray with an equal number of odd and even elements is [2, 3].\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The total number of subarrays with an equal number of odd and even elements.\n\n    Constraints:\n    - The list must contain at least two elements.\n    - The elements in the list are all positive integers.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n\n    for num in nums:\n        if num % 2 == 0:\n            prefix_sum += 1\n        else:\n            prefix_sum -= 1\n\n        if prefix_sum in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum]\n\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a word search puzzle and a list of words, find the number of words that can be found in the puzzle.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    words = [\"ABCCED\", \"SEE\", \"AD\", \"E\"]\n    output: 3\n    Explanation: The words \"ABCCED\", \"SEE\", and \"E\" can be found in the puzzle.\n\n    Args:\n    - grid: A grid of characters representing a word search puzzle.\n    - words: A list of words to search for in the puzzle.\n\n    Returns:\n    - The number of words that can be found in the puzzle.\n\n    Constraints:\n    - The grid will have at most 200 rows and columns.\n    - The words will have at most 10^3 characters.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n\n    def dfs(i: int, j: int, word: str) -> bool:\n        if len(word) == 0:\n            return True\n\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != word[0]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        found = dfs(i + 1, j, word[1:]) or dfs(i - 1, j, word[1:]) or dfs(i, j + 1, word[1:]) or dfs(i, j - 1, word[1:])\n\n        grid[i][j] = temp\n\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, word):\n                count += 1\n\n    return count\n\ndef g() -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters representing a word search puzzle.\n    \"\"\"\n    return [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 309, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a word search puzzle and a list of words, find the number of words that can be found in the puzzle.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    words = [\"ABCCED\", \"SEE\", \"AD\", \"E\"]\n    output: 3\n    Explanation: The words \"ABCCED\", \"SEE\", and \"E\" can be found in the puzzle.\n\n    Args:\n    - grid: A grid of characters representing a word search puzzle.\n    - words: A list of words to search for in the puzzle.\n\n    Returns:\n    - The number of words that can be found in the puzzle.\n\n    Constraints:\n    - The grid will have at most 200 rows and columns.\n    - The words will have at most 10^3 characters.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n\n    def dfs(i: int, j: int, word: str) -> bool:\n        if len(word) == 0:\n            return True\n\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != word[0]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        found = dfs(i + 1, j, word[1:]) or dfs(i - 1, j, word[1:]) or dfs(i, j + 1, word[1:]) or dfs(i, j - 1, word[1:])\n\n        grid[i][j] = temp\n\n        return found\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, word):\n                count += 1\n\n    return count", "solution_func": "def g() -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters representing a word search puzzle.\n    \"\"\"\n    return [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 1, 9, 4]\n\n    Output:\n    [1, 2, 4, 5, 9]\n    \"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 1, 9, 4]\n\nassert f(g()) == [1, 2, 4, 5, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 309, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 1, 9, 4]\n\n    Output:\n    [1, 2, 4, 5, 9]\n    \"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 1, 9, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of occurrences of each character in the string.\n    Return the counts as a list of tuples in the format (character, count), sorted by count in descending order.\n\n    Example:\n    s = \"hello\"\n\n    Output:\n    [('l', 2), ('e', 1), ('o', 1), ('h', 1)]\n    \"\"\"\n    counts = {}\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counts\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello\"\n\nassert f(g()) == [('l', 2), ('e', 1), ('o', 1), ('h', 1)]\n", "emb": null, "idx_generation": 309, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of occurrences of each character in the string.\n    Return the counts as a list of tuples in the format (character, count), sorted by count in descending order.\n\n    Example:\n    s = \"hello\"\n\n    Output:\n    [('l', 2), ('e', 1), ('o', 1), ('h', 1)]\n    \"\"\"\n    counts = {}\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counts", "solution_func": "def g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a grid of characters, rotate the grid 90 degrees clockwise.\n    Return the rotated grid.\n\n    Example:\n    grid = [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\n    Output:\n    [['g', 'd', 'a'],\n     ['h', 'e', 'b'],\n     ['i', 'f', 'c']]\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    rotated = [[''] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            rotated[j][n-i-1] = grid[i][j]\n    return rotated\n\ndef g():\n    \"\"\"\n    Generate a grid of characters.\n    \"\"\"\n    return [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\nassert f(g()) == [['g', 'd', 'a'],\n                  ['h', 'e', 'b'],\n                  ['i', 'f', 'c']]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 309, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a grid of characters, rotate the grid 90 degrees clockwise.\n    Return the rotated grid.\n\n    Example:\n    grid = [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\n    Output:\n    [['g', 'd', 'a'],\n     ['h', 'e', 'b'],\n     ['i', 'f', 'c']]\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    rotated = [[''] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            rotated[j][n-i-1] = grid[i][j]\n    return rotated", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of characters.\n    \"\"\"\n    return [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the kth digit in the sequence of concatenation of positive integers from 1 to n.\n\n    Example:\n    n = 13, k = 12\n\n    The sequence of concatenation of positive integers from 1 to 13 is \"12345678910111213\".\n    The 12th digit in this sequence is 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    num_str = \"\"\n    for i in range(1, n + 1):\n        num_str += str(i)\n\n    return int(num_str[k - 1])\n\n\ndef g():\n    n = 13\n    k = 12\n    return n, k\n\n\nassert f(*g()) == 2\n\n", "emb": null, "idx_generation": 309, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the kth digit in the sequence of concatenation of positive integers from 1 to n.\n\n    Example:\n    n = 13, k = 12\n\n    The sequence of concatenation of positive integers from 1 to 13 is \"12345678910111213\".\n    The 12th digit in this sequence is 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    num_str = \"\"\n    for i in range(1, n + 1):\n        num_str += str(i)\n\n    return int(num_str[k - 1])", "solution_func": "def g():\n    n = 13\n    k = 12\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, edges: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges represented by tuples (a, b), return a list containing\n    the topological ordering of the nodes. If there is no valid topological ordering, return an empty list.\n\n    Example:\n    n = 4\n    edges = [(1, 2), (2, 3), (3, 1), (4, 2)]\n\n    The valid topological ordering of the nodes is [4, 1, 2, 3].\n\n    Therefore, the function should return [4, 1, 2, 3].\n    \"\"\"\n    graph = {i: [] for i in range(1, n + 1)}\n    in_degrees = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in edges:\n        graph[a].append(b)\n        in_degrees[b] += 1\n\n    queue = [i for i in range(1, n + 1) if in_degrees[i] == 0]\n    topo_order = []\n\n    while queue:\n        node = queue.pop(0)\n        topo_order.append(node)\n\n        for neighbor in graph[node]:\n            in_degrees[neighbor] -= 1\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(topo_order) != n:\n        return []\n\n    return topo_order\n\n\ndef g():\n    n = 4\n    edges = [(1, 2), (2, 3), (3, 1), (4, 2)]\n    return n, edges\n\n\nassert f(*g()) == [4, 1, 2, 3]\n\n", "emb": null, "idx_generation": 309, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, edges: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges represented by tuples (a, b), return a list containing\n    the topological ordering of the nodes. If there is no valid topological ordering, return an empty list.\n\n    Example:\n    n = 4\n    edges = [(1, 2), (2, 3), (3, 1), (4, 2)]\n\n    The valid topological ordering of the nodes is [4, 1, 2, 3].\n\n    Therefore, the function should return [4, 1, 2, 3].\n    \"\"\"\n    graph = {i: [] for i in range(1, n + 1)}\n    in_degrees = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in edges:\n        graph[a].append(b)\n        in_degrees[b] += 1\n\n    queue = [i for i in range(1, n + 1) if in_degrees[i] == 0]\n    topo_order = []\n\n    while queue:\n        node = queue.pop(0)\n        topo_order.append(node)\n\n        for neighbor in graph[node]:\n            in_degrees[neighbor] -= 1\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(topo_order) != n:\n        return []\n\n    return topo_order", "solution_func": "def g():\n    n = 4\n    edges = [(1, 2), (2, 3), (3, 1), (4, 2)]\n    return n, edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s representing a mathematical expression, evaluate the expression and return the result.\n\n    The expression can contain the following operators: '+', '-', '*', '/'. The expression can also contain\n    parentheses '(' and ')'. The expression does not contain any spaces.\n\n    Example:\n    s = \"(10 + 2) * 5 - 3\"\n\n    The expression evaluates to 57.\n\n    Therefore, the function should return 57.\n    \"\"\"\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n\n    for char in s:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == '+':\n            result += sign * num\n            num = 0\n            sign = 1\n        elif char == '-':\n            result += sign * num\n            num = 0\n            sign = -1\n        elif char == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == ')':\n            result += sign * num\n            num = 0\n            result *= stack.pop()\n            result += stack.pop()\n\n    result += sign * num\n\n    return result\n\n\ndef g():\n    s = \"(10 + 2) * 5 - 3\"\n    return s\n\n\nassert f(g()) == 57\n\n", "emb": null, "idx_generation": 309, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "import math\nfrom typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s representing a mathematical expression, evaluate the expression and return the result.\n\n    The expression can contain the following operators: '+', '-', '*', '/'. The expression can also contain\n    parentheses '(' and ')'. The expression does not contain any spaces.\n\n    Example:\n    s = \"(10 + 2) * 5 - 3\"\n\n    The expression evaluates to 57.\n\n    Therefore, the function should return 57.\n    \"\"\"\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n\n    for char in s:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == '+':\n            result += sign * num\n            num = 0\n            sign = 1\n        elif char == '-':\n            result += sign * num\n            num = 0\n            sign = -1\n        elif char == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == ')':\n            result += sign * num\n            num = 0\n            result *= stack.pop()\n            result += stack.pop()\n\n    result += sign * num\n\n    return result", "solution_func": "def g():\n    s = \"(10 + 2) * 5 - 3\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n\n    Constraints:\n    - The list is non-empty and contains at least k elements.\n    - The maximum value of k is less than or equal to the length of the list.\n    \"\"\"\n\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    max_sum = float('-inf')\n    for i in range(k, n + 1):\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[i - k])\n\n    return max_sum\n\ndef g(nums=[1, -2, 3, -4, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 309, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n\n    Constraints:\n    - The list is non-empty and contains at least k elements.\n    - The maximum value of k is less than or equal to the length of the list.\n    \"\"\"\n\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    max_sum = float('-inf')\n    for i in range(k, n + 1):\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[i - k])\n\n    return max_sum", "solution_func": "def g(nums=[1, -2, 3, -4, 5], k=3):\n    return nums, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int, word: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and a start node, find if there exists a path in the\n    graph that spells out a specific word by traversing the nodes. Each node in the graph represents a letter, and the\n    edges represent the ordering of the letters.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    word = \"DOG\"\n\n    In the given graph, there exists a path from node 0 to node 3 that spells out the word \"DOG\": 0 -> 1 -> 2 -> 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = [(start, \"\")]\n\n    while stack:\n        node, path = stack.pop()\n\n        if node == target and path == word:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                stack.append((neighbor, path + str(neighbor)))\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    word = \"DOG\"\n    return graph, start, target, word\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 310, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int, word: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and a start node, find if there exists a path in the\n    graph that spells out a specific word by traversing the nodes. Each node in the graph represents a letter, and the\n    edges represent the ordering of the letters.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    word = \"DOG\"\n\n    In the given graph, there exists a path from node 0 to node 3 that spells out the word \"DOG\": 0 -> 1 -> 2 -> 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = [(start, \"\")]\n\n    while stack:\n        node, path = stack.pop()\n\n        if node == target and path == word:\n            return True\n\n        visited[node] = True\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                stack.append((neighbor, path + str(neighbor)))\n\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    word = \"DOG\"\n    return graph, start, target, word", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]], start: str, target: str, pattern: str) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes (strings) and the values are lists of nodes\n    that can be reached from the key node, find if there exists a path from the start node to the target node\n    that matches a specific pattern. The pattern is represented as a string where each character represents a node,\n    and the order of the characters represents the order of traversal.\n\n    Example:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    pattern = 'ACF'\n\n    In the given graph, there exists a path from node 'A' to node 'F' that matches the pattern 'ACF': 'A' -> 'C' -> 'F'.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n    stack = [(start, \"\")]\n\n    while stack:\n        node, path = stack.pop()\n\n        if node == target and path == pattern:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + neighbor))\n\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    pattern = 'ACF'\n    return graph, start, target, pattern\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 310, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]], start: str, target: str, pattern: str) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes (strings) and the values are lists of nodes\n    that can be reached from the key node, find if there exists a path from the start node to the target node\n    that matches a specific pattern. The pattern is represented as a string where each character represents a node,\n    and the order of the characters represents the order of traversal.\n\n    Example:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    pattern = 'ACF'\n\n    In the given graph, there exists a path from node 'A' to node 'F' that matches the pattern 'ACF': 'A' -> 'C' -> 'F'.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n    stack = [(start, \"\")]\n\n    while stack:\n        node, path = stack.pop()\n\n        if node == target and path == pattern:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + neighbor))\n\n    return False", "solution_func": "def g():\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    pattern = 'ACF'\n    return graph, start, target, pattern", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]], start: str, target: str, keywords: List[str]) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes (strings) and the values are lists of nodes\n    that can be reached from the key node, find if there exists a path from the start node to the target node\n    that contains any of the given keywords.\n\n    Example:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    keywords = ['ACD', 'B', 'EF']\n\n    In the given graph, there exists a path from node 'A' to node 'F' that contains the keyword 'ACD': 'A' -> 'C' -> 'D' -> 'F'.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n    stack = [(start, '')]\n\n    while stack:\n        node, path = stack.pop()\n\n        if node == target and any(keyword in path for keyword in keywords):\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + node))\n\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    keywords = ['ACD', 'B', 'EF']\n    return graph, start, target, keywords\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 310, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import Dict, List\n\ndef f(graph: Dict[str, List[str]], start: str, target: str, keywords: List[str]) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes (strings) and the values are lists of nodes\n    that can be reached from the key node, find if there exists a path from the start node to the target node\n    that contains any of the given keywords.\n\n    Example:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    keywords = ['ACD', 'B', 'EF']\n\n    In the given graph, there exists a path from node 'A' to node 'F' that contains the keyword 'ACD': 'A' -> 'C' -> 'D' -> 'F'.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n    stack = [(start, '')]\n\n    while stack:\n        node, path = stack.pop()\n\n        if node == target and any(keyword in path for keyword in keywords):\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + node))\n\n    return False", "solution_func": "def g():\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    keywords = ['ACD', 'B', 'EF']\n    return graph, start, target, keywords", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product is 5 * 4 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product is 5 * 4 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    Return the length.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has length 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    \n    for i, char in enumerate(s):\n        if char in seen and start <= seen[char]:\n            start = seen[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        seen[char] = i\n        \n    return max_length\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    Return the length.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has length 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    \n    for i, char in enumerate(s):\n        if char in seen and start <= seen[char]:\n            start = seen[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        seen[char] = i\n        \n    return max_length", "solution_func": "def g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that appear only once and return them in a list.\n    \n    Example:\n    Input: [1, 2, 1, 3, 2, 5]\n    Output: [3, 5]\n    Explanation: The numbers 3 and 5 appear only once in the list.\n\n    Note:\n    - The list will always have exactly two numbers that appear only once, and all other numbers will appear twice.\n    \"\"\"\n    xor = 0\n    for num in nums:\n        xor ^= num\n    \n    # Find the rightmost set bit in the XOR result\n    rightmost_bit = xor & (-xor)\n    \n    # Divide the numbers into two groups based on the rightmost set bit\n    group1, group2 = 0, 0\n    for num in nums:\n        if num & rightmost_bit:\n            group1 ^= num\n        else:\n            group2 ^= num\n    \n    return [group1, group2]\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 1, 3, 2, 5]\n\nassert f(g()) == [3, 5]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that appear only once and return them in a list.\n    \n    Example:\n    Input: [1, 2, 1, 3, 2, 5]\n    Output: [3, 5]\n    Explanation: The numbers 3 and 5 appear only once in the list.\n\n    Note:\n    - The list will always have exactly two numbers that appear only once, and all other numbers will appear twice.\n    \"\"\"\n    xor = 0\n    for num in nums:\n        xor ^= num\n    \n    # Find the rightmost set bit in the XOR result\n    rightmost_bit = xor & (-xor)\n    \n    # Divide the numbers into two groups based on the rightmost set bit\n    group1, group2 = 0, 0\n    for num in nums:\n        if num & rightmost_bit:\n            group1 ^= num\n        else:\n            group2 ^= num\n    \n    return [group1, group2]", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 1, 3, 2, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are two numbers in the list whose sum is equal to the target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([3, 5, 2, 9, 1, 7], 10)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are two numbers in the list whose sum is equal to the target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([3, 5, 2, 9, 1, 7], 10)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 23\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 23", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string and a target substring, determine if the target substring appears at the beginning of the string.\n    \"\"\"\n    return s.startswith(target)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return (\"apple\", \"app\")\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 310, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string and a target substring, determine if the target substring appears at the beginning of the string.\n    \"\"\"\n    return s.startswith(target)", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return (\"apple\", \"app\")", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum size of a square subgrid where all elements are 1.\n\n    Return the maximum size of the square subgrid.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    The maximum size of the square subgrid is 3x3, so the function should return 9.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    max_size = 0\n\n    for i in range(rows):\n        dp[i][0] = grid[i][0]\n        max_size = max(max_size, dp[i][0])\n\n    for j in range(cols):\n        dp[0][j] = grid[0][j]\n        max_size = max(max_size, dp[0][j])\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 310, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum size of a square subgrid where all elements are 1.\n\n    Return the maximum size of the square subgrid.\n\n    Example:\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    The maximum size of the square subgrid is 3x3, so the function should return 9.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    max_size = 0\n\n    for i in range(rows):\n        dp[i][0] = grid[i][0]\n        max_size = max(max_size, dp[i][0])\n\n    for j in range(cols):\n        dp[0][j] = grid[0][j]\n        max_size = max(max_size, dp[0][j])\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all unique combinations of elements in nums that add up to the target.\n    Each number in nums may only be used once in the combination.\n    \"\"\"\n\n    def backtrack(nums, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(nums, target-nums[i], i+1, path+[nums[i]], res)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, 0, [], res)\n    return res\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number for Puzzle 3.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == [[2, 5], [3, 4]]\n", "emb": null, "idx_generation": 311, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all unique combinations of elements in nums that add up to the target.\n    Each number in nums may only be used once in the combination.\n    \"\"\"\n\n    def backtrack(nums, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(nums, target-nums[i], i+1, path+[nums[i]], res)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, 0, [], res)\n    return res", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number for Puzzle 3.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subsequence with the constraint that no two numbers in the subsequence should be adjacent in the original list.\n    \"\"\"\n\n    def find_max_sum(nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0], nums[1])\n        \n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        \n        return dp[-1]\n\n    return find_max_sum(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [4, 1, 2, 7, 5, 3]\n\nassert f(g()) == 13\n", "emb": null, "idx_generation": 311, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subsequence with the constraint that no two numbers in the subsequence should be adjacent in the original list.\n    \"\"\"\n\n    def find_max_sum(nums):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0], nums[1])\n        \n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        \n        return dp[-1]\n\n    return find_max_sum(nums)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [4, 1, 2, 7, 5, 3]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target number, determine if there is a subset of nums that adds up to the target.\n    \"\"\"\n\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(nums):\n            return False\n        \n        if subset_sum(nums, target-nums[index], index+1):\n            return True\n        if subset_sum(nums, target, index+1):\n            return True\n        \n        return False\n\n    return subset_sum(nums, target, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number for Puzzle 5.\n    \"\"\"\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target number, determine if there is a subset of nums that adds up to the target.\n    \"\"\"\n\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(nums):\n            return False\n        \n        if subset_sum(nums, target-nums[index], index+1):\n            return True\n        if subset_sum(nums, target, index+1):\n            return True\n        \n        return False\n\n    return subset_sum(nums, target, 0)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number for Puzzle 5.\n    \"\"\"\n    return ([2, 4, 6, 8], 10)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    The path can only move down or right.\n\n    Return the maximum sum.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D DP array to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Base case: the maximum sum at the top-left corner is the value of the top-left cell\n    dp[0][0] = grid[0][0]\n\n    # Fill in the DP array\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers to find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    return grid\n\ngrid = [[1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]]\n\nassert f(*g(grid)) == 9\n", "emb": null, "idx_generation": 311, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    The path can only move down or right.\n\n    Return the maximum sum.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D DP array to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Base case: the maximum sum at the top-left corner is the value of the top-left cell\n    dp[0][0] = grid[0][0]\n\n    # Fill in the DP array\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers to find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    return grid\n\ngrid = [[1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    The cost of moving to a neighboring cell is the absolute difference between the values of the current cell and the target cell.\n\n    Return the minimum cost.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D DP array to store the minimum cost at each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # Base case: the minimum cost at the top-left corner is 0\n    dp[0][0] = 0\n\n    # Fill in the DP array\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + abs(grid[i][0] - grid[i-1][0])\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + abs(grid[0][j] - grid[0][j-1])\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + abs(grid[i][j] - grid[i-1][j-1])\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers to find the minimum cost to reach the bottom-right corner from the top-left corner.\n    \"\"\"\n    return grid\n\ngrid = [[1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]]\n\nassert f(*g(grid)) == 12\n", "emb": null, "idx_generation": 311, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    The cost of moving to a neighboring cell is the absolute difference between the values of the current cell and the target cell.\n\n    Return the minimum cost.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D DP array to store the minimum cost at each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # Base case: the minimum cost at the top-left corner is 0\n    dp[0][0] = 0\n\n    # Fill in the DP array\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + abs(grid[i][0] - grid[i-1][0])\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + abs(grid[0][j] - grid[0][j-1])\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + abs(grid[i][j] - grid[i-1][j-1])\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers to find the minimum cost to reach the bottom-right corner from the top-left corner.\n    \"\"\"\n    return grid\n\ngrid = [[1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the minimum number of moves required to reach the target character 'T' from the starting character 'S'.\n    The moves are restricted to moving up, down, left, or right in the grid.\n\n    Return the minimum number of moves, or -1 if the target cannot be reached.\n    \"\"\"\n    if not grid:\n        return -1\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D DP array to store the minimum number of moves at each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # Find the indices of the starting and target characters\n    start_row, start_col = -1, -1\n    target_row, target_col = -1, -1\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start_row, start_col = i, j\n            elif grid[i][j] == 'T':\n                target_row, target_col = i, j\n\n    # Base case: the minimum number of moves at the starting cell is 0\n    dp[start_row][start_col] = 0\n\n    # Fill in the DP array\n    for i in range(start_row+1, rows):\n        dp[i][start_col] = dp[i-1][start_col] + 1 if grid[i][start_col] != '#' else float('inf')\n\n    for j in range(start_col+1, cols):\n        dp[start_row][j] = dp[start_row][j-1] + 1 if grid[start_row][j] != '#' else float('inf')\n\n    for i in range(start_row+1, rows):\n        for j in range(start_col+1, cols):\n            if grid[i][j] != '#':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n\n    return dp[target_row][target_col] if dp[target_row][target_col] != float('inf') else -1\n\ndef g(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters to find the minimum number of moves required to reach the target character 'T' from the starting character 'S'.\n    \"\"\"\n    return grid\n\ngrid = [['S', '.', '.', '#', '.'],\n        ['#', '.', '.', '.', '.'],\n        ['#', '.', '.', '.', '.'],\n        ['#', '#', '#', '#', 'T']]\n\nassert f(*g(grid)) == 6\n", "emb": null, "idx_generation": 311, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the minimum number of moves required to reach the target character 'T' from the starting character 'S'.\n    The moves are restricted to moving up, down, left, or right in the grid.\n\n    Return the minimum number of moves, or -1 if the target cannot be reached.\n    \"\"\"\n    if not grid:\n        return -1\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D DP array to store the minimum number of moves at each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # Find the indices of the starting and target characters\n    start_row, start_col = -1, -1\n    target_row, target_col = -1, -1\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start_row, start_col = i, j\n            elif grid[i][j] == 'T':\n                target_row, target_col = i, j\n\n    # Base case: the minimum number of moves at the starting cell is 0\n    dp[start_row][start_col] = 0\n\n    # Fill in the DP array\n    for i in range(start_row+1, rows):\n        dp[i][start_col] = dp[i-1][start_col] + 1 if grid[i][start_col] != '#' else float('inf')\n\n    for j in range(start_col+1, cols):\n        dp[start_row][j] = dp[start_row][j-1] + 1 if grid[start_row][j] != '#' else float('inf')\n\n    for i in range(start_row+1, rows):\n        for j in range(start_col+1, cols):\n            if grid[i][j] != '#':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n\n    return dp[target_row][target_col] if dp[target_row][target_col] != float('inf') else -1", "solution_func": "def g(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters to find the minimum number of moves required to reach the target character 'T' from the starting character 'S'.\n    \"\"\"\n    return grid\n\ngrid = [['S', '.', '.', '#', '.'],\n        ['#', '.', '.', '.', '.'],\n        ['#', '.', '.', '.', '.'],\n        ['#', '#', '#', '#', 'T']]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The maximum XOR value between any two elements in the list is 28 (obtained by XORing 5 and 25).\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The maximum XOR value between any two elements in the list is 28 (obtained by XORing 5 and 25).\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in ascending order based on the count of set bits in each number.\n\n    Return the sorted list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The count of set bits in each number is:\n    3 -> 2 bits\n    10 -> 2 bits\n    5 -> 2 bits\n    25 -> 3 bits\n    2 -> 1 bit\n\n    After sorting based on the count of set bits, the sorted list is: [2, 3, 5, 10, 25]\n\n    Therefore, the function should return [2, 3, 5, 10, 25].\n    \"\"\"\n    def count_bits(n):\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    return sorted(nums, key=count_bits)\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums\n\nassert f(g()) == [2, 3, 5, 10, 25]\n\n", "emb": null, "idx_generation": 311, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in ascending order based on the count of set bits in each number.\n\n    Return the sorted list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The count of set bits in each number is:\n    3 -> 2 bits\n    10 -> 2 bits\n    5 -> 2 bits\n    25 -> 3 bits\n    2 -> 1 bit\n\n    After sorting based on the count of set bits, the sorted list is: [2, 3, 5, 10, 25]\n\n    Therefore, the function should return [2, 3, 5, 10, 25].\n    \"\"\"\n    def count_bits(n):\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    return sorted(nums, key=count_bits)", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any two elements in the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The maximum product of any two elements in the list is 250 (obtained by multiplying 10 and 25).\n\n    Therefore, the function should return 250.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    return max_product\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums\n\nassert f(g()) == 250\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any two elements in the list.\n\n    Return the maximum product.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The maximum product of any two elements in the list is 250 (obtained by multiplying 10 and 25).\n\n    Therefore, the function should return 250.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers arr and a target value, determine if there is a subarray that adds up to the target.\n    Return True if such a subarray exists, False otherwise.\n\n    Sample input:\n    arr = [1, 5, 3, 2, 4]\n    target = 8\n\n    Sample output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = {0}\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(arr = [1, 5, 3, 2, 4], target = 8):\n    return arr\n\nassert f(g(), 8) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 311, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers arr and a target value, determine if there is a subarray that adds up to the target.\n    Return True if such a subarray exists, False otherwise.\n\n    Sample input:\n    arr = [1, 5, 3, 2, 4]\n    target = 8\n\n    Sample output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = {0}\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False", "solution_func": "def g(arr = [1, 5, 3, 2, 4], target = 8):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is present in the list. \n    If the target value is not present, return the index where it would be inserted in order.\n    \"\"\"\n    def binary_search(arr: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return low\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 4)\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value if it is present in the list. \n    If the target value is not present, return the index where it would be inserted in order.\n    \"\"\"\n    def binary_search(arr: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return low\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 4)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n    \"\"\"\n    n = len(arr)\n    left_products = [1] * n\n    right_products = [1] * n\n    output = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * arr[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * arr[i + 1]\n\n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n\n    return output\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 312, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n    \"\"\"\n    n = len(arr)\n    left_products = [1] * n\n    right_products = [1] * n\n    output = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * arr[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * arr[i + 1]\n\n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n\n    return output", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n    \"\"\"\n    n = len(arr)\n    prefix_sums = [0] * n\n\n    prefix_sums[0] = arr[0]\n    for i in range(1, n):\n        prefix_sums[i] = prefix_sums[i - 1] + arr[i]\n\n    return prefix_sums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n    \"\"\"\n    n = len(arr)\n    prefix_sums = [0] * n\n\n    prefix_sums[0] = arr[0]\n    for i in range(1, n):\n        prefix_sums[i] = prefix_sums[i - 1] + arr[i]\n\n    return prefix_sums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands in the grid.\n\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    Assume all four edges of the grid are surrounded by water.\n    \"\"\"\n    num_islands = 0\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                num_islands += 1\n                dfs(grid, visited, i, j)\n\n    return num_islands\n\ndef dfs(grid: List[List[int]], visited: List[List[bool]], row: int, col: int) -> None:\n    rows, cols = len(grid), len(grid[0])\n    if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] == 0 or visited[row][col]:\n        return\n\n    visited[row][col] = True\n    dfs(grid, visited, row + 1, col)\n    dfs(grid, visited, row - 1, col)\n    dfs(grid, visited, row, col + 1)\n    dfs(grid, visited, row, col - 1)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands in the grid.\n\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    Assume all four edges of the grid are surrounded by water.\n    \"\"\"\n    num_islands = 0\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                num_islands += 1\n                dfs(grid, visited, i, j)\n\n    return num_islands\n\ndef dfs(grid: List[List[int]], visited: List[List[bool]], row: int, col: int) -> None:\n    rows, cols = len(grid), len(grid[0])\n    if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] == 0 or visited[row][col]:\n        return\n\n    visited[row][col] = True\n    dfs(grid, visited, row + 1, col)\n    dfs(grid, visited, row - 1, col)\n    dfs(grid, visited, row, col + 1)\n    dfs(grid, visited, row, col - 1)", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    You can only move down or right.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    You can only move down or right.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the minimum number of steps required to move from the top-left cell to the bottom-right cell.\n\n    You can only move down, right, or diagonally (down-right).\n    Each step from one cell to another takes one unit of time.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    dp[0][0] = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n            if i > 0 and j > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 0],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the minimum number of steps required to move from the top-left cell to the bottom-right cell.\n\n    You can only move down, right, or diagonally (down-right).\n    Each step from one cell to another takes one unit of time.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    dp[0][0] = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n            if i > 0 and j > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 0],\n        [1, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum length of a sequence of 1s in the grid that forms a straight line.\n    The line can be horizontal, vertical, or diagonal.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest straight line of 1s in the grid is the diagonal line from (0, 0) to (2, 2) with a length of 4.\n\n    \"\"\"\n\n    def get_longest_sequence(grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        max_length = 0\n\n        # Check horizontal lines\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check vertical lines\n        for j in range(cols):\n            length = 0\n            for i in range(rows):\n                if grid[i][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check diagonal lines (top-left to bottom-right)\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if i + j < rows and grid[i + j][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check diagonal lines (top-right to bottom-left)\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if i + j < rows and grid[i + j][cols - 1 - j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        return max_length\n\n    return get_longest_sequence(grid)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 312, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum length of a sequence of 1s in the grid that forms a straight line.\n    The line can be horizontal, vertical, or diagonal.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest straight line of 1s in the grid is the diagonal line from (0, 0) to (2, 2) with a length of 4.\n\n    \"\"\"\n\n    def get_longest_sequence(grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        max_length = 0\n\n        # Check horizontal lines\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check vertical lines\n        for j in range(cols):\n            length = 0\n            for i in range(rows):\n                if grid[i][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check diagonal lines (top-left to bottom-right)\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if i + j < rows and grid[i + j][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check diagonal lines (top-right to bottom-left)\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if i + j < rows and grid[i + j][cols - 1 - j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        return max_length\n\n    return get_longest_sequence(grid)", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]", "map_ix": [1, 1, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of letters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of adjacent cells (horizontally or vertically),\n    but a cell can only be used once in the word.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Explanation:\n    The word \"ABCCED\" can be formed by starting at (0,0) and moving right -> down -> down.\n\n    \"\"\"\n\n    def dfs(i: int, j: int, k: int) -> bool:\n        if k == len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[k]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni = i + dx\n            nj = j + dy\n            if dfs(ni, nj, k + 1):\n                return True\n\n        grid[i][j] = temp\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\ndef g() -> List[List[str]]:\n    return [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\nassert f(g(), \"ABCCED\") == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of letters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of adjacent cells (horizontally or vertically),\n    but a cell can only be used once in the word.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Explanation:\n    The word \"ABCCED\" can be formed by starting at (0,0) and moving right -> down -> down.\n\n    \"\"\"\n\n    def dfs(i: int, j: int, k: int) -> bool:\n        if k == len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[k]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni = i + dx\n            nj = j + dy\n            if dfs(ni, nj, k + 1):\n                return True\n\n        grid[i][j] = temp\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n\n    return False", "solution_func": "def g() -> List[List[str]]:\n    return [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]", "map_ix": [0, 0, 1, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n            if (row, col) == (rows-1, cols-1):\n                return steps\n\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:\n                    queue.append((new_row, new_col, steps+1))\n\n        return -1\n\n    return bfs(0, 0)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0], "idx_generation": 312, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n            if (row, col) == (rows-1, cols-1):\n                return steps\n\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:\n                    queue.append((new_row, new_col, steps+1))\n\n        return -1\n\n    return bfs(0, 0)", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 1, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there are two numbers in the given list whose XOR is equal to the target value\n    \"\"\"\n    seen = set()\n    for num in arr:\n        complement = target ^ num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 312, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there are two numbers in the given list whose XOR is equal to the target value\n    \"\"\"\n    seen = set()\n    for num in arr:\n        complement = target ^ num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g():\n    return ([1, 2, 3, 4, 5], 6)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"\n    Check if there is a path between two nodes in a graph.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False\n\ndef g(graph: dict, start: str, end: str):\n    \"\"\"\n    Create a graph and find a path between two nodes.\n    \"\"\"\n    return f(graph, start, end)\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['C', 'D'],\n    'C': ['D'],\n    'D': ['E'],\n    'E': []\n}\n\nassert g(graph, 'A', 'E')\n\nassert f(g()) == True", "emb": null, "idx_generation": 313, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom collections import defaultdict\n\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"\n    Check if there is a path between two nodes in a graph.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    \n    return False", "solution_func": "def g(graph: dict, start: str, end: str):\n    \"\"\"\n    Create a graph and find a path between two nodes.\n    \"\"\"\n    return f(graph, start, end)\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['C', 'D'],\n    'C': ['D'],\n    'D': ['E'],\n    'E': []\n}", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a string can be divided into k equal parts.\n    \"\"\"\n    if len(s) % k != 0:\n        return False\n    \n    part_length = len(s) // k\n    parts = [s[i:i+part_length] for i in range(0, len(s), part_length)]\n    \n    return all(part == parts[0] for part in parts)\n\ndef g(s: str, k: int):\n    \"\"\"\n    Divide a string into k equal parts.\n    \"\"\"\n    return f(s, k)\n\nassert g(\"abcdabcdabcd\", 3)\n\nassert f(g()) == True", "emb": null, "idx_generation": 313, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a string can be divided into k equal parts.\n    \"\"\"\n    if len(s) % k != 0:\n        return False\n    \n    part_length = len(s) // k\n    parts = [s[i:i+part_length] for i in range(0, len(s), part_length)]\n    \n    return all(part == parts[0] for part in parts)", "solution_func": "def g(s: str, k: int):\n    \"\"\"\n    Divide a string into k equal parts.\n    \"\"\"\n    return f(s, k)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Check if a target number exists in a matrix.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == target:\n                return True\n    \n    return False\n\ndef g(matrix: List[List[int]], target: int):\n    \"\"\"\n    Find if a target number exists in a matrix.\n    \"\"\"\n    return f(matrix, target)\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nassert g(matrix, 5)\n\nassert f(g()) == True", "emb": null, "idx_generation": 313, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Check if a target number exists in a matrix.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == target:\n                return True\n    \n    return False", "solution_func": "def g(matrix: List[List[int]], target: int):\n    \"\"\"\n    Find if a target number exists in a matrix.\n    \"\"\"\n    return f(matrix, target)\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to arrange n pairs of parentheses such that they are balanced.\n    \"\"\"\n    def backtrack(s: str, left: int, right: int, res: List[str]):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right, res)\n        if right < left:\n            backtrack(s + ')', left, right + 1, res)\n\n    res = []\n    backtrack(\"\", 0, 0, res)\n    return len(res)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to arrange n pairs of parentheses such that they are balanced.\n    \"\"\"\n    def backtrack(s: str, left: int, right: int, res: List[str]):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right, res)\n        if right < left:\n            backtrack(s + ')', left, right + 1, res)\n\n    res = []\n    backtrack(\"\", 0, 0, res)\n    return len(res)", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all unique permutations of the numbers 1 to n.\n    \"\"\"\n    def backtrack(nums: List[int], path: List[int], res: List[List[int]]):\n        if len(path) == len(nums):\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if nums[i] not in path:\n                backtrack(nums, path + [nums[i]], res)\n\n    nums = list(range(1, n+1))\n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all unique permutations of the numbers 1 to n.\n    \"\"\"\n    def backtrack(nums: List[int], path: List[int], res: List[List[int]]):\n        if len(path) == len(nums):\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if nums[i] not in path:\n                backtrack(nums, path + [nums[i]], res)\n\n    nums = list(range(1, n+1))\n    res = []\n    backtrack(nums, [], res)\n    return res", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the nth Fibonacci number using recursion and memoization.\n    \"\"\"\n    memo = {}\n\n    def fibonacci(n: int) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1) + fibonacci(n-2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the nth Fibonacci number using recursion and memoization.\n    \"\"\"\n    memo = {}\n\n    def fibonacci(n: int) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1) + fibonacci(n-2)\n        return memo[n]\n\n    return fibonacci(n)", "solution_func": "def g(n=6):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> int:\n    \"\"\"\n    Given a graph and two nodes, return the number of unique paths from the start node to the end node.\n    Each node in the graph is represented by a string, and the graph is represented as a dictionary where the keys are the nodes and the values are lists of adjacent nodes.\n    \"\"\"\n    def dfs(node: str) -> int:\n        if node == end:\n            return 1\n        \n        if node in visited:\n            return 0\n        \n        visited.add(node)\n        paths = 0\n        \n        for neighbor in graph[node]:\n            paths += dfs(neighbor)\n        \n        visited.remove(node)\n        \n        return paths\n    \n    visited = set()\n    return dfs(start)\n\ndef g() -> Dict[str, List[str]]:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    return graph\n\nassert f(g(), 'A', 'E') == 3\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> int:\n    \"\"\"\n    Given a graph and two nodes, return the number of unique paths from the start node to the end node.\n    Each node in the graph is represented by a string, and the graph is represented as a dictionary where the keys are the nodes and the values are lists of adjacent nodes.\n    \"\"\"\n    def dfs(node: str) -> int:\n        if node == end:\n            return 1\n        \n        if node in visited:\n            return 0\n        \n        visited.add(node)\n        paths = 0\n        \n        for neighbor in graph[node]:\n            paths += dfs(neighbor)\n        \n        visited.remove(node)\n        \n        return paths\n    \n    visited = set()\n    return dfs(start)", "solution_func": "def g() -> Dict[str, List[str]]:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, return a list of two numbers from the list that add up to the target.\n    If multiple solutions exist, return any valid pair. You may assume that each input has exactly one solution.\n    \"\"\"\n    num_map = {}\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_map:\n            return [complement, num]\n        num_map[num] = True\n    \n    return []\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [2, 7]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, return a list of two numbers from the list that add up to the target.\n    If multiple solutions exist, return any valid pair. You may assume that each input has exactly one solution.\n    \"\"\"\n    num_map = {}\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_map:\n            return [complement, num]\n        num_map[num] = True\n    \n    return []", "solution_func": "def g() -> List[int]:\n    return [2, 7, 11, 15]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, return a list of three numbers from the list that add up to the target.\n    If multiple solutions exist, return any valid triplet. You may assume that each input has exactly one solution.\n    \"\"\"\n    nums.sort()\n    \n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15, 3, 1, 5]\n\nassert f(g(), 18) == [2, 7, 9]\n\n", "emb": null, "idx_generation": 313, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, return a list of three numbers from the list that add up to the target.\n    If multiple solutions exist, return any valid triplet. You may assume that each input has exactly one solution.\n    \"\"\"\n    nums.sort()\n    \n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return []", "solution_func": "def g() -> List[int]:\n    return [2, 7, 11, 15, 3, 1, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n\n    A matrix is considered a magic square if the sum of each row, each column, and each diagonal is equal.\n\n    Example:\n    Input: matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n\n    Explanation:\n    The matrix:\n    2 7 6\n    9 5 1\n    4 3 8\n\n    The sum of each row, each column, and each diagonal is 15.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum_2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum_1 != target_sum or diagonal_sum_2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 313, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n\n    A matrix is considered a magic square if the sum of each row, each column, and each diagonal is equal.\n\n    Example:\n    Input: matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n\n    Explanation:\n    The matrix:\n    2 7 6\n    9 5 1\n    4 3 8\n\n    The sum of each row, each column, and each diagonal is 15.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum_2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum_1 != target_sum or diagonal_sum_2 != target_sum:\n        return False\n\n    return True", "solution_func": "def g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes 'n' and a list of edges 'edges', return the maximum depth of a tree formed by the edges.\n\n    Example:\n    n = 6\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    The edges form a tree with maximum depth 3, so the function should return 3.\n    \"\"\"\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append(v)\n    \n    def dfs(node, depth):\n        if node not in graph:\n            return depth\n        max_depth = 0\n        for neighbor in graph[node]:\n            max_depth = max(max_depth, dfs(neighbor, depth + 1))\n        return max_depth\n    \n    return dfs(1, 1)\n\ndef g():\n    n = 6\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    return n, edges\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 314, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes 'n' and a list of edges 'edges', return the maximum depth of a tree formed by the edges.\n\n    Example:\n    n = 6\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    The edges form a tree with maximum depth 3, so the function should return 3.\n    \"\"\"\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append(v)\n    \n    def dfs(node, depth):\n        if node not in graph:\n            return depth\n        max_depth = 0\n        for neighbor in graph[node]:\n            max_depth = max(max_depth, dfs(neighbor, depth + 1))\n        return max_depth\n    \n    return dfs(1, 1)", "solution_func": "def g():\n    n = 6\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]\n    return n, edges", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words 'words', return a new list where each word is reversed if it starts with a vowel, and the \n    original word otherwise.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    The words that start with vowels are \"apple\" and \"orange\". After reversing them, the function should return \n    [\"elppa\", \"banana\", \"egnaro\", \"kiwi\"].\n    \"\"\"\n    vowels = set(\"aeiou\")\n    return [word[::-1] if word[0].lower() in vowels else word for word in words]\n\ndef g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    return words\n\nassert f(g()) == [\"elppa\", \"banana\", \"egnaro\", \"kiwi\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words 'words', return a new list where each word is reversed if it starts with a vowel, and the \n    original word otherwise.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    The words that start with vowels are \"apple\" and \"orange\". After reversing them, the function should return \n    [\"elppa\", \"banana\", \"egnaro\", \"kiwi\"].\n    \"\"\"\n    vowels = set(\"aeiou\")\n    return [word[::-1] if word[0].lower() in vowels else word for word in words]", "solution_func": "def g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    return words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words 'words', return a new list where each word is sorted in increasing order of the number of \n    vowels it contains.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    The word \"apple\" has 2 vowels, \"banana\" has 3 vowels, \"orange\" has 3 vowels, and \"kiwi\" has 2 vowels. After sorting \n    the words based on the number of vowels, the function should return [\"kiwi\", \"apple\", \"orange\", \"banana\"].\n    \"\"\"\n    def count_vowels(word):\n        count = 0\n        for char in word:\n            if char.lower() in \"aeiou\":\n                count += 1\n        return count\n    \n    return sorted(words, key=count_vowels)\n\ndef g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    return words\n\nassert f(g()) == [\"kiwi\", \"apple\", \"orange\", \"banana\"]\n", "emb": null, "idx_generation": 314, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words 'words', return a new list where each word is sorted in increasing order of the number of \n    vowels it contains.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    The word \"apple\" has 2 vowels, \"banana\" has 3 vowels, \"orange\" has 3 vowels, and \"kiwi\" has 2 vowels. After sorting \n    the words based on the number of vowels, the function should return [\"kiwi\", \"apple\", \"orange\", \"banana\"].\n    \"\"\"\n    def count_vowels(word):\n        count = 0\n        for char in word:\n            if char.lower() in \"aeiou\":\n                count += 1\n        return count\n    \n    return sorted(words, key=count_vowels)", "solution_func": "def g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the number of inversions in the list.\n\n    An inversion occurs when there are two elements i and j such that i < j and arr[i] > arr[j].\n\n    Sample Input:\n    arr = [1, 3, 2, 4, 5]\n\n    Sample Output:\n    1\n\n    Explanation:\n    In the given list, the pair (3, 2) is an inversion since 3 > 2.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that it contains at least one inversion.\n    \"\"\"\n    return [1, 3, 2, 4, 5]\n\nassert f(g()) == 1\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the number of inversions in the list.\n\n    An inversion occurs when there are two elements i and j such that i < j and arr[i] > arr[j].\n\n    Sample Input:\n    arr = [1, 3, 2, 4, 5]\n\n    Sample Output:\n    1\n\n    Explanation:\n    In the given list, the pair (3, 2) is an inversion since 3 > 2.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that it contains at least one inversion.\n    \"\"\"\n    return [1, 3, 2, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all prime numbers in the list.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    10\n\n    Explanation:\n    In the given list, the prime numbers are 2, 3, and 5.\n    Their sum is 2 + 3 + 5 = 10.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in arr:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that it contains at least one prime number.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 10\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all prime numbers in the list.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    10\n\n    Explanation:\n    In the given list, the prime numbers are 2, 3, and 5.\n    Their sum is 2 + 3 + 5 = 10.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in arr:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that it contains at least one prime number.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to arrange k items from a set of n items with repetition allowed.\n\n    Sample Input:\n    n = 3\n    k = 2\n\n    Sample Output:\n    9\n\n    Explanation:\n    In the given set of 3 items, the possible arrangements of 2 items with repetition allowed are:\n    (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3).\n    Hence, there are 9 ways to arrange 2 items from a set of 3 items with repetition allowed.\n    \"\"\"\n    return n ** k\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two integers n and k such that there are at least k ways to arrange k items from a set of n items with repetition allowed.\n    \"\"\"\n    n = 3\n    k = 2\n    return n, k\n\nassert f(*g()) == 9\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to arrange k items from a set of n items with repetition allowed.\n\n    Sample Input:\n    n = 3\n    k = 2\n\n    Sample Output:\n    9\n\n    Explanation:\n    In the given set of 3 items, the possible arrangements of 2 items with repetition allowed are:\n    (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3).\n    Hence, there are 9 ways to arrange 2 items from a set of 3 items with repetition allowed.\n    \"\"\"\n    return n ** k", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate two integers n and k such that there are at least k ways to arrange k items from a set of n items with repetition allowed.\n    \"\"\"\n    n = 3\n    k = 2\n    return n, k", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum = 6.\n\n    Input: nums = [1, -2, 3, -4, 5]\n    Output: 7\n    Explanation: The contiguous subarray [3, -4, 5] has the largest sum = 7.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = curr_sum = nums[0]\n    for i in range(1, len(nums)):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, -1, 3, -2, 4, -3, 5]\n\nassert f(g()) == 11\n", "emb": null, "idx_generation": 314, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum = 6.\n\n    Input: nums = [1, -2, 3, -4, 5]\n    Output: 7\n    Explanation: The contiguous subarray [3, -4, 5] has the largest sum = 7.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = curr_sum = nums[0]\n    for i in range(1, len(nums)):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, -1, 3, -2, 4, -3, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 6, 7, 1, 2, 3, 4]\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 314, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 6, 7, 1, 2, 3, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after deleting at most one character.\n\n    Example:\n    Input: s = \"aba\"\n    Output: True\n    Explanation: The string is already a palindrome.\n\n    Input: s = \"abca\"\n    Output: True\n    Explanation: By deleting 'b', the resulting string is \"aca\", which is a palindrome.\n\n    Input: s = \"abcda\"\n    Output: False\n    Explanation: There is no way to make the string a palindrome by deleting at most one character.\n    \"\"\"\n    def is_palindrome(s: str, i: int, j: int) -> bool:\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n    \n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    \n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcda\"\n\nassert f(g()) == False\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 314, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after deleting at most one character.\n\n    Example:\n    Input: s = \"aba\"\n    Output: True\n    Explanation: The string is already a palindrome.\n\n    Input: s = \"abca\"\n    Output: True\n    Explanation: By deleting 'b', the resulting string is \"aca\", which is a palindrome.\n\n    Input: s = \"abcda\"\n    Output: False\n    Explanation: There is no way to make the string a palindrome by deleting at most one character.\n    \"\"\"\n    def is_palindrome(s: str, i: int, j: int) -> bool:\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n    \n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    \n    return True", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcda\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of combinations of elements in the given list that add up to the target value.\n    \"\"\"\n    def backtrack(index: int, remaining: int) -> int:\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n        if index >= len(nums):\n            return 0\n        return backtrack(index + 1, remaining) + backtrack(index, remaining - nums[index])\n    \n    return backtrack(0, target)\n\ndef g(nums: List[int], target: int):\n    return nums\n\nassert f(g([2, 4, 6, 8], 10)) == 2\n", "emb": null, "idx_generation": 314, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of combinations of elements in the given list that add up to the target value.\n    \"\"\"\n    def backtrack(index: int, remaining: int) -> int:\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n        if index >= len(nums):\n            return 0\n        return backtrack(index + 1, remaining) + backtrack(index, remaining - nums[index])\n    \n    return backtrack(0, target)", "solution_func": "def g(nums: List[int], target: int):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right at any point in time. However, some cells in the grid are blocked and cannot be traversed.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right at any point in time. However, some cells in the grid are blocked and cannot be traversed.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[-1][-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum product of any two distinct numbers in the array.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 250\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum product of any two distinct numbers in the array.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    \n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target value 'target',\n    find the index of the target value in the array using binary search.\n    If the target value is not present in the array, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9], target = 5\n\n    The target value 5 is present at index 2 in the array.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target value 'target',\n    find the index of the target value in the array using binary search.\n    If the target value is not present in the array, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9], target = 5\n\n    The target value 5 is present at index 2 in the array.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be obtained by XORing 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be obtained by XORing 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the number of distinct values that can be obtained by performing\n    bitwise XOR operation on any two numbers in the list.\n\n    Example:\n    nums = [3, 4, 5, 4, 3, 6]\n\n    The distinct values that can be obtained by performing bitwise XOR operation are [0, 1, 3, 4, 5, 6, 7].\n\n    Therefore, the function should return 7.\n    \"\"\"\n\n    distinct_values = set()\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            distinct_values.add(xor)\n\n    return len(distinct_values)\n\ndef g() -> List[int]:\n    nums = [3, 4, 5, 4, 3, 6]\n    return nums\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the number of distinct values that can be obtained by performing\n    bitwise XOR operation on any two numbers in the list.\n\n    Example:\n    nums = [3, 4, 5, 4, 3, 6]\n\n    The distinct values that can be obtained by performing bitwise XOR operation are [0, 1, 3, 4, 5, 6, 7].\n\n    Therefore, the function should return 7.\n    \"\"\"\n\n    distinct_values = set()\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            distinct_values.add(xor)\n\n    return len(distinct_values)", "solution_func": "def g() -> List[int]:\n    nums = [3, 4, 5, 4, 3, 6]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two elements in the array.\n    XOR is a bitwise operation that returns 0 if the corresponding bits are the same, and 1 otherwise.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two elements in the array is 28, which can be obtained by XORing 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n\n    # Iterate through each bit position from the most significant bit to the least significant bit\n    for i in range(31, -1, -1):\n        max_xor <<= 1\n        prefixes = set()\n\n        # Create a set of prefixes of the current bit position\n        for num in nums:\n            prefixes.add(num >> i)\n\n        # Try to find a pair of numbers that have different prefixes at the current bit position\n        for prefix in prefixes:\n            complement = max_xor ^ prefix\n\n            if complement in prefixes:\n                max_xor |= 1\n\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": null, "idx_generation": 315, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two elements in the array.\n    XOR is a bitwise operation that returns 0 if the corresponding bits are the same, and 1 otherwise.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two elements in the array is 28, which can be obtained by XORing 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n\n    # Iterate through each bit position from the most significant bit to the least significant bit\n    for i in range(31, -1, -1):\n        max_xor <<= 1\n        prefixes = set()\n\n        # Create a set of prefixes of the current bit position\n        for num in nums:\n            prefixes.add(num >> i)\n\n        # Try to find a pair of numbers that have different prefixes at the current bit position\n        for prefix in prefixes:\n            complement = max_xor ^ prefix\n\n            if complement in prefixes:\n                max_xor |= 1\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    You can move in four directions: up, down, left, and right.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    The longest increasing path in the grid is [1, 2, 6, 9], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_length = 0\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        length = 1\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                length = max(length, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = length\n        return length\n\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    You can move in four directions: up, down, left, and right.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    The longest increasing path in the grid is [1, 2, 6, 9], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_length = 0\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        length = 1\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                length = max(length, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = length\n        return length\n\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right cell\n    from the top-left cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum number of steps required to reach the bottom-right cell from the top-left cell is 7,\n    following the path: right -> down -> down -> right -> right -> down -> right.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 315, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the bottom-right cell\n    from the top-left cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum number of steps required to reach the bottom-right cell from the top-left cell is 7,\n    following the path: right -> down -> down -> right -> right -> down -> right.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a pair of numbers that sum up to the target.\n\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    return nums, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 315, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a pair of numbers that sum up to the target.\n\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of subarrays that have a sum that is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 3\n\n    Explanation: The subarrays with a sum divisible by 3 are [3], [1, 2], and [2, 3].\n\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    remainder_count = [0] * 3\n\n    for num in nums:\n        prefix_sum += num\n        remainder = prefix_sum % 3\n        remainder_count[remainder] += 1\n\n    count += remainder_count[0]  # Subarrays with sum divisible by 3\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Subarrays with sum divisible by 3 and length 2\n    count += (remainder_count[1] * (remainder_count[1] - 1)) // 2  # Subarrays with sum divisible by 3 and length 2\n    count += (remainder_count[2] * (remainder_count[2] - 1)) // 2  # Subarrays with sum divisible by 3 and length 2\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 316, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of subarrays that have a sum that is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 3\n\n    Explanation: The subarrays with a sum divisible by 3 are [3], [1, 2], and [2, 3].\n\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    remainder_count = [0] * 3\n\n    for num in nums:\n        prefix_sum += num\n        remainder = prefix_sum % 3\n        remainder_count[remainder] += 1\n\n    count += remainder_count[0]  # Subarrays with sum divisible by 3\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Subarrays with sum divisible by 3 and length 2\n    count += (remainder_count[1] * (remainder_count[1] - 1)) // 2  # Subarrays with sum divisible by 3 and length 2\n    count += (remainder_count[2] * (remainder_count[2] - 1)) // 2  # Subarrays with sum divisible by 3 and length 2\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph as an adjacency list, determine if it contains a cycle.\n\n    Example:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n\n    \"\"\"\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, -1):\n                return True\n\n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph as an adjacency list, determine if it contains a cycle.\n\n    Example:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n\n    \"\"\"\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, -1):\n                return True\n\n    return False", "solution_func": "def g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, check if there exists a subset of the integers that adds up to the\n    target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    Output: True\n\n    Explanation: The subset [2, 8] adds up to the target 10.\n\n    \"\"\"\n    def backtrack(index, current_sum):\n        if current_sum == target:\n            return True\n\n        if current_sum > target or index >= len(nums):\n            return False\n\n        if memo[index][current_sum] != -1:\n            return memo[index][current_sum]\n\n        if backtrack(index + 1, current_sum + nums[index]):\n            memo[index][current_sum] = True\n            return True\n\n        if backtrack(index + 1, current_sum):\n            memo[index][current_sum] = True\n            return True\n\n        memo[index][current_sum] = False\n        return False\n\n    memo = [[-1] * (target + 1) for _ in range(len(nums))]\n\n    return backtrack(0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, check if there exists a subset of the integers that adds up to the\n    target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    Output: True\n\n    Explanation: The subset [2, 8] adds up to the target 10.\n\n    \"\"\"\n    def backtrack(index, current_sum):\n        if current_sum == target:\n            return True\n\n        if current_sum > target or index >= len(nums):\n            return False\n\n        if memo[index][current_sum] != -1:\n            return memo[index][current_sum]\n\n        if backtrack(index + 1, current_sum + nums[index]):\n            memo[index][current_sum] = True\n            return True\n\n        if backtrack(index + 1, current_sum):\n            memo[index][current_sum] = True\n            return True\n\n        memo[index][current_sum] = False\n        return False\n\n    memo = [[-1] * (target + 1) for _ in range(len(nums))]\n\n    return backtrack(0, 0)", "solution_func": "def g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, return the index of the first occurrence of the target number in the list.\n    If the target number is not present in the list, return -1.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]\n    target = 5\n    output: 5\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, return the index of the first occurrence of the target number in the list.\n    If the target number is not present in the list, return -1.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]\n    target = 5\n    output: 5\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]\n    target = 5\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 316, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) sum up to the target number 9.\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 316, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) sum up to the target number 9.\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[n-1]\n\ndef g():\n    # The list of integers\n    nums = [1, 2, 3, 1, 5, 6, 7]\n    \n    return nums\n\nassert f(g()) == 16\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[n-1]", "solution_func": "def g():\n    # The list of integers\n    nums = [1, 2, 3, 1, 5, 6, 7]\n    \n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a target sum, find the minimum number of elements from nums that can be added up to the target sum.\n    Return the minimum number of elements.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return -1\n    if n == 1:\n        if nums[0] == target:\n            return 1\n        else:\n            return -1\n    \n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    \n    for i in range(1, target + 1):\n        for num in nums:\n            if num <= i:\n                dp[i] = min(dp[i], dp[i-num] + 1)\n    \n    if dp[target] == float('inf'):\n        return -1\n    else:\n        return dp[target]\n\ndef g():\n    # The list of integers\n    nums = [1, 3, 5, 7]\n    \n    # The target sum\n    target = 10\n    \n    return nums\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 316, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a target sum, find the minimum number of elements from nums that can be added up to the target sum.\n    Return the minimum number of elements.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return -1\n    if n == 1:\n        if nums[0] == target:\n            return 1\n        else:\n            return -1\n    \n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    \n    for i in range(1, target + 1):\n        for num in nums:\n            if num <= i:\n                dp[i] = min(dp[i], dp[i-num] + 1)\n    \n    if dp[target] == float('inf'):\n        return -1\n    else:\n        return dp[target]", "solution_func": "def g():\n    # The list of integers\n    nums = [1, 3, 5, 7]\n    \n    # The target sum\n    target = 10\n    \n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (LIS).\n    Return the length of the LIS.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    # The list of integers\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    \n    return nums\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (LIS).\n    Return the length of the LIS.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g():\n    # The list of integers\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    \n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    The function should return 4 since the longest increasing subsequence is [2, 3, 7, 101].\n\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there exists a longest increasing subsequence.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 316, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    The function should return 4 since the longest increasing subsequence is [2, 3, 7, 101].\n\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there exists a longest increasing subsequence.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    def two_sum(nums: List[int], target: int, start: int, end: int) -> bool:\n        if start >= end:\n            return False\n        if nums[start] + nums[end] == target:\n            return True\n        if nums[start] + nums[end] < target:\n            return two_sum(nums, target, start + 1, end)\n        else:\n            return two_sum(nums, target, start, end - 1)\n    \n    nums.sort()\n    return two_sum(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target sum\"\"\"\n    return ([3, 5, 1, 2, 4], 7)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    def two_sum(nums: List[int], target: int, start: int, end: int) -> bool:\n        if start >= end:\n            return False\n        if nums[start] + nums[end] == target:\n            return True\n        if nums[start] + nums[end] < target:\n            return two_sum(nums, target, start + 1, end)\n        else:\n            return two_sum(nums, target, start, end - 1)\n    \n    nums.sort()\n    return two_sum(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target sum\"\"\"\n    return ([3, 5, 1, 2, 4], 7)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string\"\"\"\n    def reverse_words(s: str) -> str:\n        words = s.split()\n        reversed_words = [word[::-1] for word in words]\n        return ' '.join(reversed_words)\n\n    return reverse_words(s)\n\ndef g() -> str:\n    \"\"\"Generate a string\"\"\"\n    return \"Hello world\"\n\nassert f(g()) == \"olleH dlrow\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string\"\"\"\n    def reverse_words(s: str) -> str:\n        words = s.split()\n        reversed_words = [word[::-1] for word in words]\n        return ' '.join(reversed_words)\n\n    return reverse_words(s)", "solution_func": "def g() -> str:\n    \"\"\"Generate a string\"\"\"\n    return \"Hello world\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    def fibonacci(n: int, memo: Dict[int, int]) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)\n\ndef g() -> int:\n    \"\"\"Generate an integer\"\"\"\n    return 6\n\nassert f(g()) == 8\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    def fibonacci(n: int, memo: Dict[int, int]) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)", "solution_func": "def g() -> int:\n    \"\"\"Generate an integer\"\"\"\n    return 6", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n        - F(0) = 0\n        - F(1) = 1\n        - F(n) = F(n-1) + F(n-2) for n > 1\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n        - F(0) = 0\n        - F(1) = 1\n        - F(n) = F(n-1) + F(n-2) for n > 1\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    A subarray is a contiguous part of the array.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    A subarray is a contiguous part of the array.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i\n    is the product of all the numbers in the original list except the one at i.\n    \"\"\"\n    n = len(nums)\n    product = 1\n    output = [1] * n\n    \n    # Calculate the product of all elements before index i\n    for i in range(n):\n        output[i] *= product\n        product *= nums[i]\n    \n    product = 1\n    \n    # Calculate the product of all elements after index i\n    for i in range(n-1, -1, -1):\n        output[i] *= product\n        product *= nums[i]\n    \n    return output\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i\n    is the product of all the numbers in the original list except the one at i.\n    \"\"\"\n    n = len(nums)\n    product = 1\n    output = [1] * n\n    \n    # Calculate the product of all elements before index i\n    for i in range(n):\n        output[i] *= product\n        product *= nums[i]\n    \n    product = 1\n    \n    # Calculate the product of all elements after index i\n    for i in range(n-1, -1, -1):\n        output[i] *= product\n        product *= nums[i]\n    \n    return output", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is sorted in non-decreasing order and contains only prime numbers.\"\"\"\n    def is_prime(n: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) and all(is_prime(num) for num in arr)\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [2, 3, 5, 7, 11, 13]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is sorted in non-decreasing order and contains only prime numbers.\"\"\"\n    def is_prime(n: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) and all(is_prime(num) for num in arr)", "solution_func": "def g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [2, 3, 5, 7, 11, 13]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"Check if the given list of points forms a rectangle.\"\"\"\n    def is_perpendicular(p1: List[int], p2: List[int], p3: List[int]) -> bool:\n        \"\"\"Check if two line segments are perpendicular.\"\"\"\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        dx1 = x2 - x1\n        dy1 = y2 - y1\n        dx2 = x3 - x2\n        dy2 = y3 - y2\n        return dx1 * dx2 + dy1 * dy2 == 0\n\n    def is_right_angle(p1: List[int], p2: List[int], p3: List[int]) -> bool:\n        \"\"\"Check if three points form a right angle.\"\"\"\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        dx1 = x2 - x1\n        dy1 = y2 - y1\n        dx2 = x3 - x2\n        dy2 = y3 - y2\n        return dx1 * dx2 + dy1 * dy2 == 0\n\n    if len(points) != 4:\n        return False\n\n    for i in range(4):\n        p1, p2, p3 = points[i-1], points[i], points[(i+1) % 4]\n        if not is_perpendicular(p1, p2, p3) or not is_right_angle(p1, p2, p3):\n            return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a list of points.\"\"\"\n    return [[0, 0], [0, 3], [4, 0], [4, 3]]\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 317, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"Check if the given list of points forms a rectangle.\"\"\"\n    def is_perpendicular(p1: List[int], p2: List[int], p3: List[int]) -> bool:\n        \"\"\"Check if two line segments are perpendicular.\"\"\"\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        dx1 = x2 - x1\n        dy1 = y2 - y1\n        dx2 = x3 - x2\n        dy2 = y3 - y2\n        return dx1 * dx2 + dy1 * dy2 == 0\n\n    def is_right_angle(p1: List[int], p2: List[int], p3: List[int]) -> bool:\n        \"\"\"Check if three points form a right angle.\"\"\"\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        dx1 = x2 - x1\n        dy1 = y2 - y1\n        dx2 = x3 - x2\n        dy2 = y3 - y2\n        return dx1 * dx2 + dy1 * dy2 == 0\n\n    if len(points) != 4:\n        return False\n\n    for i in range(4):\n        p1, p2, p3 = points[i-1], points[i], points[(i+1) % 4]\n        if not is_perpendicular(p1, p2, p3) or not is_right_angle(p1, p2, p3):\n            return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"Generate a list of points.\"\"\"\n    return [[0, 0], [0, 3], [4, 0], [4, 3]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid contains a valid sudoku solution.\"\"\"\n    def is_valid_row(row: List[int]) -> bool:\n        \"\"\"Check if a row in the grid is valid.\"\"\"\n        return len(set(row)) == 9\n\n    def is_valid_column(col: List[int]) -> bool:\n        \"\"\"Check if a column in the grid is valid.\"\"\"\n        return len(set(col)) == 9\n\n    def is_valid_box(box: List[int]) -> bool:\n        \"\"\"Check if a 3x3 box in the grid is valid.\"\"\"\n        return len(set(box)) == 9\n\n    # Check rows\n    for row in grid:\n        if not is_valid_row(row):\n            return False\n\n    # Check columns\n    for col in zip(*grid):\n        if not is_valid_column(col):\n            return False\n\n    # Check boxes\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid_box(box):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a valid sudoku grid.\"\"\"\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid contains a valid sudoku solution.\"\"\"\n    def is_valid_row(row: List[int]) -> bool:\n        \"\"\"Check if a row in the grid is valid.\"\"\"\n        return len(set(row)) == 9\n\n    def is_valid_column(col: List[int]) -> bool:\n        \"\"\"Check if a column in the grid is valid.\"\"\"\n        return len(set(col)) == 9\n\n    def is_valid_box(box: List[int]) -> bool:\n        \"\"\"Check if a 3x3 box in the grid is valid.\"\"\"\n        return len(set(box)) == 9\n\n    # Check rows\n    for row in grid:\n        if not is_valid_row(row):\n            return False\n\n    # Check columns\n    for col in zip(*grid):\n        if not is_valid_column(col):\n            return False\n\n    # Check boxes\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid_box(box):\n                return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"Generate a valid sudoku grid.\"\"\"\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]", "map_ix": [1, 1, 1, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    if not s:\n        return 0\n\n    n = len(s)\n    max_len = 0\n    start = 0\n    seen = set()\n\n    for i in range(n):\n        while s[i] in seen:\n            seen.remove(s[start])\n            start += 1\n        seen.add(s[i])\n        max_len = max(max_len, i - start + 1)\n\n    return max_len\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 317, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    if not s:\n        return 0\n\n    n = len(s)\n    max_len = 0\n    start = 0\n    seen = set()\n\n    for i in range(n):\n        while s[i] in seen:\n            seen.remove(s[start])\n            start += 1\n        seen.add(s[i])\n        max_len = max(max_len, i - start + 1)\n\n    return max_len", "solution_func": "def g() -> str:\n    return \"abcabcbb\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and an integer n,\n    return the number of distinct paths from node 0 to node n-1.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n\n    The graph can be represented as follows:\n      0 -> 1 -> 3\n       \\-> 2 -> 3\n\n    There are 2 distinct paths from node 0 to node 3.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    def dfs(node: int) -> int:\n        if node == n - 1:\n            return 1\n\n        count = 0\n        for neighbor in graph[node]:\n            count += dfs(neighbor)\n\n        return count\n\n    return dfs(0)\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n    return n, edges\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 318, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and an integer n,\n    return the number of distinct paths from node 0 to node n-1.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n\n    The graph can be represented as follows:\n      0 -> 1 -> 3\n       \\-> 2 -> 3\n\n    There are 2 distinct paths from node 0 to node 3.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    def dfs(node: int) -> int:\n        if node == n - 1:\n            return 1\n\n        count = 0\n        for neighbor in graph[node]:\n            count += dfs(neighbor)\n\n        return count\n\n    return dfs(0)", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n    return n, edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and an integer n,\n    return the number of distinct paths from node 0 to node n-1, where the sum of the values along the path is divisible by 3.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n\n    The graph can be represented as follows:\n      0 -> 1 -> 3\n       \\-> 2 -> 3\n\n    There are 2 distinct paths from node 0 to node 3 that have a sum divisible by 3:\n    - 0 -> 1 -> 3 (sum = 4)\n    - 0 -> 2 -> 3 (sum = 5)\n\n    Therefore, the function should return 2.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    def dfs(node: int, path_sum: int) -> int:\n        if node == n - 1:\n            if path_sum % 3 == 0:\n                return 1\n            else:\n                return 0\n\n        count = 0\n        for neighbor in graph[node]:\n            count += dfs(neighbor, path_sum + neighbor)\n\n        return count\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n    return n, edges\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 318, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and an integer n,\n    return the number of distinct paths from node 0 to node n-1, where the sum of the values along the path is divisible by 3.\n\n    Example:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n\n    The graph can be represented as follows:\n      0 -> 1 -> 3\n       \\-> 2 -> 3\n\n    There are 2 distinct paths from node 0 to node 3 that have a sum divisible by 3:\n    - 0 -> 1 -> 3 (sum = 4)\n    - 0 -> 2 -> 3 (sum = 5)\n\n    Therefore, the function should return 2.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    def dfs(node: int, path_sum: int) -> int:\n        if node == n - 1:\n            if path_sum % 3 == 0:\n                return 1\n            else:\n                return 0\n\n        count = 0\n        for neighbor in graph[node]:\n            count += dfs(neighbor, path_sum + neighbor)\n\n        return count\n\n    return dfs(0, 0)", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]\n    return n, edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and an integer n,\n    return the number of distinct paths from node 0 to node n-1, where the sum of the values along the path is divisible by 3.\n\n    Example:\n    n = 4\n    edges = [[0, 1, 2], [0, 2, 3], [1, 2, 4], [1, 3, 1], [2, 3, 2]]\n\n    The graph can be represented as follows:\n      0 -> 1 -> 3\n       \\-> 2 -> 3\n\n    There are 2 distinct paths from node 0 to node 3 that have a sum divisible by 3:\n    - 0 -> 1 -> 3 (sum = 6)\n    - 0 -> 2 -> 3 (sum = 7)\n\n    Therefore, the function should return 2.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append((edge[1], edge[2]))\n\n    def dfs(node: int, path_sum: int) -> int:\n        if node == n - 1:\n            if path_sum % 3 == 0:\n                return 1\n            else:\n                return 0\n\n        count = 0\n        for neighbor, value in graph[node]:\n            count += dfs(neighbor, path_sum + value)\n\n        return count\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1, 2], [0, 2, 3], [1, 2, 4], [1, 3, 1], [2, 3, 2]]\n    return n, edges\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 318, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list and an integer n,\n    return the number of distinct paths from node 0 to node n-1, where the sum of the values along the path is divisible by 3.\n\n    Example:\n    n = 4\n    edges = [[0, 1, 2], [0, 2, 3], [1, 2, 4], [1, 3, 1], [2, 3, 2]]\n\n    The graph can be represented as follows:\n      0 -> 1 -> 3\n       \\-> 2 -> 3\n\n    There are 2 distinct paths from node 0 to node 3 that have a sum divisible by 3:\n    - 0 -> 1 -> 3 (sum = 6)\n    - 0 -> 2 -> 3 (sum = 7)\n\n    Therefore, the function should return 2.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append((edge[1], edge[2]))\n\n    def dfs(node: int, path_sum: int) -> int:\n        if node == n - 1:\n            if path_sum % 3 == 0:\n                return 1\n            else:\n                return 0\n\n        count = 0\n        for neighbor, value in graph[node]:\n            count += dfs(neighbor, path_sum + value)\n\n        return count\n\n    return dfs(0, 0)", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0, 1, 2], [0, 2, 3], [1, 2, 4], [1, 3, 1], [2, 3, 2]]\n    return n, edges", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner,\n    where the sum of the values along the path is a perfect square.\n    You can only move down or right, and you can start and end at any cell.\n    Return True if such a path exists, otherwise return False.\n    \"\"\"\n    def is_perfect_square(num: int) -> bool:\n        \"\"\"\n        Check if a number is a perfect square.\n        \"\"\"\n        root = int(num ** 0.5)\n        return root * root == num\n\n    def find_path(matrix: List[List[int]], i: int, j: int, curr_sum: int) -> bool:\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return is_perfect_square(curr_sum + matrix[i][j])\n\n        if i < len(matrix) - 1 and find_path(matrix, i + 1, j, curr_sum + matrix[i][j]):\n            return True\n\n        if j < len(matrix[0]) - 1 and find_path(matrix, i, j + 1, curr_sum + matrix[i][j]):\n            return True\n\n        return False\n\n    return find_path(matrix, 0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner,\n    where the sum of the values along the path is a perfect square.\n    You can only move down or right, and you can start and end at any cell.\n    Return True if such a path exists, otherwise return False.\n    \"\"\"\n    def is_perfect_square(num: int) -> bool:\n        \"\"\"\n        Check if a number is a perfect square.\n        \"\"\"\n        root = int(num ** 0.5)\n        return root * root == num\n\n    def find_path(matrix: List[List[int]], i: int, j: int, curr_sum: int) -> bool:\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return is_perfect_square(curr_sum + matrix[i][j])\n\n        if i < len(matrix) - 1 and find_path(matrix, i + 1, j, curr_sum + matrix[i][j]):\n            return True\n\n        if j < len(matrix[0]) - 1 and find_path(matrix, i, j + 1, curr_sum + matrix[i][j]):\n            return True\n\n        return False\n\n    return find_path(matrix, 0, 0, 0)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all pairs of numbers in the list that sum up to the target.\n    Return a list of tuples, where each tuple contains the indices of a pair of numbers.\n    \"\"\"\n    def two_sum(nums: List[int], target: int, start: int) -> List[Tuple[int, int]]:\n        result = []\n        seen = set()\n\n        for i in range(start, len(nums)):\n            complement = target - nums[i]\n            if complement in seen:\n                result.append((nums.index(complement), i))\n            seen.add(nums[i])\n\n        return result\n\n    result = []\n    for i in range(len(nums)):\n        pairs = two_sum(nums, target - nums[i], i + 1)\n        for pair in pairs:\n            result.append((i,) + pair)\n\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 5, 3, 1, 6, 4], 7)\n\nassert f(*g()) == [(0, 1, 2), (1, 3, 4)]\n", "emb": null, "idx_generation": 318, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all pairs of numbers in the list that sum up to the target.\n    Return a list of tuples, where each tuple contains the indices of a pair of numbers.\n    \"\"\"\n    def two_sum(nums: List[int], target: int, start: int) -> List[Tuple[int, int]]:\n        result = []\n        seen = set()\n\n        for i in range(start, len(nums)):\n            complement = target - nums[i]\n            if complement in seen:\n                result.append((nums.index(complement), i))\n            seen.add(nums[i])\n\n        return result\n\n    result = []\n    for i in range(len(nums)):\n        pairs = two_sum(nums, target - nums[i], i + 1)\n        for pair in pairs:\n            result.append((i,) + pair)\n\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 5, 3, 1, 6, 4], 7)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Generate the first n numbers in the Fibonacci sequence.\n    Return the list of generated numbers.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return [fibonacci(i) for i in range(n)]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == [0, 1, 1, 2, 3]\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 318, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Generate the first n numbers in the Fibonacci sequence.\n    Return the list of generated numbers.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return [fibonacci(i) for i in range(n)]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a valid arithmetic progression.\"\"\"\n    if len(nums) < 3:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] != nums[i-1] + diff:\n            return False\n    return True\n\ndef g():\n    return [1, 3, 5, 7, 9]\n    \nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a valid arithmetic progression.\"\"\"\n    if len(nums) < 3:\n        return False\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] != nums[i-1] + diff:\n            return False\n    return True", "solution_func": "def g():\n    return [1, 3, 5, 7, 9]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])\n\ndef g():\n    return \"racecar\"\n    \nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])", "solution_func": "def g():\n    return \"racecar\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers contains any duplicates.\"\"\"\n    num_set = set(nums)\n    return len(num_set) < len(nums)\n\ndef g():\n    return [1, 2, 3, 4, 5, 5]\n    \nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers contains any duplicates.\"\"\"\n    num_set = set(nums)\n    return len(num_set) < len(nums)", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True, since 3 + 4 = 7\n    \"\"\"\n\n    def helper(start: int, end: int, target: int) -> bool:\n        if start >= end:\n            return False\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return helper(mid + 1, end, target)\n        else:\n            return helper(start, mid, target)\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if helper(i + 1, len(nums), complement):\n            return True\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 318, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Output:\n    True, since 3 + 4 = 7\n    \"\"\"\n\n    def helper(start: int, end: int, target: int) -> bool:\n        if start >= end:\n            return False\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return helper(mid + 1, end, target)\n        else:\n            return helper(start, mid, target)\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if helper(i + 1, len(nums), complement):\n            return True\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of numbers and a target sum, find all unique combinations in the list where the numbers sum up to\n    the target. Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n\n    Explanation: The combinations [2, 2, 3] and [7] sum up to the target 7.\n\n    Sample Input:\n    nums = [2, 3, 5]\n    target = 8\n\n    Sample Output:\n    [\n        [2, 2, 2, 2],\n        [2, 3, 3],\n        [3, 5]\n    ]\n\n    Explanation: The combinations [2, 2, 2, 2], [2, 3, 3], and [3, 5] sum up to the target 8.\n\n    \"\"\"\n    def backtrack(remain, current_combination, start):\n        if remain == 0:\n            result.append(list(current_combination))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            current_combination.append(nums[i])\n            backtrack(remain - nums[i], current_combination, i)\n            current_combination.pop()\n\n    result = []\n    backtrack(target, [], 0)\n    return result\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of numbers and a target sum, find all unique combinations in the list where the numbers sum up to\n    the target. Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n\n    Explanation: The combinations [2, 2, 3] and [7] sum up to the target 7.\n\n    Sample Input:\n    nums = [2, 3, 5]\n    target = 8\n\n    Sample Output:\n    [\n        [2, 2, 2, 2],\n        [2, 3, 3],\n        [3, 5]\n    ]\n\n    Explanation: The combinations [2, 2, 2, 2], [2, 3, 3], and [3, 5] sum up to the target 8.\n\n    \"\"\"\n    def backtrack(remain, current_combination, start):\n        if remain == 0:\n            result.append(list(current_combination))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            current_combination.append(nums[i])\n            backtrack(remain - nums[i], current_combination, i)\n            current_combination.pop()\n\n    result = []\n    backtrack(target, [], 0)\n    return result", "solution_func": "def g(nums=[2, 3, 6, 7], target=7):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine whether a given string is a palindrome or not.\n\n    Sample Input:\n    s = \"racecar\"\n\n    Sample Output:\n    True\n\n    Explanation: \"racecar\" is a palindrome.\n\n    Sample Input:\n    s = \"hello\"\n\n    Sample Output:\n    False\n\n    Explanation: \"hello\" is not a palindrome.\n\n    \"\"\"\n    return s == s[::-1]\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine whether a given string is a palindrome or not.\n\n    Sample Input:\n    s = \"racecar\"\n\n    Sample Output:\n    True\n\n    Explanation: \"racecar\" is a palindrome.\n\n    Sample Input:\n    s = \"hello\"\n\n    Sample Output:\n    False\n\n    Explanation: \"hello\" is not a palindrome.\n\n    \"\"\"\n    return s == s[::-1]", "solution_func": "def g(s=\"racecar\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x m matrix, where each row is sorted in non-decreasing order, return a sorted list of all the\n    elements in the matrix.\n\n    Sample Input:\n    matrix = [\n        [1, 3, 5],\n        [2, 4, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Explanation: The elements in the matrix are sorted in non-decreasing order.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Explanation: The elements in the matrix are already sorted in non-decreasing order.\n\n    \"\"\"\n    result = []\n    for row in matrix:\n        result.extend(row)\n    return sorted(result)\n\ndef g(matrix=[[1, 3, 5], [2, 4, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x m matrix, where each row is sorted in non-decreasing order, return a sorted list of all the\n    elements in the matrix.\n\n    Sample Input:\n    matrix = [\n        [1, 3, 5],\n        [2, 4, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Explanation: The elements in the matrix are sorted in non-decreasing order.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    Explanation: The elements in the matrix are already sorted in non-decreasing order.\n\n    \"\"\"\n    result = []\n    for row in matrix:\n        result.extend(row)\n    return sorted(result)", "solution_func": "def g(matrix=[[1, 3, 5], [2, 4, 6], [7, 8, 9]]):\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 7\n    Output: 3\n    Explanation: The target value 7 is found at index 3 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 5\n    Output: -1\n    Explanation: The target value 5 is not found in the list, so -1 is returned.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 7)\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 319, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 7\n    Output: 3\n    Explanation: The target value 7 is found at index 3 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 5\n    Output: -1\n    Explanation: The target value 5 is not found in the list, so -1 is returned.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 7)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the number of occurrences of the target value in the list.\n\n    Example:\n    Input: nums = [1, 2, 2, 3, 4, 5, 5, 5], target = 5\n    Output: 3\n    Explanation: The target value 5 occurs 3 times in the list.\n\n    Input: nums = [2, 2, 2, 2, 2], target = 3\n    Output: 0\n    Explanation: The target value 3 does not occur in the list, so 0 is returned.\n    \"\"\"\n\n    count = 0\n    for num in nums:\n        if num == target:\n            count += 1\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 2, 3, 4, 5, 5, 5], 5)\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the number of occurrences of the target value in the list.\n\n    Example:\n    Input: nums = [1, 2, 2, 3, 4, 5, 5, 5], target = 5\n    Output: 3\n    Explanation: The target value 5 occurs 3 times in the list.\n\n    Input: nums = [2, 2, 2, 2, 2], target = 3\n    Output: 0\n    Explanation: The target value 3 does not occur in the list, so 0 is returned.\n    \"\"\"\n\n    count = 0\n    for num in nums:\n        if num == target:\n            count += 1\n\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 2, 3, 4, 5, 5, 5], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value k, find the maximum subarray sum modulo k.\n\n    Example:\n    Input: nums = [4, 5, 0, -2, -3, 1], k = 5\n    Output: 3\n    Explanation: The maximum subarray sum modulo 5 is 3. One possible subarray is [4, 5, 0, -2, -3].\n\n    Input: nums = [7, -5, 5, 8, -6, 6], k = 10\n    Output: 9\n    Explanation: The maximum subarray sum modulo 10 is 9. One possible subarray is [5, 8, -6, 6].\n\n    Note:\n    - The length of the list will not exceed 10^5.\n    - The value of each element in the list will be in the range of [-10^4, 10^4].\n    - The value of k will be in the range of [1, 10^4].\n    \"\"\"\n\n    prefix_sum = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    max_sum = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            subarray_sum = prefix_sum[j] - prefix_sum[i]\n            max_sum = max(max_sum, subarray_sum % k)\n\n    return max_sum\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([4, 5, 0, -2, -3, 1], 5)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 319, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value k, find the maximum subarray sum modulo k.\n\n    Example:\n    Input: nums = [4, 5, 0, -2, -3, 1], k = 5\n    Output: 3\n    Explanation: The maximum subarray sum modulo 5 is 3. One possible subarray is [4, 5, 0, -2, -3].\n\n    Input: nums = [7, -5, 5, 8, -6, 6], k = 10\n    Output: 9\n    Explanation: The maximum subarray sum modulo 10 is 9. One possible subarray is [5, 8, -6, 6].\n\n    Note:\n    - The length of the list will not exceed 10^5.\n    - The value of each element in the list will be in the range of [-10^4, 10^4].\n    - The value of k will be in the range of [1, 10^4].\n    \"\"\"\n\n    prefix_sum = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    max_sum = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            subarray_sum = prefix_sum[j] - prefix_sum[i]\n            max_sum = max(max_sum, subarray_sum % k)\n\n    return max_sum", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([4, 5, 0, -2, -3, 1], 5)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is between 5 and 25, which gives a result of 28.\n\n    Therefore, the function should return 28.\n\n    Note:\n    - The length of the array will be at most 2 * 10^4.\n    - The range of integers in the array is -2^31 <= nums[i] <= 2^31 - 1.\n    \"\"\"\n    def find_max_xor(nums: List[int], start: int, end: int, xor: int) -> int:\n        if start == end:\n            return xor\n\n        mid = (start + end) // 2\n\n        left_xor = find_max_xor(nums, start, mid, xor)\n        right_xor = find_max_xor(nums, mid + 1, end, xor)\n\n        return max(left_xor, right_xor, left_xor ^ right_xor)\n\n    return find_max_xor(nums, 0, len(nums) - 1, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": null, "idx_generation": 319, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is between 5 and 25, which gives a result of 28.\n\n    Therefore, the function should return 28.\n\n    Note:\n    - The length of the array will be at most 2 * 10^4.\n    - The range of integers in the array is -2^31 <= nums[i] <= 2^31 - 1.\n    \"\"\"\n    def find_max_xor(nums: List[int], start: int, end: int, xor: int) -> int:\n        if start == end:\n            return xor\n\n        mid = (start + end) // 2\n\n        left_xor = find_max_xor(nums, start, mid, xor)\n        right_xor = find_max_xor(nums, mid + 1, end, xor)\n\n        return max(left_xor, right_xor, left_xor ^ right_xor)\n\n    return find_max_xor(nums, 0, len(nums) - 1, 0)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum product of any two distinct numbers in the array.\n\n    Example:\n    nums = [1, 5, 4, 2]\n\n    The maximum product is between 5 and 4, which gives a result of 20.\n\n    Therefore, the function should return 20.\n\n    Note:\n    - The length of the array will be at least 2 and at most 500.\n    - The range of integers in the array is -10^3 <= nums[i] <= 10^3.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [1, 5, 4, 2]\n\nassert f(g()) == 20\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 319, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum product of any two distinct numbers in the array.\n\n    Example:\n    nums = [1, 5, 4, 2]\n\n    The maximum product is between 5 and 4, which gives a result of 20.\n\n    Therefore, the function should return 20.\n\n    Note:\n    - The length of the array will be at least 2 and at most 500.\n    - The range of integers in the array is -10^3 <= nums[i] <= 10^3.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [1, 5, 4, 2]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers nums, determine if it can be divided into two subsets such that the sum of elements in both subsets is equal.\n\n    Example:\n    nums = [1, 5, 11, 5]\n\n    The array can be divided into two subsets [1, 5, 5] and [11] with equal sum.\n\n    Therefore, the function should return True.\n\n    Note:\n    - The length of the array will be at most 200.\n    - The range of integers in the array is 0 <= nums[i] <= 100.\n    \"\"\"\n    def can_partition(nums: List[int], index: int, current_sum: int, target_sum: int, memo: List[List[bool]]) -> bool:\n        if index == len(nums):\n            return current_sum == target_sum\n\n        if memo[index][current_sum] != -1:\n            return memo[index][current_sum]\n\n        if current_sum + nums[index] <= target_sum:\n            if can_partition(nums, index + 1, current_sum + nums[index], target_sum, memo):\n                memo[index][current_sum] = True\n                return True\n\n        if can_partition(nums, index + 1, current_sum, target_sum, memo):\n            memo[index][current_sum] = True\n            return True\n\n        memo[index][current_sum] = False\n        return False\n\n    total_sum = sum(nums)\n\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    memo = [[-1] * (target_sum + 1) for _ in range(len(nums))]\n\n    return can_partition(nums, 0, 0, target_sum, memo)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [1, 5, 11, 5]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 319, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers nums, determine if it can be divided into two subsets such that the sum of elements in both subsets is equal.\n\n    Example:\n    nums = [1, 5, 11, 5]\n\n    The array can be divided into two subsets [1, 5, 5] and [11] with equal sum.\n\n    Therefore, the function should return True.\n\n    Note:\n    - The length of the array will be at most 200.\n    - The range of integers in the array is 0 <= nums[i] <= 100.\n    \"\"\"\n    def can_partition(nums: List[int], index: int, current_sum: int, target_sum: int, memo: List[List[bool]]) -> bool:\n        if index == len(nums):\n            return current_sum == target_sum\n\n        if memo[index][current_sum] != -1:\n            return memo[index][current_sum]\n\n        if current_sum + nums[index] <= target_sum:\n            if can_partition(nums, index + 1, current_sum + nums[index], target_sum, memo):\n                memo[index][current_sum] = True\n                return True\n\n        if can_partition(nums, index + 1, current_sum, target_sum, memo):\n            memo[index][current_sum] = True\n            return True\n\n        memo[index][current_sum] = False\n        return False\n\n    total_sum = sum(nums)\n\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    memo = [[-1] * (target_sum + 1) for _ in range(len(nums))]\n\n    return can_partition(nums, 0, 0, target_sum, memo)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [1, 5, 11, 5]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a path from start to end in the graph that visits all nodes exactly once.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    start = 0\n    end = 4\n\n    There is a path from vertex 0 to vertex 4 in the given graph that visits all nodes exactly once.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    visited[start] = True\n\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return all(visited)\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                visited[neighbor] = True\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 319, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a path from start to end in the graph that visits all nodes exactly once.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    start = 0\n    end = 4\n\n    There is a path from vertex 0 to vertex 4 in the given graph that visits all nodes exactly once.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    visited[start] = True\n\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return all(visited)\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                visited[neighbor] = True\n                stack.append(neighbor)\n\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0, 1],\n        [1, 0, 1, 0, 0],\n        [1, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n\n    The anagram pairs are \"cat\" and \"tac\", and \"dog\" and \"god\".\n    So the function should return [\"cat\", \"tac\", \"dog\", \"god\"].\n    \"\"\"\n\n    def is_anagram(word1: str, word2: str) -> bool:\n        \"\"\"\n        Check if two words are anagrams of each other.\n        \"\"\"\n        return sorted(word1) == sorted(word2)\n\n    anagrams = []\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if is_anagram(words[i], words[j]):\n                anagrams.append(words[i])\n                anagrams.append(words[j])\n\n    return anagrams\n\ndef g() -> List[str]:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    return words\n\nassert f(g()) == [\"cat\", \"tac\", \"dog\", \"god\"]\n", "emb": null, "idx_generation": 320, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n\n    The anagram pairs are \"cat\" and \"tac\", and \"dog\" and \"god\".\n    So the function should return [\"cat\", \"tac\", \"dog\", \"god\"].\n    \"\"\"\n\n    def is_anagram(word1: str, word2: str) -> bool:\n        \"\"\"\n        Check if two words are anagrams of each other.\n        \"\"\"\n        return sorted(word1) == sorted(word2)\n\n    anagrams = []\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if is_anagram(words[i], words[j]):\n                anagrams.append(words[i])\n                anagrams.append(words[j])\n\n    return anagrams", "solution_func": "def g() -> List[str]:\n    words = [\"cat\", \"dog\", \"tac\", \"god\", \"act\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The maximum product of any three numbers is 2 * 3 * 4 = 24.\n    So the function should return 24.\n    \"\"\"\n\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The maximum product of any three numbers is 2 * 3 * 4 = 24.\n    So the function should return 24.\n    \"\"\"\n\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of any subarray is 4 + (-1) + 2 + 1 = 6.\n    So the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of any subarray is 4 + (-1) + 2 + 1 = 6.\n    So the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to represent n as a sum of powers of 2.\n\n    For example, if n = 5, the possible representations are:\n    - 1 + 4 = 5\n    - 1 + 2 + 2 = 5\n    - 1 + 1 + 1 + 2 = 5\n    So the expected output is 3.\n    \"\"\"\n    def count_ways(n: int, i: int) -> int:\n        if n == 0:\n            return 1\n        if n < 0 or i < 0:\n            return 0\n        return count_ways(n - (2 ** i), i) + count_ways(n, i - 1)\n\n    return count_ways(n, int(math.log2(n)))\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 320, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to represent n as a sum of powers of 2.\n\n    For example, if n = 5, the possible representations are:\n    - 1 + 4 = 5\n    - 1 + 2 + 2 = 5\n    - 1 + 1 + 1 + 2 = 5\n    So the expected output is 3.\n    \"\"\"\n    def count_ways(n: int, i: int) -> int:\n        if n == 0:\n            return 1\n        if n < 0 or i < 0:\n            return 0\n        return count_ways(n - (2 ** i), i) + count_ways(n, i - 1)\n\n    return count_ways(n, int(math.log2(n)))", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a directed graph represented as a list of edges,\n    find all possible paths from node 0 to node n-1 that contain exactly k edges.\n\n    Return a list of paths, where each path is represented as a list of nodes visited.\n    \"\"\"\n    def dfs(v: int, k: int, path: List[int], paths: List[List[int]]) -> None:\n        if v == n - 1:\n            if len(path) == k + 1:\n                paths.append(path)\n            return\n\n        if len(path) > k + 1:\n            return\n\n        for neighbor in graph[v]:\n            dfs(neighbor, k, path + [neighbor], paths)\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    paths = []\n    dfs(0, k, [0], paths)\n    return paths\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a directed graph represented as a list of edges,\n    and an integer k.\n    \"\"\"\n    edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 4], [3, 4]]\n    k = 2\n    return len(edges), edges, k\n\nassert f(*g()) == [[0, 1, 3, 4], [0, 2, 3, 4]]\n", "emb": null, "idx_generation": 320, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a directed graph represented as a list of edges,\n    find all possible paths from node 0 to node n-1 that contain exactly k edges.\n\n    Return a list of paths, where each path is represented as a list of nodes visited.\n    \"\"\"\n    def dfs(v: int, k: int, path: List[int], paths: List[List[int]]) -> None:\n        if v == n - 1:\n            if len(path) == k + 1:\n                paths.append(path)\n            return\n\n        if len(path) > k + 1:\n            return\n\n        for neighbor in graph[v]:\n            dfs(neighbor, k, path + [neighbor], paths)\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    paths = []\n    dfs(0, k, [0], paths)\n    return paths", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a directed graph represented as a list of edges,\n    and an integer k.\n    \"\"\"\n    edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 4], [3, 4]]\n    k = 2\n    return len(edges), edges, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of connected 1s.\n\n    A connected group of 1s consists of 1s that are horizontally or vertically adjacent.\n\n    Return the maximum number of connected 1s.\n    \"\"\"\n    def dfs(i: int, j: int, visited: List[List[bool]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j] or grid[i][j] == 0:\n            return 0\n\n        visited[i][j] = True\n        count = 1\n\n        count += dfs(i + 1, j, visited)\n        count += dfs(i - 1, j, visited)\n        count += dfs(i, j + 1, visited)\n        count += dfs(i, j - 1, visited)\n\n        return count\n\n    max_connected = 0\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1 and not visited[i][j]:\n                max_connected = max(max_connected, dfs(i, j, visited))\n\n    return max_connected\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    grid = [[1, 0, 1, 0, 1],\n            [0, 1, 0, 1, 0],\n            [1, 0, 1, 0, 1],\n            [0, 1, 0, 1, 0]]\n\n    return grid\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 320, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of connected 1s.\n\n    A connected group of 1s consists of 1s that are horizontally or vertically adjacent.\n\n    Return the maximum number of connected 1s.\n    \"\"\"\n    def dfs(i: int, j: int, visited: List[List[bool]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j] or grid[i][j] == 0:\n            return 0\n\n        visited[i][j] = True\n        count = 1\n\n        count += dfs(i + 1, j, visited)\n        count += dfs(i - 1, j, visited)\n        count += dfs(i, j + 1, visited)\n        count += dfs(i, j - 1, visited)\n\n        return count\n\n    max_connected = 0\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1 and not visited[i][j]:\n                max_connected = max(max_connected, dfs(i, j, visited))\n\n    return max_connected", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s.\n    \"\"\"\n    grid = [[1, 0, 1, 0, 1],\n            [0, 1, 0, 1, 0],\n            [1, 0, 1, 0, 1],\n            [0, 1, 0, 1, 0]]\n\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a pair of numbers (num1, num2) such that num1 ^ num2 = num1 + num2.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == nums[i] + nums[j]:\n                return True\n    \n    return False\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a pair of numbers (num1, num2) such that num1 ^ num2 = num1 + num2.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == nums[i] + nums[j]:\n                return True\n    \n    return False", "solution_func": "def g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct substrings that can be formed by removing exactly one character from s.\n    Return the count of distinct substrings.\n    \"\"\"\n    substrings = set()\n    for i in range(len(s)):\n        substrings.add(s[:i] + s[i+1:])\n    \n    return len(substrings)\n\ndef g() -> str:\n    s = \"abcde\"\n    return s\n\nassert f(g()) == 14\n", "emb": null, "idx_generation": 320, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct substrings that can be formed by removing exactly one character from s.\n    Return the count of distinct substrings.\n    \"\"\"\n    substrings = set()\n    for i in range(len(s)):\n        substrings.add(s[:i] + s[i+1:])\n    \n    return len(substrings)", "solution_func": "def g() -> str:\n    s = \"abcde\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, find all the unique triplets (nums[i], nums[j], nums[k]) such that i < j < k and nums[i] & nums[j] & nums[k] == 0.\n    Return a list of all unique triplets.\n    \"\"\"\n    triplets = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] & nums[j] & nums[k] == 0:\n                    triplet = [nums[i], nums[j], nums[k]]\n                    triplet.sort()\n                    if triplet not in triplets:\n                        triplets.append(triplet)\n    \n    return triplets\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]\n", "emb": null, "idx_generation": 320, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, find all the unique triplets (nums[i], nums[j], nums[k]) such that i < j < k and nums[i] & nums[j] & nums[k] == 0.\n    Return a list of all unique triplets.\n    \"\"\"\n    triplets = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] & nums[j] & nums[k] == 0:\n                    triplet = [nums[i], nums[j], nums[k]]\n                    triplet.sort()\n                    if triplet not in triplets:\n                        triplets.append(triplet)\n    \n    return triplets", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a pair of integers in the list\n    such that their XOR is equal to k.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1, 6], k = 3\n    Output: True\n    Explanation: The pair (4, 7) has XOR equal to 3.\n\n    Note:\n    - The length of the list will not exceed 1000.\n    - The range of integers in the list and the value of k will be in the range [-10^9, 10^9].\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums: List[int], k: int) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair of integers in the list nums such that their XOR is equal to k.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1, 6], k = 3\n    Output: (4, 7)\n\n    Note:\n    - The length of the list will not exceed 1000.\n    - The range of integers in the list and the value of k will be in the range [-10^9, 10^9].\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k ^ num in seen:\n            return (num, k ^ num)\n        seen.add(num)\n    return (-1, -1)\n\nassert f(g([4, 7, 2, 9, 5, 1, 6], 3), 3)\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 320, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a pair of integers in the list\n    such that their XOR is equal to k.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1, 6], k = 3\n    Output: True\n    Explanation: The pair (4, 7) has XOR equal to 3.\n\n    Note:\n    - The length of the list will not exceed 1000.\n    - The range of integers in the list and the value of k will be in the range [-10^9, 10^9].\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k ^ num in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g(nums: List[int], k: int) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair of integers in the list nums such that their XOR is equal to k.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1, 6], k = 3\n    Output: (4, 7)\n\n    Note:\n    - The length of the list will not exceed 1000.\n    - The range of integers in the list and the value of k will be in the range [-10^9, 10^9].\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k ^ num in seen:\n            return (num, k ^ num)\n        seen.add(num)\n    return (-1, -1)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of subarrays that have an odd sum.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 9\n\n    Explanation:\n    The subarrays with an odd sum are: [1], [2], [3], [4], [5], [1, 2, 3], [1, 2, 3, 4, 5], [2, 3, 4], [3, 4, 5].\n\n    Therefore, the function should return 9.\n    \"\"\"\n\n    count = 0\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append(prefix_sums[-1] + num)\n\n    for i in range(len(prefix_sums)):\n        for j in range(i):\n            if (prefix_sums[i] - prefix_sums[j]) % 2 != 0:\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of subarrays that have an odd sum.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 9\n\n    Explanation:\n    The subarrays with an odd sum are: [1], [2], [3], [4], [5], [1, 2, 3], [1, 2, 3, 4, 5], [2, 3, 4], [3, 4, 5].\n\n    Therefore, the function should return 9.\n    \"\"\"\n\n    count = 0\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append(prefix_sums[-1] + num)\n\n    for i in range(len(prefix_sums)):\n        for j in range(i):\n            if (prefix_sums[i] - prefix_sums[j]) % 2 != 0:\n                count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the minimum number of elements that need to be removed\n    in order to make the remaining elements in the list distinct.\n\n    Example:\n    Input: [1, 2, 2, 3, 4, 4, 5]\n    Output: 2\n\n    Explanation:\n    By removing the two 2's, the remaining elements [1, 3, 4, 5] are distinct.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    for num, frequency in freq.items():\n        if frequency > 1:\n            count += frequency - 1\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the minimum number of elements that need to be removed\n    in order to make the remaining elements in the list distinct.\n\n    Example:\n    Input: [1, 2, 2, 3, 4, 4, 5]\n    Output: 2\n\n    Explanation:\n    By removing the two 2's, the remaining elements [1, 3, 4, 5] are distinct.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    for num, frequency in freq.items():\n        if frequency > 1:\n            count += frequency - 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Therefore, the function should return 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Therefore, the function should return 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find if there exists a subset of the list whose sum is equal to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(target + 1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i-1]]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [3, 2, 7, 1, 6]\n    target = 9\n    return nums, target\n\nassert f(*g())\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find if there exists a subset of the list whose sum is equal to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(target + 1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i-1]]\n    \n    return dp[n][target]", "solution_func": "def g():\n    nums = [3, 2, 7, 1, 6]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    if n <= 1:\n        return n\n    \n    max_len = 0\n    start = 0\n    seen = {}\n    for end in range(n):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        seen[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n    \n    return max_len\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    if n <= 1:\n        return n\n    \n    max_len = 0\n    start = 0\n    seen = {}\n    for end in range(n):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        seen[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n    \n    return max_len", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of subarrays whose sum is equal to or greater than the target.\n    \"\"\"\n    n = len(nums)\n    count = float('inf')\n    left = 0\n    curr_sum = 0\n\n    for right in range(n):\n        curr_sum += nums[right]\n\n        while curr_sum >= target:\n            count = min(count, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n    \n    return count\n\ndef g():\n    nums = [2, 3, 1, 2, 4, 3]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 321, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of subarrays whose sum is equal to or greater than the target.\n    \"\"\"\n    n = len(nums)\n    count = float('inf')\n    left = 0\n    curr_sum = 0\n\n    for right in range(n):\n        curr_sum += nums[right]\n\n        while curr_sum >= target:\n            count = min(count, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n    \n    return count", "solution_func": "def g():\n    nums = [2, 3, 1, 2, 4, 3]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list\n    that add up to the target value. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list\n    that add up to the target value. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, return a new list of words that match the pattern.\n    The pattern string consists of lowercase letters, and each letter in the pattern corresponds to a unique\n    character in the words. A word matches the pattern if replacing each letter in the pattern with a\n    corresponding character from the word results in the same pattern.\n\n    Example:\n    words = [\"foo\", \"bar\", \"baz\", \"cat\", \"bat\"]\n    pattern = \"abb\"\n\n    Output:\n    [\"foo\", \"bar\", \"bat\"]\n    \"\"\"\n    result = []\n    pattern_mapping = {}\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n\n        is_match = True\n        for i in range(len(word)):\n            if pattern[i] not in pattern_mapping:\n                pattern_mapping[pattern[i]] = word[i]\n            elif pattern_mapping[pattern[i]] != word[i]:\n                is_match = False\n                break\n\n        if is_match:\n            result.append(word)\n\n    return result\n\ndef g():\n    words = [\"foo\", \"bar\", \"baz\", \"cat\", \"bat\"]\n    pattern = \"abb\"\n    return words, pattern\n\nassert f(*g()) == [\"foo\", \"bar\", \"bat\"]\n", "emb": null, "idx_generation": 321, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern string, return a new list of words that match the pattern.\n    The pattern string consists of lowercase letters, and each letter in the pattern corresponds to a unique\n    character in the words. A word matches the pattern if replacing each letter in the pattern with a\n    corresponding character from the word results in the same pattern.\n\n    Example:\n    words = [\"foo\", \"bar\", \"baz\", \"cat\", \"bat\"]\n    pattern = \"abb\"\n\n    Output:\n    [\"foo\", \"bar\", \"bat\"]\n    \"\"\"\n    result = []\n    pattern_mapping = {}\n\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n\n        is_match = True\n        for i in range(len(word)):\n            if pattern[i] not in pattern_mapping:\n                pattern_mapping[pattern[i]] = word[i]\n            elif pattern_mapping[pattern[i]] != word[i]:\n                is_match = False\n                break\n\n        if is_match:\n            result.append(word)\n\n    return result", "solution_func": "def g():\n    words = [\"foo\", \"bar\", \"baz\", \"cat\", \"bat\"]\n    pattern = \"abb\"\n    return words, pattern", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(maze: List[List[int]]) -> int:\n    \"\"\"\n    Given a maze represented as a 2D list of integers where 0 represents a path and 1 represents a wall,\n    find the shortest path from the top-left corner to the bottom-right corner.\n\n    Example:\n    maze = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n\n    queue = [(0, 0, 0)]  # (row, col, distance)\n    visited = set()\n\n    while queue:\n        row, col, distance = queue.pop(0)\n\n        if row == rows - 1 and col == cols - 1:\n            return distance\n\n        if (row, col) not in visited:\n            visited.add((row, col))\n\n            if row > 0 and maze[row - 1][col] == 0:  # move up\n                queue.append((row - 1, col, distance + 1))\n            if row < rows - 1 and maze[row + 1][col] == 0:  # move down\n                queue.append((row + 1, col, distance + 1))\n            if col > 0 and maze[row][col - 1] == 0:  # move left\n                queue.append((row, col - 1, distance + 1))\n            if col < cols - 1 and maze[row][col + 1] == 0:  # move right\n                queue.append((row, col + 1, distance + 1))\n\n    return -1\n\ndef g():\n    maze = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return maze\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(maze: List[List[int]]) -> int:\n    \"\"\"\n    Given a maze represented as a 2D list of integers where 0 represents a path and 1 represents a wall,\n    find the shortest path from the top-left corner to the bottom-right corner.\n\n    Example:\n    maze = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n\n    queue = [(0, 0, 0)]  # (row, col, distance)\n    visited = set()\n\n    while queue:\n        row, col, distance = queue.pop(0)\n\n        if row == rows - 1 and col == cols - 1:\n            return distance\n\n        if (row, col) not in visited:\n            visited.add((row, col))\n\n            if row > 0 and maze[row - 1][col] == 0:  # move up\n                queue.append((row - 1, col, distance + 1))\n            if row < rows - 1 and maze[row + 1][col] == 0:  # move down\n                queue.append((row + 1, col, distance + 1))\n            if col > 0 and maze[row][col - 1] == 0:  # move left\n                queue.append((row, col - 1, distance + 1))\n            if col < cols - 1 and maze[row][col + 1] == 0:  # move right\n                queue.append((row, col + 1, distance + 1))\n\n    return -1", "solution_func": "def g():\n    maze = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return maze", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers arr and a target number, find a pair of numbers in the array that sum up to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return arr, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 321, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers arr and a target number, find a pair of numbers in the array that sum up to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(arr=[1, 2, 3, 4, 5], target=9):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix such that the sum is not divisible by 3.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum submatrix is [[5, 6], [8, 9]], which has a sum of 29, and 29 is not divisible by 3.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Calculate the prefix sum matrix\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]\n\n    max_sum = float('-inf')\n\n    # Iterate through all possible submatrices\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for l in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[k][j-1] - prefix_sum[i-1][l] + prefix_sum[i-1][j-1]\n                    if submatrix_sum % 3 != 0:\n                        max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum\n\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n\nassert f(g()) == 29\n", "emb": null, "idx_generation": 322, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix such that the sum is not divisible by 3.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    29\n\n    Explanation:\n    The maximum sum submatrix is [[5, 6], [8, 9]], which has a sum of 29, and 29 is not divisible by 3.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Calculate the prefix sum matrix\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]\n\n    max_sum = float('-inf')\n\n    # Iterate through all possible submatrices\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for l in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[k][j-1] - prefix_sum[i-1][l] + prefix_sum[i-1][j-1]\n                    if submatrix_sum % 3 != 0:\n                        max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges, determine if there exists a cycle in the directed graph.\n\n    Example:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n    Output:\n    True\n\n    Explanation:\n    The directed graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    # Build the directed graph\n    for u, v in edges:\n        graph[u].append(v)\n\n    # Perform depth-first search to detect cycles\n    def dfs(node):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    # Check for cycles in each connected component\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False\n\n\ndef g():\n    return 4, [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges, determine if there exists a cycle in the directed graph.\n\n    Example:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n    Output:\n    True\n\n    Explanation:\n    The directed graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    # Build the directed graph\n    for u, v in edges:\n        graph[u].append(v)\n\n    # Perform depth-first search to detect cycles\n    def dfs(node):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    # Check for cycles in each connected component\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False", "solution_func": "def g():\n    return 4, [(0, 1), (1, 2), (2, 3), (3, 0)]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path in the matrix where each adjacent cell's value is greater than the previous cell's value.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path in the matrix is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < rows and 0 <= y < cols and matrix[x][y] > matrix[i][j]:\n                length = 1 + dfs(x, y)\n                max_length = max(max_length, length)\n\n        dp[i][j] = max_length\n        return max_length\n\n    longest_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            length = dfs(i, j)\n            longest_path = max(longest_path, length)\n\n    return longest_path\n\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path in the matrix where each adjacent cell's value is greater than the previous cell's value.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path in the matrix is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < rows and 0 <= y < cols and matrix[x][y] > matrix[i][j]:\n                length = 1 + dfs(x, y)\n                max_length = max(max_length, length)\n\n        dp[i][j] = max_length\n        return max_length\n\n    longest_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            length = dfs(i, j)\n            longest_path = max(longest_path, length)\n\n    return longest_path", "solution_func": "def g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine whether there exists a subset of size k from the integers 1 to n whose sum is divisible by k.\n    \"\"\"\n    def subset_sum(arr, n, target, k, dp):\n        if target == 0 and k == 0:\n            return True\n        if n == 0 or k == 0:\n            return False\n        if dp[n][target][k] != -1:\n            return dp[n][target][k]\n        if arr[n-1] <= target:\n            include = subset_sum(arr, n-1, target-arr[n-1], (k+arr[n-1]) % k, dp)\n            exclude = subset_sum(arr, n-1, target, k, dp)\n            dp[n][target][k] = include or exclude\n            return dp[n][target][k]\n        else:\n            exclude = subset_sum(arr, n-1, target, k, dp)\n            dp[n][target][k] = exclude\n            return dp[n][target][k]\n\n    if n < k or k == 0:\n        return False\n    arr = list(range(1, n+1))\n    target_sum = (n*(n+1)) // (2*k)\n    dp = [[[-1 for _ in range(k)] for _ in range(target_sum+1)] for _ in range(n+1)]\n    return subset_sum(arr, n, target_sum, 0, dp)\n\ndef g(n = 10, k = 3):\n    return n, k\n\nassert f(*g())\n", "emb": null, "idx_generation": 322, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine whether there exists a subset of size k from the integers 1 to n whose sum is divisible by k.\n    \"\"\"\n    def subset_sum(arr, n, target, k, dp):\n        if target == 0 and k == 0:\n            return True\n        if n == 0 or k == 0:\n            return False\n        if dp[n][target][k] != -1:\n            return dp[n][target][k]\n        if arr[n-1] <= target:\n            include = subset_sum(arr, n-1, target-arr[n-1], (k+arr[n-1]) % k, dp)\n            exclude = subset_sum(arr, n-1, target, k, dp)\n            dp[n][target][k] = include or exclude\n            return dp[n][target][k]\n        else:\n            exclude = subset_sum(arr, n-1, target, k, dp)\n            dp[n][target][k] = exclude\n            return dp[n][target][k]\n\n    if n < k or k == 0:\n        return False\n    arr = list(range(1, n+1))\n    target_sum = (n*(n+1)) // (2*k)\n    dp = [[[-1 for _ in range(k)] for _ in range(target_sum+1)] for _ in range(n+1)]\n    return subset_sum(arr, n, target_sum, 0, dp)", "solution_func": "def g(n = 10, k = 3):\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether a given directed graph contains a Hamiltonian Path, which visits each vertex exactly once.\n    \"\"\"\n    def hamiltonian_path(graph, path, visited, curr):\n        if len(path) == len(graph):\n            return True\n        visited[curr] = True\n        path.append(curr)\n        for v in graph[curr]:\n            if not visited[v]:\n                if hamiltonian_path(graph, path, visited, v):\n                    return True\n        visited[curr] = False\n        path.pop()\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n    path = []\n    for i in range(n):\n        if hamiltonian_path(graph, path, visited, i):\n            return True\n    return False\n\ndef g():\n    graph = [[1, 2, 3], [2, 3], [3], []]\n    return graph\n\nassert f(g())\n", "emb": null, "idx_generation": 322, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether a given directed graph contains a Hamiltonian Path, which visits each vertex exactly once.\n    \"\"\"\n    def hamiltonian_path(graph, path, visited, curr):\n        if len(path) == len(graph):\n            return True\n        visited[curr] = True\n        path.append(curr)\n        for v in graph[curr]:\n            if not visited[v]:\n                if hamiltonian_path(graph, path, visited, v):\n                    return True\n        visited[curr] = False\n        path.pop()\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n    path = []\n    for i in range(n):\n        if hamiltonian_path(graph, path, visited, i):\n            return True\n    return False", "solution_func": "def g():\n    graph = [[1, 2, 3], [2, 3], [3], []]\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine whether there exists a prime number whose digits sum up to n.\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n\n    for i in range(2, n):\n        if is_prime(i) and digit_sum(i) == n:\n            return True\n    return False\n\ndef g(n = 10):\n    return n\n\nassert f(g())\n", "emb": null, "idx_generation": 322, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine whether there exists a prime number whose digits sum up to n.\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n\n    for i in range(2, n):\n        if is_prime(i) and digit_sum(i) == n:\n            return True\n    return False", "solution_func": "def g(n = 10):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right cell (marked as 9) \n    starting from the top-left cell (marked as 1). You can only move down or right, and cannot move \n    outside the grid or cross through cells marked as 0.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    def dfs(i, j):\n        # Base cases\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 0:\n            return False\n        \n        # Recursive cases\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g(grid=[[1, 0, 1, 1], \n            [1, 1, 1, 0], \n            [0, 1, 1, 1], \n            [1, 1, 0, 9]]):\n    return grid\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 322, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right cell (marked as 9) \n    starting from the top-left cell (marked as 1). You can only move down or right, and cannot move \n    outside the grid or cross through cells marked as 0.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    def dfs(i, j):\n        # Base cases\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 0:\n            return False\n        \n        # Recursive cases\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)", "solution_func": "def g(grid=[[1, 0, 1, 1], \n            [1, 1, 1, 0], \n            [0, 1, 1, 1], \n            [1, 1, 0, 9]]):\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s, determine if it is possible to split the string into k non-empty palindromic substrings.\n    A palindromic substring is a substring that reads the same forwards and backwards.\n    \"\"\"\n    n = len(s)\n    \n    def is_palindrome(start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    \n    def dfs(start, count):\n        # Base case\n        if count == k:\n            return True\n        \n        # Recursive cases\n        for i in range(start, n):\n            if is_palindrome(start, i):\n                if dfs(i+1, count+1):\n                    return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g(s='aabbaa', k=2):\n    return s, k\n\nassert f(*g())\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 322, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s, determine if it is possible to split the string into k non-empty palindromic substrings.\n    A palindromic substring is a substring that reads the same forwards and backwards.\n    \"\"\"\n    n = len(s)\n    \n    def is_palindrome(start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    \n    def dfs(start, count):\n        # Base case\n        if count == k:\n            return True\n        \n        # Recursive cases\n        for i in range(start, n):\n            if is_palindrome(start, i):\n                if dfs(i+1, count+1):\n                    return True\n        return False\n    \n    return dfs(0, 0)", "solution_func": "def g(s='aabbaa', k=2):\n    return s, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of characters, determine if it contains a valid word from a given dictionary.\n    A valid word can be formed by connecting adjacent cells (horizontally or vertically) without \n    reusing the same cell. The path can start from any cell and can use any number of cells.\n    \"\"\"\n    def dfs(i, j, word):\n        # Base case\n        if len(word) == 0:\n            return True\n        \n        # Recursive cases\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n            return False\n        \n        temp = grid[i][j]\n        grid[i][j] = '#'\n        \n        res = dfs(i-1, j, word[1:]) or dfs(i+1, j, word[1:]) or dfs(i, j-1, word[1:]) or dfs(i, j+1, word[1:])\n        \n        grid[i][j] = temp\n        \n        return res\n    \n    dictionary = {'apple', 'banana', 'cherry', 'date'}\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, grid[i][j]):\n                return True\n    \n    return False\n\ndef g(grid=[['a', 'b', 'c', 'd'],\n            ['e', 'f', 'g', 'h'],\n            ['i', 'j', 'k', 'l'],\n            ['m', 'n', 'o', 'p']]):\n    return grid\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 322, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of characters, determine if it contains a valid word from a given dictionary.\n    A valid word can be formed by connecting adjacent cells (horizontally or vertically) without \n    reusing the same cell. The path can start from any cell and can use any number of cells.\n    \"\"\"\n    def dfs(i, j, word):\n        # Base case\n        if len(word) == 0:\n            return True\n        \n        # Recursive cases\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n            return False\n        \n        temp = grid[i][j]\n        grid[i][j] = '#'\n        \n        res = dfs(i-1, j, word[1:]) or dfs(i+1, j, word[1:]) or dfs(i, j-1, word[1:]) or dfs(i, j+1, word[1:])\n        \n        grid[i][j] = temp\n        \n        return res\n    \n    dictionary = {'apple', 'banana', 'cherry', 'date'}\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, grid[i][j]):\n                return True\n    \n    return False", "solution_func": "def g(grid=[['a', 'b', 'c', 'd'],\n            ['e', 'f', 'g', 'h'],\n            ['i', 'j', 'k', 'l'],\n            ['m', 'n', 'o', 'p']]):\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the sum of all the even numbers in the list.\n    \"\"\"\n    def helper(nums, index):\n        if index < 0:\n            return 0\n        if nums[index] % 2 == 0:\n            return nums[index] + helper(nums, index - 1)\n        else:\n            return helper(nums, index - 1)\n    \n    return helper(numbers, len(numbers) - 1)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers to find the sum of all the even numbers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 322, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the sum of all the even numbers in the list.\n    \"\"\"\n    def helper(nums, index):\n        if index < 0:\n            return 0\n        if nums[index] % 2 == 0:\n            return nums[index] + helper(nums, index - 1)\n        else:\n            return helper(nums, index - 1)\n    \n    return helper(numbers, len(numbers) - 1)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers to find the sum of all the even numbers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) such that i < j and nums[i] > 2 * nums[j].\n\n    Example:\n    Input: nums = [1, 3, 2, 4]\n    Output: 2\n    Explanation: The pairs (1, 0) and (3, 2) satisfy the condition nums[i] > 2 * nums[j].\n\n    Input: nums = [5, 4, 3, 2, 1]\n    Output: 0\n    Explanation: There are no pairs that satisfy the condition nums[i] > 2 * nums[j].\n    \"\"\"\n\n    def count_pairs(nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] > 2 * nums[j]:\n                    count += 1\n\n        return count\n\n    return count_pairs(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 2, 4]\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 323, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) such that i < j and nums[i] > 2 * nums[j].\n\n    Example:\n    Input: nums = [1, 3, 2, 4]\n    Output: 2\n    Explanation: The pairs (1, 0) and (3, 2) satisfy the condition nums[i] > 2 * nums[j].\n\n    Input: nums = [5, 4, 3, 2, 1]\n    Output: 0\n    Explanation: There are no pairs that satisfy the condition nums[i] > 2 * nums[j].\n    \"\"\"\n\n    def count_pairs(nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] > 2 * nums[j]:\n                    count += 1\n\n        return count\n\n    return count_pairs(nums)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 2, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k].\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 10\n    Explanation: The pairs (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4) satisfy the condition nums[i] < nums[j] < nums[k].\n\n    Input: nums = [5, 4, 3, 2, 1]\n    Output: 0\n    Explanation: There are no pairs that satisfy the condition nums[i] < nums[j] < nums[k].\n    \"\"\"\n\n    def count_triplets(nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums[i] < nums[j] < nums[k]:\n                        count += 1\n\n        return count\n\n    return count_triplets(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k].\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 10\n    Explanation: The pairs (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4) satisfy the condition nums[i] < nums[j] < nums[k].\n\n    Input: nums = [5, 4, 3, 2, 1]\n    Output: 0\n    Explanation: There are no pairs that satisfy the condition nums[i] < nums[j] < nums[k].\n    \"\"\"\n\n    def count_triplets(nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums[i] < nums[j] < nums[k]:\n                        count += 1\n\n        return count\n\n    return count_triplets(nums)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [2, 4, 5, 8, 9]\n    target = 13\n\n    Sample Output:\n    [1, 4]\n    Explanation: The numbers at indices 1 and 4, [4, 9], add up to the target value 13.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 5, 8, 9], 13\n\nassert f(*g()) == [1, 4]\n", "emb": null, "idx_generation": 323, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [2, 4, 5, 8, 9]\n    target = 13\n\n    Sample Output:\n    [1, 4]\n    Explanation: The numbers at indices 1 and 4, [4, 9], add up to the target value 13.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 5, 8, 9], 13", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there exists a subarray in the list\n    whose sum is divisible by k.\n\n    Sample input:\n    arr = [4, 7, 2, 5, 9]\n    k = 3\n\n    Sample output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    remainders = {0}\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in remainders:\n            return True\n        remainders.add(prefix_sum)\n    return False\n\ndef g(arr = [4, 7, 2, 5, 9], k = 3):\n    return arr\n\nassert f(g(), 3) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there exists a subarray in the list\n    whose sum is divisible by k.\n\n    Sample input:\n    arr = [4, 7, 2, 5, 9]\n    k = 3\n\n    Sample output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    remainders = {0}\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in remainders:\n            return True\n        remainders.add(prefix_sum)\n    return False", "solution_func": "def g(arr = [4, 7, 2, 5, 9], k = 3):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subarray in the list\n    whose sum is equal to the target.\n\n    Sample input:\n    arr = [3, 4, 7, 2, 1, 8]\n    target = 10\n\n    Sample output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    seen = {0}\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum - target in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g(arr = [3, 4, 7, 2, 1, 8], target = 10):\n    return arr\n\nassert f(g(), 10) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subarray in the list\n    whose sum is equal to the target.\n\n    Sample input:\n    arr = [3, 4, 7, 2, 1, 8]\n    target = 10\n\n    Sample output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    seen = {0}\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum - target in seen:\n            return True\n        seen.add(prefix_sum)\n    return False", "solution_func": "def g(arr = [3, 4, 7, 2, 1, 8], target = 10):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value k, count the number of subarrays in the list\n    whose sum is divisible by k.\n\n    Sample input:\n    arr = [4, 7, 2, 5, 9]\n    k = 3\n\n    Sample output:\n    4\n    \"\"\"\n    prefix_sum = 0\n    count = 0\n    remainders = {0: 1}\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in remainders:\n            count += remainders[prefix_sum]\n        remainders[prefix_sum] = remainders.get(prefix_sum, 0) + 1\n    return count\n\ndef g(arr = [4, 7, 2, 5, 9], k = 3):\n    return arr\n\nassert f(g(), 3) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value k, count the number of subarrays in the list\n    whose sum is divisible by k.\n\n    Sample input:\n    arr = [4, 7, 2, 5, 9]\n    k = 3\n\n    Sample output:\n    4\n    \"\"\"\n    prefix_sum = 0\n    count = 0\n    remainders = {0: 1}\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in remainders:\n            count += remainders[prefix_sum]\n        remainders[prefix_sum] = remainders.get(prefix_sum, 0) + 1\n    return count", "solution_func": "def g(arr = [4, 7, 2, 5, 9], k = 3):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of swaps required to sort the list in non-decreasing order.\n    \"\"\"\n    n = len(nums)\n    swaps = 0\n    \n    for i in range(n):\n        min_idx = i\n        \n        for j in range(i+1, n):\n            if nums[j] < nums[min_idx]:\n                min_idx = j\n        \n        if min_idx != i:\n            nums[i], nums[min_idx] = nums[min_idx], nums[i]\n            swaps += 1\n    \n    return swaps\n\ndef g():\n    nums = [4, 2, 1, 3]\n    return nums\n\nassert f(g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of swaps required to sort the list in non-decreasing order.\n    \"\"\"\n    n = len(nums)\n    swaps = 0\n    \n    for i in range(n):\n        min_idx = i\n        \n        for j in range(i+1, n):\n            if nums[j] < nums[min_idx]:\n                min_idx = j\n        \n        if min_idx != i:\n            nums[i], nums[min_idx] = nums[min_idx], nums[i]\n            swaps += 1\n    \n    return swaps", "solution_func": "def g():\n    nums = [4, 2, 1, 3]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that sum up to a target value. Return their indices in a list.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [1, 2, 3, 5, 7]\n    target = 8\n    return (nums, target)\n\nassert f(*g()) == [2, 3]\n", "emb": null, "idx_generation": 323, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that sum up to a target value. Return their indices in a list.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g():\n    nums = [1, 2, 3, 5, 7]\n    target = 8\n    return (nums, target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any subgrid with dimensions 3x3.\n    \"\"\"\n    max_sum = float('-inf')\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid_sum = 0\n            \n            for k in range(3):\n                for l in range(3):\n                    subgrid_sum += grid[i+k][j+l]\n            \n            max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3, 4, 5],\n        [6, 7, 8, 9, 10],\n        [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20]\n    ]\n    return grid\n\nassert f(g()) == 171\n", "emb": null, "idx_generation": 323, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any subgrid with dimensions 3x3.\n    \"\"\"\n    max_sum = float('-inf')\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid_sum = 0\n            \n            for k in range(3):\n                for l in range(3):\n                    subgrid_sum += grid[i+k][j+l]\n            \n            max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum", "solution_func": "def g():\n    grid = [\n        [1, 2, 3, 4, 5],\n        [6, 7, 8, 9, 10],\n        [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target value, check if there exists a pair of elements in the list whose sum is equal to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n    Explanation: The sum of arr[2] = 3 and arr[4] = 5 is equal to the target value of 7.\n\n    Input: arr = [1, 2, 3, 4, 5], target = 10\n    Output: False\n    Explanation: There are no two elements in the list whose sum is equal to the target value of 10.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 323, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target value, check if there exists a pair of elements in the list whose sum is equal to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n    Explanation: The sum of arr[2] = 3 and arr[4] = 5 is equal to the target value of 7.\n\n    Input: arr = [1, 2, 3, 4, 5], target = 10\n    Output: False\n    Explanation: There are no two elements in the list whose sum is equal to the target value of 10.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation:\n    - The maximum product of any two distinct numbers in the given list is 5 * 4 = 20.\n    \"\"\"\n\n    def max_product(arr):\n        n = len(arr)\n        if n < 2:\n            return 0\n        \n        max_product = float('-inf')\n        for i in range(n-1):\n            for j in range(i+1, n):\n                product = arr[i] * arr[j]\n                max_product = max(max_product, product)\n                \n        return max_product\n\n    return max_product(arr)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 324, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation:\n    - The maximum product of any two distinct numbers in the given list is 5 * 4 = 20.\n    \"\"\"\n\n    def max_product(arr):\n        n = len(arr)\n        if n < 2:\n            return 0\n        \n        max_product = float('-inf')\n        for i in range(n-1):\n            for j in range(i+1, n):\n                product = arr[i] * arr[j]\n                max_product = max(max_product, product)\n                \n        return max_product\n\n    return max_product(arr)", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Example:\n    Input: [2, 7, 11, 15], target = 9\n    Output: [2, 7]\n    Explanation:\n    - The numbers 2 and 7 in the given list add up to the target number 9.\n    \"\"\"\n\n    def two_sum(arr, target):\n        n = len(arr)\n        if n < 2:\n            return []\n        \n        num_map = {}\n        for i in range(n):\n            complement = target - arr[i]\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[arr[i]] = i\n        \n        return []\n\n    return two_sum(arr, target)\n\ndef g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return (arr, target)\n\nassert f(*g()) == [2, 7]\n", "emb": null, "idx_generation": 324, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Example:\n    Input: [2, 7, 11, 15], target = 9\n    Output: [2, 7]\n    Explanation:\n    - The numbers 2 and 7 in the given list add up to the target number 9.\n    \"\"\"\n\n    def two_sum(arr, target):\n        n = len(arr)\n        if n < 2:\n            return []\n        \n        num_map = {}\n        for i in range(n):\n            complement = target - arr[i]\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[arr[i]] = i\n        \n        return []\n\n    return two_sum(arr, target)", "solution_func": "def g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return (arr, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n    Explanation:\n    - The 6th Fibonacci number is 8.\n    \"\"\"\n\n    def fibonacci(n):\n        if n <= 1:\n            return n\n\n        fib_list = [0, 1]\n        for i in range(2, n+1):\n            fib_list.append(fib_list[i-1] + fib_list[i-2])\n\n        return fib_list[n]\n\n    return fibonacci(n)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n    Explanation:\n    - The 6th Fibonacci number is 8.\n    \"\"\"\n\n    def fibonacci(n):\n        if n <= 1:\n            return n\n\n        fib_list = [0, 1]\n        for i in range(2, n+1):\n            fib_list.append(fib_list[i-1] + fib_list[i-2])\n\n        return fib_list[n]\n\n    return fibonacci(n)", "solution_func": "def g():\n    n = 6\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, check if it is possible to rearrange the characters of s\n    such that no two adjacent characters are the same, and the resulting string has exactly k distinct characters.\n\n    Example:\n    s = \"aabbc\"\n    k = 3\n\n    f(s, k) => True\n\n    Explanation: By rearranging the characters, we can obtain the string \"ababc\", which has exactly 3 distinct characters.\n\n    \"\"\"\n    distinct_chars = len(set(s))\n    return distinct_chars == k\n\ndef g() -> Tuple[str, int]:\n    return \"aabbc\", 3\n\nassert f(*g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 324, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, check if it is possible to rearrange the characters of s\n    such that no two adjacent characters are the same, and the resulting string has exactly k distinct characters.\n\n    Example:\n    s = \"aabbc\"\n    k = 3\n\n    f(s, k) => True\n\n    Explanation: By rearranging the characters, we can obtain the string \"ababc\", which has exactly 3 distinct characters.\n\n    \"\"\"\n    distinct_chars = len(set(s))\n    return distinct_chars == k", "solution_func": "def g() -> Tuple[str, int]:\n    return \"aabbc\", 3", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s containing only lowercase alphabets, convert each character to its corresponding binary representation.\n    Return a string consisting of the binary representations of the characters in s, concatenated together.\n\n    Example:\n    s = \"abc\"\n\n    f(s) => \"11000011100010\"\n\n    Explanation: The binary representation of 'a', 'b', and 'c' are '1100001', '1100010', and '1100011' respectively.\n    Concatenating these binary representations gives us the final result \"11000011100010\".\n\n    \"\"\"\n\n    binary_str = ''\n    for char in s:\n        binary_str += bin(ord(char))[2:]\n\n    return binary_str\n\ndef g() -> str:\n    return \"abc\"\n\nassert f(g()) == \"11000011100010\"\n", "emb": null, "idx_generation": 324, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s containing only lowercase alphabets, convert each character to its corresponding binary representation.\n    Return a string consisting of the binary representations of the characters in s, concatenated together.\n\n    Example:\n    s = \"abc\"\n\n    f(s) => \"11000011100010\"\n\n    Explanation: The binary representation of 'a', 'b', and 'c' are '1100001', '1100010', and '1100011' respectively.\n    Concatenating these binary representations gives us the final result \"11000011100010\".\n\n    \"\"\"\n\n    binary_str = ''\n    for char in s:\n        binary_str += bin(ord(char))[2:]\n\n    return binary_str", "solution_func": "def g() -> str:\n    return \"abc\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with each word reversed.\n\n    Example:\n    s = \"Hello, World!\"\n\n    f(s) => \"olleH, dlroW!\"\n\n    Explanation: The words \"Hello\" and \"World\" are reversed to \"olleH\" and \"dlroW\" respectively, while the punctuation remains the same.\n\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n\n    return ' '.join(reversed_words)\n\ndef g() -> str:\n    return \"Hello, World!\"\n\nassert f(g()) == \"olleH, dlroW!\"\n", "emb": null, "idx_generation": 324, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with each word reversed.\n\n    Example:\n    s = \"Hello, World!\"\n\n    f(s) => \"olleH, dlroW!\"\n\n    Explanation: The words \"Hello\" and \"World\" are reversed to \"olleH\" and \"dlroW\" respectively, while the punctuation remains the same.\n\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n\n    return ' '.join(reversed_words)", "solution_func": "def g() -> str:\n    return \"Hello, World!\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers `arr`, find `k` elements whose sum is equal to the target.\n    Return True if such elements exist, otherwise return False.\n\n    Sample Input:\n    arr = [2, 4, 6, 8, 10]\n    target = 16\n    k = 3\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(curr_sum, curr_k, start):\n        if curr_sum == target and curr_k == k:\n            return True\n        if curr_sum > target or curr_k > k:\n            return False\n\n        for i in range(start, len(arr)):\n            if dfs(curr_sum + arr[i], curr_k + 1, i + 1):\n                return True\n        return False\n\n    return dfs(0, 0, 0)\n\ndef g(arr = [2, 4, 6, 8, 10], target = 16, k = 3):\n    return f(arr, target, k)\nassert g()\n\nassert f(g()) == True", "emb": null, "idx_generation": 324, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers `arr`, find `k` elements whose sum is equal to the target.\n    Return True if such elements exist, otherwise return False.\n\n    Sample Input:\n    arr = [2, 4, 6, 8, 10]\n    target = 16\n    k = 3\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(curr_sum, curr_k, start):\n        if curr_sum == target and curr_k == k:\n            return True\n        if curr_sum > target or curr_k > k:\n            return False\n\n        for i in range(start, len(arr)):\n            if dfs(curr_sum + arr[i], curr_k + 1, i + 1):\n                return True\n        return False\n\n    return dfs(0, 0, 0)", "solution_func": "def g(arr = [2, 4, 6, 8, 10], target = 16, k = 3):\n    return f(arr, target, k)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings `s` and `t`, find the minimum number of operations required to convert `s` to `t`.\n    The possible operations are:\n    - Insert a character\n    - Delete a character\n    - Replace a character\n\n    Return True if the minimum number of operations is even, otherwise return False.\n\n    Sample Input:\n    s = \"kitten\"\n    t = \"sitting\"\n\n    Sample Output:\n    True\n    \"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    return dp[m][n] % 2 == 0\n\ndef g(s = \"kitten\", t = \"sitting\"):\n    return f(s, t)\nassert g()\n\nassert f(g()) == True", "emb": null, "idx_generation": 324, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings `s` and `t`, find the minimum number of operations required to convert `s` to `t`.\n    The possible operations are:\n    - Insert a character\n    - Delete a character\n    - Replace a character\n\n    Return True if the minimum number of operations is even, otherwise return False.\n\n    Sample Input:\n    s = \"kitten\"\n    t = \"sitting\"\n\n    Sample Output:\n    True\n    \"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    return dp[m][n] % 2 == 0", "solution_func": "def g(s = \"kitten\", t = \"sitting\"):\n    return f(s, t)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers `arr` and a target integer, find the length of the shortest subarray\n    that needs to be sorted in order for the entire list to be sorted in ascending order.\n    Return True if the length of the shortest subarray is even, otherwise return False.\n\n    Sample Input:\n    arr = [1, 3, 5, 4, 2, 6, 8, 10, 9, 7]\n    target = 8\n\n    Sample Output:\n    True\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < len(arr) - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n\n    if left > right:\n        return False\n\n    min_val, max_val = min(arr[left:right+1]), max(arr[left:right+1])\n\n    while left > 0 and arr[left - 1] > min_val:\n        left -= 1\n\n    while right < len(arr) - 1 and arr[right + 1] < max_val:\n        right += 1\n\n    return (right - left + 1) % 2 == 0\n\ndef g(arr = [1, 3, 5, 4, 2, 6, 8, 10, 9, 7], target = 8):\n    return f(arr, target)\nassert g()\n\nassert f(g()) == True", "emb": null, "idx_generation": 324, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers `arr` and a target integer, find the length of the shortest subarray\n    that needs to be sorted in order for the entire list to be sorted in ascending order.\n    Return True if the length of the shortest subarray is even, otherwise return False.\n\n    Sample Input:\n    arr = [1, 3, 5, 4, 2, 6, 8, 10, 9, 7]\n    target = 8\n\n    Sample Output:\n    True\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < len(arr) - 1 and arr[left] <= arr[left + 1]:\n        left += 1\n\n    while right > 0 and arr[right] >= arr[right - 1]:\n        right -= 1\n\n    if left > right:\n        return False\n\n    min_val, max_val = min(arr[left:right+1]), max(arr[left:right+1])\n\n    while left > 0 and arr[left - 1] > min_val:\n        left -= 1\n\n    while right < len(arr) - 1 and arr[right + 1] < max_val:\n        right += 1\n\n    return (right - left + 1) % 2 == 0", "solution_func": "def g(arr = [1, 3, 5, 4, 2, 6, 8, 10, 9, 7], target = 8):\n    return f(arr, target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine if it is possible to reach the target by performing the following operations:\n    - Start at the first element of the list.\n    - Choose either addition or subtraction operation.\n    - Apply the chosen operation to the current number and move to the next number in the list.\n\n    Return True if it is possible to reach the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 7\n    f(nums, target) => True\n    Explanation: 1 + 2 + 4 = 7\n    \"\"\"\n\n    def dfs(i, curr_sum):\n        if i == len(nums):\n            return curr_sum == target\n        return dfs(i + 1, curr_sum + nums[i]) or dfs(i + 1, curr_sum - nums[i])\n\n    return dfs(0, 0)\n\ndef g():\n    return ([1, 2, 3, 4], 7)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 324, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine if it is possible to reach the target by performing the following operations:\n    - Start at the first element of the list.\n    - Choose either addition or subtraction operation.\n    - Apply the chosen operation to the current number and move to the next number in the list.\n\n    Return True if it is possible to reach the target, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 7\n    f(nums, target) => True\n    Explanation: 1 + 2 + 4 = 7\n    \"\"\"\n\n    def dfs(i, curr_sum):\n        if i == len(nums):\n            return curr_sum == target\n        return dfs(i + 1, curr_sum + nums[i]) or dfs(i + 1, curr_sum - nums[i])\n\n    return dfs(0, 0)", "solution_func": "def g():\n    return ([1, 2, 3, 4], 7)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every two nodes are connected to each other by a path.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The graph has 2 connected components:\n    - Component 1: Nodes 0, 1\n    - Component 2: Nodes 2, 3\n\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                for neighbor in range(len(matrix)):\n                    if matrix[curr][neighbor] == 1 and not visited[neighbor]:\n                        stack.append(neighbor)\n    \n    n = len(matrix)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n    \n    return count\n\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 325, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every two nodes are connected to each other by a path.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The graph has 2 connected components:\n    - Component 1: Nodes 0, 1\n    - Component 2: Nodes 2, 3\n\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                for neighbor in range(len(matrix)):\n                    if matrix[curr][neighbor] == 1 and not visited[neighbor]:\n                        stack.append(neighbor)\n    \n    n = len(matrix)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n    \n    return count", "solution_func": "def g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    A word is defined as a sequence of non-space characters separated by a space.\n\n    Example:\n    s = \"hello world\"\n    Output: \"world hello\"\n\n    Note: You may assume that the input string does not contain leading or trailing spaces and the words are separated by a single space.\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\n\ndef g():\n    s = \"hello world\"\n    return s\n\nassert f(g()) == \"world hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    A word is defined as a sequence of non-space characters separated by a space.\n\n    Example:\n    s = \"hello world\"\n    Output: \"world hello\"\n\n    Note: You may assume that the input string does not contain leading or trailing spaces and the words are separated by a single space.\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "solution_func": "def g():\n    s = \"hello world\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return a new array where each element is the product of all the elements in the original array except itself.\n\n    Example:\n    arr = [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The product of all elements in the original array except 1 is 24. The product of all elements except 2 is 12, and so on.\n\n    Note: You may assume that the input array does not contain any zeros.\n    \"\"\"\n    n = len(arr)\n    result = [1] * n\n\n    product = 1\n    for i in range(n):\n        result[i] *= product\n        product *= arr[i]\n\n    product = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= product\n        product *= arr[i]\n\n    return result\n\n\ndef g():\n    arr = [1, 2, 3, 4]\n    return arr\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return a new array where each element is the product of all the elements in the original array except itself.\n\n    Example:\n    arr = [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The product of all elements in the original array except 1 is 24. The product of all elements except 2 is 12, and so on.\n\n    Note: You may assume that the input array does not contain any zeros.\n    \"\"\"\n    n = len(arr)\n    result = [1] * n\n\n    product = 1\n    for i in range(n):\n        result[i] *= product\n        product *= arr[i]\n\n    product = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= product\n        product *= arr[i]\n\n    return result", "solution_func": "def g():\n    arr = [1, 2, 3, 4]\n    return arr", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    def binary_search(arr: List[int], target: int, low: int, high: int) -> int:\n        if low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                return binary_search(arr, target, mid + 1, high)\n            else:\n                return binary_search(arr, target, low, mid - 1)\n        else:\n            return -1\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    def binary_search(arr: List[int], target: int, low: int, high: int) -> int:\n        if low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                return binary_search(arr, target, mid + 1, high)\n            else:\n                return binary_search(arr, target, low, mid - 1)\n        else:\n            return -1\n\n    return binary_search(arr, target, 0, len(arr) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string.\n    \"\"\"\n    vowels = set(['a', 'e', 'i', 'o', 'u'])\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, World!\"\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string.\n    \"\"\"\n    vowels = set(['a', 'e', 'i', 'o', 'u'])\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, World!\"", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all positive integers less than or equal to n.\n    \"\"\"\n    if n == 1:\n        return 1\n    return n + f(n - 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 325, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all positive integers less than or equal to n.\n    \"\"\"\n    if n == 1:\n        return 1\n    return n + f(n - 1)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'fig']) -> bool:\n    \"\"\"Find the longest palindrome in a list of strings.\"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    palindromes = [string for string in strings if is_palindrome(string)]\n    longest_palindrome = max(palindromes, key=len)\n    \n    return s == longest_palindrome\n\ndef g(strings=['apple', 'banana', 'cherry', 'date', 'fig']):\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    palindromes = [string for string in strings if is_palindrome(string)]\n    longest_palindrome = max(palindromes, key=len)\n    \n    return longest_palindrome\n\nassert f(g())\n", "emb": null, "idx_generation": 325, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'fig']) -> bool:\n    \"\"\"Find the longest palindrome in a list of strings.\"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    palindromes = [string for string in strings if is_palindrome(string)]\n    longest_palindrome = max(palindromes, key=len)\n    \n    return s == longest_palindrome", "solution_func": "def g(strings=['apple', 'banana', 'cherry', 'date', 'fig']):\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    palindromes = [string for string in strings if is_palindrome(string)]\n    longest_palindrome = max(palindromes, key=len)\n    \n    return longest_palindrome", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(num: int, nums=[10, 20, 30, 40, 50]) -> bool:\n    \"\"\"Check if the given number is a Fibonacci number.\"\"\"\n    def is_perfect_square(number):\n        return int(number ** 0.5) ** 2 == number\n    \n    def is_fibonacci(num):\n        return is_perfect_square(5 * (num ** 2) + 4) or is_perfect_square(5 * (num ** 2) - 4)\n    \n    return is_fibonacci(num)\n\ndef g(nums=[10, 20, 30, 40, 50]):\n    def is_perfect_square(number):\n        return int(number ** 0.5) ** 2 == number\n    \n    def is_fibonacci(num):\n        return is_perfect_square(5 * (num ** 2) + 4) or is_perfect_square(5 * (num ** 2) - 4)\n    \n    return nums[0]\n\nassert f(g())\n", "emb": null, "idx_generation": 325, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(num: int, nums=[10, 20, 30, 40, 50]) -> bool:\n    \"\"\"Check if the given number is a Fibonacci number.\"\"\"\n    def is_perfect_square(number):\n        return int(number ** 0.5) ** 2 == number\n    \n    def is_fibonacci(num):\n        return is_perfect_square(5 * (num ** 2) + 4) or is_perfect_square(5 * (num ** 2) - 4)\n    \n    return is_fibonacci(num)", "solution_func": "def g(nums=[10, 20, 30, 40, 50]):\n    def is_perfect_square(number):\n        return int(number ** 0.5) ** 2 == number\n    \n    def is_fibonacci(num):\n        return is_perfect_square(5 * (num ** 2) + 4) or is_perfect_square(5 * (num ** 2) - 4)\n    \n    return nums[0]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'fig']) -> bool:\n    \"\"\"Check if the given string is a substring of any string in a list.\"\"\"\n    return any(s in string for string in strings)\n\ndef g(strings=['apple', 'banana', 'cherry', 'date', 'fig']):\n    return strings[0] + \"pie\"\n\nassert f(g())\n", "emb": null, "idx_generation": 325, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'fig']) -> bool:\n    \"\"\"Check if the given string is a substring of any string in a list.\"\"\"\n    return any(s in string for string in strings)", "solution_func": "def g(strings=['apple', 'banana', 'cherry', 'date', 'fig']):\n    return strings[0] + \"pie\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum sum of any contiguous subarray of the list.\n\n    Sample Input:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    -6\n\n    Explanation: The contiguous subarray with the minimum sum is [-2, 1, -3, 4, -1, 2, 1], which sums up to -6.\n    \"\"\"\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there is a contiguous subarray with the minimum sum.\n    \"\"\"\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == -6\n\n", "emb": null, "idx_generation": 325, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum sum of any contiguous subarray of the list.\n\n    Sample Input:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    -6\n\n    Explanation: The contiguous subarray with the minimum sum is [-2, 1, -3, 4, -1, 2, 1], which sums up to -6.\n    \"\"\"\n\n    min_sum = float('inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there is a contiguous subarray with the minimum sum.\n    \"\"\"\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum in linear time.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum in linear time.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subarray.\n\n    Example:\n    Input: [1, 2, 3, 2, 5, 4, 7, 6, 8]\n    Output: 4\n\n    Explanation: The longest increasing subarray is [2, 5, 4, 7] with length 4.\n\n    Hint: Use dynamic programming to keep track of the longest increasing subarray length at each index.\n    \"\"\"\n    length = 1\n    max_length = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            length += 1\n            max_length = max(max_length, length)\n        else:\n            length = 1\n\n    return max_length\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 2, 5, 4, 7, 6, 8]\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 326, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subarray.\n\n    Example:\n    Input: [1, 2, 3, 2, 5, 4, 7, 6, 8]\n    Output: 4\n\n    Explanation: The longest increasing subarray is [2, 5, 4, 7] with length 4.\n\n    Hint: Use dynamic programming to keep track of the longest increasing subarray length at each index.\n    \"\"\"\n    length = 1\n    max_length = 1\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            length += 1\n            max_length = max(max_length, length)\n        else:\n            length = 1\n\n    return max_length", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 2, 5, 4, 7, 6, 8]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the minimum number of elements that need to be removed from the array to make the sum of the remaining elements equal to the target.\n\n    Example:\n    Input: arr = [5, 6, 7, 8, 9], target = 20\n    Output: 1\n\n    Explanation: Removing the element 8 results in the sum of the remaining elements [5, 6, 7, 9] equal to the target 20.\n\n    Hint: Use dynamic programming to keep track of the minimum number of elements to be removed at each index.\n    \"\"\"\n    n = len(arr)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i-1] <= j:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-arr[i-1]] + arr[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    return n - dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    return ([5, 6, 7, 8, 9], 20)\n\nassert f(*g()) == 1\n\n", "emb": null, "idx_generation": 326, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the minimum number of elements that need to be removed from the array to make the sum of the remaining elements equal to the target.\n\n    Example:\n    Input: arr = [5, 6, 7, 8, 9], target = 20\n    Output: 1\n\n    Explanation: Removing the element 8 results in the sum of the remaining elements [5, 6, 7, 9] equal to the target 20.\n\n    Hint: Use dynamic programming to keep track of the minimum number of elements to be removed at each index.\n    \"\"\"\n    n = len(arr)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i-1] <= j:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-arr[i-1]] + arr[i-1])\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    return n - dp[n][target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    return ([5, 6, 7, 8, 9], 20)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, find if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    f(nums, target) => True, since 6 + 8 = 14\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return (nums, target)\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, find if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    f(nums, target) => True, since 6 + 8 = 14\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down, right, or diagonally.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    f(grid) => 1 + 4 + 5 + 8 + 9 = 27\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return (grid,)\n\nassert f(*g()) == 27\n", "emb": null, "idx_generation": 326, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down, right, or diagonally.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    f(grid) => 1 + 4 + 5 + 8 + 9 = 27\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return (grid,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum sum of a subarray is 6, which corresponds to the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return (nums,)\n\nassert f(*g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum sum of a subarray is 6, which corresponds to the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return (nums,)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer,\n    find the maximum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    Explanation:\n    The maximum path sum is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 326, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer,\n    find the maximum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    Explanation:\n    The maximum path sum is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target sum, determine the number of\n    unique combinations that add up to the target sum.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output:\n    7\n    Explanation:\n    There are 7 unique combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target sum, determine the number of\n    unique combinations that add up to the target sum.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output:\n    7\n    Explanation:\n    There are 7 unique combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer,\n    find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    Explanation:\n    The minimum cost to reach the bottom-right cell is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 326, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer,\n    find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    Explanation:\n    The minimum cost to reach the bottom-right cell is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of consecutive subarrays whose sum is equal to the target.\n    Return the count of such subarrays.\n\n    Sample input:\n    nums = [1, 1, 1], target = 2\n\n    Sample output:\n    2\n\n    Explanation:\n    There are 2 subarrays with sum equal to 2: [1, 1] and [1, 1].\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_counts = {0: 1}  # Store the count of prefix sums\n\n    for num in nums:\n        prefix_sum += num\n        complement = prefix_sum - target\n        if complement in sum_counts:\n            count += sum_counts[complement]\n        sum_counts[prefix_sum] = sum_counts.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g():\n    nums = [1, 1, 1]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 326, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of consecutive subarrays whose sum is equal to the target.\n    Return the count of such subarrays.\n\n    Sample input:\n    nums = [1, 1, 1], target = 2\n\n    Sample output:\n    2\n\n    Explanation:\n    There are 2 subarrays with sum equal to 2: [1, 1] and [1, 1].\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_counts = {0: 1}  # Store the count of prefix sums\n\n    for num in nums:\n        prefix_sum += num\n        complement = prefix_sum - target\n        if complement in sum_counts:\n            count += sum_counts[complement]\n        sum_counts[prefix_sum] = sum_counts.get(prefix_sum, 0) + 1\n\n    return count", "solution_func": "def g():\n    nums = [1, 1, 1]\n    target = 2\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given the number of nodes n and a list of edges, return a list of the indegrees of each node in the graph.\n\n    Each edge in the list represents a directed connection between two nodes.\n\n    Example:\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n\n    The edges represent the following connections:\n    1 -> 2\n    2 -> 3\n    3 -> 4\n\n    The indegrees of the nodes are:\n    [0, 1, 1, 1]\n\n    Therefore, the function should return [0, 1, 1, 1].\n\n    Note:\n    - The nodes are labeled from 1 to n.\n    - The list of edges will not contain any duplicate connections.\n    \"\"\"\n\n    # Create the adjacency list and initialize the indegrees of each node to 0\n    adj_list = [[] for _ in range(n + 1)]\n    indegrees = [0] * (n + 1)\n\n    # Populate the adjacency list and count the indegrees of each node\n    for u, v in edges:\n        adj_list[u].append(v)\n        indegrees[v] += 1\n\n    return indegrees\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes n and a list of edges.\n    \"\"\"\n    return 4, [[1, 2], [2, 3], [3, 4]]\n\nassert f(*g()) == [0, 1, 1, 1]\n", "emb": null, "idx_generation": 327, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given the number of nodes n and a list of edges, return a list of the indegrees of each node in the graph.\n\n    Each edge in the list represents a directed connection between two nodes.\n\n    Example:\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n\n    The edges represent the following connections:\n    1 -> 2\n    2 -> 3\n    3 -> 4\n\n    The indegrees of the nodes are:\n    [0, 1, 1, 1]\n\n    Therefore, the function should return [0, 1, 1, 1].\n\n    Note:\n    - The nodes are labeled from 1 to n.\n    - The list of edges will not contain any duplicate connections.\n    \"\"\"\n\n    # Create the adjacency list and initialize the indegrees of each node to 0\n    adj_list = [[] for _ in range(n + 1)]\n    indegrees = [0] * (n + 1)\n\n    # Populate the adjacency list and count the indegrees of each node\n    for u, v in edges:\n        adj_list[u].append(v)\n        indegrees[v] += 1\n\n    return indegrees", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes n and a list of edges.\n    \"\"\"\n    return 4, [[1, 2], [2, 3], [3, 4]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, ...\n\n    The 6th Fibonacci number is 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Initialize the first two Fibonacci numbers\n    fib_0 = 0\n    fib_1 = 1\n\n    # Calculate the nth Fibonacci number using dynamic programming\n    for _ in range(2, n + 1):\n        fib_2 = fib_0 + fib_1\n        fib_0 = fib_1\n        fib_1 = fib_2\n\n    return fib_1\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, ...\n\n    The 6th Fibonacci number is 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    # Base cases\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Initialize the first two Fibonacci numbers\n    fib_0 = 0\n    fib_1 = 1\n\n    # Calculate the nth Fibonacci number using dynamic programming\n    for _ in range(2, n + 1):\n        fib_2 = fib_0 + fib_1\n        fib_0 = fib_1\n        fib_1 = fib_2\n\n    return fib_1", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a square matrix of size n x n, return the sum of the main diagonal elements.\n\n    The main diagonal of a matrix consists of the elements that are on the diagonal from the top-left to the bottom-right.\n\n    Example:\n    n = 3\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The main diagonal elements are: 1, 5, 9\n\n    The sum of the main diagonal elements is: 1 + 5 + 9 = 15\n\n    Therefore, the function should return 15.\n\n    Note:\n    - The matrix is guaranteed to be a square matrix.\n    \"\"\"\n\n    # Initialize the sum of the main diagonal elements\n    diagonal_sum = 0\n\n    # Calculate the sum of the main diagonal elements\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a positive integer n and a square matrix.\n    \"\"\"\n    return 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a square matrix of size n x n, return the sum of the main diagonal elements.\n\n    The main diagonal of a matrix consists of the elements that are on the diagonal from the top-left to the bottom-right.\n\n    Example:\n    n = 3\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The main diagonal elements are: 1, 5, 9\n\n    The sum of the main diagonal elements is: 1 + 5 + 9 = 15\n\n    Therefore, the function should return 15.\n\n    Note:\n    - The matrix is guaranteed to be a square matrix.\n    \"\"\"\n\n    # Initialize the sum of the main diagonal elements\n    diagonal_sum = 0\n\n    # Calculate the sum of the main diagonal elements\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n\n    return diagonal_sum", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a positive integer n and a square matrix.\n    \"\"\"\n    return 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport heapq\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, find the kth largest element in the list.\n\n    Sample input:\n    nums = [3,2,1,5,6,4], k = 2\n\n    Sample output:\n    5\n\n    Explanation:\n    The second largest element in the list is 5.\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heapq.heappop(heap)\n\ndef g():\n    nums = [3,2,1,5,6,4]\n    k = 2\n    return nums, k\n\nassert f(*g()) == 5\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nimport heapq\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, find the kth largest element in the list.\n\n    Sample input:\n    nums = [3,2,1,5,6,4], k = 2\n\n    Sample output:\n    5\n\n    Explanation:\n    The second largest element in the list is 5.\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heapq.heappop(heap)", "solution_func": "def g():\n    nums = [3,2,1,5,6,4]\n    k = 2\n    return nums, k", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and an integer k, find the k largest elements in the list and return them in sorted order.\n\n    Sample input:\n    nums = [3,2,1,5,6,4], k = 3\n\n    Sample output:\n    [4, 5, 6]\n\n    Explanation:\n    The three largest elements in the list are 4, 5, and 6, and they are returned in sorted order.\n    \"\"\"\n    return sorted(nums)[-k:]\n\ndef g():\n    nums = [3,2,1,5,6,4]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [4, 5, 6]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and an integer k, find the k largest elements in the list and return them in sorted order.\n\n    Sample input:\n    nums = [3,2,1,5,6,4], k = 3\n\n    Sample output:\n    [4, 5, 6]\n\n    Explanation:\n    The three largest elements in the list are 4, 5, and 6, and they are returned in sorted order.\n    \"\"\"\n    return sorted(nums)[-k:]", "solution_func": "def g():\n    nums = [3,2,1,5,6,4]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find three numbers in the list that add up to the target.\n    Return the indices of the three numbers.\n\n    Sample input:\n    nums = [2, 7, 11, 15], target = 24\n\n    Sample output:\n    [1, 2, 3]\n\n    Explanation:\n    The numbers at indices 1, 2, and 3 are 7, 11, and 15, and their sum is 24.\n    \"\"\"\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i, num_indices[num]]\n        num_indices[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 24\n    return nums, target\n\nassert f(*g()) == [1, 2, 3]\n", "emb": null, "idx_generation": 327, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find three numbers in the list that add up to the target.\n    Return the indices of the three numbers.\n\n    Sample input:\n    nums = [2, 7, 11, 15], target = 24\n\n    Sample output:\n    [1, 2, 3]\n\n    Explanation:\n    The numbers at indices 1, 2, and 3 are 7, 11, and 15, and their sum is 24.\n    \"\"\"\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i, num_indices[num]]\n        num_indices[num] = i\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 24\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the number of occurrences of the target in the list.\n    Return the count of occurrences.\n\n    Example:\n    Input: nums = [1, 2, 2, 3, 3, 3, 4, 5], target = 3\n    Output: 3\n\n    Explanation: The target value 3 appears 3 times in the list.\n\n    Note: You must use binary search to solve this problem.\n    \"\"\"\n\n    def binary_search_left(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right\n\n    left_index = binary_search_left(nums, target)\n    right_index = binary_search_right(nums, target)\n\n    return right_index - left_index + 1\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 3, 3, 3, 4, 5]\n    target = 3\n    return (nums, target)\n\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the number of occurrences of the target in the list.\n    Return the count of occurrences.\n\n    Example:\n    Input: nums = [1, 2, 2, 3, 3, 3, 4, 5], target = 3\n    Output: 3\n\n    Explanation: The target value 3 appears 3 times in the list.\n\n    Note: You must use binary search to solve this problem.\n    \"\"\"\n\n    def binary_search_left(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right\n\n    left_index = binary_search_left(nums, target)\n    right_index = binary_search_right(nums, target)\n\n    return right_index - left_index + 1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 3, 3, 3, 4, 5]\n    target = 3\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if it is bipartite.\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n    Return True if the graph is bipartite, False otherwise.\n\n    Example:\n    Input: graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    Output: True\n\n    Explanation: The graph can be colored as follows:\n    0 - color A\n    1 - color B\n    2 - color A\n    3 - color B\n    No two adjacent vertices have the same color.\n\n    Note: You must use a depth-first search (DFS) algorithm to solve this problem.\n    \"\"\"\n\n    def dfs(node: int, color: int) -> bool:\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n\n    for i in range(n):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    return graph\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if it is bipartite.\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n    Return True if the graph is bipartite, False otherwise.\n\n    Example:\n    Input: graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    Output: True\n\n    Explanation: The graph can be colored as follows:\n    0 - color A\n    1 - color B\n    2 - color A\n    3 - color B\n    No two adjacent vertices have the same color.\n\n    Note: You must use a depth-first search (DFS) algorithm to solve this problem.\n    \"\"\"\n\n    def dfs(node: int, color: int) -> bool:\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n\n    for i in range(n):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it clockwise by 90 degrees in place.\n\n    Example:\n    Input: matrix = [[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]\n    Output: [[7, 4, 1],\n             [8, 5, 2],\n             [9, 6, 3]]\n\n    Explanation: The matrix is rotated clockwise by 90 degrees.\n\n    Note: You must perform the rotation in place, without using any extra space.\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it clockwise by 90 degrees in place.\n\n    Example:\n    Input: matrix = [[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]\n    Output: [[7, 4, 1],\n             [8, 5, 2],\n             [9, 6, 3]]\n\n    Explanation: The matrix is rotated clockwise by 90 degrees.\n\n    Note: You must perform the rotation in place, without using any extra space.\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any rectangle submatrix. The submatrix can be of any size and must be contiguous.\n\n    Return the maximum sum.\n\n    Example:\n    matrix = [[1, 2, -1, -4, -20],\n              [-8, -3, 4, 2, 1],\n              [3, 8, 10, 1, 3],\n              [-4, -1, 1, 7, -6]]\n\n    The maximum sum of any rectangle submatrix is 29, which can be obtained from the submatrix [[10, 1, 3],\n                                                                                              [1, 7, -6]].\n\n    Therefore, the function should return 29.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            curr_sum = kadane(temp)\n            max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef kadane(arr: List[int]) -> int:\n    max_sum = arr[0]\n    curr_sum = arr[0]\n    for i in range(1, len(arr)):\n        curr_sum = max(arr[i], curr_sum + arr[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, -1, -4, -20],\n            [-8, -3, 4, 2, 1],\n            [3, 8, 10, 1, 3],\n            [-4, -1, 1, 7, -6]]\n\nassert f(g()) == 29\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 327, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any rectangle submatrix. The submatrix can be of any size and must be contiguous.\n\n    Return the maximum sum.\n\n    Example:\n    matrix = [[1, 2, -1, -4, -20],\n              [-8, -3, 4, 2, 1],\n              [3, 8, 10, 1, 3],\n              [-4, -1, 1, 7, -6]]\n\n    The maximum sum of any rectangle submatrix is 29, which can be obtained from the submatrix [[10, 1, 3],\n                                                                                              [1, 7, -6]].\n\n    Therefore, the function should return 29.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            curr_sum = kadane(temp)\n            max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef kadane(arr: List[int]) -> int:\n    max_sum = arr[0]\n    curr_sum = arr[0]\n    for i in range(1, len(arr)):\n        curr_sum = max(arr[i], curr_sum + arr[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, -1, -4, -20],\n            [-8, -3, 4, 2, 1],\n            [3, 8, 10, 1, 3],\n            [-4, -1, 1, 7, -6]]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the indices (0-indexed) of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [0, 1]\n    Explanation: The sum of 2 and 7 is 9. Therefore, the indices are [0, 1].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 12\n    return (nums, target)\n\nassert f(*g()) == [2, 3]\n", "emb": null, "idx_generation": 328, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the indices (0-indexed) of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [0, 1]\n    Explanation: The sum of 2 and 7 is 9. Therefore, the indices are [0, 1].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of distinct integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 12\n    return (nums, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array nums of n integers, find the maximum possible sum of a subarray such that the subarray does not contain adjacent elements (i.e., choose elements from the array such that no two adjacent elements are selected).\n\n    Example:\n    Input: nums = [2,7,9,3,1]\n    Output: 12\n    Explanation: Choose subarray [2,9,1] with maximum sum = 12.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 328, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array nums of n integers, find the maximum possible sum of a subarray such that the subarray does not contain adjacent elements (i.e., choose elements from the array such that no two adjacent elements are selected).\n\n    Example:\n    Input: nums = [2,7,9,3,1]\n    Output: 12\n    Explanation: Choose subarray [2,9,1] with maximum sum = 12.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\n    If target is not found in the array, return [-1, -1].\n    You must write an algorithm with O(log n) runtime complexity.\n    \n    Example:\n    Input: nums = [5,7,7,8,8,10], target = 8\n    Output: [3,4]\n    \"\"\"\n    def find_leftmost(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] == target:\n            return left\n        else:\n            return -1\n    \n    def find_rightmost(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        if nums[right] == target:\n            return right\n        else:\n            return -1\n    \n    leftmost = find_leftmost(nums, target)\n    rightmost = find_rightmost(nums, target)\n    \n    return [leftmost, rightmost]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return (nums, target)\n\nassert f(*g()) == [1, 3]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\n    If target is not found in the array, return [-1, -1].\n    You must write an algorithm with O(log n) runtime complexity.\n    \n    Example:\n    Input: nums = [5,7,7,8,8,10], target = 8\n    Output: [3,4]\n    \"\"\"\n    def find_leftmost(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] == target:\n            return left\n        else:\n            return -1\n    \n    def find_rightmost(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        if nums[right] == target:\n            return right\n        else:\n            return -1\n    \n    leftmost = find_leftmost(nums, target)\n    rightmost = find_rightmost(nums, target)\n    \n    return [leftmost, rightmost]", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport heapq\nfrom typing import List, Tuple\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8], k = 3\n    Output: 8\n\n    Explanation:\n    The 3rd largest element in the list is 8.\n    \"\"\"\n\n    # Use a min-heap to keep track of the k largest elements\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    return heapq.heappop(heap)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 8\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 328, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nimport heapq\nfrom typing import List, Tuple\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8], k = 3\n    Output: 8\n\n    Explanation:\n    The 3rd largest element in the list is 8.\n    \"\"\"\n\n    # Use a min-heap to keep track of the k largest elements\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    return heapq.heappop(heap)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all numbers that can be obtained by bitwise OR-ing any subset of nums.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: 7\n\n    Explanation:\n    The possible subsets and their bitwise OR sums are:\n    - [1] -> 1\n    - [2] -> 2\n    - [3] -> 3\n    - [1, 2] -> 3\n    - [1, 3] -> 3\n    - [2, 3] -> 3\n    - [1, 2, 3] -> 3\n    The sum of all these numbers is 1 + 2 + 3 + 3 + 3 + 3 + 3 = 18.\n    \"\"\"\n\n    total_sum = 0\n    n = len(nums)\n\n    for i in range(1, (1 << n)):\n        subset_sum = 0\n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                subset_sum |= nums[j]\n        total_sum += subset_sum\n\n    return total_sum\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 18\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all numbers that can be obtained by bitwise OR-ing any subset of nums.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: 7\n\n    Explanation:\n    The possible subsets and their bitwise OR sums are:\n    - [1] -> 1\n    - [2] -> 2\n    - [3] -> 3\n    - [1, 2] -> 3\n    - [1, 3] -> 3\n    - [2, 3] -> 3\n    - [1, 2, 3] -> 3\n    The sum of all these numbers is 1 + 2 + 3 + 3 + 3 + 3 + 3 = 18.\n    \"\"\"\n\n    total_sum = 0\n    n = len(nums)\n\n    for i in range(1, (1 << n)):\n        subset_sum = 0\n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                subset_sum |= nums[j]\n        total_sum += subset_sum\n\n    return total_sum", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers 'arr' and an integer 'k', find if there exists a subarray of 'arr'\n    that has exactly 'k' elements and the sum of its elements is divisible by 'k'.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % k\n        count += prefix_sum_count.get(prefix_sum, 0)\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count >= 2\n\ndef g(arr: List[int] = [-2, 1, 4, -1, 2, -3], k: int = 3):\n    return arr\n\nassert f(g())\n", "emb": null, "idx_generation": 328, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers 'arr' and an integer 'k', find if there exists a subarray of 'arr'\n    that has exactly 'k' elements and the sum of its elements is divisible by 'k'.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % k\n        count += prefix_sum_count.get(prefix_sum, 0)\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count >= 2", "solution_func": "def g(arr: List[int] = [-2, 1, 4, -1, 2, -3], k: int = 3):\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a list of directed edges, represented as lists of two integers [u, v],\n    where u represents the source node and v represents the destination node,\n    find the indegree of each node in the graph and return a list containing\n    the indegree of each node.\n    \"\"\"\n    indegree = [0] * (len(edges) + 1)\n\n    for edge in edges:\n        indegree[edge[1]] += 1\n\n    return indegree\n\ndef g(edges: List[List[int]] = [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [4, 1]]):\n    return edges\n\nassert f(g())\n", "emb": null, "idx_generation": 328, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a list of directed edges, represented as lists of two integers [u, v],\n    where u represents the source node and v represents the destination node,\n    find the indegree of each node in the graph and return a list containing\n    the indegree of each node.\n    \"\"\"\n    indegree = [0] * (len(edges) + 1)\n\n    for edge in edges:\n        indegree[edge[1]] += 1\n\n    return indegree", "solution_func": "def g(edges: List[List[int]] = [[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [4, 1]]):\n    return edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string 's' and an integer 'k', find the number of substrings of 's'\n    that have exactly 'k' distinct characters.\n    \"\"\"\n    count = 0\n\n    for i in range(len(s)):\n        distinct_chars = set()\n        for j in range(i, len(s)):\n            distinct_chars.add(s[j])\n            if len(distinct_chars) == k:\n                count += 1\n            elif len(distinct_chars) > k:\n                break\n\n    return count\n\ndef g(s: str = \"abacab\", k: int = 2):\n    return s\n\nassert f(g())\n", "emb": null, "idx_generation": 328, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string 's' and an integer 'k', find the number of substrings of 's'\n    that have exactly 'k' distinct characters.\n    \"\"\"\n    count = 0\n\n    for i in range(len(s)):\n        distinct_chars = set()\n        for j in range(i, len(s)):\n            distinct_chars.add(s[j])\n            if len(distinct_chars) == k:\n                count += 1\n            elif len(distinct_chars) > k:\n                break\n\n    return count", "solution_func": "def g(s: str = \"abacab\", k: int = 2):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 4 and 10 add up to the target 14.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 328, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 4 and 10 add up to the target 14.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum size of a square submatrix that contains only 1s.\n\n    Example:\n    Input: matrix = [\n                      [1, 0, 1, 0, 0],\n                      [1, 0, 1, 1, 1],\n                      [1, 1, 1, 1, 1],\n                      [1, 0, 0, 1, 0]\n                    ]\n    Output: 4\n\n    Explanation: The largest square submatrix with only 1s is highlighted in the matrix above.\n\n    Note:\n    - The input matrix will be a binary matrix, consisting only of 0s and 1s.\n    - The maximum size of the input matrix is 300 x 300.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size ** 2\n\ndef g() -> List[List[int]]:\n    return [\n              [1, 0, 1, 0, 0],\n              [1, 0, 1, 1, 1],\n              [1, 1, 1, 1, 1],\n              [1, 0, 0, 1, 0]\n           ]\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum size of a square submatrix that contains only 1s.\n\n    Example:\n    Input: matrix = [\n                      [1, 0, 1, 0, 0],\n                      [1, 0, 1, 1, 1],\n                      [1, 1, 1, 1, 1],\n                      [1, 0, 0, 1, 0]\n                    ]\n    Output: 4\n\n    Explanation: The largest square submatrix with only 1s is highlighted in the matrix above.\n\n    Note:\n    - The input matrix will be a binary matrix, consisting only of 0s and 1s.\n    - The maximum size of the input matrix is 300 x 300.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size ** 2", "solution_func": "def g() -> List[List[int]]:\n    return [\n              [1, 0, 1, 0, 0],\n              [1, 0, 1, 1, 1],\n              [1, 1, 1, 1, 1],\n              [1, 0, 0, 1, 0]\n           ]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise XOR value of any two elements.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum bitwise XOR value is obtained by XORing 5 (binary 101) and 25 (binary 11001), which gives 28.\n\n    Note:\n    - The length of the input array is between 1 and 2 * 10^4.\n    - Each element in the input array is between 0 and 2^31 - 1.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        max_possible_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if max_possible_xor ^ prefix in prefix_set:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise XOR value of any two elements.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum bitwise XOR value is obtained by XORing 5 (binary 101) and 25 (binary 11001), which gives 28.\n\n    Note:\n    - The length of the input array is between 1 and 2 * 10^4.\n    - Each element in the input array is between 0 and 2^31 - 1.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        max_possible_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if max_possible_xor ^ prefix in prefix_set:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of different k-digits strings of length n.\n\n    Example:\n    Input: n = 3, k = 2\n    Output: 8\n\n    Explanation: There are 8 different 2-digits strings of length 3: 00, 01, 10, 11, 20, 21, 30, 31.\n\n    Note:\n    - The output should be returned modulo 10^9 + 7.\n    \"\"\"\n\n    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j] * (k - 1) + dp[i - 1][j - 1]) % MOD\n\n    return dp[n][k]\n\ndef g() -> Tuple[int, int]:\n    return (3, 2)\n\nassert f(*g()) == 8\n", "emb": null, "idx_generation": 329, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of different k-digits strings of length n.\n\n    Example:\n    Input: n = 3, k = 2\n    Output: 8\n\n    Explanation: There are 8 different 2-digits strings of length 3: 00, 01, 10, 11, 20, 21, 30, 31.\n\n    Note:\n    - The output should be returned modulo 10^9 + 7.\n    \"\"\"\n\n    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j] * (k - 1) + dp[i - 1][j - 1]) % MOD\n\n    return dp[n][k]", "solution_func": "def g() -> Tuple[int, int]:\n    return (3, 2)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the elevation of a terrain, find the maximum amount of water that can be trapped between the bars.\n    Each bar has a width of 1 unit.\n\n    Sample Input:\n    heights = [0,1,0,2,1,0,1,3,2,1,2,1]\n\n    Sample Output:\n    6\n\n    Explanation: The figure below represents the elevation map where 'X' indicates water being trapped.\n                 The total amount of water trapped is 6 units.\n\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n    \"\"\"\n\n    n = len(heights)\n    if n < 3:\n        return 0\n    \n    left_max = [0] * n\n    right_max = [0] * n\n\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    water = 0\n    for i in range(1, n-1):\n        min_height = min(left_max[i], right_max[i])\n        water += max(0, min_height - heights[i])\n\n    return water\n\ndef g() -> List[int]:\n    heights = [0,1,0,2,1,0,1,3,2,1,2,1]\n    return heights\n\nassert f(g()) == 6\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 329, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the elevation of a terrain, find the maximum amount of water that can be trapped between the bars.\n    Each bar has a width of 1 unit.\n\n    Sample Input:\n    heights = [0,1,0,2,1,0,1,3,2,1,2,1]\n\n    Sample Output:\n    6\n\n    Explanation: The figure below represents the elevation map where 'X' indicates water being trapped.\n                 The total amount of water trapped is 6 units.\n\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n    \"\"\"\n\n    n = len(heights)\n    if n < 3:\n        return 0\n    \n    left_max = [0] * n\n    right_max = [0] * n\n\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    water = 0\n    for i in range(1, n-1):\n        min_height = min(left_max[i], right_max[i])\n        water += max(0, min_height - heights[i])\n\n    return water", "solution_func": "def g() -> List[int]:\n    heights = [0,1,0,2,1,0,1,3,2,1,2,1]\n    return heights", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down, right, or diagonally lower-right.\n\n    Sample Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Sample Output:\n    7\n\n    Explanation: The minimum cost path is as follows:\n                 1 -> 3 -> 1 -> 1 -> 1 = 7.\n\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 329, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down, right, or diagonally lower-right.\n\n    Sample Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Sample Output:\n    7\n\n    Explanation: The minimum cost path is as follows:\n                 1 -> 3 -> 1 -> 1 -> 1 = 7.\n\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Sample Input:\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n\n    Sample Output:\n    6\n\n    Explanation: The contiguous subarray [4,-1,2,1] has the maximum sum of 6.\n\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    curr_sum = max_sum = nums[0]\n\n    for i in range(1, n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Sample Input:\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n\n    Sample Output:\n    6\n\n    Explanation: The contiguous subarray [4,-1,2,1] has the maximum sum of 6.\n\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    curr_sum = max_sum = nums[0]\n\n    for i in range(1, n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the longest path of consecutive 1s.\n    A consecutive path is defined as a path of 1s from one cell to another, where each cell is adjacent to its neighboring 1s (left, right, top, or bottom).\n    \"\"\"\n\n    def dfs(grid, i, j, length):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return length\n        grid[i][j] = 0\n        length += 1\n        length = max(length, dfs(grid, i + 1, j, length))\n        length = max(length, dfs(grid, i - 1, j, length))\n        length = max(length, dfs(grid, i, j + 1, length))\n        length = max(length, dfs(grid, i, j - 1, length))\n        return length\n\n    max_length = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_length = max(max_length, dfs(grid, i, j, 0))\n\n    return max_length\n\ndef g(grid=[[1, 1, 0, 1], [1, 0, 1, 0], [1, 1, 1, 1]]):\n    return grid\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 329, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the longest path of consecutive 1s.\n    A consecutive path is defined as a path of 1s from one cell to another, where each cell is adjacent to its neighboring 1s (left, right, top, or bottom).\n    \"\"\"\n\n    def dfs(grid, i, j, length):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return length\n        grid[i][j] = 0\n        length += 1\n        length = max(length, dfs(grid, i + 1, j, length))\n        length = max(length, dfs(grid, i - 1, j, length))\n        length = max(length, dfs(grid, i, j + 1, length))\n        length = max(length, dfs(grid, i, j - 1, length))\n        return length\n\n    max_length = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                max_length = max(max_length, dfs(grid, i, j, 0))\n\n    return max_length", "solution_func": "def g(grid=[[1, 1, 0, 1], [1, 0, 1, 0], [1, 1, 1, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, convert it into a new array where each element is the product of all the elements in the original array except itself.\n    The product of all the elements except the current element can be calculated by dividing the total product of all elements by the current element.\n    \"\"\"\n\n    n = len(nums)\n    result = [0] * n\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    for i in range(n):\n        result[i] = product // nums[i]\n\n    return result\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 329, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, convert it into a new array where each element is the product of all the elements in the original array except itself.\n    The product of all the elements except the current element can be calculated by dividing the total product of all elements by the current element.\n    \"\"\"\n\n    n = len(nums)\n    result = [0] * n\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    for i in range(n):\n        result[i] = product // nums[i]\n\n    return result", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square composed entirely of 1s.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    max_size = 0\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            elif grid[i][j] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n            max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size\n\ndef g(grid=[[1, 1, 0, 1], [1, 0, 1, 0], [1, 1, 1, 1]]):\n    return grid\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 329, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the size of the largest square composed entirely of 1s.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    max_size = 0\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            elif grid[i][j] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n            max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size", "solution_func": "def g(grid=[[1, 1, 0, 1], [1, 0, 1, 0], [1, 1, 1, 1]]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int, path: List[int] = []) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as a dictionary where the keys are the node numbers and the values\n    are lists of adjacent nodes, find a path from the start node to the end node.\n\n    Return the path as a list of node numbers.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [4],\n        3: [],\n        4: []\n    }\n    start = 0\n    end = 4\n    output: [0, 2, 4]\n    \"\"\"\n    path.append(start)\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            new_path = f(graph, node, end, path)\n            if new_path is not None:\n                return new_path\n    return None\n\ndef g(graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [], 4: []}, start = 0, end = 4):\n    return graph, start, end\n\nassert f(*g()) == [0, 2, 4]\n", "emb": null, "idx_generation": 329, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int, path: List[int] = []) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as a dictionary where the keys are the node numbers and the values\n    are lists of adjacent nodes, find a path from the start node to the end node.\n\n    Return the path as a list of node numbers.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [4],\n        3: [],\n        4: []\n    }\n    start = 0\n    end = 4\n    output: [0, 2, 4]\n    \"\"\"\n    path.append(start)\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            new_path = f(graph, node, end, path)\n            if new_path is not None:\n                return new_path\n    return None", "solution_func": "def g(graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [], 4: []}, start = 0, end = 4):\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the smallest subarray that has a sum greater than or equal to the target value.\n    Return the length of the subarray.\n\n    Example:\n    Input: nums = [1, 4, 3, 2, 6, 5], target = 10\n    Output: 2\n\n    Explanation:\n    The subarray [4, 3] has a sum of 7, which is the smallest subarray that has a sum greater than or equal to 10.\n    \"\"\"\n\n    left = 0\n    right = 0\n    min_len = float('inf')\n    curr_sum = 0\n\n    while right < len(nums):\n        curr_sum += nums[right]\n        right += 1\n\n        while curr_sum >= target:\n            min_len = min(min_len, right - left)\n            curr_sum -= nums[left]\n            left += 1\n\n    return min_len if min_len != float('inf') else 0\n\ndef g() -> List[int]:\n    return [1, 4, 3, 2, 6, 5], 10\n\nassert f(*g()) == 2\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 330, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the smallest subarray that has a sum greater than or equal to the target value.\n    Return the length of the subarray.\n\n    Example:\n    Input: nums = [1, 4, 3, 2, 6, 5], target = 10\n    Output: 2\n\n    Explanation:\n    The subarray [4, 3] has a sum of 7, which is the smallest subarray that has a sum greater than or equal to 10.\n    \"\"\"\n\n    left = 0\n    right = 0\n    min_len = float('inf')\n    curr_sum = 0\n\n    while right < len(nums):\n        curr_sum += nums[right]\n        right += 1\n\n        while curr_sum >= target:\n            min_len = min(min_len, right - left)\n            curr_sum -= nums[left]\n            left += 1\n\n    return min_len if min_len != float('inf') else 0", "solution_func": "def g() -> List[int]:\n    return [1, 4, 3, 2, 6, 5], 10", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subarray in the list with a sum divisible by k.\n    Return True if such a subarray exists, otherwise return False.\n\n    Example:\n    Input: nums = [4, 5, 3, 2, 8, 7], k = 6\n    Output: True\n\n    Explanation:\n    The subarray [5, 3, 2, 8] has a sum of 18, which is divisible by 6.\n    \"\"\"\n\n    prefix_sum = 0\n    mod = {0: -1}\n\n    for i in range(len(nums)):\n        prefix_sum = (prefix_sum + nums[i]) % k\n\n        if prefix_sum in mod:\n            if i - mod[prefix_sum] > 1:\n                return True\n        else:\n            mod[prefix_sum] = i\n\n    return False\n\ndef g() -> List[int]:\n    return [4, 5, 3, 2, 8, 7], 6\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subarray in the list with a sum divisible by k.\n    Return True if such a subarray exists, otherwise return False.\n\n    Example:\n    Input: nums = [4, 5, 3, 2, 8, 7], k = 6\n    Output: True\n\n    Explanation:\n    The subarray [5, 3, 2, 8] has a sum of 18, which is divisible by 6.\n    \"\"\"\n\n    prefix_sum = 0\n    mod = {0: -1}\n\n    for i in range(len(nums)):\n        prefix_sum = (prefix_sum + nums[i]) % k\n\n        if prefix_sum in mod:\n            if i - mod[prefix_sum] > 1:\n                return True\n        else:\n            mod[prefix_sum] = i\n\n    return False", "solution_func": "def g() -> List[int]:\n    return [4, 5, 3, 2, 8, 7], 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two non-overlapping subarrays such that the sum of the elements in each subarray is equal to the target value.\n    Return the indices of the starting and ending positions of the two subarrays.\n\n    Example:\n    Input: nums = [3, 4, 7, 2, 1, 2, 1, 4], target = 7\n    Output: [0, 4]\n\n    Explanation:\n    The subarrays [3, 4] and [1, 2, 1, 4] both have a sum of 7.\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sum_map = {0: -1}\n    result = []\n\n    for i in range(len(nums)):\n        prefix_sum += nums[i]\n\n        if prefix_sum - target in prefix_sum_map:\n            start = prefix_sum_map[prefix_sum - target] + 1\n            end = i\n            result.append([start, end])\n\n        prefix_sum_map[prefix_sum] = i\n\n    if len(result) < 2:\n        return []\n\n    result.sort(key=lambda x: x[1])\n\n    return [result[0][0], result[1][1]]\n\ndef g() -> List[int]:\n    return [3, 4, 7, 2, 1, 2, 1, 4], 7\n\nassert f(*g()) == [0, 4]\n", "emb": null, "idx_generation": 330, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two non-overlapping subarrays such that the sum of the elements in each subarray is equal to the target value.\n    Return the indices of the starting and ending positions of the two subarrays.\n\n    Example:\n    Input: nums = [3, 4, 7, 2, 1, 2, 1, 4], target = 7\n    Output: [0, 4]\n\n    Explanation:\n    The subarrays [3, 4] and [1, 2, 1, 4] both have a sum of 7.\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sum_map = {0: -1}\n    result = []\n\n    for i in range(len(nums)):\n        prefix_sum += nums[i]\n\n        if prefix_sum - target in prefix_sum_map:\n            start = prefix_sum_map[prefix_sum - target] + 1\n            end = i\n            result.append([start, end])\n\n        prefix_sum_map[prefix_sum] = i\n\n    if len(result) < 2:\n        return []\n\n    result.sort(key=lambda x: x[1])\n\n    return [result[0][0], result[1][1]]", "solution_func": "def g() -> List[int]:\n    return [3, 4, 7, 2, 1, 2, 1, 4], 7", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers as a list. You may assume that each input would have exactly one solution,\n    and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], because nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> (List[int], int):\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers as a list. You may assume that each input would have exactly one solution,\n    and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], because nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> (List[int], int):\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [1, 2],\n        [0, 2],\n        [0, 1, 3],\n        [2]\n    ]\n\n    The function should return True, because the graph contains a cycle (0 -> 1 -> 2 -> 0).\n    \"\"\"\n    def has_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [\n        [1, 2],\n        [0, 2],\n        [0, 1, 3],\n        [2]\n    ]\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [1, 2],\n        [0, 2],\n        [0, 1, 3],\n        [2]\n    ]\n\n    The function should return True, because the graph contains a cycle (0 -> 1 -> 2 -> 0).\n    \"\"\"\n    def has_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [1, 2],\n        [0, 2],\n        [0, 1, 3],\n        [2]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [0, 1, 0],\n        [1, 1, 1]\n    ]\n\n    The function should return 4, because the shortest path is 1 -> 1 -> 0 -> 1 -> 1 -> 1.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row > 0:\n                dp[row][col] = min(dp[row][col], dp[row-1][col] + grid[row][col])\n            if col > 0:\n                dp[row][col] = min(dp[row][col], dp[row][col-1] + grid[row][col])\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1],\n        [0, 1, 0],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 330, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [0, 1, 0],\n        [1, 1, 1]\n    ]\n\n    The function should return 4, because the shortest path is 1 -> 1 -> 0 -> 1 -> 1 -> 1.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for row in range(rows):\n        for col in range(cols):\n            if row > 0:\n                dp[row][col] = min(dp[row][col], dp[row-1][col] + grid[row][col])\n            if col > 0:\n                dp[row][col] = min(dp[row][col], dp[row][col-1] + grid[row][col])\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1],\n        [0, 1, 0],\n        [1, 1, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique subsets that XOR to 0.\n    Return the count.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 6\n    Explanation: The subsets that XOR to 0 are [1, 2, 3, 4, 5], [1, 4, 5], [2, 3], [2, 5], [3, 4], [1, 3, 4, 5].\n    \"\"\"\n    xor_sum = 0\n    count = 0\n    xor_counts = {0: 1}\n    \n    for num in nums:\n        xor_sum ^= num\n        count += xor_counts.get(xor_sum, 0)\n        xor_counts[xor_sum] = xor_counts.get(xor_sum, 0) + 1\n        \n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 330, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique subsets that XOR to 0.\n    Return the count.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 6\n    Explanation: The subsets that XOR to 0 are [1, 2, 3, 4, 5], [1, 4, 5], [2, 3], [2, 5], [3, 4], [1, 3, 4, 5].\n    \"\"\"\n    xor_sum = 0\n    count = 0\n    xor_counts = {0: 1}\n    \n    for num in nums:\n        xor_sum ^= num\n        count += xor_counts.get(xor_sum, 0)\n        xor_counts[xor_sum] = xor_counts.get(xor_sum, 0) + 1\n        \n    return count", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring.\n\n    Example:\n    Input: \"babad\"\n    Output: \"bab\"\n    Explanation: The longest palindromic substring in \"babad\" is \"bab\".\n    \"\"\"\n    if len(s) < 2:\n        return s\n    \n    start = 0\n    max_length = 1\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return left + 1, right - 1\n    \n    for i in range(len(s)):\n        left1, right1 = expand_around_center(i, i)\n        left2, right2 = expand_around_center(i, i + 1)\n        \n        if right1 - left1 + 1 > max_length:\n            start = left1\n            max_length = right1 - left1 + 1\n            \n        if right2 - left2 + 1 > max_length:\n            start = left2\n            max_length = right2 - left2 + 1\n            \n    return s[start:start + max_length]\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"babad\"\n\nassert f(g()) == \"bab\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 330, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring.\n\n    Example:\n    Input: \"babad\"\n    Output: \"bab\"\n    Explanation: The longest palindromic substring in \"babad\" is \"bab\".\n    \"\"\"\n    if len(s) < 2:\n        return s\n    \n    start = 0\n    max_length = 1\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return left + 1, right - 1\n    \n    for i in range(len(s)):\n        left1, right1 = expand_around_center(i, i)\n        left2, right2 = expand_around_center(i, i + 1)\n        \n        if right1 - left1 + 1 > max_length:\n            start = left1\n            max_length = right1 - left1 + 1\n            \n        if right2 - left2 + 1 > max_length:\n            start = left2\n            max_length = right2 - left2 + 1\n            \n    return s[start:start + max_length]", "solution_func": "def g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"babad\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of unique binary strings of length n\n    that do not contain consecutive ones.\n\n    Example:\n    Input: 4\n    Output: 8\n    Explanation: The unique binary strings of length 4 that do not contain consecutive ones are:\n    0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    ending_with_zero = 1\n    ending_with_one = 1\n    \n    for i in range(2, n + 1):\n        ending_with_zero, ending_with_one = ending_with_zero + ending_with_one, ending_with_zero\n    \n    return ending_with_zero + ending_with_one\n\ndef g():\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return 4\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 330, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of unique binary strings of length n\n    that do not contain consecutive ones.\n\n    Example:\n    Input: 4\n    Output: 8\n    Explanation: The unique binary strings of length 4 that do not contain consecutive ones are:\n    0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    ending_with_zero = 1\n    ending_with_one = 1\n    \n    for i in range(2, n + 1):\n        ending_with_zero, ending_with_one = ending_with_zero + ending_with_one, ending_with_zero\n    \n    return ending_with_zero + ending_with_one", "solution_func": "def g():\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return 4", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers at indices 0 and 1, i.e., 2 and 7, add up to the target value 9.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 330, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers at indices 0 and 1, i.e., 2 and 7, add up to the target value 9.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a subset of nums that XORs to 0.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: True (subset [1, 4, 5] XORs to 0)\n\n    Hint: Use bit manipulation and dynamic programming to find the subset with XOR 0.\n    \"\"\"\n    total_xor = 0\n    for num in nums:\n        total_xor ^= num\n\n    if total_xor == 0:\n        return True\n\n    n = len(nums)\n    dp = [[False] * (total_xor + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(total_xor + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][total_xor]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 331, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a subset of nums that XORs to 0.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: True (subset [1, 4, 5] XORs to 0)\n\n    Hint: Use bit manipulation and dynamic programming to find the subset with XOR 0.\n    \"\"\"\n    total_xor = 0\n    for num in nums:\n        total_xor ^= num\n\n    if total_xor == 0:\n        return True\n\n    n = len(nums)\n    dp = [[False] * (total_xor + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(total_xor + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][total_xor]", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 7 (3 ^ 4 = 7)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root: TrieNode, num: int):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root: TrieNode, num: int) -> int:\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor_val |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor_val\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 331, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 7 (3 ^ 4 = 7)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root: TrieNode, num: int):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root: TrieNode, num: int) -> int:\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor_val |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor_val\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 1s and 0s, find the minimum number of steps required to transform all the 1s into 0s.\n    Each step involves flipping a cell and all its adjacent cells (up, down, left, right).\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0]\n    ]\n    Output:\n    3\n\n    Hint: Use BFS with a queue to find the minimum number of steps.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n\n    if len(queue) == 0:\n        return 0\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    min_steps = float('inf')\n\n    while queue:\n        row, col, steps = queue.pop(0)\n\n        grid[row][col] = 0\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:\n                queue.append((new_row, new_col, steps + 1))\n                min_steps = min(min_steps, steps + 1)\n\n    return min_steps\n\ndef g():\n    return [\n        [1, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0]\n    ]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 331, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 1s and 0s, find the minimum number of steps required to transform all the 1s into 0s.\n    Each step involves flipping a cell and all its adjacent cells (up, down, left, right).\n\n    Example:\n    Input:\n    grid = [\n        [1, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0]\n    ]\n    Output:\n    3\n\n    Hint: Use BFS with a queue to find the minimum number of steps.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    queue = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n\n    if len(queue) == 0:\n        return 0\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    min_steps = float('inf')\n\n    while queue:\n        row, col, steps = queue.pop(0)\n\n        grid[row][col] = 0\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:\n                queue.append((new_row, new_col, steps + 1))\n                min_steps = min(min_steps, steps + 1)\n\n    return min_steps", "solution_func": "def g():\n    return [\n        [1, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], target: str) -> bool:\n    \"\"\"\n    Given a graph and a target string, determine if there is a path in the graph that spells out the target string.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    def dfs(node: int, visited: set, path: str) -> bool:\n        if path == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + str(neighbor)):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(len(graph)):\n        visited = set()\n        if dfs(i, visited, str(i)):\n            return True\n    return False\n\ndef g(target: str):\n    \"\"\"\n    Generate a graph that spells out the target string.\n    \"\"\"\n    n = len(target)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if target[j] == target[i]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph\n\nassert f(g(\"hello\")) == True\n\n", "emb": null, "idx_generation": 331, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], target: str) -> bool:\n    \"\"\"\n    Given a graph and a target string, determine if there is a path in the graph that spells out the target string.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    def dfs(node: int, visited: set, path: str) -> bool:\n        if path == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + str(neighbor)):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(len(graph)):\n        visited = set()\n        if dfs(i, visited, str(i)):\n            return True\n    return False", "solution_func": "def g(target: str):\n    \"\"\"\n    Generate a graph that spells out the target string.\n    \"\"\"\n    n = len(target)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if target[j] == target[i]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], word: str) -> bool:\n    \"\"\"\n    Given a graph and a word, determine if the word can be formed by traversing the graph.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    def dfs(node: int, visited: set, path: str) -> bool:\n        if path == word:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + str(neighbor)):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(len(graph)):\n        visited = set()\n        if dfs(i, visited, str(i)):\n            return True\n    return False\n\ndef g(word: str):\n    \"\"\"\n    Generate a graph that can spell out the word.\n    \"\"\"\n    n = len(word)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if word[j] == word[i]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph\n\nassert f(g(\"python\")) == True\n\n", "emb": null, "idx_generation": 331, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], word: str) -> bool:\n    \"\"\"\n    Given a graph and a word, determine if the word can be formed by traversing the graph.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    def dfs(node: int, visited: set, path: str) -> bool:\n        if path == word:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + str(neighbor)):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(len(graph)):\n        visited = set()\n        if dfs(i, visited, str(i)):\n            return True\n    return False", "solution_func": "def g(word: str):\n    \"\"\"\n    Generate a graph that can spell out the word.\n    \"\"\"\n    n = len(word)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if word[j] == word[i]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], word: str) -> bool:\n    \"\"\"\n    Given a graph and a word, determine if the word can be formed by traversing the graph.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    def dfs(node: int, visited: set, path: str) -> bool:\n        if len(path) > len(word):\n            return False\n        if path == word:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + str(neighbor)):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(len(graph)):\n        visited = set()\n        if dfs(i, visited, str(i)):\n            return True\n    return False\n\ndef g(word: str):\n    \"\"\"\n    Generate a graph that can spell out the word.\n    \"\"\"\n    n = len(word)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if word[j] == word[i]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph\n\nassert f(g(\"programming\")) == True\n\n", "emb": null, "idx_generation": 331, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], word: str) -> bool:\n    \"\"\"\n    Given a graph and a word, determine if the word can be formed by traversing the graph.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    def dfs(node: int, visited: set, path: str) -> bool:\n        if len(path) > len(word):\n            return False\n        if path == word:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + str(neighbor)):\n                    return True\n        visited.remove(node)\n        return False\n    \n    for i in range(len(graph)):\n        visited = set()\n        if dfs(i, visited, str(i)):\n            return True\n    return False", "solution_func": "def g(word: str):\n    \"\"\"\n    Generate a graph that can spell out the word.\n    \"\"\"\n    n = len(word)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if word[j] == word[i]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique strings of length n that can be formed using the characters 'a', 'b', and 'c', such that no two adjacent characters are the same and the string does not contain more than k consecutive occurrences of any character.\n\n    Example:\n    Input: n = 3, k = 1\n    Output: 18\n    Explanation: The valid strings are: \"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\".\n\n    Hint: Use recursion with dynamic programming to count the number of valid strings.\n    \"\"\"\n\n    def count_strings(length: int, prev_char: str, consec_count: int, memo: Dict[Tuple[int, str, int], int]) -> int:\n        if length == 0:\n            return 1\n        \n        if (length, prev_char, consec_count) in memo:\n            return memo[(length, prev_char, consec_count)]\n        \n        count = 0\n        for char in ['a', 'b', 'c']:\n            if char != prev_char and consec_count < k:\n                count += count_strings(length - 1, char, consec_count + 1, memo)\n            elif char != prev_char:\n                count += count_strings(length - 1, char, 1, memo)\n        \n        memo[(length, prev_char, consec_count)] = count\n        return count\n    \n    memo = {}\n    return count_strings(n, '', 0, memo)\n\ndef g():\n    return 3, 1\n\nassert f(*g()) == 18\n", "emb": null, "idx_generation": 331, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique strings of length n that can be formed using the characters 'a', 'b', and 'c', such that no two adjacent characters are the same and the string does not contain more than k consecutive occurrences of any character.\n\n    Example:\n    Input: n = 3, k = 1\n    Output: 18\n    Explanation: The valid strings are: \"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\".\n\n    Hint: Use recursion with dynamic programming to count the number of valid strings.\n    \"\"\"\n\n    def count_strings(length: int, prev_char: str, consec_count: int, memo: Dict[Tuple[int, str, int], int]) -> int:\n        if length == 0:\n            return 1\n        \n        if (length, prev_char, consec_count) in memo:\n            return memo[(length, prev_char, consec_count)]\n        \n        count = 0\n        for char in ['a', 'b', 'c']:\n            if char != prev_char and consec_count < k:\n                count += count_strings(length - 1, char, consec_count + 1, memo)\n            elif char != prev_char:\n                count += count_strings(length - 1, char, 1, memo)\n        \n        memo[(length, prev_char, consec_count)] = count\n        return count\n    \n    memo = {}\n    return count_strings(n, '', 0, memo)", "solution_func": "def g():\n    return 3, 1", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, return a string representing the n-th row of Pascal's Triangle.\n\n    Example:\n    Input: n = 5\n    Output: \"1 4 6 4 1\"\n\n    Hint: Use recursion to calculate each element of Pascal's Triangle.\n    \"\"\"\n\n    def pascal_triangle_row(row: int, memo: Dict[Tuple[int, int], int]) -> List[int]:\n        if row == 0:\n            return [1]\n        \n        if row == 1:\n            return [1, 1]\n        \n        if row in memo:\n            return memo[row]\n        \n        prev_row = pascal_triangle_row(row - 1, memo)\n        curr_row = [1]\n        for i in range(len(prev_row) - 1):\n            curr_row.append(prev_row[i] + prev_row[i+1])\n        curr_row.append(1)\n        \n        memo[row] = curr_row\n        return curr_row\n    \n    row = pascal_triangle_row(n, {})\n    return ' '.join([str(num) for num in row])\n\ndef g():\n    return 5\n\nassert f(*g()) == \"1 4 6 4 1\"\n", "emb": null, "idx_generation": 331, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, return a string representing the n-th row of Pascal's Triangle.\n\n    Example:\n    Input: n = 5\n    Output: \"1 4 6 4 1\"\n\n    Hint: Use recursion to calculate each element of Pascal's Triangle.\n    \"\"\"\n\n    def pascal_triangle_row(row: int, memo: Dict[Tuple[int, int], int]) -> List[int]:\n        if row == 0:\n            return [1]\n        \n        if row == 1:\n            return [1, 1]\n        \n        if row in memo:\n            return memo[row]\n        \n        prev_row = pascal_triangle_row(row - 1, memo)\n        curr_row = [1]\n        for i in range(len(prev_row) - 1):\n            curr_row.append(prev_row[i] + prev_row[i+1])\n        curr_row.append(1)\n        \n        memo[row] = curr_row\n        return curr_row\n    \n    row = pascal_triangle_row(n, {})\n    return ' '.join([str(num) for num in row])", "solution_func": "def g():\n    return 5", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of size m x n, find the maximum length of a square subgrid that contains only 1's.\n\n    Example:\n    Input: grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Hint: Use dynamic programming to calculate the maximum length of the square subgrid.\n    \"\"\"\n    \n    m = len(grid)\n    n = len(grid[0])\n    \n    max_length = 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_length = max(max_length, dp[i][j])\n    \n    return max_length\n\ndef g():\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 331, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of size m x n, find the maximum length of a square subgrid that contains only 1's.\n\n    Example:\n    Input: grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Hint: Use dynamic programming to calculate the maximum length of the square subgrid.\n    \"\"\"\n    \n    m = len(grid)\n    n = len(grid[0])\n    \n    max_length = 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_length = max(max_length, dp[i][j])\n    \n    return max_length", "solution_func": "def g():\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that multiply to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that multiply to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        product = numbers[left] * numbers[right]\n        if product == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif product < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 80\n    substring = \"10\"\n    return numbers, target, substring\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 331, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that multiply to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that multiply to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        product = numbers[left] * numbers[right]\n        if product == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif product < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 80\n    substring = \"10\"\n    return numbers, target, substring", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) such that a XOR b is equal to a + b.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 3\n\n    Explanation: The distinct pairs are (1, 2), (2, 1), and (4, 4), which give the XOR values equal to the sum of the pair.\n\n    Hint: Use two nested loops to iterate through all possible pairs and count the ones that satisfy the condition.\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) == (nums[i] + nums[j]):\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 332, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) such that a XOR b is equal to a + b.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 3\n\n    Explanation: The distinct pairs are (1, 2), (2, 1), and (4, 4), which give the XOR values equal to the sum of the pair.\n\n    Hint: Use two nested loops to iterate through all possible pairs and count the ones that satisfy the condition.\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) == (nums[i] + nums[j]):\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: [10, 20, 30, 40, 50]\n    Output: 62\n\n    Explanation: The maximum XOR value is achieved by combining 50 (binary: 110010) and 20 (binary: 010100), which results in 62 (binary: 111110).\n\n    Hint: Utilize the property that XOR is maximized when the bits at each position are maximally different.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    return [10, 20, 30, 40, 50]\n\nassert f(g()) == 62\n\n", "emb": null, "idx_generation": 332, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: [10, 20, 30, 40, 50]\n    Output: 62\n\n    Explanation: The maximum XOR value is achieved by combining 50 (binary: 110010) and 20 (binary: 010100), which results in 62 (binary: 111110).\n\n    Hint: Utilize the property that XOR is maximized when the bits at each position are maximally different.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [10, 20, 30, 40, 50]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest substring that contains only unique characters.\n\n    Example:\n    Input: \"aabccdefgh\"\n    Output: \"cdefgh\"\n\n    Explanation: The longest substring with unique characters is \"cdefgh\".\n\n    Hint: Use a sliding window approach to find the longest substring.\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    return s[start:start + max_length]\n\ndef g() -> str:\n    return \"aabccdefgh\"\n\nassert f(g()) == \"cdefgh\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest substring that contains only unique characters.\n\n    Example:\n    Input: \"aabccdefgh\"\n    Output: \"cdefgh\"\n\n    Explanation: The longest substring with unique characters is \"cdefgh\".\n\n    Hint: Use a sliding window approach to find the longest substring.\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    return s[start:start + max_length]", "solution_func": "def g() -> str:\n    return \"aabccdefgh\"", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums, and a target value, find the index of the target in the list using binary search.\n    If the target is not found in the list, return -1.\n\n    Example:\n    Input: nums = [-2, 0, 5, 9, 12, 15], target = 9\n    Output: 3 (The target value 9 is found at index 3)\n\n    Hint: Use the binary search algorithm to divide the search space in half at each step.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [-2, 0, 5, 9, 12, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums, and a target value, find the index of the target in the list using binary search.\n    If the target is not found in the list, return -1.\n\n    Example:\n    Input: nums = [-2, 0, 5, 9, 12, 15], target = 9\n    Output: 3 (The target value 9 is found at index 3)\n\n    Hint: Use the binary search algorithm to divide the search space in half at each step.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g():\n    nums = [-2, 0, 5, 9, 12, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, rotate the list to the right by k steps.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3\n    Output: [5, 6, 7, 1, 2, 3, 4]\n\n    Hint: Use the concept of cyclic rotations and modular arithmetic to optimize the solution.\n    \"\"\"\n    n = len(nums)\n    k %= n\n    nums[:] = nums[n-k:] + nums[:n-k]\n    return nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [5, 6, 7, 1, 2, 3, 4]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, rotate the list to the right by k steps.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3\n    Output: [5, 6, 7, 1, 2, 3, 4]\n\n    Hint: Use the concept of cyclic rotations and modular arithmetic to optimize the solution.\n    \"\"\"\n    n = len(nums)\n    k %= n\n    nums[:] = nums[n-k:] + nums[:n-k]\n    return nums", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number that appears only once in the list.\n    All other numbers in the list appear exactly twice.\n\n    Example:\n    Input: [2, 4, 6, 4, 2]\n    Output: 6 (The number 6 appears only once, while all other numbers appear twice)\n\n    Hint: Use the concept of bitwise XOR to find the number that appears only once.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    nums = [2, 4, 6, 4, 2]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number that appears only once in the list.\n    All other numbers in the list appear exactly twice.\n\n    Example:\n    Input: [2, 4, 6, 4, 2]\n    Output: 6 (The number 6 appears only once, while all other numbers appear twice)\n\n    Hint: Use the concept of bitwise XOR to find the number that appears only once.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "solution_func": "def g():\n    nums = [2, 4, 6, 4, 2]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a pattern and a list of words, return a new list containing only the words that match the pattern.\n    In the pattern, each letter represents a unique character in a word, and each word in the list\n    should have the same pattern as the given pattern.\n\n    Example:\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"aba\"\n\n    The pattern \"aba\" corresponds to the words [\"abc\", \"jkl\"].\n    Therefore, the function should return [\"abc\", \"jkl\"].\n    \"\"\"\n    def match_pattern(word, pattern):\n        if len(word) != len(pattern):\n            return False\n\n        char_map = {}\n        for i in range(len(word)):\n            if pattern[i] in char_map:\n                if char_map[pattern[i]] != word[i]:\n                    return False\n            else:\n                char_map[pattern[i]] = word[i]\n\n        return True\n\n    return [word for word in words if match_pattern(word, pattern)]\n\n\ndef g() -> (List[str], str):\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"aba\"\n    return words, pattern\n\n\nassert f(*g()) == [\"abc\", \"jkl\"]\n", "emb": null, "idx_generation": 332, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a pattern and a list of words, return a new list containing only the words that match the pattern.\n    In the pattern, each letter represents a unique character in a word, and each word in the list\n    should have the same pattern as the given pattern.\n\n    Example:\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"aba\"\n\n    The pattern \"aba\" corresponds to the words [\"abc\", \"jkl\"].\n    Therefore, the function should return [\"abc\", \"jkl\"].\n    \"\"\"\n    def match_pattern(word, pattern):\n        if len(word) != len(pattern):\n            return False\n\n        char_map = {}\n        for i in range(len(word)):\n            if pattern[i] in char_map:\n                if char_map[pattern[i]] != word[i]:\n                    return False\n            else:\n                char_map[pattern[i]] = word[i]\n\n        return True\n\n    return [word for word in words if match_pattern(word, pattern)]", "solution_func": "def g() -> (List[str], str):\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    pattern = \"aba\"\n    return words, pattern", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    by only moving down or right. The path can only traverse cells with a value of 1.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    There exists a path from (0, 0) to (3, 3): [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)].\n\n    Therefore, the function should return True.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        if i < m - 1 and grid[i + 1][j] == 1:\n            if dfs(i + 1, j):\n                return True\n\n        if j < n - 1 and grid[i][j + 1] == 1:\n            if dfs(i, j + 1):\n                return True\n\n        return False\n\n    return dfs(0, 0)\n\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return grid\n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    by only moving down or right. The path can only traverse cells with a value of 1.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    There exists a path from (0, 0) to (3, 3): [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)].\n\n    Therefore, the function should return True.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        if i < m - 1 and grid[i + 1][j] == 1:\n            if dfs(i + 1, j):\n                return True\n\n        if j < n - 1 and grid[i][j + 1] == 1:\n            if dfs(i, j + 1):\n                return True\n\n        return False\n\n    return dfs(0, 0)", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(pattern: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a pattern and a list of words, return a new list containing only the words that match the pattern.\n    In the pattern, each letter represents a unique character in a word, and each word in the list\n    should have the same pattern as the given pattern.\n\n    Example:\n    pattern = \"aba\"\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n\n    The pattern \"aba\" corresponds to the words [\"abc\", \"jkl\"].\n    Therefore, the function should return [\"abc\", \"jkl\"].\n    \"\"\"\n    def match_pattern(word, pattern):\n        if len(word) != len(pattern):\n            return False\n\n        char_map = {}\n        for i in range(len(word)):\n            if pattern[i] in char_map:\n                if char_map[pattern[i]] != word[i]:\n                    return False\n            else:\n                char_map[pattern[i]] = word[i]\n\n        return True\n\n    return [word for word in words if match_pattern(word, pattern)]\n\n\ndef g() -> (str, List[str]):\n    pattern = \"aba\"\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    return pattern, words\n\n\nassert f(*g()) == [\"abc\", \"jkl\"]\n", "emb": null, "idx_generation": 332, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(pattern: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a pattern and a list of words, return a new list containing only the words that match the pattern.\n    In the pattern, each letter represents a unique character in a word, and each word in the list\n    should have the same pattern as the given pattern.\n\n    Example:\n    pattern = \"aba\"\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n\n    The pattern \"aba\" corresponds to the words [\"abc\", \"jkl\"].\n    Therefore, the function should return [\"abc\", \"jkl\"].\n    \"\"\"\n    def match_pattern(word, pattern):\n        if len(word) != len(pattern):\n            return False\n\n        char_map = {}\n        for i in range(len(word)):\n            if pattern[i] in char_map:\n                if char_map[pattern[i]] != word[i]:\n                    return False\n            else:\n                char_map[pattern[i]] = word[i]\n\n        return True\n\n    return [word for word in words if match_pattern(word, pattern)]", "solution_func": "def g() -> (str, List[str]):\n    pattern = \"aba\"\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\"]\n    return pattern, words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers that add up to the target value.\n\n    Example:\n    f([1, 2, 3, 4, 5], 8) -> [2, 4]\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where two numbers in the list add up to the target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 8)\n\nassert f(*g()) == [2, 4]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 332, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target value.\n\n    Returns:\n    - A list of two integers representing the indices of the two numbers that add up to the target value.\n\n    Example:\n    f([1, 2, 3, 4, 5], 8) -> [2, 4]\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where two numbers in the list add up to the target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 8)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a contiguous subarray.\n    \"\"\"\n    max_prod = float('-inf')\n    curr_prod = 1\n    for num in nums:\n        curr_prod *= num\n        max_prod = max(max_prod, curr_prod)\n        if curr_prod == 0:\n            curr_prod = 1\n    return max_prod\n\ndef g(nums=[1, -2, 3, -4, 5, -6, 7]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == 5040\n", "emb": null, "idx_generation": 333, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a contiguous subarray.\n    \"\"\"\n    max_prod = float('-inf')\n    curr_prod = 1\n    for num in nums:\n        curr_prod *= num\n        max_prod = max(max_prod, curr_prod)\n        if curr_prod == 0:\n            curr_prod = 1\n    return max_prod", "solution_func": "def g(nums=[1, -2, 3, -4, 5, -6, 7]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers except itself.\n    \"\"\"\n    n = len(nums)\n    left_prod = [1] * n\n    right_prod = [1] * n\n    output = [0] * n\n    \n    for i in range(1, n):\n        left_prod[i] = left_prod[i-1] * nums[i-1]\n        \n    for i in range(n-2, -1, -1):\n        right_prod[i] = right_prod[i+1] * nums[i+1]\n        \n    for i in range(n):\n        output[i] = left_prod[i] * right_prod[i]\n    \n    return output\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers except itself.\n    \"\"\"\n    n = len(nums)\n    left_prod = [1] * n\n    right_prod = [1] * n\n    output = [0] * n\n    \n    for i in range(1, n):\n        left_prod[i] = left_prod[i-1] * nums[i-1]\n        \n    for i in range(n-2, -1, -1):\n        right_prod[i] = right_prod[i+1] * nums[i+1]\n        \n    for i in range(n):\n        output[i] = left_prod[i] * right_prod[i]\n    \n    return output", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    The 2nd largest element in the list is 5.\n    Therefore, the function should return 5.\n    \"\"\"\n\n    nums.sort(reverse=True)\n    return nums[k-1]\n\ndef g():\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    return [nums, k]\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    The 2nd largest element in the list is 5.\n    Therefore, the function should return 5.\n    \"\"\"\n\n    nums.sort(reverse=True)\n    return nums[k-1]", "solution_func": "def g():\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    return [nums, k]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, generate all possible permutations of the characters in the string and return them as a list.\n\n    Example:\n    s = \"abc\"\n\n    The possible permutations of the characters 'a', 'b', and 'c' are:\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n    Therefore, the function should return ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'].\n    \"\"\"\n\n    def backtrack(start, end):\n        if start == end:\n            res.append(\"\".join(s))\n        else:\n            for i in range(start, end):\n                s[start], s[i] = s[i], s[start]\n                backtrack(start + 1, end)\n                s[start], s[i] = s[i], s[start]\n\n    s = list(s)\n    res = []\n    backtrack(0, len(s))\n    return res\n\ndef g():\n    return \"abc\"\n\nassert f(*g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n\n", "emb": null, "idx_generation": 333, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, generate all possible permutations of the characters in the string and return them as a list.\n\n    Example:\n    s = \"abc\"\n\n    The possible permutations of the characters 'a', 'b', and 'c' are:\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n    Therefore, the function should return ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'].\n    \"\"\"\n\n    def backtrack(start, end):\n        if start == end:\n            res.append(\"\".join(s))\n        else:\n            for i in range(start, end):\n                s[start], s[i] = s[i], s[start]\n                backtrack(start + 1, end)\n                s[start], s[i] = s[i], s[start]\n\n    s = list(s)\n    res = []\n    backtrack(0, len(s))\n    return res", "solution_func": "def g():\n    return \"abc\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence in the list and return its length.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in the list is [2, 3, 7, 101],\n    therefore the function should return 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return [nums]\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence in the list and return its length.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in the list is [2, 3, 7, 101],\n    therefore the function should return 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return [nums]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n\n    The target value 5 is located at index 4 in the list nums, so the function should return 4.\n\n    Note:\n    - The input list will be sorted in ascending order.\n    - If the target value is not found in the list, the function should return -1.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n\n    The target value 5 is located at index 4 in the list nums, so the function should return 4.\n\n    Note:\n    - The input list will be sorted in ascending order.\n    - If the target value is not found in the list, the function should return -1.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the number of connected components in the graph.\n\n    Example:\n    graph = [\n        [1],\n        [0, 2],\n        [1],\n        [4],\n        [3]\n    ]\n\n    The graph has 2 connected components: {0, 1, 2} and {3, 4}. So the function should return 2.\n\n    Note:\n    - The graph will be given as a list of lists, where each inner list represents the neighbors of a given node.\n    - The nodes will be labeled from 0 to n-1, where n is the number of nodes in the graph.\n    \"\"\"\n\n    def dfs(node):\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    visited = set()\n    components = 0\n\n    for node in range(len(graph)):\n        if node not in visited:\n            dfs(node)\n            components += 1\n\n    return components\n\ndef g() -> List[List[int]]:\n    graph = [\n        [1],\n        [0, 2],\n        [1],\n        [4],\n        [3]\n    ]\n    return graph\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 333, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the number of connected components in the graph.\n\n    Example:\n    graph = [\n        [1],\n        [0, 2],\n        [1],\n        [4],\n        [3]\n    ]\n\n    The graph has 2 connected components: {0, 1, 2} and {3, 4}. So the function should return 2.\n\n    Note:\n    - The graph will be given as a list of lists, where each inner list represents the neighbors of a given node.\n    - The nodes will be labeled from 0 to n-1, where n is the number of nodes in the graph.\n    \"\"\"\n\n    def dfs(node):\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    visited = set()\n    components = 0\n\n    for node in range(len(graph)):\n        if node not in visited:\n            dfs(node)\n            components += 1\n\n    return components", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [1],\n        [0, 2],\n        [1],\n        [4],\n        [3]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the sum of all elements in the subgrid is less than or equal to a given target sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 15\n\n    The maximum sum of a subgrid where the sum is less than or equal to 15 is 14, which can be achieved by selecting the subgrid [[1, 2], [4, 5]].\n\n    Therefore, the function should return 14.\n\n    Note:\n    - The grid will be given as a list of lists, where each inner list represents a row of the grid.\n    - The target sum will be a positive integer.\n    \"\"\"\n\n    def get_subgrid_sum(subgrid):\n        return sum(sum(row) for row in subgrid)\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid = [row[j:l+1] for row in grid[i:k+1]]\n                    subgrid_sum = get_subgrid_sum(subgrid)\n                    \n                    if subgrid_sum <= target:\n                        max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> Tuple[List[List[int]], int]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 15\n    return grid, target\n\nassert f(*g()) == 14\n", "emb": null, "idx_generation": 333, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the sum of all elements in the subgrid is less than or equal to a given target sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 15\n\n    The maximum sum of a subgrid where the sum is less than or equal to 15 is 14, which can be achieved by selecting the subgrid [[1, 2], [4, 5]].\n\n    Therefore, the function should return 14.\n\n    Note:\n    - The grid will be given as a list of lists, where each inner list represents a row of the grid.\n    - The target sum will be a positive integer.\n    \"\"\"\n\n    def get_subgrid_sum(subgrid):\n        return sum(sum(row) for row in subgrid)\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid = [row[j:l+1] for row in grid[i:k+1]]\n                    subgrid_sum = get_subgrid_sum(subgrid)\n                    \n                    if subgrid_sum <= target:\n                        max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g() -> Tuple[List[List[int]], int]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 15\n    return grid, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, target: int) -> bool:\n    \"\"\"\n    Given a list of positive integers, find if there exists a subset whose sum is equal to the target value.\n\n    Example:\n    n = 5\n    target = 9\n    lst = [2, 4, 6, 8, 10]\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 4, 8] has a sum of 14, which is equal to the target value 9.\n    \"\"\"\n\n    def subset_sum(lst, target, subset):\n        if target == 0:\n            return True\n        if len(lst) == 0:\n            return False\n        if lst[0] > target:\n            return subset_sum(lst[1:], target, subset)\n        return subset_sum(lst[1:], target, subset) or subset_sum(lst[1:], target - lst[0], subset + [lst[0]])\n\n    return subset_sum(lst, target, [])\n\ndef g():\n    n = 5\n    target = 9\n    lst = [2, 4, 6, 8, 10]\n    return n, target, lst\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 333, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, target: int) -> bool:\n    \"\"\"\n    Given a list of positive integers, find if there exists a subset whose sum is equal to the target value.\n\n    Example:\n    n = 5\n    target = 9\n    lst = [2, 4, 6, 8, 10]\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 4, 8] has a sum of 14, which is equal to the target value 9.\n    \"\"\"\n\n    def subset_sum(lst, target, subset):\n        if target == 0:\n            return True\n        if len(lst) == 0:\n            return False\n        if lst[0] > target:\n            return subset_sum(lst[1:], target, subset)\n        return subset_sum(lst[1:], target, subset) or subset_sum(lst[1:], target - lst[0], subset + [lst[0]])\n\n    return subset_sum(lst, target, [])", "solution_func": "def g():\n    n = 5\n    target = 9\n    lst = [2, 4, 6, 8, 10]\n    return n, target, lst", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that sum up to a target value.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] = 2 and nums[1] = 7 is equal to the target value 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    def two_sum(nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            curr_sum = nums[left] + nums[right]\n            if curr_sum == target:\n                return [left, right]\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return []\n\n    return two_sum(nums, target)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where the sum of two numbers in the list is equal to the target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that sum up to a target value.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] = 2 and nums[1] = 7 is equal to the target value 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    def two_sum(nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            curr_sum = nums[left] + nums[right]\n            if curr_sum == target:\n                return [left, right]\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return []\n\n    return two_sum(nums, target)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where the sum of two numbers in the list is equal to the target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs whose XOR value is equal to the target value.\n    Return the count of such pairs.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 3\n    Output: 2\n\n    Explanation:\n    The XOR value of pairs (1, 2) and (2, 1) is equal to the target value 3.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def count_xor_pairs(nums, target):\n        count = 0\n        xor_pairs = set()\n\n        for num in nums:\n            if num ^ target in xor_pairs:\n                count += 1\n            xor_pairs.add(num)\n\n        return count\n\n    return count_xor_pairs(nums, target)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value where the number of pairs whose XOR value is equal to the target value is greater than 0.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 334, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs whose XOR value is equal to the target value.\n    Return the count of such pairs.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 3\n    Output: 2\n\n    Explanation:\n    The XOR value of pairs (1, 2) and (2, 1) is equal to the target value 3.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def count_xor_pairs(nums, target):\n        count = 0\n        xor_pairs = set()\n\n        for num in nums:\n            if num ^ target in xor_pairs:\n                count += 1\n            xor_pairs.add(num)\n\n        return count\n\n    return count_xor_pairs(nums, target)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value where the number of pairs whose XOR value is equal to the target value is greater than 0.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose XOR value is equal to the target value.\n    Return the count of such subsets.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 0\n    Output: 4\n\n    Explanation:\n    The XOR value of subsets [1], [2], [3], and [] is equal to the target value 0.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    def count_xor_subsets(nums, target):\n        count = 0\n        xor_subsets = set([0])\n\n        for num in nums:\n            xor_subsets |= {subset ^ num for subset in xor_subsets}\n\n        for subset in xor_subsets:\n            if subset == target:\n                count += 1\n\n        return count\n\n    return count_xor_subsets(nums, target)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value where the number of subsets whose XOR value is equal to the target value is greater than 0.\n    \"\"\"\n    return [1, 2, 3], 0\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 334, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose XOR value is equal to the target value.\n    Return the count of such subsets.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 0\n    Output: 4\n\n    Explanation:\n    The XOR value of subsets [1], [2], [3], and [] is equal to the target value 0.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    def count_xor_subsets(nums, target):\n        count = 0\n        xor_subsets = set([0])\n\n        for num in nums:\n            xor_subsets |= {subset ^ num for subset in xor_subsets}\n\n        for subset in xor_subsets:\n            if subset == target:\n                count += 1\n\n        return count\n\n    return count_xor_subsets(nums, target)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value where the number of subsets whose XOR value is equal to the target value is greater than 0.\n    \"\"\"\n    return [1, 2, 3], 0", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list.\n\n    Args:\n        arr: A sorted list of integers.\n        target: The target value to search for.\n\n    Returns:\n        The number of occurrences of the target value in the list.\n\n    Example:\n        Input: arr = [1, 2, 2, 2, 3, 4, 5, 5, 6], target = 2\n        Output: 3\n    \"\"\"\n\n    def binary_search_left(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    left_index = binary_search_left(arr, target)\n    right_index = binary_search_right(arr, target)\n\n    return right_index - left_index + 1\n\ndef g():\n    return [1, 2, 2, 2, 3, 4, 5, 5, 6], 2\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list.\n\n    Args:\n        arr: A sorted list of integers.\n        target: The target value to search for.\n\n    Returns:\n        The number of occurrences of the target value in the list.\n\n    Example:\n        Input: arr = [1, 2, 2, 2, 3, 4, 5, 5, 6], target = 2\n        Output: 3\n    \"\"\"\n\n    def binary_search_left(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    left_index = binary_search_left(arr, target)\n    right_index = binary_search_right(arr, target)\n\n    return right_index - left_index + 1", "solution_func": "def g():\n    return [1, 2, 2, 2, 3, 4, 5, 5, 6], 2", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\n\n    Args:\n        adj_matrix: A 2D list representing the adjacency matrix of the graph, where adj_matrix[i][j] = 1 if there is an edge from node i to node j, and 0 otherwise.\n\n    Returns:\n        True if the graph contains a cycle, False otherwise.\n\n    Example:\n        Input: adj_matrix = [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\n        Output: True\n        Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n\n    Note:\n        - The number of nodes in the graph is equal to the number of rows/columns in the adjacency matrix.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, recursion_stack):\n                        return True\n                elif recursion_stack[neighbor]:\n                    return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 334, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\n\n    Args:\n        adj_matrix: A 2D list representing the adjacency matrix of the graph, where adj_matrix[i][j] = 1 if there is an edge from node i to node j, and 0 otherwise.\n\n    Returns:\n        True if the graph contains a cycle, False otherwise.\n\n    Example:\n        Input: adj_matrix = [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\n        Output: True\n        Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n\n    Note:\n        - The number of nodes in the graph is equal to the number of rows/columns in the adjacency matrix.\n    \"\"\"\n\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in range(len(adj_matrix)):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, recursion_stack):\n                        return True\n                elif recursion_stack[neighbor]:\n                    return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False", "solution_func": "def g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence in the list.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The length of the longest increasing subsequence.\n\n    Example:\n        Input: arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n        Output: 6\n        Explanation: The longest increasing subsequence is [10, 22, 33, 50, 60, 80].\n\n    Note:\n        - The elements of the longest increasing subsequence must be in ascending order.\n        - The subsequence can be non-contiguous (i.e., not adjacent elements in the original list).\n    \"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 334, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence in the list.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The length of the longest increasing subsequence.\n\n    Example:\n        Input: arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n        Output: 6\n        Explanation: The longest increasing subsequence is [10, 22, 33, 50, 60, 80].\n\n    Note:\n        - The elements of the longest increasing subsequence must be in ascending order.\n        - The subsequence can be non-contiguous (i.e., not adjacent elements in the original list).\n    \"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, find the maximum possible XOR value between any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, find the maximum possible XOR value between any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the numbers that appear an odd number of times in the list.\n    Return a list containing these numbers.\n\n    Example:\n    Input: nums = [2, 3, 2, 5, 6, 7, 6, 7, 5]\n    Output: [3]\n    \"\"\"\n\n    odd_occurrences = []\n\n    for num in nums:\n        if nums.count(num) % 2 != 0 and num not in odd_occurrences:\n            odd_occurrences.append(num)\n\n    return odd_occurrences\n\ndef g() -> List[int]:\n    nums = [2, 3, 2, 5, 6, 7, 6, 7, 5]\n    return nums\n\nassert f(g()) == [3]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 334, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the numbers that appear an odd number of times in the list.\n    Return a list containing these numbers.\n\n    Example:\n    Input: nums = [2, 3, 2, 5, 6, 7, 6, 7, 5]\n    Output: [3]\n    \"\"\"\n\n    odd_occurrences = []\n\n    for num in nums:\n        if nums.count(num) % 2 != 0 and num not in odd_occurrences:\n            odd_occurrences.append(num)\n\n    return odd_occurrences", "solution_func": "def g() -> List[int]:\n    nums = [2, 3, 2, 5, 6, 7, 6, 7, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence such that the bitwise XOR of the subsequence is equal to 0.\n    Return True if such subsequence exists, otherwise return False.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: True\n\n    Explanation:\n    The subsequence [1, 5] has a bitwise XOR of 0 (1 ^ 5 = 4 ^ 4 = 0).\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(1, 2**n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(nums[j])\n        xor_value = subsequence[0]\n        for k in range(1, len(subsequence)):\n            xor_value ^= subsequence[k]\n        if xor_value == 0:\n            return True\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence such that the bitwise XOR of the subsequence is equal to 0.\n    Return True if such subsequence exists, otherwise return False.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: True\n\n    Explanation:\n    The subsequence [1, 5] has a bitwise XOR of 0 (1 ^ 5 = 4 ^ 4 = 0).\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(1, 2**n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(nums[j])\n        xor_value = subsequence[0]\n        for k in range(1, len(subsequence)):\n            xor_value ^= subsequence[k]\n        if xor_value == 0:\n            return True\n\n    return False", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int = 3) -> bool:\n    \"\"\"Check if there exists a set of k positive integers that sum up to n.\"\"\"\n    if k == 1:\n        return True\n    if k > n or k <= 0:\n        return False\n    dp = [[False] * (n + 1) for _ in range(k + 1)]\n    for i in range(1, n + 1):\n        dp[1][i] = True\n    for i in range(2, k + 1):\n        for j in range(1, n + 1):\n            for x in range(1, j + 1):\n                dp[i][j] = dp[i][j] or (dp[i - 1][j - x] and x >= i)\n    return dp[k][n]\ndef g(n = 10, k = 3):\n    return n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 334, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int = 3) -> bool:\n    \"\"\"Check if there exists a set of k positive integers that sum up to n.\"\"\"\n    if k == 1:\n        return True\n    if k > n or k <= 0:\n        return False\n    dp = [[False] * (n + 1) for _ in range(k + 1)]\n    for i in range(1, n + 1):\n        dp[1][i] = True\n    for i in range(2, k + 1):\n        for j in range(1, n + 1):\n            for x in range(1, j + 1):\n                dp[i][j] = dp[i][j] or (dp[i - 1][j - x] and x >= i)\n    return dp[k][n]", "solution_func": "def g(n = 10, k = 3):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n\n    Explanation:\n    The maximum subarray sum is [4, -1, 2, 1], therefore the sum is 6.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n\n    Explanation:\n    The maximum subarray sum is [4, -1, 2, 1], therefore the sum is 6.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest arithmetic subsequence.\n\n    Example:\n    Input: nums = [3, 6, 9, 12]\n    Output: 4\n\n    Explanation:\n    The longest arithmetic subsequence is [3, 6, 9, 12], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = {}\n    max_length = 2\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            diff = nums[j] - nums[i]\n            if diff not in dp:\n                dp[diff] = 2\n            else:\n                dp[diff] += 1\n            max_length = max(max_length, dp[diff])\n\n    return max_length\n\ndef g():\n    nums = [3, 6, 9, 12]\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest arithmetic subsequence.\n\n    Example:\n    Input: nums = [3, 6, 9, 12]\n    Output: 4\n\n    Explanation:\n    The longest arithmetic subsequence is [3, 6, 9, 12], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = {}\n    max_length = 2\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            diff = nums[j] - nums[i]\n            if diff not in dp:\n                dp[diff] = 2\n            else:\n                dp[diff] += 1\n            max_length = max(max_length, dp[diff])\n\n    return max_length", "solution_func": "def g():\n    nums = [3, 6, 9, 12]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value that can be obtained by selecting one element from each row.\n\n    Return the maximum XOR value.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum XOR value that can be obtained is 15 by selecting 3 from the first row, 6 from the second row, and 6 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n\n    for row in matrix:\n        row_xor = 0\n        for num in row:\n            row_xor ^= num\n        max_xor = max(max_xor, row_xor)\n\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 15\n", "emb": null, "idx_generation": 335, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value that can be obtained by selecting one element from each row.\n\n    Return the maximum XOR value.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum XOR value that can be obtained is 15 by selecting 3 from the first row, 6 from the second row, and 6 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n\n    for row in matrix:\n        row_xor = 0\n        for num in row:\n            row_xor ^= num\n        max_xor = max(max_xor, row_xor)\n\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by selecting two elements from the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum XOR value that can be obtained is 7 by selecting 3 and 4.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by selecting two elements from the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum XOR value that can be obtained is 7 by selecting 3 and 4.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, determine the minimum XOR value along the path from the start cell\n    to the end cell. You can only move to adjacent cells (up, down, left, or right) that are not blocked (value 0).\n\n    Return the minimum XOR value.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    The minimum XOR value along the path from the start cell (0, 0) to the end cell (3, 3) is 0.\n\n    Therefore, the function should return 0.\n    \"\"\"\n\n    def dfs(grid, curr_row, curr_col, end_row, end_col, visited, xor_val):\n        if curr_row == end_row and curr_col == end_col:\n            return xor_val\n\n        if curr_row < 0 or curr_row >= len(grid) or curr_col < 0 or curr_col >= len(grid[0]) or grid[curr_row][curr_col] == 0 or visited[curr_row][curr_col]:\n            return float('inf')\n\n        visited[curr_row][curr_col] = True\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        min_xor = float('inf')\n\n        for direction in directions:\n            next_row = curr_row + direction[0]\n            next_col = curr_col + direction[1]\n\n            xor = grid[curr_row][curr_col] ^ grid[next_row][next_col]\n            min_xor = min(min_xor, dfs(grid, next_row, next_col, end_row, end_col, visited, xor))\n\n        return min_xor\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n\n    return dfs(grid, start[0], start[1], end[0], end[1], visited, 0)\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end\n\nassert f(*g()) == 0\n", "emb": null, "idx_generation": 335, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, determine the minimum XOR value along the path from the start cell\n    to the end cell. You can only move to adjacent cells (up, down, left, or right) that are not blocked (value 0).\n\n    Return the minimum XOR value.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    The minimum XOR value along the path from the start cell (0, 0) to the end cell (3, 3) is 0.\n\n    Therefore, the function should return 0.\n    \"\"\"\n\n    def dfs(grid, curr_row, curr_col, end_row, end_col, visited, xor_val):\n        if curr_row == end_row and curr_col == end_col:\n            return xor_val\n\n        if curr_row < 0 or curr_row >= len(grid) or curr_col < 0 or curr_col >= len(grid[0]) or grid[curr_row][curr_col] == 0 or visited[curr_row][curr_col]:\n            return float('inf')\n\n        visited[curr_row][curr_col] = True\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        min_xor = float('inf')\n\n        for direction in directions:\n            next_row = curr_row + direction[0]\n            next_col = curr_col + direction[1]\n\n            xor = grid[curr_row][curr_col] ^ grid[next_row][next_col]\n            min_xor = min(min_xor, dfs(grid, next_row, next_col, end_row, end_col, visited, xor))\n\n        return min_xor\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n\n    return dfs(grid, start[0], start[1], end[0], end[1], visited, 0)", "solution_func": "def g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it represents a valid arithmetic expression. The expression can contain digits,\n    arithmetic operators (+, -, *, /), and parentheses. The expression must follow the rules of arithmetic and have\n    balanced parentheses.\n\n    Example:\n    Input: \"3 + (4 * 2)\"\n    Output: True\n\n    Input: \"8 - 2 * 3 / (1 + 3)\"\n    Output: True\n\n    Input: \"5 + 6 * 2\"\n    Output: False\n\n    Input: \"(4 * 2)\"\n    Output: False\n    \"\"\"\n    stack = []\n    for char in s:\n        if char.isdigit():\n            continue\n        elif char in \"+-*/\":\n            if not stack or stack[-1] not in \"+-*/\":\n                return False\n        elif char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack or stack[-1] != \"(\":\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"(4 * 2)\"\n    \nassert f(g())\n", "emb": null, "idx_generation": 335, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it represents a valid arithmetic expression. The expression can contain digits,\n    arithmetic operators (+, -, *, /), and parentheses. The expression must follow the rules of arithmetic and have\n    balanced parentheses.\n\n    Example:\n    Input: \"3 + (4 * 2)\"\n    Output: True\n\n    Input: \"8 - 2 * 3 / (1 + 3)\"\n    Output: True\n\n    Input: \"5 + 6 * 2\"\n    Output: False\n\n    Input: \"(4 * 2)\"\n    Output: False\n    \"\"\"\n    stack = []\n    for char in s:\n        if char.isdigit():\n            continue\n        elif char in \"+-*/\":\n            if not stack or stack[-1] not in \"+-*/\":\n                return False\n        elif char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack or stack[-1] != \"(\":\n                return False\n            stack.pop()\n    return len(stack) == 0", "solution_func": "def g():\n    return \"(4 * 2)\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Example:\n    Input: 7\n    Output: True\n\n    Input: 12\n    Output: False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 7\n    \nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Example:\n    Input: 7\n    Output: True\n\n    Input: 12\n    Output: False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g():\n    return 7", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid email address. The email address must follow the format of\n    {username}@{domain}.{extension}, where:\n    - {username} can contain alphanumeric characters, dots (.), underscores (_), and hyphens (-), but cannot start or end with a dot.\n    - {domain} can contain alphanumeric characters and hyphens (-), but cannot start or end with a hyphen.\n    - {extension} can contain only lowercase alphabetic characters and must have a length of 2 or 3.\n\n    Example:\n    Input: \"john.doe@example.com\"\n    Output: True\n\n    Input: \"jane@doe@example.com\"\n    Output: False\n\n    Input: \"john.doe@example\"\n    Output: False\n\n    Input: \"john.doe@example..com\"\n    Output: False\n    \"\"\"\n    username, domain = s.split(\"@\")\n    if not username or not domain:\n        return False\n    if not username[0].isalnum() or not username[-1].isalnum():\n        return False\n    if \"..\" in username or username[0] == \".\" or username[-1] == \".\":\n        return False\n    if \"-\" in domain:\n        return False\n    if domain[0] == \"-\" or domain[-1] == \"-\":\n        return False\n    if not domain.lower().islower():\n        return False\n    if len(domain.split(\".\")) != 2:\n        return False\n    extension = domain.split(\".\")[1]\n    if len(extension) < 2 or len(extension) > 3 or not extension.islower():\n        return False\n    return True\n\ndef g():\n    return \"john.doe@example.com\"\n    \nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid email address. The email address must follow the format of\n    {username}@{domain}.{extension}, where:\n    - {username} can contain alphanumeric characters, dots (.), underscores (_), and hyphens (-), but cannot start or end with a dot.\n    - {domain} can contain alphanumeric characters and hyphens (-), but cannot start or end with a hyphen.\n    - {extension} can contain only lowercase alphabetic characters and must have a length of 2 or 3.\n\n    Example:\n    Input: \"john.doe@example.com\"\n    Output: True\n\n    Input: \"jane@doe@example.com\"\n    Output: False\n\n    Input: \"john.doe@example\"\n    Output: False\n\n    Input: \"john.doe@example..com\"\n    Output: False\n    \"\"\"\n    username, domain = s.split(\"@\")\n    if not username or not domain:\n        return False\n    if not username[0].isalnum() or not username[-1].isalnum():\n        return False\n    if \"..\" in username or username[0] == \".\" or username[-1] == \".\":\n        return False\n    if \"-\" in domain:\n        return False\n    if domain[0] == \"-\" or domain[-1] == \"-\":\n        return False\n    if not domain.lower().islower():\n        return False\n    if len(domain.split(\".\")) != 2:\n        return False\n    extension = domain.split(\".\")[1]\n    if len(extension) < 2 or len(extension) > 3 or not extension.islower():\n        return False\n    return True", "solution_func": "def g():\n    return \"john.doe@example.com\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, arr, find the maximum XOR value of any two elements in arr.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    The maximum XOR value is 28 (25 ^ 3).\n\n    Return the maximum XOR value.\n\n    Note:\n    - The length of the input list arr will be at least 2.\n    - The maximum value of the elements in arr will not exceed 10^9.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(num, root):\n        node = root\n        maxXOR = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                maxXOR |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return maxXOR\n\n    root = TrieNode()\n    for num in arr:\n        insert(num, root)\n\n    maxXOR = 0\n    for num in arr:\n        maxXOR = max(maxXOR, findMaxXOR(num, root))\n\n    return maxXOR\n\ndef g(arr: List[int]):\n    \"\"\"\n    Find the maximum XOR value of any two elements in arr.\n    \"\"\"\n    return arr\n\narr = [3, 10, 5, 25, 2, 8]\nassert f(g(arr)) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 335, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, arr, find the maximum XOR value of any two elements in arr.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    The maximum XOR value is 28 (25 ^ 3).\n\n    Return the maximum XOR value.\n\n    Note:\n    - The length of the input list arr will be at least 2.\n    - The maximum value of the elements in arr will not exceed 10^9.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(num, root):\n        node = root\n        maxXOR = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                maxXOR |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return maxXOR\n\n    root = TrieNode()\n    for num in arr:\n        insert(num, root)\n\n    maxXOR = 0\n    for num in arr:\n        maxXOR = max(maxXOR, findMaxXOR(num, root))\n\n    return maxXOR", "solution_func": "def g(arr: List[int]):\n    \"\"\"\n    Find the maximum XOR value of any two elements in arr.\n    \"\"\"\n    return arr\n\narr = [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square. A magic square is a square matrix in which the sum\n    of each row, each column, and both diagonals are equal.\n\n    Example:\n    Input:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of each row, each column, and both diagonals is 15, so the matrix is a magic square.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Calculate the sum of the first row\n    target_sum = sum(matrix[0])\n\n    # Check if the sum of each row is equal to the target sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check if the sum of each column is equal to the target sum\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check if the sum of the main diagonal is equal to the target sum\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != target_sum:\n        return False\n\n    # Check if the sum of the secondary diagonal is equal to the target sum\n    secondary_diag_sum = sum(matrix[i][n - i - 1] for i in range(n))\n    if secondary_diag_sum != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square. A magic square is a square matrix in which the sum\n    of each row, each column, and both diagonals are equal.\n\n    Example:\n    Input:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of each row, each column, and both diagonals is 15, so the matrix is a magic square.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Calculate the sum of the first row\n    target_sum = sum(matrix[0])\n\n    # Check if the sum of each row is equal to the target sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check if the sum of each column is equal to the target sum\n    for col in range(n):\n        col_sum = sum(matrix[i][col] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check if the sum of the main diagonal is equal to the target sum\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != target_sum:\n        return False\n\n    # Check if the sum of the secondary diagonal is equal to the target sum\n    secondary_diag_sum = sum(matrix[i][n - i - 1] for i in range(n))\n    if secondary_diag_sum != target_sum:\n        return False\n\n    return True", "solution_func": "def g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of permutations of n items taken k at a time.\n\n    Example:\n    Input:\n    n = 5\n    k = 3\n\n    Output:\n    60\n\n    Explanation:\n    There are 60 different permutations of 5 items taken 3 at a time.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    return factorial(n) // factorial(n - k)\n\ndef g():\n    n = 5\n    k = 3\n    return [n, k]\n\nassert f(*g()) == 60\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of permutations of n items taken k at a time.\n\n    Example:\n    Input:\n    n = 5\n    k = 3\n\n    Output:\n    60\n\n    Explanation:\n    There are 60 different permutations of 5 items taken 3 at a time.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    return factorial(n) // factorial(n - k)", "solution_func": "def g():\n    n = 5\n    k = 3\n    return [n, k]", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that sum up to a specific target value.\n\n    Example:\n    Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target value of 9.\n    \"\"\"\n\n    num_set = set()\n\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return [complement, num]\n        num_set.add(num)\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return [nums, target]\n\nassert f(*g()) == [2, 7]\n", "emb": null, "idx_generation": 336, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that sum up to a specific target value.\n\n    Example:\n    Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [2, 7]\n\n    Explanation:\n    The numbers 2 and 7 sum up to the target value of 9.\n    \"\"\"\n\n    num_set = set()\n\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return [complement, num]\n        num_set.add(num)\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return [nums, target]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n    Return the subarray with the maximum sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: [4, -1, 2, 1] (The subarray with the maximum sum is [4, -1, 2, 1] and the sum is 6)\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = i\n\n        if current_sum < 0:\n            current_sum = 0\n            start = i + 1\n\n    return arr[start:end+1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == [4, -1, 2, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n    Return the subarray with the maximum sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: [4, -1, 2, 1] (The subarray with the maximum sum is [4, -1, 2, 1] and the sum is 6)\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = i\n\n        if current_sum < 0:\n            current_sum = 0\n            start = i + 1\n\n    return arr[start:end+1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8 (The 6th Fibonacci number is 8)\n\n    Hint: Use dynamic programming to optimize the calculation of Fibonacci numbers.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate the value of n.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 336, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8 (The 6th Fibonacci number is 8)\n\n    Hint: Use dynamic programming to optimize the calculation of Fibonacci numbers.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate the value of n.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the number of ways to make the target value using the elements of the array.\n    You can use each element of the array multiple times.\n\n    Example:\n    Input: arr = [1, 2, 3], target = 4\n    Output: 7 (There are 7 ways to make the target value using the elements of the array: [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [2, 1, 1], [3, 1], [4])\n\n    Hint: Use dynamic programming to calculate the number of ways to make the target value.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(arr)):\n            if i - arr[j] >= 0:\n                dp[i] += dp[i - arr[j]]\n\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing the array of integers and the target value.\n    \"\"\"\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the number of ways to make the target value using the elements of the array.\n    You can use each element of the array multiple times.\n\n    Example:\n    Input: arr = [1, 2, 3], target = 4\n    Output: 7 (There are 7 ways to make the target value using the elements of the array: [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [2, 1, 1], [3, 1], [4])\n\n    Hint: Use dynamic programming to calculate the number of ways to make the target value.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(arr)):\n            if i - arr[j] >= 0:\n                dp[i] += dp[i - arr[j]]\n\n    return dp[target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing the array of integers and the target value.\n    \"\"\"\n    return ([1, 2, 3], 4)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target number, find the number of unique combinations of the integers that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to the target are: [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]\n    So, the expected output is 4.\n\n    Returns the number of unique combinations.\n    \"\"\"\n\n    def count_combinations(nums: List[int], target: int) -> int:\n        \"\"\"\n        Counts the number of unique combinations that sum up to the target.\n        \"\"\"\n        if target == 0:\n            return 1\n        if target < 0 or not nums:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(nums, target - num)\n\n        return count\n\n    return count_combinations(nums, target)\n\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 336, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target number, find the number of unique combinations of the integers that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to the target are: [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]\n    So, the expected output is 4.\n\n    Returns the number of unique combinations.\n    \"\"\"\n\n    def count_combinations(nums: List[int], target: int) -> int:\n        \"\"\"\n        Counts the number of unique combinations that sum up to the target.\n        \"\"\"\n        if target == 0:\n            return 1\n        if target < 0 or not nums:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(nums, target - num)\n\n        return count\n\n    return count_combinations(nums, target)", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    So, the expected output is 3.\n\n    Returns the length of the longest substring without repeating characters.\n    \"\"\"\n\n    def longest_substring(s: str) -> int:\n        \"\"\"\n        Finds the length of the longest substring without repeating characters.\n        \"\"\"\n        start = 0\n        max_length = 0\n        seen = {}\n\n        for end, char in enumerate(s):\n            if char in seen and start <= seen[char]:\n                start = seen[char] + 1\n            else:\n                max_length = max(max_length, end - start + 1)\n            \n            seen[char] = end\n\n        return max_length\n\n    return longest_substring(s)\n\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    So, the expected output is 3.\n\n    Returns the length of the longest substring without repeating characters.\n    \"\"\"\n\n    def longest_substring(s: str) -> int:\n        \"\"\"\n        Finds the length of the longest substring without repeating characters.\n        \"\"\"\n        start = 0\n        max_length = 0\n        seen = {}\n\n        for end, char in enumerate(s):\n            if char in seen and start <= seen[char]:\n                start = seen[char] + 1\n            else:\n                max_length = max(max_length, end - start + 1)\n            \n            seen[char] = end\n\n        return max_length\n\n    return longest_substring(s)", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target number, find the minimum number of combinations of the integers that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [2, 3, 5]\n    target = 11\n\n    The minimum number of combinations that sum up to the target is 3: [5, 3, 3].\n    So, the expected output is 3.\n\n    Returns the minimum number of combinations.\n    \"\"\"\n\n    def min_combinations(nums: List[int], target: int) -> int:\n        \"\"\"\n        Finds the minimum number of combinations that sum up to the target.\n        \"\"\"\n        if target == 0:\n            return 0\n        if target < 0 or not nums:\n            return float('inf')\n\n        min_count = float('inf')\n        for num in nums:\n            count = min_combinations(nums, target - num) + 1\n            min_count = min(min_count, count)\n\n        return min_count\n\n    return min_combinations(nums, target)\n\n\ndef g():\n    nums = [2, 3, 5]\n    target = 11\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 336, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target number, find the minimum number of combinations of the integers that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [2, 3, 5]\n    target = 11\n\n    The minimum number of combinations that sum up to the target is 3: [5, 3, 3].\n    So, the expected output is 3.\n\n    Returns the minimum number of combinations.\n    \"\"\"\n\n    def min_combinations(nums: List[int], target: int) -> int:\n        \"\"\"\n        Finds the minimum number of combinations that sum up to the target.\n        \"\"\"\n        if target == 0:\n            return 0\n        if target < 0 or not nums:\n            return float('inf')\n\n        min_count = float('inf')\n        for num in nums:\n            count = min_combinations(nums, target - num) + 1\n            min_count = min(min_count, count)\n\n        return min_count\n\n    return min_combinations(nums, target)", "solution_func": "def g():\n    nums = [2, 3, 5]\n    target = 11\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray in nums.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum+num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, -2, 3, 8, -6, 4, 1, -9, 7]\n\nassert f(g()) == 16\n\n", "emb": null, "idx_generation": 336, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray in nums.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum+num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, -2, 3, 8, -6, 4, 1, -9, 7]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range from 1 to n.\n\n    Example:\n    n = 4\n    k = 2\n\n    The possible combinations of 2 numbers out of the range from 1 to 4 are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n\n    Therefore, the function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n\n    def backtrack(start, combination):\n        if len(combination) == k:\n            combinations.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    combinations = []\n    backtrack(1, [])\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range from 1 to n.\n\n    Example:\n    n = 4\n    k = 2\n\n    The possible combinations of 2 numbers out of the range from 1 to 4 are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n\n    Therefore, the function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n\n    def backtrack(start, combination):\n        if len(combination) == k:\n            combinations.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    combinations = []\n    backtrack(1, [])\n    return combinations", "solution_func": "def g():\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase with n steps. You can climb\n    either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    The distinct ways to climb to the top of a staircase with 4 steps are 5.\n\n    Therefore, the function should return 5.\n    \"\"\"\n\n    def climbStairs(n):\n        if n <= 2:\n            return n\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\n    return climbStairs(n)\n\ndef g():\n    n = 4\n    return n\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 337, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase with n steps. You can climb\n    either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    The distinct ways to climb to the top of a staircase with 4 steps are 5.\n\n    Therefore, the function should return 5.\n    \"\"\"\n\n    def climbStairs(n):\n        if n <= 2:\n            return n\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n\n    return climbStairs(n)", "solution_func": "def g():\n    n = 4\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer target, determine if there exists a combination of numbers in the list\n    that adds up to the target.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 9\n\n    There exists a combination of numbers [2, 3, 5] that adds up to the target 9.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def backtrack(start, curr_sum):\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\ndef g():\n    nums = [2, 3, 5, 7]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer target, determine if there exists a combination of numbers in the list\n    that adds up to the target.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 9\n\n    There exists a combination of numbers [2, 3, 5] that adds up to the target 9.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def backtrack(start, curr_sum):\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)", "solution_func": "def g():\n    nums = [2, 3, 5, 7]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of each row, each column, and each diagonal is 15 (2 + 7 + 6 = 15, 9 + 5 + 1 = 15, 4 + 3 + 8 = 15, 2 + 5 + 8 = 15, 4 + 5 + 6 = 15).\n    Therefore, the matrix is a magic square.\n\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Checking rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Checking columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Checking diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of each row, each column, and each diagonal is 15 (2 + 7 + 6 = 15, 9 + 5 + 1 = 15, 4 + 3 + 8 = 15, 2 + 5 + 8 = 15, 4 + 5 + 6 = 15).\n    Therefore, the matrix is a magic square.\n\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Checking rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Checking columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Checking diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True", "solution_func": "def g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest arithmetic subsequence in the list.\n    An arithmetic subsequence is a sequence of numbers in which the difference between consecutive elements is constant.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    Output:\n    5\n\n    Explanation:\n    The longest arithmetic subsequence is [1, 3, 5, 7, 9], with a common difference of 2 and length 5.\n\n    \"\"\"\n    n = len(nums)\n    if n < 3:\n        return n\n\n    dp = [{} for _ in range(n)]\n    longest = 2\n\n    for i in range(1, n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff in dp[j]:\n                dp[i][diff] = dp[j][diff] + 1\n            else:\n                dp[i][diff] = 2\n            longest = max(longest, dp[i][diff])\n\n    return longest\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    return nums\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest arithmetic subsequence in the list.\n    An arithmetic subsequence is a sequence of numbers in which the difference between consecutive elements is constant.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    Output:\n    5\n\n    Explanation:\n    The longest arithmetic subsequence is [1, 3, 5, 7, 9], with a common difference of 2 and length 5.\n\n    \"\"\"\n    n = len(nums)\n    if n < 3:\n        return n\n\n    dp = [{} for _ in range(n)]\n    longest = 2\n\n    for i in range(1, n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff in dp[j]:\n                dp[i][diff] = dp[j][diff] + 1\n            else:\n                dp[i][diff] = 2\n            longest = max(longest, dp[i][diff])\n\n    return longest", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target sum 9.\n\n    \"\"\"\n    n = len(nums)\n    num_map = {}\n\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target sum 9.\n\n    \"\"\"\n    n = len(nums)\n    num_map = {}\n\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[nums[i]] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum difference between two consecutive numbers in the list.\n    Return 0 if the list contains less than 2 numbers.\n\n    Example:\n    nums = [1, 5, 3, 9, 7]\n\n    The maximum difference between two consecutive numbers is 6 (5 - 1).\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    if len(nums) < 2:\n        return 0\n\n    nums.sort()\n\n    max_diff = 0\n    for i in range(1, len(nums)):\n        diff = nums[i] - nums[i-1]\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 5, 3, 9, 7]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 337, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum difference between two consecutive numbers in the list.\n    Return 0 if the list contains less than 2 numbers.\n\n    Example:\n    nums = [1, 5, 3, 9, 7]\n\n    The maximum difference between two consecutive numbers is 6 (5 - 1).\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    if len(nums) < 2:\n        return 0\n\n    nums.sort()\n\n    max_diff = 0\n    for i in range(1, len(nums)):\n        diff = nums[i] - nums[i-1]\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 5, 3, 9, 7]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    count the number of pairs (a, b) in the list where a + b = target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The pairs (1, 5) and (2, 4) sum up to the target value 6.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 6) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    count the number of pairs (a, b) in the list where a + b = target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The pairs (1, 5) and (2, 4) sum up to the target value 6.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of numbers along any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The maximum sum of numbers along any path from the top-left cell to the bottom-right cell is 8 (1 + 3 + 1 + 1 + 1).\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the maximum sum for the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Calculate the maximum sum for the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Calculate the maximum sum for the remaining cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 337, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of numbers along any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The maximum sum of numbers along any path from the top-left cell to the bottom-right cell is 8 (1 + 3 + 1 + 1 + 1).\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the maximum sum for the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Calculate the maximum sum for the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Calculate the maximum sum for the remaining cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    output: 20\n    \"\"\"\n    sorted_nums = sorted(nums)\n    n = len(sorted_nums)\n    \n    return max(sorted_nums[0]*sorted_nums[1], sorted_nums[n-2]*sorted_nums[n-1])\n\ndef g(nums=[1, 2, 3, 4, 5]) -> List[int]:\n    return nums\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 337, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    output: 20\n    \"\"\"\n    sorted_nums = sorted(nums)\n    n = len(sorted_nums)\n    \n    return max(sorted_nums[0]*sorted_nums[1], sorted_nums[n-2]*sorted_nums[n-1])", "solution_func": "def g(nums=[1, 2, 3, 4, 5]) -> List[int]:\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be achieved by multiplying 2, 3, and 4, resulting in 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    \n    # If all numbers are positive or negative\n    if nums[0] >= 0 or nums[-1] <= 0:\n        return nums[-1] * nums[-2] * nums[-3]\n    \n    # If there are both positive and negative numbers\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    24\n\n    Explanation:\n    The maximum product can be achieved by multiplying 2, 3, and 4, resulting in 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    \n    # If all numbers are positive or negative\n    if nums[0] >= 0 or nums[-1] <= 0:\n        return nums[-1] * nums[-2] * nums[-3]\n    \n    # If there are both positive and negative numbers\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for i in range(n):\n        current_sum += nums[i]\n        \n        if current_sum > max_sum:\n            max_sum = current_sum\n        \n        if current_sum < 0:\n            current_sum = 0\n    \n    return max_sum\n\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for i in range(n):\n        current_sum += nums[i]\n        \n        if current_sum > max_sum:\n            max_sum = current_sum\n        \n        if current_sum < 0:\n            current_sum = 0\n    \n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 5\n\n    The binary representation of 5 is '101'.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 5\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 5\n\n    The binary representation of 5 is '101'.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g():\n    return 5", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the reverse of its binary representation as an integer.\n\n    Example:\n    n = 5\n\n    The binary representation of 5 is '101'.\n\n    Therefore, the function should return 5.\n    \"\"\"\n    binary = bin(n)[2:]\n    reverse_binary = binary[::-1]\n    return int(reverse_binary, 2)\n\ndef g():\n    return 5\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the reverse of its binary representation as an integer.\n\n    Example:\n    n = 5\n\n    The binary representation of 5 is '101'.\n\n    Therefore, the function should return 5.\n    \"\"\"\n    binary = bin(n)[2:]\n    reverse_binary = binary[::-1]\n    return int(reverse_binary, 2)", "solution_func": "def g():\n    return 5", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with all uppercase characters converted to lowercase and all lowercase characters converted to uppercase.\n\n    Example:\n    s = \"Hello World\"\n\n    The converted string should be \"hELLO wORLD\".\n    \"\"\"\n    converted = \"\"\n    for char in s:\n        if char.islower():\n            converted += char.upper()\n        else:\n            converted += char.lower()\n    return converted\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"hELLO wORLD\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with all uppercase characters converted to lowercase and all lowercase characters converted to uppercase.\n\n    Example:\n    s = \"Hello World\"\n\n    The converted string should be \"hELLO wORLD\".\n    \"\"\"\n    converted = \"\"\n    for char in s:\n        if char.islower():\n            converted += char.upper()\n        else:\n            converted += char.lower()\n    return converted", "solution_func": "def g():\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of elements whose XOR is equal to the target.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr\n\narr = [1, 2, 3, 4, 5, 6]\ntarget = 7\nassert f(g(arr, target), target)\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of elements whose XOR is equal to the target.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False", "solution_func": "def g(arr: List[int], target: int):\n    return arr\n\narr = [1, 2, 3, 4, 5, 6]\ntarget = 7", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a string s can be rearranged such that every pair of adjacent characters have at most k bits difference.\n    \"\"\"\n    for i in range(len(s)-1):\n        if abs(ord(s[i]) - ord(s[i+1])) > k:\n            return False\n    return True\n\ndef g(s: str, k: int):\n    return s\n\ns = \"abcd\"\nk = 2\nassert f(g(s, k), k)\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a string s can be rearranged such that every pair of adjacent characters have at most k bits difference.\n    \"\"\"\n    for i in range(len(s)-1):\n        if abs(ord(s[i]) - ord(s[i+1])) > k:\n            return False\n    return True", "solution_func": "def g(s: str, k: int):\n    return s\n\ns = \"abcd\"\nk = 2", "map_ix": [0, 0, 0, 0, 1, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g(arr: List[int]):\n    return arr\n\narr = [1, 2, 3, 4, 5, 6]\nassert f(g(arr))\n", "emb": null, "idx_generation": 338, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor", "solution_func": "def g(arr: List[int]):\n    return arr\n\narr = [1, 2, 3, 4, 5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a palindrome in binary representation.\n\n    Sample Input:\n    n = 9\n\n    Sample Output:\n    True\n\n    Explanation:\n    9 in binary is 1001, which is a palindrome.\n    \"\"\"\n    binary = bin(n)[2:]  # convert n to binary representation\n    return binary == binary[::-1]  # check if binary representation is a palindrome\n\ndef g():\n    return 9\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 338, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a palindrome in binary representation.\n\n    Sample Input:\n    n = 9\n\n    Sample Output:\n    True\n\n    Explanation:\n    9 in binary is 1001, which is a palindrome.\n    \"\"\"\n    binary = bin(n)[2:]  # convert n to binary representation\n    return binary == binary[::-1]  # check if binary representation is a palindrome", "solution_func": "def g():\n    return 9", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the length of the longest subarray that has a bitwise OR equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    Output:\n    3\n\n    Explanation:\n    The subarray [2, 3, 4] has a bitwise OR equal to 3 and is the longest subarray with this property.\n    \"\"\"\n\n    def backtrack(nums, start, target, curr_or):\n        if curr_or == target:\n            return start\n\n        if start == len(nums):\n            return -1\n\n        if curr_or > target:\n            return -1\n\n        # Include the current number in the OR operation\n        include = backtrack(nums, start + 1, target, curr_or | nums[start])\n\n        # Exclude the current number from the OR operation\n        exclude = backtrack(nums, start + 1, target, curr_or)\n\n        if include == -1 and exclude == -1:\n            return -1\n        elif include == -1:\n            return exclude\n        elif exclude == -1:\n            return include\n        else:\n            return max(include, exclude)\n\n    return backtrack(nums, 0, target, 0)\n\ndef g() -> List[int, int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 339, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the length of the longest subarray that has a bitwise OR equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    Output:\n    3\n\n    Explanation:\n    The subarray [2, 3, 4] has a bitwise OR equal to 3 and is the longest subarray with this property.\n    \"\"\"\n\n    def backtrack(nums, start, target, curr_or):\n        if curr_or == target:\n            return start\n\n        if start == len(nums):\n            return -1\n\n        if curr_or > target:\n            return -1\n\n        # Include the current number in the OR operation\n        include = backtrack(nums, start + 1, target, curr_or | nums[start])\n\n        # Exclude the current number from the OR operation\n        exclude = backtrack(nums, start + 1, target, curr_or)\n\n        if include == -1 and exclude == -1:\n            return -1\n        elif include == -1:\n            return exclude\n        elif exclude == -1:\n            return include\n        else:\n            return max(include, exclude)\n\n    return backtrack(nums, 0, target, 0)", "solution_func": "def g() -> List[int, int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value of any two elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2],\n        [3, 4]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 3 and 4, resulting in 7.\n    \"\"\"\n\n    def find_max_xor(nums, start, curr_xor):\n        if start == len(nums):\n            return curr_xor\n\n        max_xor = 0\n\n        for num in nums[start]:\n            max_xor = max(max_xor, find_max_xor(nums, start + 1, curr_xor ^ num))\n\n        return max_xor\n\n    return find_max_xor(matrix, 0, 0)\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2],\n        [3, 4]\n    ]\n    return matrix\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 339, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value of any two elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2],\n        [3, 4]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 3 and 4, resulting in 7.\n    \"\"\"\n\n    def find_max_xor(nums, start, curr_xor):\n        if start == len(nums):\n            return curr_xor\n\n        max_xor = 0\n\n        for num in nums[start]:\n            max_xor = max(max_xor, find_max_xor(nums, start + 1, curr_xor ^ num))\n\n        return max_xor\n\n    return find_max_xor(matrix, 0, 0)", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2],\n        [3, 4]\n    ]\n    return matrix", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 2 and 5, resulting in 7.\n    \"\"\"\n\n    def find_max_xor(nums, curr_xor):\n        max_xor = curr_xor\n\n        for num in nums:\n            max_xor = max(max_xor, find_max_xor(nums, curr_xor ^ num))\n\n        return max_xor\n\n    return find_max_xor(nums, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 339, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 2 and 5, resulting in 7.\n    \"\"\"\n\n    def find_max_xor(nums, curr_xor):\n        max_xor = curr_xor\n\n        for num in nums:\n            max_xor = max(max_xor, find_max_xor(nums, curr_xor ^ num))\n\n        return max_xor\n\n    return find_max_xor(nums, 0)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n    \"\"\"\n    # Create a dictionary to store the complement of each number\n    complement_dict = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        # Check if the complement is already in the dictionary\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        # Otherwise, add the number and its index to the dictionary\n        complement_dict[num] = i\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n    \"\"\"\n    # Create a dictionary to store the complement of each number\n    complement_dict = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        # Check if the complement is already in the dictionary\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        # Otherwise, add the number and its index to the dictionary\n        complement_dict[num] = i\n\n    return []", "solution_func": "def g():\n    return [2, 7, 11, 15], 9", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value k, find all pairs of numbers in the array that sum up to k.\n    Return a list of tuples containing the pairs.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    k = 5\n    output: [(1, 4), (2, 3)]\n    \"\"\"\n    pairs = []\n    num_dict = {}\n\n    for num in arr:\n        complement = k - num\n        if complement in num_dict:\n            pairs.append((complement, num))\n        num_dict[num] = True\n\n    return pairs\n\ndef g():\n    return [1, 2, 3, 4, 5], 5\n\nassert f(*g()) == [(1, 4), (2, 3)]\n", "emb": null, "idx_generation": 339, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value k, find all pairs of numbers in the array that sum up to k.\n    Return a list of tuples containing the pairs.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    k = 5\n    output: [(1, 4), (2, 3)]\n    \"\"\"\n    pairs = []\n    num_dict = {}\n\n    for num in arr:\n        complement = k - num\n        if complement in num_dict:\n            pairs.append((complement, num))\n        num_dict[num] = True\n\n    return pairs", "solution_func": "def g():\n    return [1, 2, 3, 4, 5], 5", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value k, find the length of the longest subarray with a sum equal to k.\n\n    Example:\n    arr = [1, -1, 5, -2, 3]\n    k = 3\n    output: 4\n    Explanation: The longest subarray with a sum equal to 3 is [1, -1, 5, -2].\n\n    Note: The subarray must be contiguous.\n    \"\"\"\n    prefix_sum = 0\n    sum_dict = {}\n    max_length = 0\n\n    for i, num in enumerate(arr):\n        prefix_sum += num\n\n        if prefix_sum == k:\n            max_length = i + 1\n\n        if prefix_sum - k in sum_dict:\n            max_length = max(max_length, i - sum_dict[prefix_sum - k])\n\n        if prefix_sum not in sum_dict:\n            sum_dict[prefix_sum] = i\n\n    return max_length\n\ndef g():\n    return [1, -1, 5, -2, 3], 3\n\nassert f(*g()) == 4\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 339, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value k, find the length of the longest subarray with a sum equal to k.\n\n    Example:\n    arr = [1, -1, 5, -2, 3]\n    k = 3\n    output: 4\n    Explanation: The longest subarray with a sum equal to 3 is [1, -1, 5, -2].\n\n    Note: The subarray must be contiguous.\n    \"\"\"\n    prefix_sum = 0\n    sum_dict = {}\n    max_length = 0\n\n    for i, num in enumerate(arr):\n        prefix_sum += num\n\n        if prefix_sum == k:\n            max_length = i + 1\n\n        if prefix_sum - k in sum_dict:\n            max_length = max(max_length, i - sum_dict[prefix_sum - k])\n\n        if prefix_sum not in sum_dict:\n            sum_dict[prefix_sum] = i\n\n    return max_length", "solution_func": "def g():\n    return [1, -1, 5, -2, 3], 3", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a non-empty subarray.\n    The subarray must contain at least one number.\n\n    Example:\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n\n    Explanation: The subarray [4,-1,2,1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')  # Initialize the maximum sum to negative infinity\n\n    for i in range(len(nums)):\n        current_sum = 0\n\n        for j in range(i, len(nums)):\n            current_sum += nums[j]  # Add the current element to the current sum\n\n            if current_sum > max_sum:\n                max_sum = current_sum  # Update the maximum sum if the current sum is greater\n\n    return max_sum\n\ndef g():\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 339, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a non-empty subarray.\n    The subarray must contain at least one number.\n\n    Example:\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n\n    Explanation: The subarray [4,-1,2,1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')  # Initialize the maximum sum to negative infinity\n\n    for i in range(len(nums)):\n        current_sum = 0\n\n        for j in range(i, len(nums)):\n            current_sum += nums[j]  # Add the current element to the current sum\n\n            if current_sum > max_sum:\n                max_sum = current_sum  # Update the maximum sum if the current sum is greater\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n    return nums", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n using recursion.\n\n    Example:\n    Input: n = 5\n    Output: 120\n\n    Explanation: The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n using recursion.\n\n    Example:\n    Input: n = 5\n    Output: 120\n\n    Explanation: The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * f(n-1)", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome using recursion.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: The string \"racecar\" is a palindrome.\n    \"\"\"\n\n    if len(s) <= 1:\n        return True\n    elif s[0] == s[-1]:\n        return f(s[1:-1])\n    else:\n        return False\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome using recursion.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: The string \"racecar\" is a palindrome.\n    \"\"\"\n\n    if len(s) <= 1:\n        return True\n    elif s[0] == s[-1]:\n        return f(s[1:-1])\n    else:\n        return False", "solution_func": "def g():\n    s = \"racecar\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings 's' and 't', find the minimum number of operations required to convert 's' to 't'.\n\n    The allowed operations are:\n    - Insert a character\n    - Delete a character\n    - Replace a character\n\n    Return the minimum number of operations.\n\n    Example:\n    s = \"kitten\"\n    t = \"sitting\"\n    Output: 3  # 'kitten' -> 'sitten' -> 'sittin' -> 'sitting'\n    \"\"\"\n    def dp(i, j):\n        if i == 0:\n            return j\n        if j == 0:\n            return i\n        if s[i - 1] == t[j - 1]:\n            return dp(i - 1, j - 1)\n        return 1 + min(dp(i, j - 1), dp(i - 1, j), dp(i - 1, j - 1))\n    \n    return dp(len(s), len(t))\n\ndef g(s=\"kitten\", t=\"sitting\"):\n    \"\"\"\n    Convert string 's' to string 't' using the minimum number of operations.\n    \"\"\"\n    return s, t\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 339, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings 's' and 't', find the minimum number of operations required to convert 's' to 't'.\n\n    The allowed operations are:\n    - Insert a character\n    - Delete a character\n    - Replace a character\n\n    Return the minimum number of operations.\n\n    Example:\n    s = \"kitten\"\n    t = \"sitting\"\n    Output: 3  # 'kitten' -> 'sitten' -> 'sittin' -> 'sitting'\n    \"\"\"\n    def dp(i, j):\n        if i == 0:\n            return j\n        if j == 0:\n            return i\n        if s[i - 1] == t[j - 1]:\n            return dp(i - 1, j - 1)\n        return 1 + min(dp(i, j - 1), dp(i - 1, j), dp(i - 1, j - 1))\n    \n    return dp(len(s), len(t))", "solution_func": "def g(s=\"kitten\", t=\"sitting\"):\n    \"\"\"\n    Convert string 's' to string 't' using the minimum number of operations.\n    \"\"\"\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    grid (List[List[int]]): The 2D grid of integers.\n\n    Returns:\n    int: The maximum sum of a path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 21\n", "emb": null, "idx_generation": 340, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Args:\n    grid (List[List[int]]): The 2D grid of integers.\n\n    Returns:\n    int: The maximum sum of a path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the area of the largest triangle that can be formed by any three points.\n\n    Args:\n    points (List[List[int]]): The list of 2D points.\n\n    Returns:\n    float: The area of the largest triangle.\n    \"\"\"\n    def distance(point1, point2):\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n    \n    max_area = 0\n    n = len(points)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a = distance(points[i], points[j])\n                b = distance(points[j], points[k])\n                c = distance(points[k], points[i])\n                s = (a + b + c) / 2\n                area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n                max_area = max(max_area, area)\n    \n    return max_area\n\ndef g(points=[[0, 0], [1, 0], [0, 1], [1, 1]]) -> List[List[int]]:\n    return points\n\nassert f(g()) == 0.5\n", "emb": null, "idx_generation": 340, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, find the area of the largest triangle that can be formed by any three points.\n\n    Args:\n    points (List[List[int]]): The list of 2D points.\n\n    Returns:\n    float: The area of the largest triangle.\n    \"\"\"\n    def distance(point1, point2):\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n    \n    max_area = 0\n    n = len(points)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a = distance(points[i], points[j])\n                b = distance(points[j], points[k])\n                c = distance(points[k], points[i])\n                s = (a + b + c) / 2\n                area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n                max_area = max(max_area, area)\n    \n    return max_area", "solution_func": "def g(points=[[0, 0], [1, 0], [0, 1], [1, 1]]) -> List[List[int]]:\n    return points", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Args:\n    matrix (List[List[int]]): The matrix of integers.\n\n    Returns:\n    List[List[int]]: The rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-i-1] = matrix[i][j]\n    \n    return rotated\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 340, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Args:\n    matrix (List[List[int]]): The matrix of integers.\n\n    Returns:\n    List[List[int]]: The rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-i-1] = matrix[i][j]\n    \n    return rotated", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> int:\n    \"\"\"\n    Given three positive integers n, m, and k, find the number of ways to place k rooks on an n x m chessboard such\n    that no two rooks can attack each other.\n    \n    Example:\n    n = 3\n    m = 3\n    k = 2\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 ways to place 2 rooks on a 3x3 chessboard without any of them attacking each other.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n        \n    return factorial(n) // (factorial(k) * factorial(n - k)) * factorial(m) // (factorial(k) * factorial(m - k))\n\ndef g():\n    n = 3\n    m = 3\n    k = 2\n    return n, m, k\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 340, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, m: int, k: int) -> int:\n    \"\"\"\n    Given three positive integers n, m, and k, find the number of ways to place k rooks on an n x m chessboard such\n    that no two rooks can attack each other.\n    \n    Example:\n    n = 3\n    m = 3\n    k = 2\n    \n    Output:\n    6\n    \n    Explanation:\n    There are 6 ways to place 2 rooks on a 3x3 chessboard without any of them attacking each other.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n        \n    return factorial(n) // (factorial(k) * factorial(n - k)) * factorial(m) // (factorial(k) * factorial(m - k))", "solution_func": "def g():\n    n = 3\n    m = 3\n    k = 2\n    return n, m, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    [[1, 3, 6],\n     [5, 10, 15],\n     [12, 20, 29]]\n\n    Explanation:\n    The maximum sum of a path from the top-left cell (1) to the bottom-right cell (9) is 29.\n    The path with the maximum sum is: 1 -> 2 -> 3 -> 6 -> 9.\n    \"\"\"\n\n    if not grid:\n        return []\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j - 1]\n\n    # Initialize the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i - 1][0]\n\n    # Calculate the maximum sum path\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i - 1][j], grid[i][j - 1])\n\n    return grid\n\ndef g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g()) == [[1, 3, 6], [5, 10, 15], [12, 20, 29]]\n", "emb": null, "idx_generation": 340, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    [[1, 3, 6],\n     [5, 10, 15],\n     [12, 20, 29]]\n\n    Explanation:\n    The maximum sum of a path from the top-left cell (1) to the bottom-right cell (9) is 29.\n    The path with the maximum sum is: 1 -> 2 -> 3 -> 6 -> 9.\n    \"\"\"\n\n    if not grid:\n        return []\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j - 1]\n\n    # Initialize the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i - 1][0]\n\n    # Calculate the maximum sum path\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i - 1][j], grid[i][j - 1])\n\n    return grid", "solution_func": "def g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of different ways to express n as the sum of positive integers.\n    The order of the summands matters, i.e., 2 + 1 and 1 + 2 are considered different ways.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different ways to express 5 as the sum of 3 positive integers: [1, 1, 3], [1, 2, 2], [1, 3, 1],\n    [2, 1, 2], [2, 2, 1], [2, 3, 0], [3, 0, 2], [3, 1, 1], [3, 2, 0], [5, 0, 0].\n    \"\"\"\n\n    def count_ways(n: int, k: int) -> int:\n        if n == 0:\n            return 1\n        elif n < 0 or k == 0:\n            return 0\n        else:\n            return count_ways(n - 1, k - 1) + count_ways(n - k, k)\n\n    return count_ways(n, k)\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n", "emb": null, "idx_generation": 340, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of different ways to express n as the sum of positive integers.\n    The order of the summands matters, i.e., 2 + 1 and 1 + 2 are considered different ways.\n\n    Example:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different ways to express 5 as the sum of 3 positive integers: [1, 1, 3], [1, 2, 2], [1, 3, 1],\n    [2, 1, 2], [2, 2, 1], [2, 3, 0], [3, 0, 2], [3, 1, 1], [3, 2, 0], [5, 0, 0].\n    \"\"\"\n\n    def count_ways(n: int, k: int) -> int:\n        if n == 0:\n            return 1\n        elif n < 0 or k == 0:\n            return 0\n        else:\n            return count_ways(n - 1, k - 1) + count_ways(n - k, k)\n\n    return count_ways(n, k)", "solution_func": "def g():\n    n = 5\n    k = 3\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the sum of the digits of a number is divisible by n.\"\"\"\n    return sum(int(d) for d in s) % n == 0\n\ndef g(n = 7):\n    return str(n) * 100\n\nassert f(g(), str(g()))\n", "emb": null, "idx_generation": 340, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the sum of the digits of a number is divisible by n.\"\"\"\n    return sum(int(d) for d in s) % n == 0", "solution_func": "def g(n = 7):\n    return str(n) * 100", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if a string is a palindrome and its length is divisible by n.\"\"\"\n    return s == s[::-1] and len(s) % n == 0\n\ndef g(n = 5):\n    return \"racecar\" * n\n\nassert f(g(), str(g()))\n", "emb": null, "idx_generation": 340, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if a string is a palindrome and its length is divisible by n.\"\"\"\n    return s == s[::-1] and len(s) % n == 0", "solution_func": "def g(n = 5):\n    return \"racecar\" * n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the sum of the ASCII values of the characters in a string is divisible by n.\"\"\"\n    return sum(ord(c) for c in s) % n == 0\n\ndef g(n = 9):\n    return \"hello\" * n\n\nassert f(g(), str(g()))\n", "emb": null, "idx_generation": 340, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if the sum of the ASCII values of the characters in a string is divisible by n.\"\"\"\n    return sum(ord(c) for c in s) % n == 0", "solution_func": "def g(n = 9):\n    return \"hello\" * n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24 (The maximum product is 2 * 3 * 4 = 24)\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product can be obtained.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 340, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24 (The maximum product is 2 * 3 * 4 = 24)\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product can be obtained.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the number of non-empty subsequences such that the sum of the subsequence is divisible by 3.\n    \"\"\"\n    count = 0\n    freq = [0] * 3\n    for num in arr:\n        freq[num % 3] += 1\n    count += (freq[0] * (freq[0] - 1) // 2)  # Counting the number of pairs divisible by 3\n    count += freq[1] * freq[2]  # Counting the number of pairs with remainder 1 and 2 respectively\n    count += (freq[0] * (freq[0] - 1) * (freq[0] - 2) // 6)  # Counting the number of triplets divisible by 3\n    count += (freq[1] * (freq[1] - 1) * (freq[1] - 2) // 6)  # Counting the number of triplets with remainder 1\n    count += (freq[2] * (freq[2] - 1) * (freq[2] - 2) // 6)  # Counting the number of triplets with remainder 2\n    count += freq[0] * freq[1] * freq[2]  # Counting the number of triplets with different remainders\n    return count\n\ndef g(arr=[1, 2, 3, 4, 5, 6]):\n    return arr\n\nassert f(*g()) == 45\n", "emb": null, "idx_generation": 341, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the number of non-empty subsequences such that the sum of the subsequence is divisible by 3.\n    \"\"\"\n    count = 0\n    freq = [0] * 3\n    for num in arr:\n        freq[num % 3] += 1\n    count += (freq[0] * (freq[0] - 1) // 2)  # Counting the number of pairs divisible by 3\n    count += freq[1] * freq[2]  # Counting the number of pairs with remainder 1 and 2 respectively\n    count += (freq[0] * (freq[0] - 1) * (freq[0] - 2) // 6)  # Counting the number of triplets divisible by 3\n    count += (freq[1] * (freq[1] - 1) * (freq[1] - 2) // 6)  # Counting the number of triplets with remainder 1\n    count += (freq[2] * (freq[2] - 1) * (freq[2] - 2) // 6)  # Counting the number of triplets with remainder 2\n    count += freq[0] * freq[1] * freq[2]  # Counting the number of triplets with different remainders\n    return count", "solution_func": "def g(arr=[1, 2, 3, 4, 5, 6]):\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or to the right.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 341, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or to the right.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    return dp[n-1][m-1]", "solution_func": "def g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[n-1]\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(*g()) == 9\n", "emb": null, "idx_generation": 341, "target_skills": [0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[n-1]", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value of 9. Their indices in the list are 0 and 1, respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value of 9. Their indices in the list are 0 and 1, respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS) in the list.\n    An increasing subsequence is a sequence of numbers in the list where the numbers are in increasing order,\n    but not necessarily contiguous.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in the list is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS) in the list.\n    An increasing subsequence is a sequence of numbers in the list where the numbers are in increasing order,\n    but not necessarily contiguous.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in the list is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Each 1 represents a cell that can be traversed, while each 0 represents a wall that cannot be traversed.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\n    The shortest path from the top-left corner (0, 0) to the bottom-right corner (3, 3) has a length of 6 units.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Each 1 represents a cell that can be traversed, while each 0 represents a wall that cannot be traversed.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\n    The shortest path from the top-left corner (0, 0) to the bottom-right corner (3, 3) has a length of 6 units.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n    \n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle that can be formed\n    by connecting adjacent buildings.\n\n    Example:\n    Input: [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The maximum area of a rectangle that can be formed is 10, which is formed by the buildings with heights 5 and 6.\n\n    Hint: Use stack to solve this problem.\n    \"\"\"\n\n    heights.append(0)\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 341, "target_skills": [0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle that can be formed\n    by connecting adjacent buildings.\n\n    Example:\n    Input: [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The maximum area of a rectangle that can be formed is 10, which is formed by the buildings with heights 5 and 6.\n\n    Hint: Use stack to solve this problem.\n    \"\"\"\n\n    heights.append(0)\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    return max_area", "solution_func": "def g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of possible combinations that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 341, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of possible combinations that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the minimum number of steps required to make the sum of the list equal to the target.\n    Each step consists of either adding or subtracting a number from the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n\n    Output:\n    3\n\n    Explanation:\n    One possible solution is to subtract 1, subtract 2, and add 3 to the list, resulting in [2, 3, 4, 5] with a sum of 10.\n    \"\"\"\n\n    def backtrack(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            return abs(target - current_sum)\n        add = backtrack(index + 1, current_sum + nums[index])\n        subtract = backtrack(index + 1, current_sum - nums[index])\n        return min(add, subtract)\n    \n    return backtrack(0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 341, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the minimum number of steps required to make the sum of the list equal to the target.\n    Each step consists of either adding or subtracting a number from the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n\n    Output:\n    3\n\n    Explanation:\n    One possible solution is to subtract 1, subtract 2, and add 3 to the list, resulting in [2, 3, 4, 5] with a sum of 10.\n    \"\"\"\n\n    def backtrack(index: int, current_sum: int) -> int:\n        if index == len(nums):\n            return abs(target - current_sum)\n        add = backtrack(index + 1, current_sum + nums[index])\n        subtract = backtrack(index + 1, current_sum - nums[index])\n        return min(add, subtract)\n    \n    return backtrack(0, 0)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the prime numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    output: 17 (2 + 3 + 5 + 7)\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return sum(num for num in nums if is_prime(num))\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> List[int]:\n    return nums\n\nassert f(g()) == 17\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the prime numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    output: 17 (2 + 3 + 5 + 7)\n    \"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return sum(num for num in nums if is_prime(num))", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) -> List[int]:\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in increasing order of the number of vowels in each string.\n\n    Example:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    output: [\"date\", \"apple\", \"banana\", \"cherry\"]\n    \"\"\"\n    def count_vowels(s):\n        vowels = \"aeiouAEIOU\"\n        return sum(1 for char in s if char in vowels)\n    \n    return sorted(strings, key=count_vowels)\n\ndef g() -> List[str]:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    return strings\n\nassert f(g()) == [\"date\", \"apple\", \"banana\", \"cherry\"]\n\n", "emb": null, "idx_generation": 342, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in increasing order of the number of vowels in each string.\n\n    Example:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    output: [\"date\", \"apple\", \"banana\", \"cherry\"]\n    \"\"\"\n    def count_vowels(s):\n        vowels = \"aeiouAEIOU\"\n        return sum(1 for char in s if char in vowels)\n    \n    return sorted(strings, key=count_vowels)", "solution_func": "def g() -> List[str]:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    return strings", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in increasing order of the number of unique characters in each string.\n\n    Example:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    output: [\"apple\", \"date\", \"banana\", \"cherry\"]\n    \"\"\"\n    def count_unique_chars(s):\n        return len(set(s))\n    \n    return sorted(strings, key=count_unique_chars)\n\ndef g() -> List[str]:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    return strings\n\nassert f(g()) == [\"apple\", \"date\", \"banana\", \"cherry\"]\n\n", "emb": null, "idx_generation": 342, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return the list sorted in increasing order of the number of unique characters in each string.\n\n    Example:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    output: [\"apple\", \"date\", \"banana\", \"cherry\"]\n    \"\"\"\n    def count_unique_chars(s):\n        return len(set(s))\n    \n    return sorted(strings, key=count_unique_chars)", "solution_func": "def g() -> List[str]:\n    strings = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    return strings", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, num_list: List[int]) -> bool:\n    \"\"\"\n    Given a target number n and a list of positive integers, determine if it is possible to reach the target number by\n    combining the integers in the list using addition, subtraction, multiplication, and division.\n\n    Return True if it is possible to reach the target number, False otherwise.\n\n    Example:\n    n = 10\n    num_list = [1, 2, 3, 4]\n\n    Possible combinations:\n    1 + 2 + 3 + 4 = 10\n    1 * 2 * 3 + 4 = 10\n\n    So, f(n, num_list) should return True.\n    \"\"\"\n    def dfs(curr: int, idx: int) -> bool:\n        if curr == n:\n            return True\n        if idx == len(num_list):\n            return False\n\n        if dfs(curr + num_list[idx], idx + 1):\n            return True\n        if dfs(curr - num_list[idx], idx + 1):\n            return True\n        if dfs(curr * num_list[idx], idx + 1):\n            return True\n        if curr % num_list[idx] == 0 and dfs(curr // num_list[idx], idx + 1):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a target number n and a list of positive integers.\n    \"\"\"\n    n = 10\n    num_list = [1, 2, 3, 4]\n    return n, num_list\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 342, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, num_list: List[int]) -> bool:\n    \"\"\"\n    Given a target number n and a list of positive integers, determine if it is possible to reach the target number by\n    combining the integers in the list using addition, subtraction, multiplication, and division.\n\n    Return True if it is possible to reach the target number, False otherwise.\n\n    Example:\n    n = 10\n    num_list = [1, 2, 3, 4]\n\n    Possible combinations:\n    1 + 2 + 3 + 4 = 10\n    1 * 2 * 3 + 4 = 10\n\n    So, f(n, num_list) should return True.\n    \"\"\"\n    def dfs(curr: int, idx: int) -> bool:\n        if curr == n:\n            return True\n        if idx == len(num_list):\n            return False\n\n        if dfs(curr + num_list[idx], idx + 1):\n            return True\n        if dfs(curr - num_list[idx], idx + 1):\n            return True\n        if dfs(curr * num_list[idx], idx + 1):\n            return True\n        if curr % num_list[idx] == 0 and dfs(curr // num_list[idx], idx + 1):\n            return True\n\n        return False\n\n    return dfs(0, 0)", "solution_func": "def g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a target number n and a list of positive integers.\n    \"\"\"\n    n = 10\n    num_list = [1, 2, 3, 4]\n    return n, num_list", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner\n    such that the sum of numbers along the path is a prime number.\n\n    Return True if such a path exists, False otherwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Possible path: 1 -> 2 -> 3 -> 6 -> 9\n\n    So, f(matrix) should return True.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def dfs(row: int, col: int, curr_sum: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return is_prime(curr_sum + matrix[row][col])\n\n        if row < len(matrix) - 1 and dfs(row + 1, col, curr_sum + matrix[row][col]):\n            return True\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, curr_sum + matrix[row][col]):\n            return True\n\n        return False\n\n    return dfs(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 342, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner\n    such that the sum of numbers along the path is a prime number.\n\n    Return True if such a path exists, False otherwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Possible path: 1 -> 2 -> 3 -> 6 -> 9\n\n    So, f(matrix) should return True.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def dfs(row: int, col: int, curr_sum: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return is_prime(curr_sum + matrix[row][col])\n\n        if row < len(matrix) - 1 and dfs(row + 1, col, curr_sum + matrix[row][col]):\n            return True\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, curr_sum + matrix[row][col]):\n            return True\n\n        return False\n\n    return dfs(0, 0, 0)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of ways to choose k items from n distinct items.\n\n    Example:\n    n = 5, k = 3\n\n    Possible combinations: (5, 4, 3), (5, 4, 2), (5, 4, 1), (5, 3, 2), (5, 3, 1), (5, 2, 1), (4, 3, 2), (4, 3, 1), (4, 2, 1), (3, 2, 1)\n\n    So, f(n, k) should return 10.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of ways to choose k items from n distinct items.\n\n    Example:\n    n = 5, k = 3\n\n    Possible combinations: (5, 4, 3), (5, 4, 2), (5, 4, 1), (5, 3, 2), (5, 3, 1), (5, 2, 1), (4, 3, 2), (4, 3, 1), (4, 2, 1), (3, 2, 1)\n\n    So, f(n, k) should return 10.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of all the even numbers in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of the squares of all the even numbers in the list.\n    \"\"\"\n    even_nums = [num for num in nums if num % 2 == 0]\n    return sum([num**2 for num in even_nums])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 120\n", "emb": null, "idx_generation": 342, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of all the even numbers in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of the squares of all the even numbers in the list.\n    \"\"\"\n    even_nums = [num for num in nums if num % 2 == 0]\n    return sum([num**2 for num in even_nums])", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum value that can be obtained by XORing any two elements in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum value that can be obtained by XORing any two elements in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of the corresponding element and its index.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    List[int]: The new list where each element is the sum of the corresponding element and its index.\n    \"\"\"\n    return [num + i for i, num in enumerate(nums)]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 5, 7, 9]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 342, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of the corresponding element and its index.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    List[int]: The new list where each element is the sum of the corresponding element and its index.\n    \"\"\"\n    return [num + i for i, num in enumerate(nums)]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n    Return the count of distinct pairs.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The distinct pairs (i, j) satisfying the condition are (1, 3) and (2, 4).\n    The sum of nums[1] + nums[3] = 2 + 4 = 6, which is divisible by 3.\n    The sum of nums[2] + nums[4] = 3 + 5 = 8, which is not divisible by 3.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    modulo_counts = [0] * 3\n\n    for num in nums:\n        modulo = num % 3\n        modulo_counts[modulo] += 1\n\n    count += (modulo_counts[0] * (modulo_counts[0] - 1)) // 2\n    count += modulo_counts[1] * modulo_counts[2]\n\n    return count\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 342, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n    Return the count of distinct pairs.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The distinct pairs (i, j) satisfying the condition are (1, 3) and (2, 4).\n    The sum of nums[1] + nums[3] = 2 + 4 = 6, which is divisible by 3.\n    The sum of nums[2] + nums[4] = 3 + 5 = 8, which is not divisible by 3.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    modulo_counts = [0] * 3\n\n    for num in nums:\n        modulo = num % 3\n        modulo_counts[modulo] += 1\n\n    count += (modulo_counts[0] * (modulo_counts[0] - 1)) // 2\n    count += modulo_counts[1] * modulo_counts[2]\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, m: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the number of ways to represent n as a sum of k positive integers such that each\n    number is at least m.\n\n    For example, f(5, 3, 1) would return 6, as there are 6 ways to represent 5 as a sum of 3 positive integers greater\n    than or equal to 1: [1, 1, 3], [1, 2, 2], [1, 3, 1], [2, 1, 2], [2, 2, 1], [3, 1, 1].\n    \"\"\"\n    def calculate_combinations(n, k, m, curr_sum, curr_nums):\n        if curr_sum == n and len(curr_nums) == k:\n            return 1\n        if curr_sum > n or len(curr_nums) == k:\n            return 0\n        count = 0\n        for i in range(m, n + 1):\n            count += calculate_combinations(n, k, m, curr_sum + i, curr_nums + [i])\n        return count\n\n    return calculate_combinations(n, k, m, 0, []) == n\ndef g(n = 5, k = 3, m = 1):\n    return n\nassert f(g())\n", "emb": null, "idx_generation": 343, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int, m: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the number of ways to represent n as a sum of k positive integers such that each\n    number is at least m.\n\n    For example, f(5, 3, 1) would return 6, as there are 6 ways to represent 5 as a sum of 3 positive integers greater\n    than or equal to 1: [1, 1, 3], [1, 2, 2], [1, 3, 1], [2, 1, 2], [2, 2, 1], [3, 1, 1].\n    \"\"\"\n    def calculate_combinations(n, k, m, curr_sum, curr_nums):\n        if curr_sum == n and len(curr_nums) == k:\n            return 1\n        if curr_sum > n or len(curr_nums) == k:\n            return 0\n        count = 0\n        for i in range(m, n + 1):\n            count += calculate_combinations(n, k, m, curr_sum + i, curr_nums + [i])\n        return count\n\n    return calculate_combinations(n, k, m, 0, []) == n", "solution_func": "def g(n = 5, k = 3, m = 1):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(adjacency_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains a cycle.\n\n    The adjacency matrix is a square matrix where adjacency_matrix[i][j] = 1 if there is an edge from vertex i to vertex j,\n    and adjacency_matrix[i][j] = 0 otherwise.\n\n    For example, given the adjacency matrix [[0, 1, 0], [0, 0, 1], [1, 0, 0]], the graph contains a cycle and the function\n    should return True.\n    \"\"\"\n    def dfs(graph, visited, current, parent):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if visited[neighbor] and neighbor != parent:\n                return True\n            if not visited[neighbor] and dfs(graph, visited, neighbor, current):\n                return True\n        return False\n\n    n = len(adjacency_matrix)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if adjacency_matrix[i][j] == 1:\n                graph[i].append(j)\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i] and dfs(graph, visited, i, -1):\n            return True\n    return False\ndef g(adjacency_matrix = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]):\n    return adjacency_matrix\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(adjacency_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains a cycle.\n\n    The adjacency matrix is a square matrix where adjacency_matrix[i][j] = 1 if there is an edge from vertex i to vertex j,\n    and adjacency_matrix[i][j] = 0 otherwise.\n\n    For example, given the adjacency matrix [[0, 1, 0], [0, 0, 1], [1, 0, 0]], the graph contains a cycle and the function\n    should return True.\n    \"\"\"\n    def dfs(graph, visited, current, parent):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if visited[neighbor] and neighbor != parent:\n                return True\n            if not visited[neighbor] and dfs(graph, visited, neighbor, current):\n                return True\n        return False\n\n    n = len(adjacency_matrix)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if adjacency_matrix[i][j] == 1:\n                graph[i].append(j)\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i] and dfs(graph, visited, i, -1):\n            return True\n    return False", "solution_func": "def g(adjacency_matrix = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]):\n    return adjacency_matrix", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t can be obtained by performing the following operations on s:\n    - Append the same letter to the end of s.\n    - Remove any letter from s.\n    - Replace any letter in s with a different letter.\n\n    If it is possible to obtain t from s, return True. Otherwise, return False.\n\n    For example, f(\"abc\", \"abac\") would return True, as we can obtain \"abac\" from \"abc\" by appending 'a' and 'c'.\n    \"\"\"\n    def is_one_edit_away(s, t):\n        if abs(len(s) - len(t)) > 1:\n            return False\n        if len(s) < len(t):\n            s, t = t, s\n        i, j = 0, 0\n        diff_found = False\n        while i < len(s) and j < len(t):\n            if s[i] != t[j]:\n                if diff_found:\n                    return False\n                diff_found = True\n                if len(s) == len(t):\n                    j += 1\n            else:\n                j += 1\n            i += 1\n        return True\n\n    if len(s) > len(t):\n        s, t = t, s\n    if len(t) - len(s) == 1:\n        for i in range(len(t)):\n            if is_one_edit_away(s, t[:i] + t[i + 1:]):\n                return True\n    elif len(t) == len(s):\n        return is_one_edit_away(s, t)\n    return False\ndef g(s = \"abc\", t = \"abac\"):\n    return s, t\nassert f(g())\n", "emb": null, "idx_generation": 343, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t can be obtained by performing the following operations on s:\n    - Append the same letter to the end of s.\n    - Remove any letter from s.\n    - Replace any letter in s with a different letter.\n\n    If it is possible to obtain t from s, return True. Otherwise, return False.\n\n    For example, f(\"abc\", \"abac\") would return True, as we can obtain \"abac\" from \"abc\" by appending 'a' and 'c'.\n    \"\"\"\n    def is_one_edit_away(s, t):\n        if abs(len(s) - len(t)) > 1:\n            return False\n        if len(s) < len(t):\n            s, t = t, s\n        i, j = 0, 0\n        diff_found = False\n        while i < len(s) and j < len(t):\n            if s[i] != t[j]:\n                if diff_found:\n                    return False\n                diff_found = True\n                if len(s) == len(t):\n                    j += 1\n            else:\n                j += 1\n            i += 1\n        return True\n\n    if len(s) > len(t):\n        s, t = t, s\n    if len(t) - len(s) == 1:\n        for i in range(len(t)):\n            if is_one_edit_away(s, t[:i] + t[i + 1:]):\n                return True\n    elif len(t) == len(s):\n        return is_one_edit_away(s, t)\n    return False", "solution_func": "def g(s = \"abc\", t = \"abac\"):\n    return s, t", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subset of nums such that the bitwise XOR of all its elements is equal to k.\n    \"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if len(subset) > 0 and reduce(lambda x, y: x ^ y, subset) == k:\n            return True\n    return False\n\ndef g(k=6):\n    \"\"\"\n    Find a list of distinct positive integers that have a bitwise XOR equal to k.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 6)\n", "emb": null, "idx_generation": 343, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subset of nums such that the bitwise XOR of all its elements is equal to k.\n    \"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if len(subset) > 0 and reduce(lambda x, y: x ^ y, subset) == k:\n            return True\n    return False", "solution_func": "def g(k=6):\n    \"\"\"\n    Find a list of distinct positive integers that have a bitwise XOR equal to k.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    \"\"\"\n    Find a perfect square number.\n    \"\"\"\n    return 16\n\nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False", "solution_func": "def g():\n    \"\"\"\n    Find a perfect square number.\n    \"\"\"\n    return 16", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the sum of its elements is equal to the target.\n    \"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if len(subset) > 0 and sum(subset) == target:\n            return True\n    return False\n\ndef g(target=7):\n    \"\"\"\n    Find a list of distinct positive integers that have a sum equal to the target.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g(), 7)\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the sum of its elements is equal to the target.\n    \"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if len(subset) > 0 and sum(subset) == target:\n            return True\n    return False", "solution_func": "def g(target=7):\n    \"\"\"\n    Find a list of distinct positive integers that have a sum equal to the target.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner of a grid of size n x n. You can only move\n    down or to the right.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2) in a 3x3 grid.\n\n    Input: 4\n    Output: 20\n    Explanation: There are 20 unique paths from (0, 0) to (3, 3) in a 4x4 grid.\n    \"\"\"\n\n    def dfs(i: int, j: int, memo: List[List[int]]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo)\n        return memo[i][j]\n\n    memo = [[0] * n for _ in range(n)]\n    return dfs(n - 1, n - 1, memo)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner of a grid of size n x n. You can only move\n    down or to the right.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2) in a 3x3 grid.\n\n    Input: 4\n    Output: 20\n    Explanation: There are 20 unique paths from (0, 0) to (3, 3) in a 4x4 grid.\n    \"\"\"\n\n    def dfs(i: int, j: int, memo: List[List[int]]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo)\n        return memo[i][j]\n\n    memo = [[0] * n for _ in range(n)]\n    return dfs(n - 1, n - 1, memo)", "solution_func": "def g():\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner of a grid of size n x 2. You can only move\n    down or to the right.\n\n    Example:\n    Input: 3\n    Output: 3\n    Explanation: There are 3 unique paths from (0, 0) to (2, 1) in a 3x2 grid.\n\n    Input: 4\n    Output: 5\n    Explanation: There are 5 unique paths from (0, 0) to (3, 1) in a 4x2 grid.\n    \"\"\"\n\n    def dfs(i: int, j: int, memo: List[List[int]]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo)\n        return memo[i][j]\n\n    memo = [[0] * 2 for _ in range(n + 1)]\n    return dfs(n, 1, memo)\n\ndef g():\n    return 3\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 343, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner of a grid of size n x 2. You can only move\n    down or to the right.\n\n    Example:\n    Input: 3\n    Output: 3\n    Explanation: There are 3 unique paths from (0, 0) to (2, 1) in a 3x2 grid.\n\n    Input: 4\n    Output: 5\n    Explanation: There are 5 unique paths from (0, 0) to (3, 1) in a 4x2 grid.\n    \"\"\"\n\n    def dfs(i: int, j: int, memo: List[List[int]]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo)\n        return memo[i][j]\n\n    memo = [[0] * 2 for _ in range(n + 1)]\n    return dfs(n, 1, memo)", "solution_func": "def g():\n    return 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner of a grid of size n x 2. You can only move\n    down or to the right. Additionally, there are obstacles in some cells denoted by 1.\n\n    Example:\n    Input: [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    Output: 2\n    Explanation: There are 2 unique paths from (0, 0) to (2, 1) in a 3x2 grid with an obstacle at (1, 1).\n\n    Input: [[0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 1, 0]]\n    Output: 1\n    Explanation: There is 1 unique path from (0, 0) to (3, 1) in a 4x2 grid with obstacles at (1, 1) and (3, 1).\n    \"\"\"\n\n    def dfs(i: int, j: int, memo: List[List[int]]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        if grid[i][j] == 1:\n            return 0\n        memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo)\n        return memo[i][j]\n\n    grid = [[0] * 2 for _ in range(n + 1)]\n    return dfs(n, 1, grid)\n\ndef g():\n    return 3\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 343, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner of a grid of size n x 2. You can only move\n    down or to the right. Additionally, there are obstacles in some cells denoted by 1.\n\n    Example:\n    Input: [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    Output: 2\n    Explanation: There are 2 unique paths from (0, 0) to (2, 1) in a 3x2 grid with an obstacle at (1, 1).\n\n    Input: [[0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 1, 0]]\n    Output: 1\n    Explanation: There is 1 unique path from (0, 0) to (3, 1) in a 4x2 grid with obstacles at (1, 1) and (3, 1).\n    \"\"\"\n\n    def dfs(i: int, j: int, memo: List[List[int]]) -> int:\n        if i == 0 or j == 0:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        if grid[i][j] == 1:\n            return 0\n        memo[i][j] = dfs(i - 1, j, memo) + dfs(i, j - 1, memo)\n        return memo[i][j]\n\n    grid = [[0] * 2 for _ in range(n + 1)]\n    return dfs(n, 1, grid)", "solution_func": "def g():\n    return 3", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find all unique combinations in nums where the numbers sum\n    to target. The same number may be chosen from nums an unlimited number of times. A combination should not contain\n    the same number twice, and the combinations should be returned in ascending order.\n\n    Example:\n    Input: nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    Note:\n    - All numbers (including target) will be positive integers.\n    - The solution set must not contain duplicate combinations.\n    - The order of combinations does not matter.\n    \"\"\"\n\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, path + [nums[i]], curr_sum + nums[i])\n\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g(nums = [2,3,6,7], target = 7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 343, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find all unique combinations in nums where the numbers sum\n    to target. The same number may be chosen from nums an unlimited number of times. A combination should not contain\n    the same number twice, and the combinations should be returned in ascending order.\n\n    Example:\n    Input: nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    Note:\n    - All numbers (including target) will be positive integers.\n    - The solution set must not contain duplicate combinations.\n    - The order of combinations does not matter.\n    \"\"\"\n\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, path + [nums[i]], curr_sum + nums[i])\n\n    result = []\n    backtrack(0, [], 0)\n    return result", "solution_func": "def g(nums = [2,3,6,7], target = 7):\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 6, -1]\n    \n    The contiguous subarray with the maximum sum is [3, 4, -5, 6], with a sum of 8.\n    \n    Therefore, the function should return 8.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n\ndef g() -> List[int]:\n    nums = [1, -2, 3, 4, -5, 6, -1]\n    return nums\n\n\nassert f(*g()) == 8\n", "emb": null, "idx_generation": 344, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 6, -1]\n    \n    The contiguous subarray with the maximum sum is [3, 4, -5, 6], with a sum of 8.\n    \n    Therefore, the function should return 8.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [1, -2, 3, 4, -5, 6, -1]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The pair of numbers that sum up to 9 is [2, 7].\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 344, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The pair of numbers that sum up to 9 is [2, 7].\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the indices of three numbers that sum up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n\n    The indices of the three numbers that sum up to 9 are [1, 2, 4].\n\n    Therefore, the function should return [1, 2, 4].\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return [i, left, right]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return []\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [1, 2, 4]\n", "emb": null, "idx_generation": 344, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the indices of three numbers that sum up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n\n    The indices of the three numbers that sum up to 9 are [1, 2, 4].\n\n    Therefore, the function should return [1, 2, 4].\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == target:\n                return [i, left, right]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return []", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The distinct pairs that sum up to a number divisible by 3 are:\n    (1, 2), (1, 5), (2, 4), (3, 6), (4, 5), (5, 6)\n\n    Therefore, the function should return 6.\n    \"\"\"\n    count = 0\n    freq = [0] * 3\n\n    for num in nums:\n        freq[num % 3] += 1\n\n    count += (freq[0] * (freq[0] - 1)) // 2  # Count pairs of numbers divisible by 3\n    count += freq[1] * freq[2]  # Count pairs of numbers where a % 3 = 1 and b % 3 = 2\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 344, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs (a, b) such that a + b is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The distinct pairs that sum up to a number divisible by 3 are:\n    (1, 2), (1, 5), (2, 4), (3, 6), (4, 5), (5, 6)\n\n    Therefore, the function should return 6.\n    \"\"\"\n    count = 0\n    freq = [0] * 3\n\n    for num in nums:\n        freq[num % 3] += 1\n\n    count += (freq[0] * (freq[0] - 1)) // 2  # Count pairs of numbers divisible by 3\n    count += freq[1] * freq[2]  # Count pairs of numbers where a % 3 = 1 and b % 3 = 2\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest subarray with an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 0, 1, 1, 0]\n\n    The longest subarray with an equal number of 0s and 1s is [0, 1, 0, 0, 1, 1], which has a length of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    count = 0\n    max_length = 0\n    count_dict = {0: -1}\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            count -= 1\n        else:\n            count += 1\n        \n        if count in count_dict:\n            max_length = max(max_length, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    \n    return max_length\n\ndef g() -> List[int]:\n    nums = [0, 1, 0, 0, 1, 1, 0]\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 344, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest subarray with an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 0, 1, 1, 0]\n\n    The longest subarray with an equal number of 0s and 1s is [0, 1, 0, 0, 1, 1], which has a length of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    count = 0\n    max_length = 0\n    count_dict = {0: -1}\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            count -= 1\n        else:\n            count += 1\n        \n        if count in count_dict:\n            max_length = max(max_length, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    \n    return max_length", "solution_func": "def g() -> List[int]:\n    nums = [0, 1, 0, 0, 1, 1, 0]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-10, -2, 3, 4, 5]\n\n    The maximum product of any three numbers is (-10) * (-2) * 5 = 100.\n\n    Therefore, the function should return 100.\n    \"\"\"\n    max_product = float('-inf')\n    min1 = float('inf')\n    min2 = float('inf')\n    max1 = float('-inf')\n    max2 = float('-inf')\n    max3 = float('-inf')\n    \n    for num in nums:\n        if num <= min1:\n            min2 = min1\n            min1 = num\n        elif num <= min2:\n            min2 = num\n        \n        if num >= max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num >= max2:\n            max3 = max2\n            max2 = num\n        elif num >= max3:\n            max3 = num\n    \n    max_product = max(min1 * min2 * max1, max1 * max2 * max3)\n    \n    return max_product\n\ndef g() -> List[int]:\n    nums = [-10, -2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 100\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [-10, -2, 3, 4, 5]\n\n    The maximum product of any three numbers is (-10) * (-2) * 5 = 100.\n\n    Therefore, the function should return 100.\n    \"\"\"\n    max_product = float('-inf')\n    min1 = float('inf')\n    min2 = float('inf')\n    max1 = float('-inf')\n    max2 = float('-inf')\n    max3 = float('-inf')\n    \n    for num in nums:\n        if num <= min1:\n            min2 = min1\n            min1 = num\n        elif num <= min2:\n            min2 = num\n        \n        if num >= max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num >= max2:\n            max3 = max2\n            max2 = num\n        elif num >= max3:\n            max3 = num\n    \n    max_product = max(min1 * min2 * max1, max1 * max2 * max3)\n    \n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [-10, -2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value can be achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value between any two numbers is known to be 28.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value can be achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value between any two numbers is known to be 28.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 5, 2, -2, -6, 3]\n    Output: 60\n\n    Explanation:\n    The maximum product can be achieved by multiplying 5, -2, and -6, which gives 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum product of any three numbers is known to be 60.\n    \"\"\"\n    return [1, 5, 2, -2, -6, 3]\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 5, 2, -2, -6, 3]\n    Output: 60\n\n    Explanation:\n    The maximum product can be achieved by multiplying 5, -2, and -6, which gives 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum product of any three numbers is known to be 60.\n    \"\"\"\n    return [1, 5, 2, -2, -6, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the height of each person in a queue, determine the number of people who are not observing the correct order.\n\n    A person is not observing the correct order if they are shorter than any person standing in front of them.\n\n    Example:\n    Input: [7, 2, 4, 6, 3, 1]\n    Output: 5\n\n    Explanation:\n    There are 5 people who are not observing the correct order: 2, 4, 6, 3, and 1.\n    \"\"\"\n    n = len(heights)\n    count = 0\n    max_height = 0\n    for i in range(n):\n        if heights[i] > max_height:\n            max_height = heights[i]\n        else:\n            count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of heights where the number of people not observing the correct order is known to be 5.\n    \"\"\"\n    return [7, 2, 4, 6, 3, 1]\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the height of each person in a queue, determine the number of people who are not observing the correct order.\n\n    A person is not observing the correct order if they are shorter than any person standing in front of them.\n\n    Example:\n    Input: [7, 2, 4, 6, 3, 1]\n    Output: 5\n\n    Explanation:\n    There are 5 people who are not observing the correct order: 2, 4, 6, 3, and 1.\n    \"\"\"\n    n = len(heights)\n    count = 0\n    max_height = 0\n    for i in range(n):\n        if heights[i] > max_height:\n            max_height = heights[i]\n        else:\n            count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of heights where the number of people not observing the correct order is known to be 5.\n    \"\"\"\n    return [7, 2, 4, 6, 3, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, check if the target number exists in the list using binary search.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False\n\ndef g(target=5):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g(), target=5) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 344, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, check if the target number exists in the list using binary search.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return False", "solution_func": "def g(target=5):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there is a subsequence of elements in the list that adds up to the target.\n    Return True if such subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)\n\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there is a subsequence of elements in the list that adds up to the target.\n    Return True if such subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find all combinations of k numbers in the list that add up to the target.\n    Return a list of lists containing the combinations.\n    \"\"\"\n    def backtrack(start: int, remain: int, path: List[int]) -> None:\n        if remain == 0 and len(path) == k:\n            combinations.append(path)\n            return\n        if remain < 0 or len(path) > k:\n            return\n\n        for i in range(start, len(nums)):\n            backtrack(i + 1, remain - nums[i], path + [nums[i]])\n\n    combinations = []\n    backtrack(0, target, [])\n    return combinations\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    k = 2\n    return (nums, target, k)\n\n\nassert f(*g()) == [[2, 5], [3, 4]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find all combinations of k numbers in the list that add up to the target.\n    Return a list of lists containing the combinations.\n    \"\"\"\n    def backtrack(start: int, remain: int, path: List[int]) -> None:\n        if remain == 0 and len(path) == k:\n            combinations.append(path)\n            return\n        if remain < 0 or len(path) > k:\n            return\n\n        for i in range(start, len(nums)):\n            backtrack(i + 1, remain - nums[i], path + [nums[i]])\n\n    combinations = []\n    backtrack(0, target, [])\n    return combinations", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    k = 2\n    return (nums, target, k)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, element):\n        self.queue.append(element)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.queue.pop(0)\n        else:\n            return None\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target integer, determine if the target exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and top to bottom.\n    Return True if the target is found, False otherwise.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    queue = Queue()\n    queue.enqueue((0, n - 1))\n\n    while not queue.is_empty():\n        row, col = queue.dequeue()\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            if row + 1 < m:\n                queue.enqueue((row + 1, col))\n            if col - 1 >= 0:\n                queue.enqueue((row, col - 1))\n\n    return False\n\n\ndef g():\n    matrix = [[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12]]\n    target = 6\n    return (matrix, target)\n\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 345, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\nclass Queue:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, element):\n        self.queue.append(element)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.queue.pop(0)\n        else:\n            return None\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target integer, determine if the target exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and top to bottom.\n    Return True if the target is found, False otherwise.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    queue = Queue()\n    queue.enqueue((0, n - 1))\n\n    while not queue.is_empty():\n        row, col = queue.dequeue()\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            if row + 1 < m:\n                queue.enqueue((row + 1, col))\n            if col - 1 >= 0:\n                queue.enqueue((row, col - 1))\n\n    return False", "solution_func": "def g():\n    matrix = [[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12]]\n    target = 6\n    return (matrix, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(tree: Dict[str, List[str]], start: str, target: str) -> bool:\n    \"\"\"\n    Given a tree represented as a dictionary where the keys are the nodes and the values\n    are lists of adjacent nodes, check if there exists a path from the start node to the\n    target node.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(tree[node])\n    \n    return False\n\ndef g():\n    tree = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['G'],\n        'F': [],\n        'G': []\n    }\n    start = 'A'\n    target = 'G'\n    return tree, start, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 345, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(tree: Dict[str, List[str]], start: str, target: str) -> bool:\n    \"\"\"\n    Given a tree represented as a dictionary where the keys are the nodes and the values\n    are lists of adjacent nodes, check if there exists a path from the start node to the\n    target node.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(tree[node])\n    \n    return False", "solution_func": "def g():\n    tree = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['G'],\n        'F': [],\n        'G': []\n    }\n    start = 'A'\n    target = 'G'\n    return tree, start, target", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(string: str, target: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be transformed into the target string by\n    performing a series of operations. Each operation involves removing a character\n    from the string.\n\n    Return True if the string can be transformed into the target string, False otherwise.\n    \"\"\"\n    stack = list(string)\n\n    for char in target:\n        if char not in stack:\n            return False\n        stack.remove(char)\n    \n    return True\n\ndef g():\n    string = \"abracadabra\"\n    target = \"acadabra\"\n    return string, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 345, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(string: str, target: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be transformed into the target string by\n    performing a series of operations. Each operation involves removing a character\n    from the string.\n\n    Return True if the string can be transformed into the target string, False otherwise.\n    \"\"\"\n    stack = list(string)\n\n    for char in target:\n        if char not in stack:\n            return False\n        stack.remove(char)\n    \n    return True", "solution_func": "def g():\n    string = \"abracadabra\"\n    target = \"acadabra\"\n    return string, target", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(queue: List[str], target: str) -> bool:\n    \"\"\"\n    Given a queue represented as a list of strings and a target string, check if the\n    target string can be generated by performing a series of operations on the queue.\n    Each operation involves removing the first element from the queue.\n\n    Return True if the target string can be generated, False otherwise.\n    \"\"\"\n    for char in target:\n        if not queue or queue[0] != char:\n            return False\n        queue.pop(0)\n    \n    return True\n\ndef g():\n    queue = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    target = \"abcde\"\n    return queue, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(queue: List[str], target: str) -> bool:\n    \"\"\"\n    Given a queue represented as a list of strings and a target string, check if the\n    target string can be generated by performing a series of operations on the queue.\n    Each operation involves removing the first element from the queue.\n\n    Return True if the target string can be generated, False otherwise.\n    \"\"\"\n    for char in target:\n        if not queue or queue[0] != char:\n            return False\n        queue.pop(0)\n    \n    return True", "solution_func": "def g():\n    queue = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    target = \"abcde\"\n    return queue, target", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine if the graph is bipartite.\n\n    A graph is bipartite if it can be divided into two sets of vertices, such that no two vertices in the same set are adjacent.\n\n    Example:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    output: True\n    Explanation: The given graph is bipartite as it can be divided into two sets {0, 2} and {1}.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    n = len(graph)\n    colors = [-1] * n\n\n    def is_bipartite(node, color):\n        colors[node] = color\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == '1':\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == -1 and not is_bipartite(neighbor, 1 - color):\n                    return False\n\n        return True\n\n    for node in range(n):\n        if colors[node] == -1 and not is_bipartite(node, 0):\n            return False\n\n    return True\n\n\ndef g() -> List[List[str]]:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    return graph\n\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine if the graph is bipartite.\n\n    A graph is bipartite if it can be divided into two sets of vertices, such that no two vertices in the same set are adjacent.\n\n    Example:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    output: True\n    Explanation: The given graph is bipartite as it can be divided into two sets {0, 2} and {1}.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    n = len(graph)\n    colors = [-1] * n\n\n    def is_bipartite(node, color):\n        colors[node] = color\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == '1':\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == -1 and not is_bipartite(neighbor, 1 - color):\n                    return False\n\n        return True\n\n    for node in range(n):\n        if colors[node] == -1 and not is_bipartite(node, 0):\n            return False\n\n    return True", "solution_func": "def g() -> List[List[str]]:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every pair of vertices is connected by a path.\n\n    Example:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    output: 1\n    Explanation: The given graph has only one connected component.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == '1' and not visited[neighbor]:\n                dfs(neighbor)\n\n    for node in range(n):\n        if not visited[node]:\n            count += 1\n            dfs(node)\n\n    return count\n\n\ndef g() -> List[List[str]]:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    return graph\n\n\nassert f(g()) == 1\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every pair of vertices is connected by a path.\n\n    Example:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    output: 1\n    Explanation: The given graph has only one connected component.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == '1' and not visited[neighbor]:\n                dfs(neighbor)\n\n    for node in range(n):\n        if not visited[node]:\n            count += 1\n            dfs(node)\n\n    return count", "solution_func": "def g() -> List[List[str]]:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each element is the reverse of the corresponding element in the input list.\n\n    Example:\n    strings = ['hello', 'world', 'python']\n    output: ['olleh', 'dlrow', 'nohtyp']\n    \"\"\"\n    result = []\n    for string in strings:\n        result.append(string[::-1])\n    return result\n\n\ndef g() -> List[str]:\n    strings = ['hello', 'world', 'python']\n    return strings\n\n\nassert f(g()) == ['olleh', 'dlrow', 'nohtyp']\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each element is the reverse of the corresponding element in the input list.\n\n    Example:\n    strings = ['hello', 'world', 'python']\n    output: ['olleh', 'dlrow', 'nohtyp']\n    \"\"\"\n    result = []\n    for string in strings:\n        result.append(string[::-1])\n    return result", "solution_func": "def g() -> List[str]:\n    strings = ['hello', 'world', 'python']\n    return strings", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target value, determine if it is possible to choose a combination of numbers from the\n    list that sums up to the target value. Each number in the list can be used multiple times.\n    \"\"\"\n    def can_sum(target: int, nums: List[int], memo: dict) -> bool:\n        \"\"\"\n        Helper function that returns True if it is possible to choose a combination of numbers from the list that sums up to the\n        target value.\n        \"\"\"\n        if target in memo:\n            return memo[target]\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n        \n        for num in nums:\n            remainder = target - num\n            if can_sum(remainder, nums, memo):\n                memo[target] = True\n                return True\n        \n        memo[target] = False\n        return False\n    \n    memo = {}\n    return can_sum(target, arr, memo)\n\ndef g() -> (List[int], int):\n    arr = [2, 4, 6, 8]\n    target = 14\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 345, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target value, determine if it is possible to choose a combination of numbers from the\n    list that sums up to the target value. Each number in the list can be used multiple times.\n    \"\"\"\n    def can_sum(target: int, nums: List[int], memo: dict) -> bool:\n        \"\"\"\n        Helper function that returns True if it is possible to choose a combination of numbers from the list that sums up to the\n        target value.\n        \"\"\"\n        if target in memo:\n            return memo[target]\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n        \n        for num in nums:\n            remainder = target - num\n            if can_sum(remainder, nums, memo):\n                memo[target] = True\n                return True\n        \n        memo[target] = False\n        return False\n    \n    memo = {}\n    return can_sum(target, arr, memo)", "solution_func": "def g() -> (List[int], int):\n    arr = [2, 4, 6, 8]\n    target = 14\n    return arr, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of ways to arrange the elements such that the sum of any two adjacent elements is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    There are 10 ways to arrange the elements such that the sum of any two adjacent elements is divisible by 3: [1, 4, 2, 5, 3], [1, 4, 5, 2, 3], [2, 5, 1, 4, 3], [3, 2, 5, 1, 4], [3, 5, 1, 4, 2], [4, 1, 5, 2, 3], [4, 2, 5, 1, 3], [4, 5, 1, 2, 3], [4, 5, 2, 1, 3], [5, 2, 1, 4, 3].\n\n    Therefore, the function should return 10.\n    \"\"\"\n\n    def is_divisible_by_3(a: int, b: int) -> bool:\n        \"\"\"\n        Check if the sum of two integers is divisible by 3.\n        \"\"\"\n        return (a + b) % 3 == 0\n\n    def count_arrangements(nums: List[int], index: int, queue: List[int], memo: Dict[Tuple[int, Tuple[int]], int]) -> int:\n        \"\"\"\n        Recursively count the number of ways to arrange the elements such that the sum of any two adjacent elements is divisible by 3.\n        \"\"\"\n        if index == len(nums):\n            return 1\n        elif (index, tuple(queue)) in memo:\n            return memo[(index, tuple(queue))]\n        else:\n            count = 0\n            for i in range(len(queue)):\n                if is_divisible_by_3(queue[i], nums[index]):\n                    queue.append(nums[index])\n                    count += count_arrangements(nums, index + 1, queue, memo)\n                    queue.pop()\n            count += count_arrangements(nums, index + 1, queue + [nums[index]], memo)\n            memo[(index, tuple(queue))] = count\n            return count\n\n    memo = {}\n    return count_arrangements(nums, 0, [], memo)\n\n\ndef g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n\n    return nums\n\nassert f(g()) == 10\n\n", "emb": null, "idx_generation": 346, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of ways to arrange the elements such that the sum of any two adjacent elements is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    There are 10 ways to arrange the elements such that the sum of any two adjacent elements is divisible by 3: [1, 4, 2, 5, 3], [1, 4, 5, 2, 3], [2, 5, 1, 4, 3], [3, 2, 5, 1, 4], [3, 5, 1, 4, 2], [4, 1, 5, 2, 3], [4, 2, 5, 1, 3], [4, 5, 1, 2, 3], [4, 5, 2, 1, 3], [5, 2, 1, 4, 3].\n\n    Therefore, the function should return 10.\n    \"\"\"\n\n    def is_divisible_by_3(a: int, b: int) -> bool:\n        \"\"\"\n        Check if the sum of two integers is divisible by 3.\n        \"\"\"\n        return (a + b) % 3 == 0\n\n    def count_arrangements(nums: List[int], index: int, queue: List[int], memo: Dict[Tuple[int, Tuple[int]], int]) -> int:\n        \"\"\"\n        Recursively count the number of ways to arrange the elements such that the sum of any two adjacent elements is divisible by 3.\n        \"\"\"\n        if index == len(nums):\n            return 1\n        elif (index, tuple(queue)) in memo:\n            return memo[(index, tuple(queue))]\n        else:\n            count = 0\n            for i in range(len(queue)):\n                if is_divisible_by_3(queue[i], nums[index]):\n                    queue.append(nums[index])\n                    count += count_arrangements(nums, index + 1, queue, memo)\n                    queue.pop()\n            count += count_arrangements(nums, index + 1, queue + [nums[index]], memo)\n            memo[(index, tuple(queue))] = count\n            return count\n\n    memo = {}\n    return count_arrangements(nums, 0, [], memo)", "solution_func": "def g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, rearrange the elements such that all even numbers appear before odd numbers, while preserving their relative order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    After rearranging the elements, the list becomes [2, 4, 1, 3, 5].\n\n    Therefore, the function should return [2, 4, 1, 3, 5].\n    \"\"\"\n\n    def is_even(num: int) -> bool:\n        \"\"\"\n        Check if a number is even.\n        \"\"\"\n        return num % 2 == 0\n\n    queue = []\n    for num in nums:\n        if is_even(num):\n            queue.append(num)\n    for num in nums:\n        if not is_even(num):\n            queue.append(num)\n    return queue\n\n\ndef g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n\n    return nums\n\nassert f(g()) == [2, 4, 1, 3, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, rearrange the elements such that all even numbers appear before odd numbers, while preserving their relative order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    After rearranging the elements, the list becomes [2, 4, 1, 3, 5].\n\n    Therefore, the function should return [2, 4, 1, 3, 5].\n    \"\"\"\n\n    def is_even(num: int) -> bool:\n        \"\"\"\n        Check if a number is even.\n        \"\"\"\n        return num % 2 == 0\n\n    queue = []\n    for num in nums:\n        if is_even(num):\n            queue.append(num)\n    for num in nums:\n        if not is_even(num):\n            queue.append(num)\n    return queue", "solution_func": "def g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of ways to arrange the elements such that the product of any two adjacent elements is divisible by 6.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    There are 12 ways to arrange the elements such that the product of any two adjacent elements is divisible by 6: [1, 2, 3, 4, 5], [1, 2, 3, 5, 4], [1, 2, 4, 3, 5], [1, 2, 4, 5, 3], [1, 2, 5, 3, 4], [1, 2, 5, 4, 3], [2, 1, 3, 4, 5], [2, 1, 3, 5, 4], [2, 1, 4, 3, 5], [2, 1, 4, 5, 3], [2, 1, 5, 3, 4], [2, 1, 5, 4, 3].\n\n    Therefore, the function should return 12.\n    \"\"\"\n\n    def is_divisible_by_6(a: int, b: int) -> bool:\n        \"\"\"\n        Check if the product of two integers is divisible by 6.\n        \"\"\"\n        return (a * b) % 6 == 0\n\n    def count_arrangements(nums: List[int], index: int, queue: List[int], memo: Dict[Tuple[int, Tuple[int]], int]) -> int:\n        \"\"\"\n        Recursively count the number of ways to arrange the elements such that the product of any two adjacent elements is divisible by 6.\n        \"\"\"\n        if index == len(nums):\n            return 1\n        elif (index, tuple(queue)) in memo:\n            return memo[(index, tuple(queue))]\n        else:\n            count = 0\n            for i in range(len(queue)):\n                if is_divisible_by_6(queue[i], nums[index]):\n                    queue.append(nums[index])\n                    count += count_arrangements(nums, index + 1, queue, memo)\n                    queue.pop()\n            count += count_arrangements(nums, index + 1, queue + [nums[index]], memo)\n            memo[(index, tuple(queue))] = count\n            return count\n\n    memo = {}\n    return count_arrangements(nums, 0, [], memo)\n\n\ndef g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n\n    return nums\n\nassert f(g()) == 12\n\n", "emb": null, "idx_generation": 346, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of ways to arrange the elements such that the product of any two adjacent elements is divisible by 6.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    There are 12 ways to arrange the elements such that the product of any two adjacent elements is divisible by 6: [1, 2, 3, 4, 5], [1, 2, 3, 5, 4], [1, 2, 4, 3, 5], [1, 2, 4, 5, 3], [1, 2, 5, 3, 4], [1, 2, 5, 4, 3], [2, 1, 3, 4, 5], [2, 1, 3, 5, 4], [2, 1, 4, 3, 5], [2, 1, 4, 5, 3], [2, 1, 5, 3, 4], [2, 1, 5, 4, 3].\n\n    Therefore, the function should return 12.\n    \"\"\"\n\n    def is_divisible_by_6(a: int, b: int) -> bool:\n        \"\"\"\n        Check if the product of two integers is divisible by 6.\n        \"\"\"\n        return (a * b) % 6 == 0\n\n    def count_arrangements(nums: List[int], index: int, queue: List[int], memo: Dict[Tuple[int, Tuple[int]], int]) -> int:\n        \"\"\"\n        Recursively count the number of ways to arrange the elements such that the product of any two adjacent elements is divisible by 6.\n        \"\"\"\n        if index == len(nums):\n            return 1\n        elif (index, tuple(queue)) in memo:\n            return memo[(index, tuple(queue))]\n        else:\n            count = 0\n            for i in range(len(queue)):\n                if is_divisible_by_6(queue[i], nums[index]):\n                    queue.append(nums[index])\n                    count += count_arrangements(nums, index + 1, queue, memo)\n                    queue.pop()\n            count += count_arrangements(nums, index + 1, queue + [nums[index]], memo)\n            memo[(index, tuple(queue))] = count\n            return count\n\n    memo = {}\n    return count_arrangements(nums, 0, [], memo)", "solution_func": "def g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest rectangle that can be formed with only 1s.\n    The rectangle must be aligned with the grid and can only be formed using adjacent 1s.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n\n    The largest rectangle that can be formed with only 1s is of area 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    heights = [0] * cols\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                heights[j] += 1\n            else:\n                heights[j] = 0\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    stack = [-1]\n    max_area = 0\n\n    for i, height in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] >= height:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area\n\ndef g():\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest rectangle that can be formed with only 1s.\n    The rectangle must be aligned with the grid and can only be formed using adjacent 1s.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n\n    The largest rectangle that can be formed with only 1s is of area 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    heights = [0] * cols\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                heights[j] += 1\n            else:\n                heights[j] = 0\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    stack = [-1]\n    max_area = 0\n\n    for i, height in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] >= height:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area", "solution_func": "def g():\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome after deleting at most one character.\n\n    Example:\n    Input: \"raceacar\"\n    Output: True\n\n    Explanation: You can either delete the 'e' at index 3 or the 'a' at index 4 to make s a valid palindrome.\n    \"\"\"\n    def is_palindrome(s: str, i: int, j: int) -> bool:\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n\n    return True\n\ndef g():\n    s = \"raceacar\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 346, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome after deleting at most one character.\n\n    Example:\n    Input: \"raceacar\"\n    Output: True\n\n    Explanation: You can either delete the 'e' at index 3 or the 'a' at index 4 to make s a valid palindrome.\n    \"\"\"\n    def is_palindrome(s: str, i: int, j: int) -> bool:\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n\n    return True", "solution_func": "def g():\n    s = \"raceacar\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and the number of nodes n,\n    return the shortest path from node 0 to each node in the graph.\n    If a node is not reachable from node 0, its distance should be -1.\n\n    Example:\n    n = 5\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n\n    The shortest path from node 0 to each node in the graph is:\n    [0, 1, 1, 1, 2]\n\n    Therefore, the function should return [0, 1, 1, 1, 2].\n    \"\"\"\n    from collections import deque\n\n    if not edges:\n        return []\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    distances = [-1] * n\n    distances[0] = 0\n\n    queue = deque([0])\n\n    while queue:\n        node = queue.popleft()\n\n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n\n    return distances\n\ndef g():\n    n = 5\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n    return n, edges\n\nassert f(*g()) == [0, 1, 1, 1, 2]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 346, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and the number of nodes n,\n    return the shortest path from node 0 to each node in the graph.\n    If a node is not reachable from node 0, its distance should be -1.\n\n    Example:\n    n = 5\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n\n    The shortest path from node 0 to each node in the graph is:\n    [0, 1, 1, 1, 2]\n\n    Therefore, the function should return [0, 1, 1, 1, 2].\n    \"\"\"\n    from collections import deque\n\n    if not edges:\n        return []\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    distances = [-1] * n\n    distances[0] = 0\n\n    queue = deque([0])\n\n    while queue:\n        node = queue.popleft()\n\n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n\n    return distances", "solution_func": "def g():\n    n = 5\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, check if there exists two integers in the array such that their sum is equal to the target.\n\n    Return True if there exists such integers, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5], target = 8):\n    return arr, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, check if there exists two integers in the array such that their sum is equal to the target.\n\n    Return True if there exists such integers, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(arr = [1, 2, 3, 4, 5], target = 8):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n different objects in a row such that no two specific objects are adjacent to each other.\n\n    Return the total number of possible arrangements.\n    \"\"\"\n    def count_arrangements(n: int, k: int) -> int:\n        if n < k:\n            return 0\n        elif k == 0:\n            return 1\n        else:\n            return (n - k + 1) * count_arrangements(n - 2, k - 1) + count_arrangements(n - 1, k)\n\n    return count_arrangements(n, n // 2)\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n different objects in a row such that no two specific objects are adjacent to each other.\n\n    Return the total number of possible arrangements.\n    \"\"\"\n    def count_arrangements(n: int, k: int) -> int:\n        if n < k:\n            return 0\n        elif k == 0:\n            return 1\n        else:\n            return (n - k + 1) * count_arrangements(n - 2, k - 1) + count_arrangements(n - 1, k)\n\n    return count_arrangements(n, n // 2)", "solution_func": "def g(n = 4):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a grid represented by a list of lists, find the shortest distance from the top-left cell to each cell in the grid.\n\n    Return a list of integers representing the shortest distances to each cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[0][0] = grid[0][0]\n\n    def dfs(row: int, col: int, distance: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return\n        if distance >= distances[row][col]:\n            return\n        distances[row][col] = distance\n        dfs(row + 1, col, distance + grid[row + 1][col])\n        dfs(row, col + 1, distance + grid[row][col + 1])\n\n    dfs(0, 0, 0)\n    return distances\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == [[1, 4, 5], [2, 7, 6], [6, 8, 7]]\n", "emb": null, "idx_generation": 346, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a grid represented by a list of lists, find the shortest distance from the top-left cell to each cell in the grid.\n\n    Return a list of integers representing the shortest distances to each cell.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[0][0] = grid[0][0]\n\n    def dfs(row: int, col: int, distance: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return\n        if distance >= distances[row][col]:\n            return\n        distances[row][col] = distance\n        dfs(row + 1, col, distance + grid[row + 1][col])\n        dfs(row, col + 1, distance + grid[row][col + 1])\n\n    dfs(0, 0, 0)\n    return distances", "solution_func": "def g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of all the even numbers.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 346, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The sum of all the even numbers.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n\n    Output:\n    [2, 6]\n\n    Explanation:\n    The numbers 2 and 6 add up to the target value of 8.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == [2, 6]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n\n    Output:\n    [2, 6]\n\n    Explanation:\n    The numbers 2 and 6 add up to the target value of 8.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a subarray within the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The subarray with the maximum sum is [1, 2, 3, 4, 5, 6, 7, 8, 9], which sums up to 45.\n    \"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        row_sums = [0] * rows\n\n        for right in range(left, cols):\n            for i in range(rows):\n                row_sums[i] += matrix[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a subarray within the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    Explanation:\n    The subarray with the maximum sum is [1, 2, 3, 4, 5, 6, 7, 8, 9], which sums up to 45.\n    \"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        row_sums = [0] * rows\n\n        for right in range(left, cols):\n            for i in range(rows):\n                row_sums[i] += matrix[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed acyclic graph (DAG), find the longest path in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is [0, 1, 2, 3], which has a length of 3.\n    \"\"\"\n    n = len(graph)\n    dp = [0] * n\n\n    for i in range(n):\n        for j in range(i):\n            if graph[j][i] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed acyclic graph (DAG), find the longest path in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is [0, 1, 2, 3], which has a length of 3.\n    \"\"\"\n    n = len(graph)\n    dp = [0] * n\n\n    for i in range(n):\n        for j in range(i):\n            if graph[j][i] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target value, determine if it is possible to find a path from the top-left\n    corner to the bottom-right corner, moving only down or right, where the sum of the values along the path is equal to the target.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    target = 15\n\n    Output: True\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[False] * m for _ in range(n)]\n    dp[0][0] = grid[0][0] == target\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] or (grid[i][0] == target)\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] or (grid[0][j] == target)\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] or dp[i][j-1] or (dp[i-1][j-1] and grid[i][j] == target)\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g(), 15)\n", "emb": null, "idx_generation": 347, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target value, determine if it is possible to find a path from the top-left\n    corner to the bottom-right corner, moving only down or right, where the sum of the values along the path is equal to the target.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    target = 15\n\n    Output: True\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[False] * m for _ in range(n)]\n    dp[0][0] = grid[0][0] == target\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] or (grid[i][0] == target)\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] or (grid[0][j] == target)\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] or dp[i][j-1] or (dp[i-1][j-1] and grid[i][j] == target)\n\n    return dp[-1][-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output: 29\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 29\n", "emb": [1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 347, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output: 29\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": [1, 0, 1, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner,\n    moving only down or right. The cost of each cell is given by the value in the cell.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    [[1, 3, 6],\n     [5, 9, 15],\n     [12, 20, 29]]\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[1, 3, 6],\n                  [5, 9, 15],\n                  [12, 20, 29]]\n", "emb": null, "idx_generation": 347, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner,\n    moving only down or right. The cost of each cell is given by the value in the cell.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    [[1, 3, 6],\n     [5, 9, 15],\n     [12, 20, 29]]\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, split the string into k equal parts.\n    If the string cannot be split into k equal parts, return an empty list.\n    \"\"\"\n    if len(s) % k != 0:\n        return []\n\n    part_length = len(s) // k\n    result = []\n    for i in range(0, len(s), part_length):\n        result.append(s[i:i+part_length])\n\n    return result\n\ndef g() -> tuple:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return \"abcdefgh\", 3\n\nassert f(*g()) == [\"abc\", \"def\", \"gh\"]\n", "emb": null, "idx_generation": 347, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, split the string into k equal parts.\n    If the string cannot be split into k equal parts, return an empty list.\n    \"\"\"\n    if len(s) % k != 0:\n        return []\n\n    part_length = len(s) // k\n    result = []\n    for i in range(0, len(s), part_length):\n        result.append(s[i:i+part_length])\n\n    return result", "solution_func": "def g() -> tuple:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return \"abcdefgh\", 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left\n    corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 347, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left\n    corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest subarray with\n    consecutive elements.\n    \"\"\"\n    longest_length = 0\n    num_set = set(nums)\n\n    for num in nums:\n        if num - 1 not in num_set:\n            current_length = 1\n            while num + 1 in num_set:\n                num += 1\n                current_length += 1\n            longest_length = max(longest_length, current_length)\n\n    return longest_length\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 9, 3, 10, 4, 20, 2]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest subarray with\n    consecutive elements.\n    \"\"\"\n    longest_length = 0\n    num_set = set(nums)\n\n    for num in nums:\n        if num - 1 not in num_set:\n            current_length = 1\n            while num + 1 in num_set:\n                num += 1\n                current_length += 1\n            longest_length = max(longest_length, current_length)\n\n    return longest_length", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 9, 3, 10, 4, 20, 2]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, and an integer target,\n    return indices of the two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The function should return [0, 1], because nums[0] + nums[1] equals 9.\n\n    \"\"\"\n    # Create a dictionary to store the complement of the current element\n    complement_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []\n\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 347, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, and an integer target,\n    return indices of the two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The function should return [0, 1], because nums[0] + nums[1] equals 9.\n\n    \"\"\"\n    # Create a dictionary to store the complement of the current element\n    complement_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the maximum consecutive sum of any subarray in the list and return it.\n\n    Example:\n    Input: arr = [1, -2, 3, -1, 2]\n    Output: 4\n    Explanation: The subarray [3, -1, 2] has the maximum consecutive sum of 4.\n\n    Input: arr = [5, -3, 2, -1, 4]\n    Output: 7\n    Explanation: The subarray [5, -3, 2, -1, 4] has the maximum consecutive sum of 7.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -2, 3, -1, 2]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the maximum consecutive sum of any subarray in the list and return it.\n\n    Example:\n    Input: arr = [1, -2, 3, -1, 2]\n    Output: 4\n    Explanation: The subarray [3, -1, 2] has the maximum consecutive sum of 4.\n\n    Input: arr = [5, -3, 2, -1, 4]\n    Output: 7\n    Explanation: The subarray [5, -3, 2, -1, 4] has the maximum consecutive sum of 7.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -2, 3, -1, 2]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a list of integers arr and a target value, find two numbers in the list whose XOR is equal to the target value and return their indices.\n\n    Example:\n    Input: arr = [2, 4, 6, 8, 10], target = 14\n    Output: (1, 3)\n    Explanation: The XOR of arr[1] = 4 and arr[3] = 8 is equal to the target value of 14, so the indices (1, 3) are returned.\n\n    Input: arr = [3, 5, 7, 9, 11], target = 6\n    Output: (0, 2)\n    Explanation: The XOR of arr[0] = 3 and arr[2] = 7 is equal to the target value of 6, so the indices (0, 2) are returned.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(arr):\n        complement = target ^ num\n        if complement in num_map:\n            return (num_map[complement], i)\n        num_map[num] = i\n\n    return ()\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([2, 4, 6, 8, 10], 14)\n\nassert f(*g()) == (1, 3)\n", "emb": null, "idx_generation": 348, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a list of integers arr and a target value, find two numbers in the list whose XOR is equal to the target value and return their indices.\n\n    Example:\n    Input: arr = [2, 4, 6, 8, 10], target = 14\n    Output: (1, 3)\n    Explanation: The XOR of arr[1] = 4 and arr[3] = 8 is equal to the target value of 14, so the indices (1, 3) are returned.\n\n    Input: arr = [3, 5, 7, 9, 11], target = 6\n    Output: (0, 2)\n    Explanation: The XOR of arr[0] = 3 and arr[2] = 7 is equal to the target value of 6, so the indices (0, 2) are returned.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(arr):\n        complement = target ^ num\n        if complement in num_map:\n            return (num_map[complement], i)\n        num_map[num] = i\n\n    return ()", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([2, 4, 6, 8, 10], 14)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string and return the reversed string.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string\n\ndef g() -> str:\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string and return the reversed string.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string", "solution_func": "def g() -> str:\n    return \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a combination of k elements that sum up to the target value.\n    Return True if such combination exists, otherwise return False.\n    \"\"\"\n    def backtrack(start, target, k):\n        if k == 0:\n            return target == 0\n        for i in range(start, len(nums)):\n            if nums[i] <= target and backtrack(i + 1, target - nums[i], k - 1):\n                return True\n        return False\n\n    nums.sort()\n    return backtrack(0, target, k)\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10, k=3):\n    return [nums, target, k]\n\nassert f(g())\n", "emb": null, "idx_generation": 348, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a combination of k elements that sum up to the target value.\n    Return True if such combination exists, otherwise return False.\n    \"\"\"\n    def backtrack(start, target, k):\n        if k == 0:\n            return target == 0\n        for i in range(start, len(nums)):\n            if nums[i] <= target and backtrack(i + 1, target - nums[i], k - 1):\n                return True\n        return False\n\n    nums.sort()\n    return backtrack(0, target, k)", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10, k=3):\n    return [nums, target, k]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    There is a ladder with n steps. You can climb up the ladder by taking either 1 or 2 steps at a time.\n    Return the number of distinct ways to climb to the top of the ladder.\n    \"\"\"\n    memo = {}\n\n    def climb(n, k):\n        if n == 0:\n            return 1\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        count = 0\n        for i in range(1, k + 1):\n            count += climb(n - i, k)\n        memo[n] = count\n        return count\n\n    return climb(n, k)\n\ndef g(n=5, k=2):\n    return [n, k]\n\nassert f(g())\n", "emb": null, "idx_generation": 348, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    There is a ladder with n steps. You can climb up the ladder by taking either 1 or 2 steps at a time.\n    Return the number of distinct ways to climb to the top of the ladder.\n    \"\"\"\n    memo = {}\n\n    def climb(n, k):\n        if n == 0:\n            return 1\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        count = 0\n        for i in range(1, k + 1):\n            count += climb(n - i, k)\n        memo[n] = count\n        return count\n\n    return climb(n, k)", "solution_func": "def g(n=5, k=2):\n    return [n, k]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray of length at most k.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if i >= k:\n            current_sum -= nums[i - k]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n\ndef g(k=3, nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return [k, nums]\n\nassert f(g())\n", "emb": null, "idx_generation": 348, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray of length at most k.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if i >= k:\n            current_sum -= nums[i - k]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum", "solution_func": "def g(k=3, nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return [k, nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the maximum XOR value between two numbers in the list\n    such that the XOR value is less than or equal to n.\n\n    Example:\n    n = 5\n    nums = [1, 2, 3, 4, 5]\n    f(n, nums) => 5\n    Explanation: The maximum XOR value is achieved by taking XOR of 2 and 5 (2 XOR 5 = 7), which is less than or equal to n.\n\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor <= n and xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef g():\n    n = 5\n    nums = [1, 2, 3, 4, 5]\n    return n, nums\n\nassert f(*g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the maximum XOR value between two numbers in the list\n    such that the XOR value is less than or equal to n.\n\n    Example:\n    n = 5\n    nums = [1, 2, 3, 4, 5]\n    f(n, nums) => 5\n    Explanation: The maximum XOR value is achieved by taking XOR of 2 and 5 (2 XOR 5 = 7), which is less than or equal to n.\n\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor <= n and xor > max_xor:\n                max_xor = xor\n\n    return max_xor", "solution_func": "def g():\n    n = 5\n    nums = [1, 2, 3, 4, 5]\n    return n, nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum length of a subarray that has an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 1, 0, 1, 0]\n    f(nums) => 6\n    Explanation: The subarray [0, 1, 0, 1, 0, 1] has an equal number of 0s and 1s, and its length is 6.\n\n    \"\"\"\n    max_length = 0\n\n    for i in range(len(nums)):\n        count_zero = 0\n        count_one = 0\n\n        for j in range(i, len(nums)):\n            if nums[j] == 0:\n                count_zero += 1\n            else:\n                count_one += 1\n\n            if count_zero == count_one:\n                length = j - i + 1\n                max_length = max(max_length, length)\n\n    return max_length\n\ndef g():\n    nums = [0, 1, 0, 1, 0, 1, 0]\n    return nums\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 348, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum length of a subarray that has an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 1, 0, 1, 0]\n    f(nums) => 6\n    Explanation: The subarray [0, 1, 0, 1, 0, 1] has an equal number of 0s and 1s, and its length is 6.\n\n    \"\"\"\n    max_length = 0\n\n    for i in range(len(nums)):\n        count_zero = 0\n        count_one = 0\n\n        for j in range(i, len(nums)):\n            if nums[j] == 0:\n                count_zero += 1\n            else:\n                count_one += 1\n\n            if count_zero == count_one:\n                length = j - i + 1\n                max_length = max(max_length, length)\n\n    return max_length", "solution_func": "def g():\n    nums = [0, 1, 0, 1, 0, 1, 0]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray that has an equal number of even and odd numbers.\n\n    Example:\n    nums = [2, 4, 6, 1, 3, 5, 7]\n    f(nums) => 16\n    Explanation: The subarray [6, 1, 3, 5, 7] has an equal number of even and odd numbers, and its sum is 16.\n\n    \"\"\"\n    max_sum = 0\n\n    for i in range(len(nums)):\n        count_even = 0\n        count_odd = 0\n        current_sum = 0\n\n        for j in range(i, len(nums)):\n            if nums[j] % 2 == 0:\n                count_even += 1\n            else:\n                count_odd += 1\n\n            current_sum += nums[j]\n\n            if count_even == count_odd:\n                max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [2, 4, 6, 1, 3, 5, 7]\n    return nums\n\nassert f(*g()) == 16\n\n", "emb": null, "idx_generation": 348, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray that has an equal number of even and odd numbers.\n\n    Example:\n    nums = [2, 4, 6, 1, 3, 5, 7]\n    f(nums) => 16\n    Explanation: The subarray [6, 1, 3, 5, 7] has an equal number of even and odd numbers, and its sum is 16.\n\n    \"\"\"\n    max_sum = 0\n\n    for i in range(len(nums)):\n        count_even = 0\n        count_odd = 0\n        current_sum = 0\n\n        for j in range(i, len(nums)):\n            if nums[j] % 2 == 0:\n                count_even += 1\n            else:\n                count_odd += 1\n\n            current_sum += nums[j]\n\n            if count_even == count_odd:\n                max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [2, 4, 6, 1, 3, 5, 7]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the closest value to the target in the array.\n    Return the closest value.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9], target = 6\n    Output: 5 (The closest value to the target 6 in the array is 5)\n\n    Hint: Use binary search to find the closest value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    # Check the closest values on both sides of the target\n    if abs(arr[left] - target) < abs(arr[right] - target):\n        return arr[left]\n    else:\n        return arr[right]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), 6) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 348, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the closest value to the target in the array.\n    Return the closest value.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9], target = 6\n    Output: 5 (The closest value to the target 6 in the array is 5)\n\n    Hint: Use binary search to find the closest value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    # Check the closest values on both sides of the target\n    if abs(arr[left] - target) < abs(arr[right] - target):\n        return arr[left]\n    else:\n        return arr[right]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, find k integers in nums such that their sum is equal to the target.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    target = 9\n\n    Sample output:\n    True\n\n    Explanation: The integers 2, 3, and 4 from the list nums can be combined to form the sum 9.\n    \"\"\"\n    def find_combinations(nums, k, target):\n        if k == 0 and target == 0:\n            return True\n        if k < 0 or target < 0:\n            return False\n        if nums and nums[-1] > target:\n            return find_combinations(nums[:-1], k, target)\n        return find_combinations(nums[:-1], k, target) or find_combinations(nums[:-1], k-1, target-nums[-1])\n    \n    return find_combinations(nums, k, target)\n\ndef g(nums=[1, 2, 3, 4, 5], k=3, target=9):\n    return nums, k, target\n\nassert f(*g())\n", "emb": null, "idx_generation": 349, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, find k integers in nums such that their sum is equal to the target.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    target = 9\n\n    Sample output:\n    True\n\n    Explanation: The integers 2, 3, and 4 from the list nums can be combined to form the sum 9.\n    \"\"\"\n    def find_combinations(nums, k, target):\n        if k == 0 and target == 0:\n            return True\n        if k < 0 or target < 0:\n            return False\n        if nums and nums[-1] > target:\n            return find_combinations(nums[:-1], k, target)\n        return find_combinations(nums[:-1], k, target) or find_combinations(nums[:-1], k-1, target-nums[-1])\n    \n    return find_combinations(nums, k, target)", "solution_func": "def g(nums=[1, 2, 3, 4, 5], k=3, target=9):\n    return nums, k, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be segmented into a space-separated sequence of dictionary words.\n\n    Sample input:\n    s = \"leetcode\"\n\n    Sample output:\n    False\n\n    Explanation: The string \"leetcode\" cannot be segmented into valid dictionary words.\n    \"\"\"\n    def word_break(s, word_dict, memo):\n        if s in memo:\n            return memo[s]\n        if not s:\n            return True\n        for i in range(1, len(s) + 1):\n            if s[:i] in word_dict and word_break(s[i:], word_dict, memo):\n                memo[s] = True\n                return True\n        memo[s] = False\n        return False\n    \n    word_dict = [\"leet\", \"code\"]\n    return word_break(s, word_dict, {})\n\ndef g(s=\"leetcode\"):\n    return s\n\nassert f(g())\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 349, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be segmented into a space-separated sequence of dictionary words.\n\n    Sample input:\n    s = \"leetcode\"\n\n    Sample output:\n    False\n\n    Explanation: The string \"leetcode\" cannot be segmented into valid dictionary words.\n    \"\"\"\n    def word_break(s, word_dict, memo):\n        if s in memo:\n            return memo[s]\n        if not s:\n            return True\n        for i in range(1, len(s) + 1):\n            if s[:i] in word_dict and word_break(s[i:], word_dict, memo):\n                memo[s] = True\n                return True\n        memo[s] = False\n        return False\n    \n    word_dict = [\"leet\", \"code\"]\n    return word_break(s, word_dict, {})", "solution_func": "def g(s=\"leetcode\"):\n    return s", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum sum of k non-overlapping subarrays.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 2\n\n    Sample output:\n    18\n\n    Explanation: The maximum sum of two non-overlapping subarrays in the list nums is 18, which is obtained by selecting subarrays [1, 2, 3] and [4, 5, 6].\n    \"\"\"\n    def max_sum_subarrays(nums, k):\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i - j][j - 1] + prefix_sum[i] - prefix_sum[i - j])\n        \n        return dp[n][k]\n    \n    return max_sum_subarrays(nums, k)\n\ndef g(nums=[1, 2, 3, 4, 5, 6], k=2):\n    return nums, k\n\nassert f(*g())\n", "emb": null, "idx_generation": 349, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum sum of k non-overlapping subarrays.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 2\n\n    Sample output:\n    18\n\n    Explanation: The maximum sum of two non-overlapping subarrays in the list nums is 18, which is obtained by selecting subarrays [1, 2, 3] and [4, 5, 6].\n    \"\"\"\n    def max_sum_subarrays(nums, k):\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i - j][j - 1] + prefix_sum[i] - prefix_sum[i - j])\n        \n        return dp[n][k]\n    \n    return max_sum_subarrays(nums, k)", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6], k=2):\n    return nums, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs of numbers whose sum is even.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 6\n    Explanation:\n    - The distinct pairs of numbers whose sum is even are: (1, 3), (1, 5), (2, 4), (3, 5), (2, 2), (4, 4).\n    \"\"\"\n\n    count = 0\n    even_nums = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_nums += 1\n\n    odd_nums = len(nums) - even_nums\n\n    # Count the number of distinct pairs of even numbers\n    count += (even_nums * (even_nums - 1)) // 2\n\n    # Count the number of distinct pairs of odd numbers\n    count += (odd_nums * (odd_nums - 1)) // 2\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 349, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs of numbers whose sum is even.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 6\n    Explanation:\n    - The distinct pairs of numbers whose sum is even are: (1, 3), (1, 5), (2, 4), (3, 5), (2, 2), (4, 4).\n    \"\"\"\n\n    count = 0\n    even_nums = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_nums += 1\n\n    odd_nums = len(nums) - even_nums\n\n    # Count the number of distinct pairs of even numbers\n    count += (even_nums * (even_nums - 1)) // 2\n\n    # Count the number of distinct pairs of odd numbers\n    count += (odd_nums * (odd_nums - 1)) // 2\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs of numbers whose bitwise AND is zero.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 3\n    Explanation:\n    - The distinct pairs of numbers whose bitwise AND is zero are: (1, 2), (1, 4), (3, 5).\n    \"\"\"\n\n    count = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                count += 1\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 349, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs of numbers whose bitwise AND is zero.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 3\n    Explanation:\n    - The distinct pairs of numbers whose bitwise AND is zero are: (1, 2), (1, 4), (3, 5).\n    \"\"\"\n\n    count = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                count += 1\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation:\n    - The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 349, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation:\n    - The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented by its number of nodes n and a list of edges, determine if the graph\n    is bipartite. A graph is bipartite if it can be colored using two colors such that no two adjacent nodes\n    have the same color.\n\n    Example:\n    Input: n = 4, edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Output: False (The graph contains a cycle with odd length, which means it cannot be bipartite)\n\n    Hint: Use depth-first search (DFS) to color the nodes and check if any adjacent nodes have the same color.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    colors = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n\n    return True\n\ndef g():\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, edges\n\nassert f(*g()) == False\n", "emb": null, "idx_generation": 349, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented by its number of nodes n and a list of edges, determine if the graph\n    is bipartite. A graph is bipartite if it can be colored using two colors such that no two adjacent nodes\n    have the same color.\n\n    Example:\n    Input: n = 4, edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Output: False (The graph contains a cycle with odd length, which means it cannot be bipartite)\n\n    Hint: Use depth-first search (DFS) to color the nodes and check if any adjacent nodes have the same color.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    colors = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n\n    return True", "solution_func": "def g():\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    Input: n = 5\n    Output: 1 (5! = 120, which has 1 trailing zero)\n\n    Hint: Trailing zeroes can be obtained by dividing n by 5 and counting the number of times the division is possible.\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 349, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    Input: n = 5\n    Output: 1 (5! = 120, which has 1 trailing zero)\n\n    Hint: Trailing zeroes can be obtained by dividing n by 5 and counting the number of times the division is possible.\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right. If there is no\n    greater element, return -1.\n\n    Example:\n    Input: nums = [4, 5, 2, 25]\n    Output: [5, 25, 25, -1]\n\n    Hint: Use a stack to keep track of elements in decreasing order. If a new element is greater than the top\n    of the stack, it is the next greater element for all elements in the stack.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        while stack and stack[-1] <= nums[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    return result\n\ndef g():\n    nums = [4, 5, 2, 25]\n    return nums\n\nassert f(*g()) == [5, 25, 25, -1]\n", "emb": null, "idx_generation": 349, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the next greater element for each element in the list.\n    The next greater element for an element x is the first greater element to its right. If there is no\n    greater element, return -1.\n\n    Example:\n    Input: nums = [4, 5, 2, 25]\n    Output: [5, 25, 25, -1]\n\n    Hint: Use a stack to keep track of elements in decreasing order. If a new element is greater than the top\n    of the stack, it is the next greater element for all elements in the stack.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)-1, -1, -1):\n        while stack and stack[-1] <= nums[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(nums[i])\n    return result", "solution_func": "def g():\n    nums = [4, 5, 2, 25]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums, and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15, 20, 25]\n    target = 27\n    return nums, target\n\nassert f(*g()) == [1, 3]\n", "emb": null, "idx_generation": 349, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums, and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in the array.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15, 20, 25]\n    target = 27\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a sublist whose sum is equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    There exists a sublist [2, 3, 4] whose sum is equal to the target value.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def find_sublist(nums, target):\n        \"\"\"\n        Find a sublist whose sum is equal to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n+1):\n                sublist = nums[i:j]\n                if sum(sublist) == target:\n                    return True\n\n        return False\n\n    return find_sublist(nums, target)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 350, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a sublist whose sum is equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    There exists a sublist [2, 3, 4] whose sum is equal to the target value.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def find_sublist(nums, target):\n        \"\"\"\n        Find a sublist whose sum is equal to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n+1):\n                sublist = nums[i:j]\n                if sum(sublist) == target:\n                    return True\n\n        return False\n\n    return find_sublist(nums, target)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to place n non-attacking rooks on the grid,\n    where a rook can attack any other rook if they are in the same row or column.\n\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    rows = [0] * n\n    cols = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n                cols[j] += 1\n    return all(r <= 1 and c <= 1 for r, c in zip(rows, cols))\n\ndef g(n = 4):\n    grid = [[1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]]\n    return n, grid\n\nassert f(*g())\n", "emb": [1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 350, "target_skills": [0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to place n non-attacking rooks on the grid,\n    where a rook can attack any other rook if they are in the same row or column.\n\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    rows = [0] * n\n    cols = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n                cols[j] += 1\n    return all(r <= 1 and c <= 1 for r, c in zip(rows, cols))", "solution_func": "def g(n = 4):\n    grid = [[1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]]\n    return n, grid", "map_ix": [1, 1, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given grid is a valid Sudoku solution.\n    Each row, column, and 3x3 sub-grid should contain all numbers from 1 to 9 without repetition.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if not is_valid(row):\n            return False\n    \n    # Check columns\n    for col in range(n):\n        column = [grid[row][col] for row in range(n)]\n        if not is_valid(column):\n            return False\n    \n    # Check 3x3 sub-grids\n    for i in range(0, n, 3):\n        for j in range(0, n, 3):\n            sub_grid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid(sub_grid):\n                return False\n    \n    return True\n\ndef is_valid(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of numbers is valid, i.e., contains all numbers from 1 to 9 without repetition.\n    \"\"\"\n    num_set = set(nums)\n    return len(num_set) == 9 and all(num in num_set for num in range(1, 10))\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 350, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given grid is a valid Sudoku solution.\n    Each row, column, and 3x3 sub-grid should contain all numbers from 1 to 9 without repetition.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if not is_valid(row):\n            return False\n    \n    # Check columns\n    for col in range(n):\n        column = [grid[row][col] for row in range(n)]\n        if not is_valid(column):\n            return False\n    \n    # Check 3x3 sub-grids\n    for i in range(0, n, 3):\n        for j in range(0, n, 3):\n            sub_grid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid(sub_grid):\n                return False\n    \n    return True\n\ndef is_valid(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of numbers is valid, i.e., contains all numbers from 1 to 9 without repetition.\n    \"\"\"\n    num_set = set(nums)\n    return len(num_set) == 9 and all(num in num_set for num in range(1, 10))", "solution_func": "def g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find a contiguous subarray that sums up to the target.\n    Return the starting and ending indices of the subarray, or an empty list if no such subarray exists.\n\n    Sample Input:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n\n    Sample Output:\n    [2, 4]\n\n    Explanation: The subarray [20, 3, 10] sums up to the target 33, and its starting and ending indices are 2 and 4 respectively.\n    \"\"\"\n\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return [i, j - 1]\n\n    return []\n\ndef g() -> List[int]:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n    return arr, target\n\nassert f(*g()) == [2, 4]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 350, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find a contiguous subarray that sums up to the target.\n    Return the starting and ending indices of the subarray, or an empty list if no such subarray exists.\n\n    Sample Input:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n\n    Sample Output:\n    [2, 4]\n\n    Explanation: The subarray [20, 3, 10] sums up to the target 33, and its starting and ending indices are 2 and 4 respectively.\n    \"\"\"\n\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return [i, j - 1]\n\n    return []", "solution_func": "def g() -> List[int]:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n    return arr, target", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(*g()) == 6\n", "emb": null, "idx_generation": 350, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Sample Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subarray.\n\n    Sample Input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n\n    Explanation: The longest increasing subarray is [2, 5, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    max_len = 1\n    curr_len = 1\n\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            curr_len += 1\n            max_len = max(max_len, curr_len)\n        else:\n            curr_len = 1\n\n    return max_len\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 350, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subarray.\n\n    Sample Input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n\n    Explanation: The longest increasing subarray is [2, 5, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    max_len = 1\n    curr_len = 1\n\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            curr_len += 1\n            max_len = max(max_len, curr_len)\n        else:\n            curr_len = 1\n\n    return max_len", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers arr and a target value, find two numbers in the list that sum up to the target.\n\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: [2, 4]\n\n    Explanation:\n    The numbers at indices 2 and 4 (3 and 5) sum up to 7.\n    \"\"\"\n\n    # Use a two-pointer approach to find the two numbers that sum up to the target\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == [2, 4]\n", "emb": null, "idx_generation": 350, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers arr and a target value, find two numbers in the list that sum up to the target.\n\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: [2, 4]\n\n    Explanation:\n    The numbers at indices 2 and 4 (3 and 5) sum up to 7.\n    \"\"\"\n\n    # Use a two-pointer approach to find the two numbers that sum up to the target\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers representing a maze, where 0 represents an obstacle and 1 represents an open path,\n    find the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner.\n    You can only move down or right, and you cannot pass through obstacles.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [1, 1, 1, 1]\n    ]\n\n    The minimum number of steps required to reach the bottom-right corner from the top-left corner is 5, following the path:\n    (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (3, 1) -> (3, 2).\n\n    Therefore, the function should return 5.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D table to store the minimum steps required to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # The minimum number of steps required to reach the top-left corner is 0\n    dp[0][0] = 0\n\n    # Define the possible directions to move\n    directions = [(1, 0), (0, 1)]\n\n    # Create a queue to perform breadth-first search\n    queue = [(0, 0)]\n\n    # Perform breadth-first search\n    while queue:\n        x, y = queue.pop(0)\n\n        # Check each possible direction to move\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n\n            # Check if the new position is within the grid boundaries\n            if 0 <= new_x < rows and 0 <= new_y < cols:\n                # Check if the new position is not an obstacle and has not been visited yet\n                if grid[new_x][new_y] != 0 and dp[new_x][new_y] == float('inf'):\n                    # Update the minimum steps required to reach the new position\n                    dp[new_x][new_y] = dp[x][y] + 1\n                    # Add the new position to the queue for further exploration\n                    queue.append((new_x, new_y))\n\n    # Return the minimum steps required to reach the bottom-right corner\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 350, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers representing a maze, where 0 represents an obstacle and 1 represents an open path,\n    find the minimum number of steps required to reach the bottom-right corner of the maze from the top-left corner.\n    You can only move down or right, and you cannot pass through obstacles.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [1, 1, 1, 1]\n    ]\n\n    The minimum number of steps required to reach the bottom-right corner from the top-left corner is 5, following the path:\n    (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (3, 1) -> (3, 2).\n\n    Therefore, the function should return 5.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D table to store the minimum steps required to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # The minimum number of steps required to reach the top-left corner is 0\n    dp[0][0] = 0\n\n    # Define the possible directions to move\n    directions = [(1, 0), (0, 1)]\n\n    # Create a queue to perform breadth-first search\n    queue = [(0, 0)]\n\n    # Perform breadth-first search\n    while queue:\n        x, y = queue.pop(0)\n\n        # Check each possible direction to move\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n\n            # Check if the new position is within the grid boundaries\n            if 0 <= new_x < rows and 0 <= new_y < cols:\n                # Check if the new position is not an obstacle and has not been visited yet\n                if grid[new_x][new_y] != 0 and dp[new_x][new_y] == float('inf'):\n                    # Update the minimum steps required to reach the new position\n                    dp[new_x][new_y] = dp[x][y] + 1\n                    # Add the new position to the queue for further exploration\n                    queue.append((new_x, new_y))\n\n    # Return the minimum steps required to reach the bottom-right corner\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target value, determine whether there exists a subarray in the list\n    that sums up to the target.\n\n    Return True if such a subarray exists, and False otherwise.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 9\n    Output: True\n\n    Explanation:\n    The subarray [2, 3, 4] sums up to 9.\n    \"\"\"\n\n    # Use a sliding window approach to find subarrays that sum up to the target\n    window_sum = 0\n    left = 0\n\n    for right in range(len(arr)):\n        window_sum += arr[right]\n\n        while window_sum > target:\n            window_sum -= arr[left]\n            left += 1\n\n        if window_sum == target:\n            return True\n\n    return False\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 350, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target value, determine whether there exists a subarray in the list\n    that sums up to the target.\n\n    Return True if such a subarray exists, and False otherwise.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 9\n    Output: True\n\n    Explanation:\n    The subarray [2, 3, 4] sums up to 9.\n    \"\"\"\n\n    # Use a sliding window approach to find subarrays that sum up to the target\n    window_sum = 0\n    left = 0\n\n    for right in range(len(arr)):\n        window_sum += arr[right]\n\n        while window_sum > target:\n            window_sum -= arr[left]\n            left += 1\n\n        if window_sum == target:\n            return True\n\n    return False", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array whose sum is equal to the target.\n    Return the indices of the two numbers (1-indexed) as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [1, 2]\n\n    Explanation:\n    The sum of 2 and 7 is equal to the target value 9.\n    Therefore, the indices of the two numbers are 1 and 2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left+1, right+1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value, where there exists two numbers in the array whose sum is equal to the target value.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [1, 2]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 350, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array whose sum is equal to the target.\n    Return the indices of the two numbers (1-indexed) as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [1, 2]\n\n    Explanation:\n    The sum of 2 and 7 is equal to the target value 9.\n    Therefore, the indices of the two numbers are 1 and 2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left+1, right+1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value, where there exists two numbers in the array whose sum is equal to the target value.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the squares of the even numbers in the given list.\n    Return the sum.\n    \"\"\"\n    even_nums = [num for num in nums if num % 2 == 0]\n    even_squares = [num**2 for num in even_nums]\n    return sum(even_squares)\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 56\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the squares of the even numbers in the given list.\n    Return the sum.\n    \"\"\"\n    even_nums = [num for num in nums if num % 2 == 0]\n    even_squares = [num**2 for num in even_nums]\n    return sum(even_squares)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if the given strings are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n    sorted_s1 = sorted(s1)\n    sorted_s2 = sorted(s2)\n    return sorted_s1 == sorted_s2\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if the given strings are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n    sorted_s1 = sorted(s1)\n    sorted_s2 = sorted(s2)\n    return sorted_s1 == sorted_s2", "solution_func": "def g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a given string.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a given string.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, return True if the string s can be formed by concatenating the words in the list, in any order. Otherwise, return False.\n\n    Example:\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n\n    The string s can be formed by concatenating the words \"apple\" and \"pie\", so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\")\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words.\n    \"\"\"\n    return \"applepie\", [\"apple\", \"pie\"]\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, return True if the string s can be formed by concatenating the words in the list, in any order. Otherwise, return False.\n\n    Example:\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n\n    The string s can be formed by concatenating the words \"apple\" and \"pie\", so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\")", "solution_func": "def g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words.\n    \"\"\"\n    return \"applepie\", [\"apple\", \"pie\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str], k: int) -> bool:\n    \"\"\"\n    Given a string s, a list of words, and a positive integer k, return True if it is possible to construct the string s by repeating any combination of the words in the list exactly k times. Otherwise, return False.\n\n    Example:\n    s = \"abcabcabc\"\n    words = [\"a\", \"b\", \"c\"]\n    k = 3\n\n    The string s can be constructed by repeating the words \"a\", \"b\", and \"c\" three times, so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\") and len(s) == k * sum(len(word) for word in words)\n\ndef g() -> Tuple[str, List[str], int]:\n    \"\"\"\n    Generate a string s, a list of words, and a positive integer k.\n    \"\"\"\n    return \"abcabcabc\", [\"a\", \"b\", \"c\"], 3\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str], k: int) -> bool:\n    \"\"\"\n    Given a string s, a list of words, and a positive integer k, return True if it is possible to construct the string s by repeating any combination of the words in the list exactly k times. Otherwise, return False.\n\n    Example:\n    s = \"abcabcabc\"\n    words = [\"a\", \"b\", \"c\"]\n    k = 3\n\n    The string s can be constructed by repeating the words \"a\", \"b\", and \"c\" three times, so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\") and len(s) == k * sum(len(word) for word in words)", "solution_func": "def g() -> Tuple[str, List[str], int]:\n    \"\"\"\n    Generate a string s, a list of words, and a positive integer k.\n    \"\"\"\n    return \"abcabcabc\", [\"a\", \"b\", \"c\"], 3", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, return True if it is possible to construct the string s by concatenating the words in the list, in any order, without any overlapping characters. Otherwise, return False.\n\n    Example:\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n\n    The string s can be formed by concatenating the words \"apple\" and \"pie\" without any overlapping characters, so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\")\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words.\n    \"\"\"\n    return \"applepie\", [\"apple\", \"pie\"]\n\nassert f(*g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 351, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, return True if it is possible to construct the string s by concatenating the words in the list, in any order, without any overlapping characters. Otherwise, return False.\n\n    Example:\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n\n    The string s can be formed by concatenating the words \"apple\" and \"pie\" without any overlapping characters, so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\")", "solution_func": "def g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words.\n    \"\"\"\n    return \"applepie\", [\"apple\", \"pie\"]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a clear path. You can only move down or right.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def backtrack(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if row >= rows or col >= cols or matrix[row][col] == 0:\n            return False\n        return backtrack(row + 1, col) or backtrack(row, col + 1)\n\n    return backtrack(0, 0)\n\ndef g(matrix=[[1, 1, 1], [1, 0, 1], [1, 1, 1]]):\n    \"\"\"\n    Generate a matrix with obstacles and clear paths.\n    \"\"\"\n    return matrix\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 351, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a clear path. You can only move down or right.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def backtrack(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if row >= rows or col >= cols or matrix[row][col] == 0:\n            return False\n        return backtrack(row + 1, col) or backtrack(row, col + 1)\n\n    return backtrack(0, 0)", "solution_func": "def g(matrix=[[1, 1, 1], [1, 0, 1], [1, 1, 1]]):\n    \"\"\"\n    Generate a matrix with obstacles and clear paths.\n    \"\"\"\n    return matrix", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return its length.\n\n    The LIS is a subsequence of a given sequence in which the subsequence's elements are in increasing order, and in\n    which the subsequence is as long as possible.\n\n    Return the length of the LIS.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return its length.\n\n    The LIS is a subsequence of a given sequence in which the subsequence's elements are in increasing order, and in\n    which the subsequence is as long as possible.\n\n    Return the length of the LIS.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given integer n is a power of two.\n\n    Return True if n is a power of two, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0\n\ndef g():\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    import random\n    return random.randint(1, 10000)\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 351, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given integer n is a power of two.\n\n    Return True if n is a power of two, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0", "solution_func": "def g():\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    import random\n    return random.randint(1, 10000)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Sample Input:\n    n = 7\n\n    Sample Output:\n    True\n\n    Sample Input:\n    n = 12\n\n    Sample Output:\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=7):\n    return n\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 351, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    Sample Input:\n    n = 7\n\n    Sample Output:\n    True\n\n    Sample Input:\n    n = 12\n\n    Sample Output:\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g(n=7):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a tuple.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return (-1, -1)\n\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 14\n    return nums, target\n\nassert f(*g()) == (5, 6)\n\n", "emb": null, "idx_generation": 352, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a tuple.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return (-1, -1)", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 14\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray within the list.\n    Return the maximum sum.\n    \"\"\"\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray within the list.\n    Return the maximum sum.\n    \"\"\"\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence within the list.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence within the list.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a square matrix of integers, find the maximum sum of any submatrix with dimensions less than or equal to k.\n\n    Example:\n    matrix = [\n        [1, -2, 3],\n        [4, -5, 6],\n        [7, -8, 9]\n    ]\n    k = 2\n\n    Output:\n    18\n\n    Explanation:\n    The maximum sum of any submatrix with dimensions less than or equal to 2 is achieved by selecting the submatrix:\n    [\n        [4, -5],\n        [7, -8]\n    ]\n    The sum of this submatrix is 18.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_sum = float('-inf')\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for m in range(i, rows + 1):\n                for n in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[m][n] - prefix_sum[i-1][n] - prefix_sum[m][j-1] + prefix_sum[i-1][j-1]\n                    if submatrix_sum > max_sum and m - i + 1 <= k and n - j + 1 <= k:\n                        max_sum = submatrix_sum\n\n    return max_sum\n\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, -2, 3],\n        [4, -5, 6],\n        [7, -8, 9]\n    ]\n    return matrix\n\n\nassert f(g()) == 18\n\n", "emb": null, "idx_generation": 352, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a square matrix of integers, find the maximum sum of any submatrix with dimensions less than or equal to k.\n\n    Example:\n    matrix = [\n        [1, -2, 3],\n        [4, -5, 6],\n        [7, -8, 9]\n    ]\n    k = 2\n\n    Output:\n    18\n\n    Explanation:\n    The maximum sum of any submatrix with dimensions less than or equal to 2 is achieved by selecting the submatrix:\n    [\n        [4, -5],\n        [7, -8]\n    ]\n    The sum of this submatrix is 18.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_sum = float('-inf')\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for m in range(i, rows + 1):\n                for n in range(j, cols + 1):\n                    submatrix_sum = prefix_sum[m][n] - prefix_sum[i-1][n] - prefix_sum[m][j-1] + prefix_sum[i-1][j-1]\n                    if submatrix_sum > max_sum and m - i + 1 <= k and n - j + 1 <= k:\n                        max_sum = submatrix_sum\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, -2, 3],\n        [4, -5, 6],\n        [7, -8, 9]\n    ]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1, i.e., 2 and 7, add up to the target number 9.\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1, i.e., 2 and 7, add up to the target number 9.\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n\n    return max(dp)\n\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, determine if it is possible to arrange n distinct numbers in a circle in such a way that the absolute difference between any two adjacent numbers is exactly k.\n\n    Example:\n    Input: n = 4, k = 2\n    Output: True\n\n    Explanation: One possible arrangement is [1, 3, 4, 2], where the absolute difference between any two adjacent numbers is 2.\n\n    Constraints:\n    - 1 <= n <= 10^9\n    - 1 <= k <= n\n    \"\"\"\n\n    if k == 0:\n        return n == 1\n    if n % 2 == 0 and k > n // 2:\n        return False\n    return n % k == 0\n\ndef g(n = 4, k = 2) -> Tuple[int, int]:\n    return n, k\n\nassert f(*g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 352, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, determine if it is possible to arrange n distinct numbers in a circle in such a way that the absolute difference between any two adjacent numbers is exactly k.\n\n    Example:\n    Input: n = 4, k = 2\n    Output: True\n\n    Explanation: One possible arrangement is [1, 3, 4, 2], where the absolute difference between any two adjacent numbers is 2.\n\n    Constraints:\n    - 1 <= n <= 10^9\n    - 1 <= k <= n\n    \"\"\"\n\n    if k == 0:\n        return n == 1\n    if n % 2 == 0 and k > n // 2:\n        return False\n    return n % k == 0", "solution_func": "def g(n = 4, k = 2) -> Tuple[int, int]:\n    return n, k", "map_ix": [1, 1, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"\n    You are given an array of integers nums and an integer k.\n\n    A subarray is defined as a non-empty sequence of consecutive elements from the array nums. The sum of the subarray is the sum of all the elements in that subarray.\n\n    Return true if there exists a subarray of nums such that the sum is equal to k, or false otherwise.\n\n    Example:\n    Input: nums = [1, 1, 1, 2, 3], k = 4\n    Output: True\n\n    Explanation: The subarray [1, 3] has a sum of 4.\n\n    Constraints:\n    - 1 <= n <= 2 * 10^4\n    - -10^9 <= nums[i] <= 10^9\n    - -10^9 <= k <= 10^9\n    \"\"\"\n\n    prefix_sum = {0: 1}\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum += num\n        if curr_sum - k in prefix_sum:\n            return True\n        prefix_sum[curr_sum] = prefix_sum.get(curr_sum, 0) + 1\n\n    return False\n\ndef g(nums = [1, 1, 1, 2, 3], k = 4) -> Tuple[List[int], int, int]:\n    return nums, k\n\nassert f(*g())\n", "emb": null, "idx_generation": 352, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"\n    You are given an array of integers nums and an integer k.\n\n    A subarray is defined as a non-empty sequence of consecutive elements from the array nums. The sum of the subarray is the sum of all the elements in that subarray.\n\n    Return true if there exists a subarray of nums such that the sum is equal to k, or false otherwise.\n\n    Example:\n    Input: nums = [1, 1, 1, 2, 3], k = 4\n    Output: True\n\n    Explanation: The subarray [1, 3] has a sum of 4.\n\n    Constraints:\n    - 1 <= n <= 2 * 10^4\n    - -10^9 <= nums[i] <= 10^9\n    - -10^9 <= k <= 10^9\n    \"\"\"\n\n    prefix_sum = {0: 1}\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum += num\n        if curr_sum - k in prefix_sum:\n            return True\n        prefix_sum[curr_sum] = prefix_sum.get(curr_sum, 0) + 1\n\n    return False", "solution_func": "def g(nums = [1, 1, 1, 2, 3], k = 4) -> Tuple[List[int], int, int]:\n    return nums, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int, target: int) -> bool:\n    \"\"\"\n    Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\n    Example:\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n\n    Explanation: The path with minimum sum is [1, 3, 1, 1, 1], which gives a sum of 7.\n\n    Constraints:\n    - m == grid.length\n    - n == grid[i].length\n    - 1 <= m, n <= 200\n    - 0 <= grid[i][j] <= 100\n    \"\"\"\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid = [[1,3,1],[1,5,1],[4,2,1]]) -> List[List[int]]:\n    return grid\n\nassert f(*g())\n", "emb": null, "idx_generation": 352, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, m: int, target: int) -> bool:\n    \"\"\"\n    Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\n    Example:\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n\n    Explanation: The path with minimum sum is [1, 3, 1, 1, 1], which gives a sum of 7.\n\n    Constraints:\n    - m == grid.length\n    - n == grid[i].length\n    - 1 <= m, n <= 200\n    - 0 <= grid[i][j] <= 100\n    \"\"\"\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g(grid = [[1,3,1],[1,5,1],[4,2,1]]) -> List[List[int]]:\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to n.\"\"\"\n    def subsetSum(n, nums, i, memo):\n        if n == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if memo[i][n] != -1:\n            return memo[i][n]\n        memo[i][n] = subsetSum(n - nums[i], nums, i + 1, memo) or subsetSum(n, nums, i + 1, memo)\n        return memo[i][n]\n    \n    memo = [[-1] * (n + 1) for _ in range(len(nums))]\n    return subsetSum(n, nums, 0, memo)\n\ndef g(nums=[2, 4, 6, 8, 10], n=14):\n    def generateSubsets(nums, curr, index, result):\n        if index == len(nums):\n            result.append(list(curr))\n            return\n        curr.append(nums[index])\n        generateSubsets(nums, curr, index+1, result)\n        curr.pop()\n        generateSubsets(nums, curr, index+1, result)\n\n    subsets = []\n    generateSubsets(nums, [], 0, subsets)\n    return subsets\n\nassert f(g(), g())\n", "emb": null, "idx_generation": 352, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to n.\"\"\"\n    def subsetSum(n, nums, i, memo):\n        if n == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if memo[i][n] != -1:\n            return memo[i][n]\n        memo[i][n] = subsetSum(n - nums[i], nums, i + 1, memo) or subsetSum(n, nums, i + 1, memo)\n        return memo[i][n]\n    \n    memo = [[-1] * (n + 1) for _ in range(len(nums))]\n    return subsetSum(n, nums, 0, memo)", "solution_func": "def g(nums=[2, 4, 6, 8, 10], n=14):\n    def generateSubsets(nums, curr, index, result):\n        if index == len(nums):\n            result.append(list(curr))\n            return\n        curr.append(nums[index])\n        generateSubsets(nums, curr, index+1, result)\n        curr.pop()\n        generateSubsets(nums, curr, index+1, result)\n\n    subsets = []\n    generateSubsets(nums, [], 0, subsets)\n    return subsets", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid crossword solution.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if len(row) != n:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column = [grid[i][j] for i in range(n)]\n        if len(column) != n:\n            return False\n    \n    # Check for intersections\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if (i > 0 and grid[i-1][j] == 1) or (i < n-1 and grid[i+1][j] == 1) or \\\n                   (j > 0 and grid[i][j-1] == 1) or (j < n-1 and grid[i][j+1] == 1):\n                    continue\n                else:\n                    return False\n    \n    return True\n\ndef g():\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid crossword solution.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if len(row) != n:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column = [grid[i][j] for i in range(n)]\n        if len(column) != n:\n            return False\n    \n    # Check for intersections\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if (i > 0 and grid[i-1][j] == 1) or (i < n-1 and grid[i+1][j] == 1) or \\\n                   (j > 0 and grid[i][j-1] == 1) or (j < n-1 and grid[i][j+1] == 1):\n                    continue\n                else:\n                    return False\n    \n    return True", "solution_func": "def g():\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a given string can be partitioned into k equal parts.\n    \"\"\"\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    part_len = n // k\n    for i in range(0, n, part_len):\n        part = s[i:i+part_len]\n        if len(set(part)) != 1:\n            return False\n    \n    return True\n\ndef g(k=3):\n    s = \"abcabcabc\"\n    return s\n\nassert f(g(), 3) == True\n\n", "emb": null, "idx_generation": 353, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a given string can be partitioned into k equal parts.\n    \"\"\"\n    n = len(s)\n    if n % k != 0:\n        return False\n    \n    part_len = n // k\n    for i in range(0, n, part_len):\n        part = s[i:i+part_len]\n        if len(set(part)) != 1:\n            return False\n    \n    return True", "solution_func": "def g(k=3):\n    s = \"abcabcabc\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Determine the number of islands in a given grid.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(i-1, j)\n        dfs(i+1, j)\n        dfs(i, j-1)\n        dfs(i, j+1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Determine the number of islands in a given grid.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(i-1, j)\n        dfs(i+1, j)\n        dfs(i, j-1)\n        dfs(i, j+1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count", "solution_func": "def g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [2,7]\n    Explanation: The sum of 2 and 7 equals 9, so the answer is [2, 7].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2,7,11,15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [2, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [2,7]\n    Explanation: The sum of 2 and 7 equals 9, so the answer is [2, 7].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2,7,11,15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of any subarray.\n    A subarray is a contiguous part of the array.\n    \n    Example:\n    Input: nums = [1, -2, 3, 0, -1, 2]\n    Output: 4\n    Explanation: The subarray with the maximum sum is [3, 0, -1, 2], which has a sum of 4.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [1, -2, 3, 0, -1, 2]\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of any subarray.\n    A subarray is a contiguous part of the array.\n    \n    Example:\n    Input: nums = [1, -2, 3, 0, -1, 2]\n    Output: 4\n    Explanation: The subarray with the maximum sum is [3, 0, -1, 2], which has a sum of 4.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [1, -2, 3, 0, -1, 2]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output: 7\n    Explanation: The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output: 7\n    Explanation: The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 6) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using interpolation search.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right and nums[left] <= target <= nums[right]:\n        pos = left + ((target - nums[left]) * (right - left)) // (nums[right] - nums[left])\n\n        if nums[pos] == target:\n            return pos\n        elif nums[pos] < target:\n            left = pos + 1\n        else:\n            right = pos - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 6) == 5\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using interpolation search.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right and nums[left] <= target <= nums[right]:\n        pos = left + ((target - nums[left]) * (right - left)) // (nums[right] - nums[left])\n\n        if nums[pos] == target:\n            return pos\n        elif nums[pos] < target:\n            left = pos + 1\n        else:\n            right = pos - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the index of the target value in the list using linear search.\n\n    Example:\n    Input: nums = [5, 3, 8, 2, 10, 6, 7, 1, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [5, 3, 8, 2, 10, 6, 7, 1, 9]\n\nassert f(g(), 6) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the index of the target value in the list using linear search.\n\n    Example:\n    Input: nums = [5, 3, 8, 2, 10, 6, 7, 1, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    for i in range(len(nums)):\n        if nums[i] == target:\n            return i\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [5, 3, 8, 2, 10, 6, 7, 1, 9]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are three numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n\n    Sample input:\n    arr = [2, 4, 6, 8, 10]\n    target = 18\n\n    Sample output:\n    True\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] + arr[j] + arr[k] == target:\n                    return True\n    return False\n\ndef g(arr = [2, 4, 6, 8, 10], target = 18):\n    return arr\n\nassert f(g(), 18) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 353, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are three numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n\n    Sample input:\n    arr = [2, 4, 6, 8, 10]\n    target = 18\n\n    Sample output:\n    True\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if arr[i] + arr[j] + arr[k] == target:\n                    return True\n    return False", "solution_func": "def g(arr = [2, 4, 6, 8, 10], target = 18):\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list using binary search.\n    If the target is not present in the list, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is located at index 5 in the list.\n    \"\"\"\n\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list using binary search.\n    If the target is not present in the list, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is located at index 5 in the list.\n    \"\"\"\n\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, count the total number of set bits in all numbers from 1 to n (inclusive).\n\n    Example:\n    n = 5\n\n    Output:\n    7\n\n    Explanation:\n    The numbers from 1 to 5 (inclusive) are 1, 2, 3, 4, 5.\n    The total number of set bits in these numbers is 7.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += 1\n            num = num & (num - 1)\n        return count\n\n    total_set_bits = 0\n    for i in range(1, n + 1):\n        total_set_bits += count_set_bits(i)\n\n    return total_set_bits\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, count the total number of set bits in all numbers from 1 to n (inclusive).\n\n    Example:\n    n = 5\n\n    Output:\n    7\n\n    Explanation:\n    The numbers from 1 to 5 (inclusive) are 1, 2, 3, 4, 5.\n    The total number of set bits in these numbers is 7.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += 1\n            num = num & (num - 1)\n        return count\n\n    total_set_bits = 0\n    for i in range(1, n + 1):\n        total_set_bits += count_set_bits(i)\n\n    return total_set_bits", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is 6, which is obtained by summing the subarray [4, -1, 2, 1].\n    \"\"\"\n\n    def max_subarray_sum(nums, left, right):\n        if left == right:\n            return nums[left]\n\n        mid = (left + right) // 2\n\n        left_max_sum = max_subarray_sum(nums, left, mid)\n        right_max_sum = max_subarray_sum(nums, mid + 1, right)\n\n        cross_max_sum = float('-inf')\n        left_sum = 0\n        for i in range(mid, left - 1, -1):\n            left_sum += nums[i]\n            cross_max_sum = max(cross_max_sum, left_sum)\n\n        right_sum = 0\n        for i in range(mid + 1, right + 1):\n            right_sum += nums[i]\n            cross_max_sum = max(cross_max_sum, right_sum)\n\n        return max(left_max_sum, right_max_sum, cross_max_sum)\n\n    return max_subarray_sum(nums, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 354, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is 6, which is obtained by summing the subarray [4, -1, 2, 1].\n    \"\"\"\n\n    def max_subarray_sum(nums, left, right):\n        if left == right:\n            return nums[left]\n\n        mid = (left + right) // 2\n\n        left_max_sum = max_subarray_sum(nums, left, mid)\n        right_max_sum = max_subarray_sum(nums, mid + 1, right)\n\n        cross_max_sum = float('-inf')\n        left_sum = 0\n        for i in range(mid, left - 1, -1):\n            left_sum += nums[i]\n            cross_max_sum = max(cross_max_sum, left_sum)\n\n        right_sum = 0\n        for i in range(mid + 1, right + 1):\n            right_sum += nums[i]\n            cross_max_sum = max(cross_max_sum, right_sum)\n\n        return max(left_max_sum, right_max_sum, cross_max_sum)\n\n    return max_subarray_sum(nums, 0, len(nums) - 1)", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to select k items from a set of n items, where order does not matter and repetition is allowed.\"\"\"\n    def combinations(n, k):\n        if k == 0 or k == n:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n    \n    return combinations(n, k) % 10**9 == 0\n\ndef g(n = 10, k = 3):\n    return n, k\n\nassert f(g())\n", "emb": null, "idx_generation": 354, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to select k items from a set of n items, where order does not matter and repetition is allowed.\"\"\"\n    def combinations(n, k):\n        if k == 0 or k == n:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n    \n    return combinations(n, k) % 10**9 == 0", "solution_func": "def g(n = 10, k = 3):\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Find the shortest path in a graph from start to end with exactly k edges.\"\"\"\n    def shortest_path(graph, start, end, k):\n        if start == end and k == 0:\n            return True\n        if k <= 0:\n            return False\n        \n        visited = set()\n        queue = deque([(start, 0)])\n        \n        while queue:\n            node, edges = queue.popleft()\n            \n            if node == end and edges == k:\n                return True\n            \n            if edges < k:\n                for neighbor in graph[node]:\n                    if (neighbor, edges + 1) not in visited:\n                        queue.append((neighbor, edges + 1))\n                        visited.add((neighbor, edges + 1))\n        \n        return False\n    \n    return shortest_path(graph, start, end, k)\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    k = 2\n    return graph, start, end, k\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 354, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom collections import deque\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Find the shortest path in a graph from start to end with exactly k edges.\"\"\"\n    def shortest_path(graph, start, end, k):\n        if start == end and k == 0:\n            return True\n        if k <= 0:\n            return False\n        \n        visited = set()\n        queue = deque([(start, 0)])\n        \n        while queue:\n            node, edges = queue.popleft()\n            \n            if node == end and edges == k:\n                return True\n            \n            if edges < k:\n                for neighbor in graph[node]:\n                    if (neighbor, edges + 1) not in visited:\n                        queue.append((neighbor, edges + 1))\n                        visited.add((neighbor, edges + 1))\n        \n        return False\n    \n    return shortest_path(graph, start, end, k)", "solution_func": "def g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    k = 2\n    return graph, start, end, k", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find the maximum subarray sum of nums that is less than or equal to the target.\"\"\"\n    def max_subarray_sum(nums, target):\n        prefix_sums = [0]\n        max_sum = float('-inf')\n        \n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n            \n            for i in range(len(prefix_sums) - 1):\n                if prefix_sums[-1] - prefix_sums[i] <= target:\n                    max_sum = max(max_sum, prefix_sums[-1] - prefix_sums[i])\n        \n        return max_sum\n    \n    return max_subarray_sum(nums, target) > 0\n\ndef g(target = 10):\n    nums = [1, -2, 3, -4, 5]\n    return nums, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find the maximum subarray sum of nums that is less than or equal to the target.\"\"\"\n    def max_subarray_sum(nums, target):\n        prefix_sums = [0]\n        max_sum = float('-inf')\n        \n        for num in nums:\n            prefix_sums.append(prefix_sums[-1] + num)\n            \n            for i in range(len(prefix_sums) - 1):\n                if prefix_sums[-1] - prefix_sums[i] <= target:\n                    max_sum = max(max_sum, prefix_sums[-1] - prefix_sums[i])\n        \n        return max_sum\n    \n    return max_subarray_sum(nums, target) > 0", "solution_func": "def g(target = 10):\n    nums = [1, -2, 3, -4, 5]\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, return a new list where each element is the sum of all previous elements in arr.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    The new list should be [1, 3, 6, 10], where the first element is the same as the original list and each subsequent element is the sum of all previous elements in the original list.\n\n    Constraints:\n    - The input list arr will have at least one element.\n    \"\"\"\n\n    # Base case: when arr is empty, return an empty list\n    if not arr:\n        return []\n\n    # Recursive case: compute the new list by adding the first element of arr to each element of the new list\n    new_arr = f(arr[:-1]) + [sum(arr)]\n    return new_arr\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be used as input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [1, 3, 6, 10]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, return a new list where each element is the sum of all previous elements in arr.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    The new list should be [1, 3, 6, 10], where the first element is the same as the original list and each subsequent element is the sum of all previous elements in the original list.\n\n    Constraints:\n    - The input list arr will have at least one element.\n    \"\"\"\n\n    # Base case: when arr is empty, return an empty list\n    if not arr:\n        return []\n\n    # Recursive case: compute the new list by adding the first element of arr to each element of the new list\n    new_arr = f(arr[:-1]) + [sum(arr)]\n    return new_arr", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be used as input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the product of all positive integers in the list.\n\n    Example:\n    nums = [2, -3, 4, 0, -1, 5]\n\n    The positive integers in the list are 2, 4, and 5. The product of these numbers is 40, so the function should return 40.\n\n    Constraints:\n    - The input list nums may contain positive and negative integers, as well as zeros.\n    - The product should be calculated using only the positive integers in the list.\n    \"\"\"\n\n    # Base case: when nums is empty, return 1 as the product\n    if not nums:\n        return 1\n\n    # Recursive case: multiply the first element of nums with the product of the rest of the list\n    product = f(nums[1:])\n    if nums[0] > 0:\n        product *= nums[0]\n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be used as input for the function f.\n    \"\"\"\n    return [2, -3, 4, 0, -1, 5]\n\nassert f(g()) == 40\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the product of all positive integers in the list.\n\n    Example:\n    nums = [2, -3, 4, 0, -1, 5]\n\n    The positive integers in the list are 2, 4, and 5. The product of these numbers is 40, so the function should return 40.\n\n    Constraints:\n    - The input list nums may contain positive and negative integers, as well as zeros.\n    - The product should be calculated using only the positive integers in the list.\n    \"\"\"\n\n    # Base case: when nums is empty, return 1 as the product\n    if not nums:\n        return 1\n\n    # Recursive case: multiply the first element of nums with the product of the rest of the list\n    product = f(nums[1:])\n    if nums[0] > 0:\n        product *= nums[0]\n    return product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be used as input for the function f.\n    \"\"\"\n    return [2, -3, 4, 0, -1, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\"]\n\n    The new list should be [\"elppa\", \"ananab\", \"yrrehc\"], where each word is reversed.\n\n    Constraints:\n    - The input list words will have at least one word.\n    \"\"\"\n\n    # Base case: when words is empty, return an empty list\n    if not words:\n        return []\n\n    # Recursive case: reverse the first word and concatenate it with the new list of reversed words\n    reversed_words = f(words[:-1]) + [words[-1][::-1]]\n    return reversed_words\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words that can be used as input for the function f.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\"]\n\nassert f(g()) == [\"elppa\", \"ananab\", \"yrrehc\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\"]\n\n    The new list should be [\"elppa\", \"ananab\", \"yrrehc\"], where each word is reversed.\n\n    Constraints:\n    - The input list words will have at least one word.\n    \"\"\"\n\n    # Base case: when words is empty, return an empty list\n    if not words:\n        return []\n\n    # Recursive case: reverse the first word and concatenate it with the new list of reversed words\n    reversed_words = f(words[:-1]) + [words[-1][::-1]]\n    return reversed_words", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of words that can be used as input for the function f.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all possible substrings of s with length k.\n\n    Example:\n    s = \"abcde\"\n    k = 3\n\n    The string \"abcde\" has the following substrings with length 3: [\"abc\", \"bcd\", \"cde\"].\n\n    Therefore, the function should return [\"abc\", \"bcd\", \"cde\"].\n    \"\"\"\n\n    substrings = []\n    for i in range(len(s) - k + 1):\n        substrings.append(s[i:i+k])\n    return substrings\n\ndef g():\n    s = \"abcde\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"abc\", \"bcd\", \"cde\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 354, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all possible substrings of s with length k.\n\n    Example:\n    s = \"abcde\"\n    k = 3\n\n    The string \"abcde\" has the following substrings with length 3: [\"abc\", \"bcd\", \"cde\"].\n\n    Therefore, the function should return [\"abc\", \"bcd\", \"cde\"].\n    \"\"\"\n\n    substrings = []\n    for i in range(len(s) - k + 1):\n        substrings.append(s[i:i+k])\n    return substrings", "solution_func": "def g():\n    s = \"abcde\"\n    k = 3\n    return s, k", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists three elements in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 3, 4, and 5 have bitwise XOR of 3, which is equal to the target value 6.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            curr_xor = nums[i] ^ nums[left] ^ nums[right]\n\n            if curr_xor == target:\n                return True\n            elif curr_xor < target:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 6) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists three elements in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 3, 4, and 5 have bitwise XOR of 3, which is equal to the target value 6.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            curr_xor = nums[i] ^ nums[left] ^ nums[right]\n\n            if curr_xor == target:\n                return True\n            elif curr_xor < target:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the sum of any two numbers in the list is equal to the XOR of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The XOR of all the numbers in the list is 1 ^ 2 ^ 3 ^ 4 ^ 5 = 3.\n\n    The sum of 2 and 3 is 5, which is equal to the XOR of all the numbers.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    xor_sum = 0\n    sum_two = set()\n\n    for num in nums:\n        xor_sum ^= num\n\n    for num in nums:\n        if (xor_sum ^ num) in sum_two:\n            return True\n        sum_two.add(num)\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the sum of any two numbers in the list is equal to the XOR of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The XOR of all the numbers in the list is 1 ^ 2 ^ 3 ^ 4 ^ 5 = 3.\n\n    The sum of 2 and 3 is 5, which is equal to the XOR of all the numbers.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    xor_sum = 0\n    sum_two = set()\n\n    for num in nums:\n        xor_sum ^= num\n\n    for num in nums:\n        if (xor_sum ^ num) in sum_two:\n            return True\n        sum_two.add(num)\n\n    return False", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by selecting any two numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum XOR value can be obtained by selecting 4 and 5, which gives the XOR value of 1.\n\n    Therefore, the function should return 1.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            curr_xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, curr_xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 355, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by selecting any two numbers from the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum XOR value can be obtained by selecting 4 and 5, which gives the XOR value of 1.\n\n    Therefore, the function should return 1.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            curr_xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, curr_xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    If the target value is not found in the list, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value for Puzzle 3.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11], 5\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    If the target value is not found in the list, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value for Puzzle 3.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11], 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum spanning tree (MST) using Prim's algorithm.\n\n    Return the total weight of the MST.\n\n    Example:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The minimum spanning tree is formed by the edges (0, 1), (1, 2), (1, 4), and (2, 3), with a total weight of 16.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    key = [float('inf')] * n\n    key[0] = 0\n    mst = 0\n\n    for _ in range(n):\n        u = min_vertex(key, visited)\n        visited[u] = True\n        mst += key[u]\n\n        for v in range(n):\n            if graph[u][v] > 0 and not visited[v] and graph[u][v] < key[v]:\n                key[v] = graph[u][v]\n\n    return mst\n\ndef min_vertex(key, visited):\n    min_key = float('inf')\n    min_vertex = -1\n\n    for v in range(len(key)):\n        if not visited[v] and key[v] < min_key:\n            min_key = key[v]\n            min_vertex = v\n    \n    return min_vertex\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\nassert f(g()) == 16\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 355, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum spanning tree (MST) using Prim's algorithm.\n\n    Return the total weight of the MST.\n\n    Example:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The minimum spanning tree is formed by the edges (0, 1), (1, 2), (1, 4), and (2, 3), with a total weight of 16.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    key = [float('inf')] * n\n    key[0] = 0\n    mst = 0\n\n    for _ in range(n):\n        u = min_vertex(key, visited)\n        visited[u] = True\n        mst += key[u]\n\n        for v in range(n):\n            if graph[u][v] > 0 and not visited[v] and graph[u][v] < key[v]:\n                key[v] = graph[u][v]\n\n    return mst\n\ndef min_vertex(key, visited):\n    min_key = float('inf')\n    min_vertex = -1\n\n    for v in range(len(key)):\n        if not visited[v] and key[v] < min_key:\n            min_key = key[v]\n            min_vertex = v\n    \n    return min_vertex", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string and an integer k, split the string into k non-empty substrings such that each substring has the same number of 'a' characters.\n\n    Return a list of the substrings.\n\n    Example:\n    s = \"aabbaaaba\"\n    k = 3\n\n    Output:\n    ['aab', 'baa', 'aba']\n\n    Explanation:\n    The string is split into 3 substrings: 'aab', 'baa', and 'aba'.\n    Each substring has the same number of 'a' characters (2).\n    \"\"\"\n    n = len(s)\n    count = s.count('a')\n\n    if count % k != 0 or n % k != 0:\n        return []\n\n    sub_length = n // k\n    sub_count = count // k\n    substrings = []\n\n    for i in range(0, n, sub_length):\n        substring = s[i:i+sub_length]\n        a_count = substring.count('a')\n\n        if a_count != sub_count:\n            return []\n        \n        substrings.append(substring)\n\n    return substrings\n\ndef g() -> List[str, int]:\n    \"\"\"\n    Generate a string and an integer for Puzzle 5.\n    \"\"\"\n    return \"aabbaaaba\", 3\n\nassert f(*g()) == ['aab', 'baa', 'aba']\n", "emb": null, "idx_generation": 355, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string and an integer k, split the string into k non-empty substrings such that each substring has the same number of 'a' characters.\n\n    Return a list of the substrings.\n\n    Example:\n    s = \"aabbaaaba\"\n    k = 3\n\n    Output:\n    ['aab', 'baa', 'aba']\n\n    Explanation:\n    The string is split into 3 substrings: 'aab', 'baa', and 'aba'.\n    Each substring has the same number of 'a' characters (2).\n    \"\"\"\n    n = len(s)\n    count = s.count('a')\n\n    if count % k != 0 or n % k != 0:\n        return []\n\n    sub_length = n // k\n    sub_count = count // k\n    substrings = []\n\n    for i in range(0, n, sub_length):\n        substring = s[i:i+sub_length]\n        a_count = substring.count('a')\n\n        if a_count != sub_count:\n            return []\n        \n        substrings.append(substring)\n\n    return substrings", "solution_func": "def g() -> List[str, int]:\n    \"\"\"\n    Generate a string and an integer for Puzzle 5.\n    \"\"\"\n    return \"aabbaaaba\", 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> int:\n    \"\"\"\n    Given an integer n and a list of integers arr, find the number of increasing subsequences of length n that can be formed from the elements of arr.\n\n    Sample Input:\n    n = 3\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    10\n\n    Explanation: The increasing subsequences of length 3 that can be formed from the elements of arr are [1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5].\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        count += count_subsequences(n, i, arr)\n    return count\n\ndef count_subsequences(n: int, index: int, arr: List[int]) -> int:\n    if n == 0:\n        return 1\n    count = 0\n    for i in range(index + 1, len(arr)):\n        if arr[i] > arr[index]:\n            count += count_subsequences(n - 1, i, arr)\n    return count\n\ndef g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a random integer n and a list of integers arr.\n    \"\"\"\n    n = 3\n    arr = [1, 2, 3, 4, 5]\n    return n, arr\n\nassert f(*g()) == 10\n", "emb": null, "idx_generation": 355, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> int:\n    \"\"\"\n    Given an integer n and a list of integers arr, find the number of increasing subsequences of length n that can be formed from the elements of arr.\n\n    Sample Input:\n    n = 3\n    arr = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    10\n\n    Explanation: The increasing subsequences of length 3 that can be formed from the elements of arr are [1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5].\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        count += count_subsequences(n, i, arr)\n    return count\n\ndef count_subsequences(n: int, index: int, arr: List[int]) -> int:\n    if n == 0:\n        return 1\n    count = 0\n    for i in range(index + 1, len(arr)):\n        if arr[i] > arr[index]:\n            count += count_subsequences(n - 1, i, arr)\n    return count", "solution_func": "def g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a random integer n and a list of integers arr.\n    \"\"\"\n    n = 3\n    arr = [1, 2, 3, 4, 5]\n    return n, arr", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to reach the bottom-right corner of a n x m grid from the top-left corner. You can only move down or right.\n\n    Sample Input:\n    n = 3\n    m = 4\n\n    Sample Output:\n    10\n\n    Explanation: From the top-left corner, there are 10 possible paths to reach the bottom-right corner of a 3 x 4 grid.\n\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n - 1, m) + f(n, m - 1)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two random integers n and m.\n    \"\"\"\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 355, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to reach the bottom-right corner of a n x m grid from the top-left corner. You can only move down or right.\n\n    Sample Input:\n    n = 3\n    m = 4\n\n    Sample Output:\n    10\n\n    Explanation: From the top-left corner, there are 10 possible paths to reach the bottom-right corner of a 3 x 4 grid.\n\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n - 1, m) + f(n, m - 1)", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two random integers n and m.\n    \"\"\"\n    n = 3\n    m = 4\n    return n, m", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int, blocked: List[List[int]]) -> int:\n    \"\"\"\n    Given two integers n and m representing the dimensions of a grid and a list of blocked cells, find the number of unique paths from the top-left cell to the bottom-right cell. You can only move down or right. The blocked cells cannot be traversed.\n\n    Sample Input:\n    n = 3\n    m = 3\n    blocked = [[1, 0], [1, 1], [2, 2]]\n\n    Sample Output:\n    2\n\n    Explanation: From the top-left corner, there are 2 unique paths to reach the bottom-right corner of the grid. The blocked cells at (1, 0), (1, 1), and (2, 2) cannot be traversed.\n\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if [i, j] in blocked:\n                continue\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][m - 1]\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate random integers n and m representing the dimensions of a grid, and a list of blocked cells.\n    \"\"\"\n    n = 3\n    m = 3\n    blocked = [[1, 0], [1, 1], [2, 2]]\n    return n, m, blocked\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 355, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int, blocked: List[List[int]]) -> int:\n    \"\"\"\n    Given two integers n and m representing the dimensions of a grid and a list of blocked cells, find the number of unique paths from the top-left cell to the bottom-right cell. You can only move down or right. The blocked cells cannot be traversed.\n\n    Sample Input:\n    n = 3\n    m = 3\n    blocked = [[1, 0], [1, 1], [2, 2]]\n\n    Sample Output:\n    2\n\n    Explanation: From the top-left corner, there are 2 unique paths to reach the bottom-right corner of the grid. The blocked cells at (1, 0), (1, 1), and (2, 2) cannot be traversed.\n\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if [i, j] in blocked:\n                continue\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][m - 1]", "solution_func": "def g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate random integers n and m representing the dimensions of a grid, and a list of blocked cells.\n    \"\"\"\n    n = 3\n    m = 3\n    blocked = [[1, 0], [1, 1], [2, 2]]\n    return n, m, blocked", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], as 2 + 7 = 9.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([2, 4, 7, 11, 15], 18)\n\nassert f(*g()) == [1, 3]\n\n", "emb": null, "idx_generation": 355, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], as 2 + 7 = 9.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([2, 4, 7, 11, 15], 18)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Check if the given string s is a permutation of the string t.\n    \"\"\"\n    sorted_s = sorted(s)\n    sorted_t = sorted(t)\n    return sorted_s == sorted_t\n\ndef g(t: str):\n    return ''.join(sorted(t))\n\nassert f(g('permutation'), 'mutationper') == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Check if the given string s is a permutation of the string t.\n    \"\"\"\n    sorted_s = sorted(s)\n    sorted_t = sorted(t)\n    return sorted_s == sorted_t", "solution_func": "def g(t: str):\n    return ''.join(sorted(t))", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Rotate the given string s by k positions to the right.\n    \"\"\"\n    n = len(s)\n    k = k % n\n    rotated_string = s[-k:] + s[:-k]\n    return rotated_string\n\ndef g(k: int):\n    return 'abcdefghij'\n\nassert f(g(3), 3) == 'hijabcdefghi'\n", "emb": null, "idx_generation": 356, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Rotate the given string s by k positions to the right.\n    \"\"\"\n    n = len(s)\n    k = k % n\n    rotated_string = s[-k:] + s[:-k]\n    return rotated_string", "solution_func": "def g(k: int):\n    return 'abcdefghij'", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Calculate the sum of the ASCII values of all the characters in the given string s.\n    \"\"\"\n    ascii_sum = sum(ord(c) for c in s)\n    return ascii_sum\n\ndef g():\n    return 'hello'\n\nassert f(g()) == 532\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Calculate the sum of the ASCII values of all the characters in the given string s.\n    \"\"\"\n    ascii_sum = sum(ord(c) for c in s)\n    return ascii_sum", "solution_func": "def g():\n    return 'hello'", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 4\n    Output: 3\n    Explanation: The target number 4 is located at index 3 in the list.\n\n    Note:\n    - The list is guaranteed to be sorted in ascending order.\n    - If the target number is not found in the list, return -1.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 2, 3, 4, 5], target=4):\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 4\n    Output: 3\n    Explanation: The target number 4 is located at index 3 in the list.\n\n    Note:\n    - The list is guaranteed to be sorted in ascending order.\n    - If the target number is not found in the list, return -1.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=4):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency list and two vertices (start and end), find the length of the shortest path from start to end.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [3],\n        3: []\n    }\n    start = 0\n    end = 3\n    Output: 3\n    Explanation: The shortest path from vertex 0 to vertex 3 is [0, 2, 3].\n\n    Note:\n    - The graph is represented as a dictionary, where the keys are the vertices and the values are lists of adjacent vertices.\n    - If there is no path from start to end, return -1.\n    \"\"\"\n\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        vertex, length = queue.pop(0)\n\n        if vertex == end:\n            return length\n\n        if vertex in visited:\n            continue\n\n        visited.add(vertex)\n\n        for neighbor in graph[vertex]:\n            queue.append((neighbor, length + 1))\n\n    return -1\n\ndef g(graph={0: [1, 2], 1: [2], 2: [3], 3: []}, start=0, end=3):\n    return graph, start, end\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 356, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency list and two vertices (start and end), find the length of the shortest path from start to end.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [3],\n        3: []\n    }\n    start = 0\n    end = 3\n    Output: 3\n    Explanation: The shortest path from vertex 0 to vertex 3 is [0, 2, 3].\n\n    Note:\n    - The graph is represented as a dictionary, where the keys are the vertices and the values are lists of adjacent vertices.\n    - If there is no path from start to end, return -1.\n    \"\"\"\n\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        vertex, length = queue.pop(0)\n\n        if vertex == end:\n            return length\n\n        if vertex in visited:\n            continue\n\n        visited.add(vertex)\n\n        for neighbor in graph[vertex]:\n            queue.append((neighbor, length + 1))\n\n    return -1", "solution_func": "def g(graph={0: [1, 2], 1: [2], 2: [3], 3: []}, start=0, end=3):\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Note:\n    - The subarray must be contiguous (i.e., it cannot skip elements in between).\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Note:\n    - The subarray must be contiguous (i.e., it cannot skip elements in between).\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of unique combinations\n    of numbers in the list that add up to k. Each number in the list may be used\n    multiple times in each combination.\n\n    Example:\n    nums = [1, 2, 3], k = 4\n    Output: 7\n\n    nums = [2, 5, 9], k = 12\n    Output: 4\n    \"\"\"\n\n    def helper(target):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        count = 0\n        for num in nums:\n            count += helper(target - num)\n        \n        memo[target] = count\n        return count\n    \n    memo = {}\n    return helper(k)\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g(), 4) == 7\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of unique combinations\n    of numbers in the list that add up to k. Each number in the list may be used\n    multiple times in each combination.\n\n    Example:\n    nums = [1, 2, 3], k = 4\n    Output: 7\n\n    nums = [2, 5, 9], k = 12\n    Output: 4\n    \"\"\"\n\n    def helper(target):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        count = 0\n        for num in nums:\n            count += helper(target - num)\n        \n        memo[target] = count\n        return count\n    \n    memo = {}\n    return helper(k)", "solution_func": "def g():\n    return [1, 2, 3]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every two nodes are connected to each other by a path.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The graph has 2 connected components:\n    - Component 1: Nodes 0, 1\n    - Component 2: Nodes 2, 3\n\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                for neighbor in range(len(matrix)):\n                    if matrix[curr][neighbor] == 1 and not visited[neighbor]:\n                        stack.append(neighbor)\n    \n    n = len(matrix)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n    \n    return count\n\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every two nodes are connected to each other by a path.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The graph has 2 connected components:\n    - Component 1: Nodes 0, 1\n    - Component 2: Nodes 2, 3\n\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                for neighbor in range(len(matrix)):\n                    if matrix[curr][neighbor] == 1 and not visited[neighbor]:\n                        stack.append(neighbor)\n    \n    n = len(matrix)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n    \n    return count", "solution_func": "def g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a number n, find the number of ways to climb to the top by taking steps of size 1, 2, or 3.\n\n    Example:\n    n = 3\n    Output: 4\n\n    Explanation: There are 4 ways to climb to the top:\n    1) 1 step + 1 step + 1 step\n    2) 1 step + 2 steps\n    3) 2 steps + 1 step\n    4) 3 steps\n    \"\"\"\n\n    def helper(steps):\n        if steps == 0:\n            return 1\n        if steps < 0:\n            return 0\n        if steps in memo:\n            return memo[steps]\n        \n        count = 0\n        for step in [1, 2, 3]:\n            count += helper(steps - step)\n        \n        memo[steps] = count\n        return count\n    \n    memo = {}\n    return helper(n)\n\ndef g():\n    return 3\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a number n, find the number of ways to climb to the top by taking steps of size 1, 2, or 3.\n\n    Example:\n    n = 3\n    Output: 4\n\n    Explanation: There are 4 ways to climb to the top:\n    1) 1 step + 1 step + 1 step\n    2) 1 step + 2 steps\n    3) 2 steps + 1 step\n    4) 3 steps\n    \"\"\"\n\n    def helper(steps):\n        if steps == 0:\n            return 1\n        if steps < 0:\n            return 0\n        if steps in memo:\n            return memo[steps]\n        \n        count = 0\n        for step in [1, 2, 3]:\n            count += helper(steps - step)\n        \n        memo[steps] = count\n        return count\n    \n    memo = {}\n    return helper(n)", "solution_func": "def g():\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> (List[int], int):\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 356, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> (List[int], int):\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of integers in the list such that their sum is equal to the target value.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    arr = [2, 7, 11, 15]\n    target = 18\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 357, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of integers in the list such that their sum is equal to the target value.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    arr = [2, 7, 11, 15]\n    target = 18\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    3\n\n    Explanation: There are three ways to climb to the top of the staircase with 3 steps:\n    1. 1 step + 1 step + 1 step\n    2. 1 step + 2 steps\n    3. 2 steps + 1 step\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 4\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    3\n\n    Explanation: There are three ways to climb to the top of the staircase with 3 steps:\n    1. 1 step + 1 step + 1 step\n    2. 1 step + 2 steps\n    3. 2 steps + 1 step\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 4", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representation of a boolean expression, evaluate the expression and return the result.\n    The expression can contain the following operators: '!', '&', '|', '(', and ')'.\n    The '!' operator represents logical negation, the '&' operator represents logical AND, and the '|' operator represents logical OR.\n\n    Sample Input:\n    expression = \"!(A & B) | C\"\n\n    Sample Output:\n    True\n\n    Explanation: The expression \"!(A & B) | C\" evaluates to True for any values of A, B, and C such that at least one of the variables is True.\n    \"\"\"\n    stack = []\n\n    for char in expression:\n        if char == ')':\n            while stack and stack[-1] != '(':\n                operand2 = stack.pop()\n                operator = stack.pop()\n                operand1 = stack.pop()\n\n                if operator == '!':\n                    result = not operand2\n                elif operator == '&':\n                    result = operand1 and operand2\n                elif operator == '|':\n                    result = operand1 or operand2\n\n                stack.append(result)\n\n            stack.pop()  # Pop the '('\n\n        else:\n            stack.append(char)\n\n    return stack[0]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string representation of a boolean expression.\n    \"\"\"\n    return \"!(A & B) | C\"\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 357, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representation of a boolean expression, evaluate the expression and return the result.\n    The expression can contain the following operators: '!', '&', '|', '(', and ')'.\n    The '!' operator represents logical negation, the '&' operator represents logical AND, and the '|' operator represents logical OR.\n\n    Sample Input:\n    expression = \"!(A & B) | C\"\n\n    Sample Output:\n    True\n\n    Explanation: The expression \"!(A & B) | C\" evaluates to True for any values of A, B, and C such that at least one of the variables is True.\n    \"\"\"\n    stack = []\n\n    for char in expression:\n        if char == ')':\n            while stack and stack[-1] != '(':\n                operand2 = stack.pop()\n                operator = stack.pop()\n                operand1 = stack.pop()\n\n                if operator == '!':\n                    result = not operand2\n                elif operator == '&':\n                    result = operand1 and operand2\n                elif operator == '|':\n                    result = operand1 or operand2\n\n                stack.append(result)\n\n            stack.pop()  # Pop the '('\n\n        else:\n            stack.append(char)\n\n    return stack[0]", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string representation of a boolean expression.\n    \"\"\"\n    return \"!(A & B) | C\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[int]:\n    \"\"\"\n    Given two integers n and m, return a list of the first n Fibonacci numbers modulo m.\n\n    Sample Input:\n    n = 6\n    m = 100\n\n    Sample Output:\n    [0, 1, 1, 2, 3, 5]\n    \"\"\"\n    fib_nums = [0, 1]  # Initialize the first two Fibonacci numbers\n    for i in range(2, n):\n        fib_nums.append((fib_nums[i - 1] + fib_nums[i - 2]) % m)  # Calculate the next Fibonacci number modulo m\n    return fib_nums\n\ndef g(n=6, m=100):\n    return n, m\n\nassert f(*g()) == [0, 1, 1, 2, 3, 5]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[int]:\n    \"\"\"\n    Given two integers n and m, return a list of the first n Fibonacci numbers modulo m.\n\n    Sample Input:\n    n = 6\n    m = 100\n\n    Sample Output:\n    [0, 1, 1, 2, 3, 5]\n    \"\"\"\n    fib_nums = [0, 1]  # Initialize the first two Fibonacci numbers\n    for i in range(2, n):\n        fib_nums.append((fib_nums[i - 1] + fib_nums[i - 2]) % m)  # Calculate the next Fibonacci number modulo m\n    return fib_nums", "solution_func": "def g(n=6, m=100):\n    return n, m", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return a list of the first n prime numbers that have exactly k digits.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    [101, 103, 107, 109, 113]\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_nums = []\n    num = 10 ** (k - 1)  # Start with the first number that has k digits\n    while len(prime_nums) < n:\n        if is_prime(num):\n            prime_nums.append(num)\n        num += 1\n    return prime_nums\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == [101, 103, 107, 109, 113]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return a list of the first n prime numbers that have exactly k digits.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    [101, 103, 107, 109, 113]\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_nums = []\n    num = 10 ** (k - 1)  # Start with the first number that has k digits\n    while len(prime_nums) < n:\n        if is_prime(num):\n            prime_nums.append(num)\n        num += 1\n    return prime_nums", "solution_func": "def g(n=5, k=3):\n    return n, k", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[str]:\n    \"\"\"\n    Given two integers n and k, return a list of all binary strings of length n that have exactly k ones.\n\n    Sample Input:\n    n = 4\n    k = 2\n\n    Sample Output:\n    ['0011', '0101', '0110', '1001', '1010', '1100']\n    \"\"\"\n    def generate_binary_strings(curr_str, num_ones, remaining):\n        if remaining == 0:\n            binary_strings.append(curr_str)\n            return\n        if num_ones > 0:\n            generate_binary_strings(curr_str + '1', num_ones - 1, remaining - 1)\n        generate_binary_strings(curr_str + '0', num_ones, remaining - 1)\n    \n    binary_strings = []\n    generate_binary_strings(\"\", k, n)\n    return binary_strings\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g()) == ['0011', '0101', '0110', '1001', '1010', '1100']\n", "emb": null, "idx_generation": 357, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[str]:\n    \"\"\"\n    Given two integers n and k, return a list of all binary strings of length n that have exactly k ones.\n\n    Sample Input:\n    n = 4\n    k = 2\n\n    Sample Output:\n    ['0011', '0101', '0110', '1001', '1010', '1100']\n    \"\"\"\n    def generate_binary_strings(curr_str, num_ones, remaining):\n        if remaining == 0:\n            binary_strings.append(curr_str)\n            return\n        if num_ones > 0:\n            generate_binary_strings(curr_str + '1', num_ones - 1, remaining - 1)\n        generate_binary_strings(curr_str + '0', num_ones, remaining - 1)\n    \n    binary_strings = []\n    generate_binary_strings(\"\", k, n)\n    return binary_strings", "solution_func": "def g(n=4, k=2):\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, a: List[int], b: List[int]) -> bool:\n    \"\"\"\n    Given two lists of integers, a and b, determine if there exists a path in a directed graph such that the sum of the\n    values along the path is equal to n. Each value in a can be used at most once, but values in b can be used multiple\n    times. The graph is represented as an adjacency list.\n\n    Note: The graph is a directed acyclic graph (DAG).\n\n    Example:\n    n = 10\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n\n    Output:\n    True\n\n    Explanation:\n    The graph can be represented as:\n    1 -> 4\n    1 -> 5\n    1 -> 6\n    2 -> 4\n    2 -> 5\n    2 -> 6\n    3 -> 4\n    3 -> 5\n    3 -> 6\n\n    There exists a path from 1 to 6 with a sum of 10: 1 -> 6\n    \"\"\"\n    graph = {}\n    for i in range(len(a)):\n        if a[i] not in graph:\n            graph[a[i]] = []\n        for j in range(len(b)):\n            graph[a[i]].append(b[j])\n    return dfs(graph, 1, n)\n\n\ndef dfs(graph, start, target):\n    stack = [(start, 0)]\n    while stack:\n        node, path_sum = stack.pop()\n        if node == target:\n            return True\n        if node in graph:\n            for neighbor in graph[node]:\n                stack.append((neighbor, path_sum + neighbor))\n    return False\n\n\ndef g(n=10, a=[1, 2, 3], b=[4, 5, 6]):\n    return n, a, b\n\n\nassert f(*g())\n", "emb": null, "idx_generation": 357, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, a: List[int], b: List[int]) -> bool:\n    \"\"\"\n    Given two lists of integers, a and b, determine if there exists a path in a directed graph such that the sum of the\n    values along the path is equal to n. Each value in a can be used at most once, but values in b can be used multiple\n    times. The graph is represented as an adjacency list.\n\n    Note: The graph is a directed acyclic graph (DAG).\n\n    Example:\n    n = 10\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n\n    Output:\n    True\n\n    Explanation:\n    The graph can be represented as:\n    1 -> 4\n    1 -> 5\n    1 -> 6\n    2 -> 4\n    2 -> 5\n    2 -> 6\n    3 -> 4\n    3 -> 5\n    3 -> 6\n\n    There exists a path from 1 to 6 with a sum of 10: 1 -> 6\n    \"\"\"\n    graph = {}\n    for i in range(len(a)):\n        if a[i] not in graph:\n            graph[a[i]] = []\n        for j in range(len(b)):\n            graph[a[i]].append(b[j])\n    return dfs(graph, 1, n)\n\n\ndef dfs(graph, start, target):\n    stack = [(start, 0)]\n    while stack:\n        node, path_sum = stack.pop()\n        if node == target:\n            return True\n        if node in graph:\n            for neighbor in graph[node]:\n                stack.append((neighbor, path_sum + neighbor))\n    return False", "solution_func": "def g(n=10, a=[1, 2, 3], b=[4, 5, 6]):\n    return n, a, b", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nimport math\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a number x such that the sum of the first k natural numbers\n    raised to the power of x is equal to n.\n\n    Example:\n    n = 16\n    k = 3\n\n    Output:\n    True\n\n    Explanation:\n    The sum of the first 3 natural numbers raised to the power of 2 is 16: 1^2 + 2^2 + 3^2 = 16.\n    \"\"\"\n    for x in range(1, int(math.log2(n)) + 1):\n        if sum([i ** x for i in range(1, k + 1)]) == n:\n            return True\n    return False\n\n\ndef g(n=16, k=3):\n    return n, k\n\n\nassert f(*g())\n", "emb": null, "idx_generation": 357, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nimport math\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a number x such that the sum of the first k natural numbers\n    raised to the power of x is equal to n.\n\n    Example:\n    n = 16\n    k = 3\n\n    Output:\n    True\n\n    Explanation:\n    The sum of the first 3 natural numbers raised to the power of 2 is 16: 1^2 + 2^2 + 3^2 = 16.\n    \"\"\"\n    for x in range(1, int(math.log2(n)) + 1):\n        if sum([i ** x for i in range(1, k + 1)]) == n:\n            return True\n    return False", "solution_func": "def g(n=16, k=3):\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, determine if there exists a substring of s that when repeated n times, results in\n    a string that is a palindrome.\n\n    Example:\n    s = \"abc\"\n    n = 2\n\n    Output:\n    True\n\n    Explanation:\n    The substring \"a\" repeated 2 times results in \"aa\", which is a palindrome.\n    \"\"\"\n    return is_palindrome(s) or is_palindrome(s * n)\n\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\n\ndef g(s=\"abc\", n=2):\n    return s, n\n\n\nassert f(*g())\n", "emb": null, "idx_generation": 357, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, determine if there exists a substring of s that when repeated n times, results in\n    a string that is a palindrome.\n\n    Example:\n    s = \"abc\"\n    n = 2\n\n    Output:\n    True\n\n    Explanation:\n    The substring \"a\" repeated 2 times results in \"aa\", which is a palindrome.\n    \"\"\"\n    return is_palindrome(s) or is_palindrome(s * n)\n\n\ndef is_palindrome(s):\n    return s == s[::-1]", "solution_func": "def g(s=\"abc\", n=2):\n    return s, n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], n=5) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it is a tree.\n    A tree is a connected acyclic graph, i.e., there are no cycles and every pair of vertices is connected.\n\n    Sample input:\n    [\n      [0, 1, 0, 0, 1],\n      [1, 0, 1, 1, 0],\n      [0, 1, 0, 0, 0],\n      [0, 1, 0, 0, 0],\n      [1, 0, 0, 0, 0]\n    ]\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    # Check if the graph has n-1 edges and is connected\n    if sum(sum(row) for row in graph) != 2 * (n - 1):\n        return False\n\n    # Check if the graph contains any cycles\n    visited = [False] * n\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in range(n):\n            if graph[node][neighbor]:\n                if visited[neighbor] and neighbor != parent:\n                    return True\n                if not visited[neighbor] and dfs(neighbor, node):\n                    return True\n        return False\n\n    if dfs(0, -1):\n        return False\n\n    return True\n\ndef g(n=5):\n    # Generate a tree with n nodes\n    graph = [[0] * n for _ in range(n)]\n    \n    # Connect the nodes to form a tree\n    for i in range(1, n):\n        graph[i][i-1] = 1\n        graph[i-1][i] = 1\n    \n    return graph\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 357, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], n=5) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it is a tree.\n    A tree is a connected acyclic graph, i.e., there are no cycles and every pair of vertices is connected.\n\n    Sample input:\n    [\n      [0, 1, 0, 0, 1],\n      [1, 0, 1, 1, 0],\n      [0, 1, 0, 0, 0],\n      [0, 1, 0, 0, 0],\n      [1, 0, 0, 0, 0]\n    ]\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    # Check if the graph has n-1 edges and is connected\n    if sum(sum(row) for row in graph) != 2 * (n - 1):\n        return False\n\n    # Check if the graph contains any cycles\n    visited = [False] * n\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in range(n):\n            if graph[node][neighbor]:\n                if visited[neighbor] and neighbor != parent:\n                    return True\n                if not visited[neighbor] and dfs(neighbor, node):\n                    return True\n        return False\n\n    if dfs(0, -1):\n        return False\n\n    return True", "solution_func": "def g(n=5):\n    # Generate a tree with n nodes\n    graph = [[0] * n for _ in range(n)]\n    \n    # Connect the nodes to form a tree\n    for i in range(1, n):\n        graph[i][i-1] = 1\n        graph[i-1][i] = 1\n    \n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> int:\n    \"\"\"\n    Given a directed graph and two nodes, find the number of paths from the start node to the end node.\n    Each node in the graph is represented by a string, and the graph is represented as a dictionary where\n    each key is a node and the corresponding value is a list of its neighboring nodes.\n\n    Sample Input:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n\n    Sample Output:\n    3\n    Explanation: There are 3 paths from node 'A' to node 'D': 'A' -> 'B' -> 'C' -> 'D', 'A' -> 'B' -> 'D', 'A' -> 'C' -> 'D'.\n    \"\"\"\n\n    def dfs(node):\n        nonlocal count\n        if node == end:\n            count += 1\n            return\n        for neighbor in graph[node]:\n            dfs(neighbor)\n    \n    count = 0\n    dfs(start)\n    return count\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 358, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> int:\n    \"\"\"\n    Given a directed graph and two nodes, find the number of paths from the start node to the end node.\n    Each node in the graph is represented by a string, and the graph is represented as a dictionary where\n    each key is a node and the corresponding value is a list of its neighboring nodes.\n\n    Sample Input:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n\n    Sample Output:\n    3\n    Explanation: There are 3 paths from node 'A' to node 'D': 'A' -> 'B' -> 'C' -> 'D', 'A' -> 'B' -> 'D', 'A' -> 'C' -> 'D'.\n    \"\"\"\n\n    def dfs(node):\n        nonlocal count\n        if node == end:\n            count += 1\n            return\n        for neighbor in graph[node]:\n            dfs(neighbor)\n    \n    count = 0\n    dfs(start)\n    return count", "solution_func": "def g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the number of occurrences of a specific pattern.\n\n    Sample Input:\n    grid = [['A', 'B', 'A', 'B', 'C'], ['B', 'A', 'B', 'C', 'A'], ['A', 'B', 'C', 'A', 'B'], ['B', 'C', 'A', 'B', 'A'], ['C', 'A', 'B', 'A', 'B']]\n    pattern = [['A', 'B'], ['B', 'C']]\n\n    Sample Output:\n    3\n    Explanation: The pattern [['A', 'B'], ['B', 'C']] occurs 3 times in the grid.\n    \"\"\"\n\n    def is_pattern(pattern, i, j):\n        for r in range(len(pattern)):\n            for c in range(len(pattern[0])):\n                if pattern[r][c] != grid[i+r][j+c]:\n                    return False\n        return True\n    \n    count = 0\n    rows = len(grid)\n    cols = len(grid[0])\n    pattern_rows = len(pattern)\n    pattern_cols = len(pattern[0])\n\n    for i in range(rows - pattern_rows + 1):\n        for j in range(cols - pattern_cols + 1):\n            if is_pattern(pattern, i, j):\n                count += 1\n\n    return count\n\ndef g():\n    grid = [['A', 'B', 'A', 'B', 'C'], ['B', 'A', 'B', 'C', 'A'], ['A', 'B', 'C', 'A', 'B'], ['B', 'C', 'A', 'B', 'A'], ['C', 'A', 'B', 'A', 'B']]\n    pattern = [['A', 'B'], ['B', 'C']]\n    return grid, pattern\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 358, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the number of occurrences of a specific pattern.\n\n    Sample Input:\n    grid = [['A', 'B', 'A', 'B', 'C'], ['B', 'A', 'B', 'C', 'A'], ['A', 'B', 'C', 'A', 'B'], ['B', 'C', 'A', 'B', 'A'], ['C', 'A', 'B', 'A', 'B']]\n    pattern = [['A', 'B'], ['B', 'C']]\n\n    Sample Output:\n    3\n    Explanation: The pattern [['A', 'B'], ['B', 'C']] occurs 3 times in the grid.\n    \"\"\"\n\n    def is_pattern(pattern, i, j):\n        for r in range(len(pattern)):\n            for c in range(len(pattern[0])):\n                if pattern[r][c] != grid[i+r][j+c]:\n                    return False\n        return True\n    \n    count = 0\n    rows = len(grid)\n    cols = len(grid[0])\n    pattern_rows = len(pattern)\n    pattern_cols = len(pattern[0])\n\n    for i in range(rows - pattern_rows + 1):\n        for j in range(cols - pattern_cols + 1):\n            if is_pattern(pattern, i, j):\n                count += 1\n\n    return count", "solution_func": "def g():\n    grid = [['A', 'B', 'A', 'B', 'C'], ['B', 'A', 'B', 'C', 'A'], ['A', 'B', 'C', 'A', 'B'], ['B', 'C', 'A', 'B', 'A'], ['C', 'A', 'B', 'A', 'B']]\n    pattern = [['A', 'B'], ['B', 'C']]\n    return grid, pattern", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them based on anagrams.\n\n    Sample Input:\n    words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n\n    Sample Output:\n    [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n    Explanation: The words 'eat', 'tea', and 'ate' are anagrams of each other, so they are grouped together.\n    The words 'tan' and 'nat' are anagrams of each other, so they are grouped together.\n    The word 'bat' does not have any anagrams, so it forms its own group.\n    \"\"\"\n\n    anagrams = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n    \n    return list(anagrams.values())\n\ndef g():\n    words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n    return words\n\nassert f(g()) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them based on anagrams.\n\n    Sample Input:\n    words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n\n    Sample Output:\n    [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n    Explanation: The words 'eat', 'tea', and 'ate' are anagrams of each other, so they are grouped together.\n    The words 'tan' and 'nat' are anagrams of each other, so they are grouped together.\n    The word 'bat' does not have any anagrams, so it forms its own group.\n    \"\"\"\n\n    anagrams = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n    \n    return list(anagrams.values())", "solution_func": "def g():\n    words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n    return words", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression consists of '(' and ')' characters, where:\n    - Every open parenthesis '(' must have a corresponding closing parenthesis ')'.\n    - Open parenthesis '(' must go before the corresponding closing parenthesis ')'.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: The valid parentheses expressions of length 6 are:\n    \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    def helper(open_count: int, close_count: int) -> int:\n        if open_count == 0 and close_count == 0:\n            return 1\n        if open_count > 0:\n            ans = helper(open_count - 1, close_count)\n        else:\n            ans = 0\n        if close_count > open_count:\n            ans += helper(open_count, close_count - 1)\n        return ans\n\n    return helper(n, n) % (10**9 + 7)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid parentheses expressions of length 2n.\n    A valid parentheses expression consists of '(' and ')' characters, where:\n    - Every open parenthesis '(' must have a corresponding closing parenthesis ')'.\n    - Open parenthesis '(' must go before the corresponding closing parenthesis ')'.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: The valid parentheses expressions of length 6 are:\n    \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    def helper(open_count: int, close_count: int) -> int:\n        if open_count == 0 and close_count == 0:\n            return 1\n        if open_count > 0:\n            ans = helper(open_count - 1, close_count)\n        else:\n            ans = 0\n        if close_count > open_count:\n            ans += helper(open_count, close_count - 1)\n        return ans\n\n    return helper(n, n) % (10**9 + 7)", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct integers in the range [0, 2^n - 1] whose binary representation\n    contains exactly n ones.\n\n    Example:\n    Input: n = 2\n    Output: 2\n\n    Explanation: The distinct integers with 2 ones in their binary representation are 3 and 6.\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    def count_ones(num: int) -> int:\n        count = 0\n        while num > 0:\n            if num & 1:\n                count += 1\n            num >>= 1\n        return count\n\n    ans = 0\n    for i in range(2**n):\n        if count_ones(i) == n:\n            ans += 1\n\n    return ans % (10**9 + 7)\n\ndef g() -> int:\n    return 2\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 358, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct integers in the range [0, 2^n - 1] whose binary representation\n    contains exactly n ones.\n\n    Example:\n    Input: n = 2\n    Output: 2\n\n    Explanation: The distinct integers with 2 ones in their binary representation are 3 and 6.\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    def count_ones(num: int) -> int:\n        count = 0\n        while num > 0:\n            if num & 1:\n                count += 1\n            num >>= 1\n        return count\n\n    ans = 0\n    for i in range(2**n):\n        if count_ones(i) == n:\n            ans += 1\n\n    return ans % (10**9 + 7)", "solution_func": "def g() -> int:\n    return 2", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum you can achieve by starting at the top-left\n    corner and moving only right and down to the bottom-right corner.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n\n    Note:\n    - You can only move either down or right at any point in time.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 358, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum you can achieve by starting at the top-left\n    corner and moving only right and down to the bottom-right corner.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n\n    Note:\n    - You can only move either down or right at any point in time.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    arr[0] + arr[1] = 2 + 7 = 9\n\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    arr[0] + arr[1] = 2 + 7 = 9\n\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "solution_func": "def g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct strings of length n that can be formed using the letters 'A', 'B', and 'C',\n    where there cannot be consecutive letters that are the same.\n\n    Example:\n    n = 3\n\n    Output:\n    24\n\n    Explanation:\n    The distinct strings of length 3 that can be formed are:\n    ABC, ACB, BAC, BCA, CAB, CBA, ABA, ACA, BAB, BCB, CAC, CBC, AAC, ACC, BBC, BCC, CAA, CBB, CCB, CAC, ACA, BAC, BCA, CBA\n\n    \"\"\"\n    if n == 1:\n        return 3\n    if n == 2:\n        return 9\n    dp = [0] * (n + 1)\n    dp[1] = 3\n    dp[2] = 9\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] * 2 + dp[i - 2]\n    return dp[n]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 24\n\n", "emb": null, "idx_generation": 358, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct strings of length n that can be formed using the letters 'A', 'B', and 'C',\n    where there cannot be consecutive letters that are the same.\n\n    Example:\n    n = 3\n\n    Output:\n    24\n\n    Explanation:\n    The distinct strings of length 3 that can be formed are:\n    ABC, ACB, BAC, BCA, CAB, CBA, ABA, ACA, BAB, BCB, CAC, CBC, AAC, ACC, BBC, BCC, CAA, CBB, CCB, CAC, ACA, BAC, BCA, CBA\n\n    \"\"\"\n    if n == 1:\n        return 3\n    if n == 2:\n        return 9\n    dp = [0] * (n + 1)\n    dp[1] = 3\n    dp[2] = 9\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] * 2 + dp[i - 2]\n    return dp[n]", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list of elements in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    \"\"\"\n    if not matrix:\n        return []\n    row_start, row_end = 0, len(matrix) - 1\n    col_start, col_end = 0, len(matrix[0]) - 1\n    result = []\n    while row_start <= row_end and col_start <= col_end:\n        # Traverse right\n        for i in range(col_start, col_end + 1):\n            result.append(matrix[row_start][i])\n        row_start += 1\n\n        # Traverse down\n        for i in range(row_start, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n\n        if row_start <= row_end:\n            # Traverse left\n            for i in range(col_end, col_start - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n\n        if col_start <= col_end:\n            # Traverse up\n            for i in range(row_end, row_start - 1, -1):\n                result.append(matrix[i][col_start])\n            col_start += 1\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 358, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list of elements in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    \"\"\"\n    if not matrix:\n        return []\n    row_start, row_end = 0, len(matrix) - 1\n    col_start, col_end = 0, len(matrix[0]) - 1\n    result = []\n    while row_start <= row_end and col_start <= col_end:\n        # Traverse right\n        for i in range(col_start, col_end + 1):\n            result.append(matrix[row_start][i])\n        row_start += 1\n\n        # Traverse down\n        for i in range(row_start, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n\n        if row_start <= row_end:\n            # Traverse left\n            for i in range(col_end, col_start - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n\n        if col_start <= col_end:\n            # Traverse up\n            for i in range(row_end, row_start - 1, -1):\n                result.append(matrix[i][col_start])\n            col_start += 1\n    return result", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 1, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of consecutive 1s in any row or column.\n    Return the maximum number of consecutive 1s.\n    \"\"\"\n    max_consecutive = 0\n    for row in grid:\n        consecutive = 0\n        for num in row:\n            if num == 1:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n    for col in range(len(grid[0])):\n        consecutive = 0\n        for row in range(len(grid)):\n            if grid[row][col] == 1:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n    return max_consecutive\n\n\ndef g():\n    grid = [[1, 1, 0, 1, 1],\n            [0, 1, 1, 1, 0],\n            [1, 1, 1, 0, 0],\n            [0, 0, 1, 1, 1]]\n    return grid\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 358, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of consecutive 1s in any row or column.\n    Return the maximum number of consecutive 1s.\n    \"\"\"\n    max_consecutive = 0\n    for row in grid:\n        consecutive = 0\n        for num in row:\n            if num == 1:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n    for col in range(len(grid[0])):\n        consecutive = 0\n        for row in range(len(grid)):\n            if grid[row][col] == 1:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n    return max_consecutive", "solution_func": "def g():\n    grid = [[1, 1, 0, 1, 1],\n            [0, 1, 1, 1, 0],\n            [1, 1, 1, 0, 0],\n            [0, 0, 1, 1, 1]]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    n = 12\n\n    f(n) => 2\n    Explanation: The binary representation of 12 is 1100, which contains 2 1 bits.\n\n    n = 23\n\n    f(n) => 4\n    Explanation: The binary representation of 23 is 10111, which contains 4 1 bits.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int = 12):\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 359, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    n = 12\n\n    f(n) => 2\n    Explanation: The binary representation of 12 is 1100, which contains 2 1 bits.\n\n    n = 23\n\n    f(n) => 4\n    Explanation: The binary representation of 23 is 10111, which contains 4 1 bits.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g(n: int = 12):\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right\n    corner. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    f(grid) => 12\n    Explanation: The maximum sum of a path from the top-left corner to the bottom-right corner is 12 (1 + 3 + 1 + 5 + 1 + 1).\n\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6]\n    ]\n\n    f(grid) => 16\n    Explanation: The maximum sum of a path from the top-left corner to the bottom-right corner is 16 (1 + 2 + 3 + 6).\n\n    \"\"\"\n\n    def max_path_sum(i: int, j: int) -> int:\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n        if i >= len(grid) or j >= len(grid[0]):\n            return 0\n        return grid[i][j] + max(max_path_sum(i + 1, j), max_path_sum(i, j + 1))\n\n    return max_path_sum(0, 0)\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 359, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right\n    corner. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    f(grid) => 12\n    Explanation: The maximum sum of a path from the top-left corner to the bottom-right corner is 12 (1 + 3 + 1 + 5 + 1 + 1).\n\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6]\n    ]\n\n    f(grid) => 16\n    Explanation: The maximum sum of a path from the top-left corner to the bottom-right corner is 16 (1 + 2 + 3 + 6).\n\n    \"\"\"\n\n    def max_path_sum(i: int, j: int) -> int:\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n        if i >= len(grid) or j >= len(grid[0]):\n            return 0\n        return grid[i][j] + max(max_path_sum(i + 1, j), max_path_sum(i, j + 1))\n\n    return max_path_sum(0, 0)", "solution_func": "def g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, return True if it is a power of 2, otherwise return False.\n\n    Example:\n    n = 16\n\n    f(n) => True\n    Explanation: 16 is a power of 2 (2 ^ 4).\n\n    n = 12\n\n    f(n) => False\n    Explanation: 12 is not a power of 2.\n\n    \"\"\"\n\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g(n: int = 16):\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 359, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, return True if it is a power of 2, otherwise return False.\n\n    Example:\n    n = 16\n\n    f(n) => True\n    Explanation: 16 is a power of 2 (2 ^ 4).\n\n    n = 12\n\n    f(n) => False\n    Explanation: 12 is not a power of 2.\n\n    \"\"\"\n\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True", "solution_func": "def g(n: int = 16):\n    return n", "map_ix": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose bitwise AND is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: 3\n\n    Explanation:\n    The subsets with bitwise AND as a perfect square are:\n    [2, 3, 5]\n    [7, 9]\n    [2, 7, 9, 3, 5]\n    Therefore, there are 3 subsets with bitwise AND as a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    count = 0\n    for i in range(1, 2 ** len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if all((x & y in squares) for x in subset for y in subset):\n            count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 359, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose bitwise AND is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: 3\n\n    Explanation:\n    The subsets with bitwise AND as a perfect square are:\n    [2, 3, 5]\n    [7, 9]\n    [2, 7, 9, 3, 5]\n    Therefore, there are 3 subsets with bitwise AND as a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    count = 0\n    for i in range(1, 2 ** len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if all((x & y in squares) for x in subset for y in subset):\n            count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose bitwise OR is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: 2\n\n    Explanation:\n    The subsets with bitwise OR as a perfect square are:\n    [2, 3, 5, 7]\n    [2, 7, 9, 3, 5]\n    Therefore, there are 2 subsets with bitwise OR as a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    count = 0\n    for i in range(1, 2 ** len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if any((x | y in squares) for x in subset for y in subset):\n            count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 359, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose bitwise OR is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: 2\n\n    Explanation:\n    The subsets with bitwise OR as a perfect square are:\n    [2, 3, 5, 7]\n    [2, 7, 9, 3, 5]\n    Therefore, there are 2 subsets with bitwise OR as a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    count = 0\n    for i in range(1, 2 ** len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if any((x | y in squares) for x in subset for y in subset):\n            count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose bitwise XOR is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: 1\n\n    Explanation:\n    The subset with bitwise XOR as a perfect square is:\n    [2, 7]\n    Therefore, there is 1 subset with bitwise XOR as a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    count = 0\n    for i in range(1, 2 ** len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if len(subset) > 1 and reduce(lambda x, y: x ^ y, subset) in squares:\n            count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 359, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose bitwise XOR is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: 1\n\n    Explanation:\n    The subset with bitwise XOR as a perfect square is:\n    [2, 7]\n    Therefore, there is 1 subset with bitwise XOR as a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    count = 0\n    for i in range(1, 2 ** len(nums)):\n        subset = [nums[j] for j in range(len(nums)) if (i >> j) & 1]\n        if len(subset) > 1 and reduce(lambda x, y: x ^ y, subset) in squares:\n            count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) where a and b are two different\n    elements from the list and a + b is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    4\n    Explanation: The distinct pairs are (1, 3), (2, 2), (3, 1), and (4, 5). The sum of each pair is a perfect square.\n\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5) ** 2\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if is_perfect_square(nums[i] + nums[j]):\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": null, "idx_generation": 359, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) where a and b are two different\n    elements from the list and a + b is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    4\n    Explanation: The distinct pairs are (1, 3), (2, 2), (3, 1), and (4, 5). The sum of each pair is a perfect square.\n\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5) ** 2\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if is_perfect_square(nums[i] + nums[j]):\n                count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct triplets (a, b, c) where a, b, and c are three different\n    elements from the list and a + b + c is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    1\n    Explanation: The only distinct triplet is (1, 2, 6). The sum of the triplet is a perfect square.\n\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5) ** 2\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if is_perfect_square(nums[i] + nums[j] + nums[k]):\n                    count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 1\n\n", "emb": null, "idx_generation": 359, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct triplets (a, b, c) where a, b, and c are three different\n    elements from the list and a + b + c is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    1\n    Explanation: The only distinct triplet is (1, 2, 6). The sum of the triplet is a perfect square.\n\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5) ** 2\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if is_perfect_square(nums[i] + nums[j] + nums[k]):\n                    count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct quadruplets (a, b, c, d) where a, b, c, and d are four different\n    elements from the list and a + b + c + d is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    0\n    Explanation: There are no distinct quadruplets that satisfy the perfect square condition.\n\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5) ** 2\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                for l in range(k+1, len(nums)):\n                    if is_perfect_square(nums[i] + nums[j] + nums[k] + nums[l]):\n                        count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 0\n\n", "emb": null, "idx_generation": 359, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct quadruplets (a, b, c, d) where a, b, c, and d are four different\n    elements from the list and a + b + c + d is a perfect square.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    0\n    Explanation: There are no distinct quadruplets that satisfy the perfect square condition.\n\n    \"\"\"\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5) ** 2\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                for l in range(k+1, len(nums)):\n                    if is_perfect_square(nums[i] + nums[j] + nums[k] + nums[l]):\n                        count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 359, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and an integer k, find if there are two distinct indices i and j in the list\n    such that arr[i] - arr[j] = k.\n\n    Example:\n    arr = [4, 2, 6, 8]\n    k = 2\n\n    The function should return True, since arr[3] - arr[1] = 8 - 2 = 6.\n\n    If such indices do not exist, the function should return False.\n    \"\"\"\n    num_set = set(arr)\n    for num in arr:\n        if num - k in num_set:\n            return True\n    return False\n\ndef g() -> List[int]:\n    arr = [4, 2, 6, 8]\n    return arr\n\nassert f(g(), 2)\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 360, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and an integer k, find if there are two distinct indices i and j in the list\n    such that arr[i] - arr[j] = k.\n\n    Example:\n    arr = [4, 2, 6, 8]\n    k = 2\n\n    The function should return True, since arr[3] - arr[1] = 8 - 2 = 6.\n\n    If such indices do not exist, the function should return False.\n    \"\"\"\n    num_set = set(arr)\n    for num in arr:\n        if num - k in num_set:\n            return True\n    return False", "solution_func": "def g() -> List[int]:\n    arr = [4, 2, 6, 8]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list is the product\n    of all the numbers in the original list except the one at i.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    The function should return [24, 12, 8, 6], since\n    - 24 = 2 * 3 * 4\n    - 12 = 1 * 3 * 4\n    - 8 = 1 * 2 * 4\n    - 6 = 1 * 2 * 3\n    \"\"\"\n    n = len(arr)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * arr[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * arr[i+1]\n\n    result = [0] * n\n    for i in range(n):\n        result[i] = prefix_products[i] * suffix_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4]\n    return arr\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 360, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list is the product\n    of all the numbers in the original list except the one at i.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    The function should return [24, 12, 8, 6], since\n    - 24 = 2 * 3 * 4\n    - 12 = 1 * 3 * 4\n    - 8 = 1 * 2 * 4\n    - 6 = 1 * 2 * 3\n    \"\"\"\n    n = len(arr)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * arr[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * arr[i+1]\n\n    result = [0] * n\n    for i in range(n):\n        result[i] = prefix_products[i] * suffix_products[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4]\n    return arr", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    arr = [5, 2, 9, 1, 7]\n\n    The function should return [1, 2, 5, 7, 9].\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g() -> List[int]:\n    arr = [5, 2, 9, 1, 7]\n    return arr\n\nassert f(g()) == [1, 2, 5, 7, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 360, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    arr = [5, 2, 9, 1, 7]\n\n    The function should return [1, 2, 5, 7, 9].\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr", "solution_func": "def g() -> List[int]:\n    arr = [5, 2, 9, 1, 7]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the number of subsets of 'nums' that XOR to 'target'.\n\n    Example:\n    nums = [1, 3, 4, 5, 6]\n    target = 7\n    Output: 2\n    Explanation: The subsets that XOR to 7 are [1, 6] and [3, 4].\n\n    \"\"\"\n\n    def count_subsets(nums, target, index, current_xor, memo):\n        if index == len(nums):\n            if current_xor == target:\n                return 1\n            else:\n                return 0\n\n        if (index, current_xor) in memo:\n            return memo[(index, current_xor)]\n\n        count = 0\n        count += count_subsets(nums, target, index + 1, current_xor ^ nums[index], memo)\n        count += count_subsets(nums, target, index + 1, current_xor, memo)\n\n        memo[(index, current_xor)] = count\n        return count\n\n    memo = {}\n    return count_subsets(nums, target, 0, 0, memo)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": null, "idx_generation": 360, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', find the number of subsets of 'nums' that XOR to 'target'.\n\n    Example:\n    nums = [1, 3, 4, 5, 6]\n    target = 7\n    Output: 2\n    Explanation: The subsets that XOR to 7 are [1, 6] and [3, 4].\n\n    \"\"\"\n\n    def count_subsets(nums, target, index, current_xor, memo):\n        if index == len(nums):\n            if current_xor == target:\n                return 1\n            else:\n                return 0\n\n        if (index, current_xor) in memo:\n            return memo[(index, current_xor)]\n\n        count = 0\n        count += count_subsets(nums, target, index + 1, current_xor ^ nums[index], memo)\n        count += count_subsets(nums, target, index + 1, current_xor, memo)\n\n        memo[(index, current_xor)] = count\n        return count\n\n    memo = {}\n    return count_subsets(nums, target, 0, 0, memo)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 4, 5, 6]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the maximum XOR value of any two elements in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n\n            node = node.children[bit]\n\n    def find_max_xor(num, root):\n        node = root\n        xor_value = 0\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            opposite_bit = 1 - bit\n\n            if opposite_bit in node.children:\n                xor_value |= (1 << i)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[bit]\n\n        return xor_value\n\n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(num, root)\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 360, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the maximum XOR value of any two elements in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n\n            node = node.children[bit]\n\n    def find_max_xor(num, root):\n        node = root\n        xor_value = 0\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            opposite_bit = 1 - bit\n\n            if opposite_bit in node.children:\n                xor_value |= (1 << i)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[bit]\n\n        return xor_value\n\n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(num, root)\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 0, 1, 0, 1, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum path from the top-left cell to the bottom-right cell,\n    where you can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 21\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    \"\"\"\n\n    def find_max_sum(grid, row, col, memo):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return grid[row][col]\n\n        if (row, col) in memo:\n            return memo[(row, col)]\n\n        down_sum = float('-inf')\n        if row + 1 < len(grid):\n            down_sum = find_max_sum(grid, row + 1, col, memo)\n\n        right_sum = float('-inf')\n        if col + 1 < len(grid[0]):\n            right_sum = find_max_sum(grid, row, col + 1, memo)\n\n        max_sum = max(down_sum, right_sum) + grid[row][col]\n        memo[(row, col)] = max_sum\n        return max_sum\n\n    memo = {}\n    return find_max_sum(grid, 0, 0, memo)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 21\n\n", "emb": null, "idx_generation": 360, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum path from the top-left cell to the bottom-right cell,\n    where you can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 21\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    \"\"\"\n\n    def find_max_sum(grid, row, col, memo):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return grid[row][col]\n\n        if (row, col) in memo:\n            return memo[(row, col)]\n\n        down_sum = float('-inf')\n        if row + 1 < len(grid):\n            down_sum = find_max_sum(grid, row + 1, col, memo)\n\n        right_sum = float('-inf')\n        if col + 1 < len(grid[0]):\n            right_sum = find_max_sum(grid, row, col + 1, memo)\n\n        max_sum = max(down_sum, right_sum) + grid[row][col]\n        memo[(row, col)] = max_sum\n        return max_sum\n\n    memo = {}\n    return find_max_sum(grid, 0, 0, memo)", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and an integer n,\n    determine if the graph contains a cycle of length n.\n\n    Return True if a cycle of length n exists, False otherwise.\n\n    Example:\n    n = 3\n    edges = [[0, 1], [1, 2], [2, 0], [0, 3]]\n\n    The graph has a cycle of length 3: 0 -> 1 -> 2 -> 0\n\n    Therefore, the function should return True.\n\n    Note:\n    - The graph does not contain self-loops or parallel edges.\n    - The graph may not be connected.\n    \"\"\"\n    def dfs(node, start, length, visited):\n        if visited[node] and length == n and node == start:\n            return True\n        if visited[node] or length > n:\n            return False\n        \n        visited[node] = True\n        for neighbor in edges[node]:\n            if dfs(neighbor, start, length + 1, visited):\n                return True\n        visited[node] = False\n        return False\n\n    for i in range(len(edges)):\n        visited = [False] * len(edges)\n        if dfs(i, i, 1, visited):\n            return True\n    return False\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate an integer n and an adjacency list representing an undirected graph.\n    \"\"\"\n    return 3, [[0, 1], [1, 2], [2, 0], [0, 3]]\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 360, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and an integer n,\n    determine if the graph contains a cycle of length n.\n\n    Return True if a cycle of length n exists, False otherwise.\n\n    Example:\n    n = 3\n    edges = [[0, 1], [1, 2], [2, 0], [0, 3]]\n\n    The graph has a cycle of length 3: 0 -> 1 -> 2 -> 0\n\n    Therefore, the function should return True.\n\n    Note:\n    - The graph does not contain self-loops or parallel edges.\n    - The graph may not be connected.\n    \"\"\"\n    def dfs(node, start, length, visited):\n        if visited[node] and length == n and node == start:\n            return True\n        if visited[node] or length > n:\n            return False\n        \n        visited[node] = True\n        for neighbor in edges[node]:\n            if dfs(neighbor, start, length + 1, visited):\n                return True\n        visited[node] = False\n        return False\n\n    for i in range(len(edges)):\n        visited = [False] * len(edges)\n        if dfs(i, i, 1, visited):\n            return True\n    return False", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate an integer n and an adjacency list representing an undirected graph.\n    \"\"\"\n    return 3, [[0, 1], [1, 2], [2, 0], [0, 3]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be achieved by XORing 25 and 5: 25 ^ 5 = 28.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, num):\n            node = self.root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if bit not in node.children:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n            node.is_end = True\n\n        def find_max_xor(self, num):\n            node = self.root\n            xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if 1 - bit in node.children:\n                    xor |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor\n\n    trie = Trie()\n    for num in nums:\n        trie.insert(num)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, trie.find_max_xor(num))\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 360, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be achieved by XORing 25 and 5: 25 ^ 5 = 28.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, num):\n            node = self.root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if bit not in node.children:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n            node.is_end = True\n\n        def find_max_xor(self, num):\n            node = self.root\n            xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if 1 - bit in node.children:\n                    xor |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor\n\n    trie = Trie()\n    for num in nums:\n        trie.insert(num)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, trie.find_max_xor(num))\n    \n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Return True if s can be segmented, False otherwise.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n\n    Therefore, the function should return True.\n\n    Note:\n    - The same word in the dictionary may be reused multiple times in the segmentation.\n    - You may assume the dictionary does not contain duplicate words.\n    \"\"\"\n    def dfs(s, wordDict, memo):\n        if s in memo:\n            return memo[s]\n        if s == \"\":\n            return True\n\n        for word in wordDict:\n            if s.startswith(word) and dfs(s[len(word):], wordDict, memo):\n                memo[s] = True\n                return True\n\n        memo[s] = False\n        return False\n\n    return dfs(s, wordDict, {})\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words wordDict.\n    \"\"\"\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 360, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Return True if s can be segmented, False otherwise.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n\n    Therefore, the function should return True.\n\n    Note:\n    - The same word in the dictionary may be reused multiple times in the segmentation.\n    - You may assume the dictionary does not contain duplicate words.\n    \"\"\"\n    def dfs(s, wordDict, memo):\n        if s in memo:\n            return memo[s]\n        if s == \"\":\n            return True\n\n        for word in wordDict:\n            if s.startswith(word) and dfs(s[len(word):], wordDict, memo):\n                memo[s] = True\n                return True\n\n        memo[s] = False\n        return False\n\n    return dfs(s, wordDict, {})", "solution_func": "def g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words wordDict.\n    \"\"\"\n    return \"leetcode\", [\"leet\", \"code\"]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, find the shortest path between two nodes.\n\n    Example:\n    matrix = [[0, 1, 1, 0, 0],\n              [1, 0, 1, 0, 0],\n              [1, 1, 0, 1, 1],\n              [0, 0, 1, 0, 1],\n              [0, 0, 1, 1, 0]]\n\n    The graph can be visualized as follows:\n    0---1---2---3---4\n\n    The shortest path between nodes 0 and 4 is [0, 1, 2, 4], so the function should return 3.\n    \"\"\"\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        \n        while queue:\n            node, distance = queue.pop(0)\n            \n            if node == end:\n                return distance\n            \n            if node in visited:\n                continue\n            visited.add(node)\n            \n            for neighbor in range(len(matrix[node])):\n                if matrix[node][neighbor] == 1:\n                    queue.append((neighbor, distance+1))\n        \n        return -1\n    \n    return bfs(0, len(matrix)-1)\n\n\ndef g() -> List[List[int]]:\n    matrix = [[0, 1, 1, 0, 0],\n              [1, 0, 1, 0, 0],\n              [1, 1, 0, 1, 1],\n              [0, 0, 1, 0, 1],\n              [0, 0, 1, 1, 0]]\n    return matrix\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 360, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, find the shortest path between two nodes.\n\n    Example:\n    matrix = [[0, 1, 1, 0, 0],\n              [1, 0, 1, 0, 0],\n              [1, 1, 0, 1, 1],\n              [0, 0, 1, 0, 1],\n              [0, 0, 1, 1, 0]]\n\n    The graph can be visualized as follows:\n    0---1---2---3---4\n\n    The shortest path between nodes 0 and 4 is [0, 1, 2, 4], so the function should return 3.\n    \"\"\"\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        \n        while queue:\n            node, distance = queue.pop(0)\n            \n            if node == end:\n                return distance\n            \n            if node in visited:\n                continue\n            visited.add(node)\n            \n            for neighbor in range(len(matrix[node])):\n                if matrix[node][neighbor] == 1:\n                    queue.append((neighbor, distance+1))\n        \n        return -1\n    \n    return bfs(0, len(matrix)-1)", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[0, 1, 1, 0, 0],\n              [1, 0, 1, 0, 0],\n              [1, 1, 0, 1, 1],\n              [0, 0, 1, 0, 1],\n              [0, 0, 1, 1, 0]]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Count the number of ways to obtain the target sum by adding or subtracting the elements in the array.\n\n    Example:\n    arr = [1, 2, 3]\n    target = 0\n\n    There are 2 ways to obtain the target sum of 0:\n    - Subtract 1, subtract 2, subtract 3: 1 - 2 - 3 = -4\n    - Add 1, add 2, subtract 3: 1 + 2 - 3 = 0\n\n    Returns the number of ways to obtain the target sum.\n    \"\"\"\n\n    def count_ways(arr: List[int], target: int, index: int, curr_sum: int) -> int:\n        \"\"\"\n        Recursively counts the number of ways to obtain the target sum.\n        \"\"\"\n        if index == len(arr):\n            # Base case: reached the end of the array\n            if curr_sum == target:\n                return 1\n            else:\n                return 0\n\n        add = count_ways(arr, target, index + 1, curr_sum + arr[index])\n        subtract = count_ways(arr, target, index + 1, curr_sum - arr[index])\n\n        return add + subtract\n\n    return count_ways(arr, target, 0, 0)\n\n\ndef g():\n    arr = [1, 2, 3]\n    target = 0\n    return arr, target\n\nassert f(*g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Count the number of ways to obtain the target sum by adding or subtracting the elements in the array.\n\n    Example:\n    arr = [1, 2, 3]\n    target = 0\n\n    There are 2 ways to obtain the target sum of 0:\n    - Subtract 1, subtract 2, subtract 3: 1 - 2 - 3 = -4\n    - Add 1, add 2, subtract 3: 1 + 2 - 3 = 0\n\n    Returns the number of ways to obtain the target sum.\n    \"\"\"\n\n    def count_ways(arr: List[int], target: int, index: int, curr_sum: int) -> int:\n        \"\"\"\n        Recursively counts the number of ways to obtain the target sum.\n        \"\"\"\n        if index == len(arr):\n            # Base case: reached the end of the array\n            if curr_sum == target:\n                return 1\n            else:\n                return 0\n\n        add = count_ways(arr, target, index + 1, curr_sum + arr[index])\n        subtract = count_ways(arr, target, index + 1, curr_sum - arr[index])\n\n        return add + subtract\n\n    return count_ways(arr, target, 0, 0)", "solution_func": "def g():\n    arr = [1, 2, 3]\n    target = 0\n    return arr, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Find the number of unique paths from the start node to the end node in a directed graph.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n\n    There are 2 unique paths from node 0 to node 3: 0 -> 1 -> 2 -> 3 and 0 -> 1 -> 3.\n\n    Returns the number of unique paths.\n    \"\"\"\n\n    def count_paths(graph: List[List[int]], start: int, end: int) -> int:\n        \"\"\"\n        Recursively counts the number of unique paths from the start node to the end node.\n        \"\"\"\n        if start == end:\n            # Base case: reached the end node\n            return 1\n\n        count = 0\n        for neighbor in graph[start]:\n            count += count_paths(graph, neighbor, end)\n\n        return count\n\n    return count_paths(graph, start, end)\n\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 361, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Find the number of unique paths from the start node to the end node in a directed graph.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n\n    There are 2 unique paths from node 0 to node 3: 0 -> 1 -> 2 -> 3 and 0 -> 1 -> 3.\n\n    Returns the number of unique paths.\n    \"\"\"\n\n    def count_paths(graph: List[List[int]], start: int, end: int) -> int:\n        \"\"\"\n        Recursively counts the number of unique paths from the start node to the end node.\n        \"\"\"\n        if start == end:\n            # Base case: reached the end node\n            return 1\n\n        count = 0\n        for neighbor in graph[start]:\n            count += count_paths(graph, neighbor, end)\n\n        return count\n\n    return count_paths(graph, start, end)", "solution_func": "def g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Determine if a given string matches a pattern, where the pattern consists of only letters and dots.\n    A dot matches any single character.\n\n    Example:\n    s = \"apple\"\n    pattern = \"a..le\"\n\n    The pattern matches the string \"apple\" because the dots can match any character.\n\n    Returns True if the string matches the pattern, False otherwise.\n    \"\"\"\n\n    def match_pattern(s: str, pattern: str) -> bool:\n        \"\"\"\n        Recursively checks if a string matches a pattern.\n        \"\"\"\n        if len(s) == 0 and len(pattern) == 0:\n            # Base case: both the string and pattern are empty\n            return True\n\n        if len(s) == 0 or len(pattern) == 0:\n            # Base case: either the string or pattern is empty\n            return False\n\n        if pattern[0] == '.':\n            # Case 1: the pattern has a dot, which can match any character\n            return match_pattern(s[1:], pattern[1:])\n\n        if s[0] == pattern[0]:\n            # Case 2: the first characters of the string and pattern match\n            return match_pattern(s[1:], pattern[1:])\n\n        return False\n\n    return match_pattern(s, pattern)\n\n\ndef g():\n    s = \"apple\"\n    pattern = \"a..le\"\n    return s, pattern\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Determine if a given string matches a pattern, where the pattern consists of only letters and dots.\n    A dot matches any single character.\n\n    Example:\n    s = \"apple\"\n    pattern = \"a..le\"\n\n    The pattern matches the string \"apple\" because the dots can match any character.\n\n    Returns True if the string matches the pattern, False otherwise.\n    \"\"\"\n\n    def match_pattern(s: str, pattern: str) -> bool:\n        \"\"\"\n        Recursively checks if a string matches a pattern.\n        \"\"\"\n        if len(s) == 0 and len(pattern) == 0:\n            # Base case: both the string and pattern are empty\n            return True\n\n        if len(s) == 0 or len(pattern) == 0:\n            # Base case: either the string or pattern is empty\n            return False\n\n        if pattern[0] == '.':\n            # Case 1: the pattern has a dot, which can match any character\n            return match_pattern(s[1:], pattern[1:])\n\n        if s[0] == pattern[0]:\n            # Case 2: the first characters of the string and pattern match\n            return match_pattern(s[1:], pattern[1:])\n\n        return False\n\n    return match_pattern(s, pattern)", "solution_func": "def g():\n    s = \"apple\"\n    pattern = \"a..le\"\n    return s, pattern", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Check if a string 's' can be rearranged to form another string 't' by permuting its characters.\n\n    Sample Input:\n    s = \"listen\"\n    t = \"silent\"\n\n    Sample Output:\n    True\n    Explanation: The string 'listen' can be rearranged to form 'silent' by permuting its characters.\n\n    Sample Input:\n    s = \"hello\"\n    t = \"world\"\n\n    Sample Output:\n    False\n    Explanation: The string 'hello' cannot be rearranged to form 'world' by permuting its characters.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for char in s:\n        count_s[ord(char) - ord('a')] += 1\n    for char in t:\n        count_t[ord(char) - ord('a')] += 1\n    return count_s == count_t\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g()) == True\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Check if a string 's' can be rearranged to form another string 't' by permuting its characters.\n\n    Sample Input:\n    s = \"listen\"\n    t = \"silent\"\n\n    Sample Output:\n    True\n    Explanation: The string 'listen' can be rearranged to form 'silent' by permuting its characters.\n\n    Sample Input:\n    s = \"hello\"\n    t = \"world\"\n\n    Sample Output:\n    False\n    Explanation: The string 'hello' cannot be rearranged to form 'world' by permuting its characters.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for char in s:\n        count_s[ord(char) - ord('a')] += 1\n    for char in t:\n        count_t[ord(char) - ord('a')] += 1\n    return count_s == count_t", "solution_func": "def g():\n    return \"listen\", \"silent\"", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of distinct integers in the range from 0 to n, where n is the length of the array,\n    find the missing number.\n\n    Sample Input:\n    nums = [3, 0, 1]\n\n    Sample Output:\n    2\n    Explanation: The missing number is 2, as it should have been included in the array [3, 0, 1].\n\n    Sample Input:\n    nums = [9, 6, 4, 2, 3, 5, 7, 0, 1]\n\n    Sample Output:\n    8\n    Explanation: The missing number is 8, as it should have been included in the array [9, 6, 4, 2, 3, 5, 7, 0, 1].\n    \"\"\"\n    n = len(nums)\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum\n\ndef g():\n    return [3, 0, 1]\n\nassert find_missing_number(g()) == 2\n\n\nassert f(g()) == True", "emb": null, "idx_generation": 361, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of distinct integers in the range from 0 to n, where n is the length of the array,\n    find the missing number.\n\n    Sample Input:\n    nums = [3, 0, 1]\n\n    Sample Output:\n    2\n    Explanation: The missing number is 2, as it should have been included in the array [3, 0, 1].\n\n    Sample Input:\n    nums = [9, 6, 4, 2, 3, 5, 7, 0, 1]\n\n    Sample Output:\n    8\n    Explanation: The missing number is 8, as it should have been included in the array [9, 6, 4, 2, 3, 5, 7, 0, 1].\n    \"\"\"\n    n = len(nums)\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum", "solution_func": "def g():\n    return [3, 0, 1]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort them in lexicographical order.\n\n    Sample Input:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n\n    Sample Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n    Explanation: The words are already sorted in lexicographical order.\n\n    Sample Input:\n    words = [\"date\", \"banana\", \"apple\", \"fig\", \"cherry\"]\n\n    Sample Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n    Explanation: The words are sorted in lexicographical order: [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"].\n    \"\"\"\n    return sorted(words)\n\ndef g():\n    return [\"date\", \"banana\", \"apple\", \"fig\", \"cherry\"]\n\nassert f(g()) == [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort them in lexicographical order.\n\n    Sample Input:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n\n    Sample Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n    Explanation: The words are already sorted in lexicographical order.\n\n    Sample Input:\n    words = [\"date\", \"banana\", \"apple\", \"fig\", \"cherry\"]\n\n    Sample Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"]\n    Explanation: The words are sorted in lexicographical order: [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"].\n    \"\"\"\n    return sorted(words)", "solution_func": "def g():\n    return [\"date\", \"banana\", \"apple\", \"fig\", \"cherry\"]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid forms a rectangle.\n    The subgrid can be obtained by selecting a rectangular region from the grid, and the sum of the subgrid is the sum of all its elements.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n\n    Explanation:\n    The maximum sum of a subgrid is obtained by selecting the entire grid, which gives a sum of 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the prefix sum of each row\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows)]\n    for i in range(rows):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i][j-1] + grid[i][j-1]\n\n    max_sum = float('-inf')\n\n    # Iterate over all possible subgrid positions and calculate the sum\n    for i in range(rows):\n        for j in range(i, rows):\n            subgrid_sum = 0\n            for k in range(cols):\n                subgrid_sum += prefix_sum[j][k+1] - prefix_sum[i][k+1]\n                max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n", "emb": null, "idx_generation": 361, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid where the subgrid forms a rectangle.\n    The subgrid can be obtained by selecting a rectangular region from the grid, and the sum of the subgrid is the sum of all its elements.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n\n    Explanation:\n    The maximum sum of a subgrid is obtained by selecting the entire grid, which gives a sum of 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the prefix sum of each row\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows)]\n    for i in range(rows):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i][j-1] + grid[i][j-1]\n\n    max_sum = float('-inf')\n\n    # Iterate over all possible subgrid positions and calculate the sum\n    for i in range(rows):\n        for j in range(i, rows):\n            subgrid_sum = 0\n            for k in range(cols):\n                subgrid_sum += prefix_sum[j][k+1] - prefix_sum[i][k+1]\n                max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing a map, find the length of the longest path in the grid.\n    The longest path is defined as the path from the top-left cell to the bottom-right cell,\n    where each step in the path is either a step right or a step down.\n\n    Example:\n    Input:\n    n = 3\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 21\n\n    Explanation:\n    The longest path is 1 -> 2 -> 3 -> 6 -> 9, which has a length of 21.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    # Initialize the first row and the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Calculate the longest path for each cell\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[n-1][n-1]\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 3\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return n, grid\n\nassert f(*g()) == 21\n", "emb": null, "idx_generation": 361, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers representing a map, find the length of the longest path in the grid.\n    The longest path is defined as the path from the top-left cell to the bottom-right cell,\n    where each step in the path is either a step right or a step down.\n\n    Example:\n    Input:\n    n = 3\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 21\n\n    Explanation:\n    The longest path is 1 -> 2 -> 3 -> 6 -> 9, which has a length of 21.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    # Initialize the first row and the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Calculate the longest path for each cell\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[n-1][n-1]", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    n = 3\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return n, grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers and two integers n and k, find the kth smallest element in the array\n    considering only the first n elements.\n\n    Example:\n    Input:\n    n = 7\n    k = 3\n    arr = [6, 2, 8, 1, 3, 5, 4]\n    Output: 3\n\n    Explanation:\n    Considering only the first 7 elements: [6, 2, 8, 1, 3, 5, 4]\n    The 3rd smallest element is 3.\n    \"\"\"\n\n    # Sort the first n elements\n    arr.sort()\n\n    return arr[k-1]\n\ndef g() -> Tuple[int, int, List[int]]:\n    n = 7\n    k = 3\n    arr = [6, 2, 8, 1, 3, 5, 4]\n    return n, k, arr\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers and two integers n and k, find the kth smallest element in the array\n    considering only the first n elements.\n\n    Example:\n    Input:\n    n = 7\n    k = 3\n    arr = [6, 2, 8, 1, 3, 5, 4]\n    Output: 3\n\n    Explanation:\n    Considering only the first 7 elements: [6, 2, 8, 1, 3, 5, 4]\n    The 3rd smallest element is 3.\n    \"\"\"\n\n    # Sort the first n elements\n    arr.sort()\n\n    return arr[k-1]", "solution_func": "def g() -> Tuple[int, int, List[int]]:\n    n = 7\n    k = 3\n    arr = [6, 2, 8, 1, 3, 5, 4]\n    return n, k, arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers\n    out of the range 1 to n.\n\n    Sample Input:\n    n = 4\n    k = 2\n\n    Sample Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(curr, start):\n        if len(curr) == k:\n            combinations.append(curr.copy())\n            return\n        for i in range(start, n+1):\n            curr.append(i)\n            backtrack(curr, i+1)\n            curr.pop()\n    \n    combinations = []\n    backtrack([], 1)\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 361, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers\n    out of the range 1 to n.\n\n    Sample Input:\n    n = 4\n    k = 2\n\n    Sample Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(curr, start):\n        if len(curr) == k:\n            combinations.append(curr.copy())\n            return\n        for i in range(start, n+1):\n            curr.append(i)\n            backtrack(curr, i+1)\n            curr.pop()\n    \n    combinations = []\n    backtrack([], 1)\n    return combinations", "solution_func": "def g():\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the size of the largest square submatrix consisting only of 1s.\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return 0\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n    return max_size ** 2\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of 0s and 1s for Puzzle 3.\n    \"\"\"\n    return [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the size of the largest square submatrix consisting only of 1s.\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return 0\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n    return max_size ** 2", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of 0s and 1s for Puzzle 3.\n    \"\"\"\n    return [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left cell to the bottom-right cell,\n    by moving only right or down, and avoiding the cells with the value 1.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return 0\n    cols = len(grid[0])\n    dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n    dp[0][1] = 0\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 0:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n    return dp[rows][cols]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s for Puzzle 4.\n    \"\"\"\n    return [[0, 0, 1, 1, 0],\n            [1, 0, 1, 1, 0],\n            [1, 0, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [1, 1, 0, 0, 0]]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 362, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left cell to the bottom-right cell,\n    by moving only right or down, and avoiding the cells with the value 1.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return 0\n    cols = len(grid[0])\n    dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n    dp[0][1] = 0\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 0:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n    return dp[rows][cols]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s for Puzzle 4.\n    \"\"\"\n    return [[0, 0, 1, 1, 0],\n            [1, 0, 1, 1, 0],\n            [1, 0, 0, 0, 0],\n            [0, 1, 1, 0, 0],\n            [1, 1, 0, 0, 0]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array, find the next greater element for each element in the array. If there is no greater element,\n    return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        while stack and stack[-1] <= arr[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(arr[i])\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 5.\n    \"\"\"\n    return [4, 5, 2, 9, 1, 7]\n\nassert f(g()) == [5, 9, 9, -1, 7, -1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array, find the next greater element for each element in the array. If there is no greater element,\n    return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        while stack and stack[-1] <= arr[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(arr[i])\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 5.\n    \"\"\"\n    return [4, 5, 2, 9, 1, 7]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct subsets whose bitwise XOR of all elements is equal to 0.\n    \"\"\"\n    def helper(nums: List[int], index: int, xor: int, subsets: int) -> int:\n        if index == len(nums):\n            if xor == 0:\n                subsets += 1\n            return subsets\n        \n        # Exclude the current element\n        subsets = helper(nums, index + 1, xor, subsets)\n        \n        # Include the current element\n        subsets = helper(nums, index + 1, xor ^ nums[index], subsets)\n        \n        return subsets\n    \n    return helper(nums, 0, 0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 362, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct subsets whose bitwise XOR of all elements is equal to 0.\n    \"\"\"\n    def helper(nums: List[int], index: int, xor: int, subsets: int) -> int:\n        if index == len(nums):\n            if xor == 0:\n                subsets += 1\n            return subsets\n        \n        # Exclude the current element\n        subsets = helper(nums, index + 1, xor, subsets)\n        \n        # Include the current element\n        subsets = helper(nums, index + 1, xor ^ nums[index], subsets)\n        \n        return subsets\n    \n    return helper(nums, 0, 0, 0)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all possible combinations of k numbers that sum up to the target.\n    \"\"\"\n    def helper(nums: List[int], target: int, k: int, index: int, curr: List[int], combinations: List[List[int]]) -> None:\n        if target == 0 and k == 0:\n            combinations.append(curr)\n            return\n        if target < 0 or k == 0 or index == len(nums):\n            return\n        \n        # Exclude the current element\n        helper(nums, target, k, index + 1, curr, combinations)\n        \n        # Include the current element\n        helper(nums, target - nums[index], k - 1, index + 1, curr + [nums[index]], combinations)\n    \n    combinations = []\n    helper(nums, target, k, 0, [], combinations)\n    return combinations\n\ndef g() -> Tuple[List[int], int, int]:\n    \"\"\"\n    Generate input values for Puzzle 5.\n    \"\"\"\n    nums = [2, 3, 4, 5]\n    target = 7\n    k = 2\n    return nums, target, k\n\nassert f(*g()) == [[2, 5], [3, 4]]\n", "emb": null, "idx_generation": 362, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all possible combinations of k numbers that sum up to the target.\n    \"\"\"\n    def helper(nums: List[int], target: int, k: int, index: int, curr: List[int], combinations: List[List[int]]) -> None:\n        if target == 0 and k == 0:\n            combinations.append(curr)\n            return\n        if target < 0 or k == 0 or index == len(nums):\n            return\n        \n        # Exclude the current element\n        helper(nums, target, k, index + 1, curr, combinations)\n        \n        # Include the current element\n        helper(nums, target - nums[index], k - 1, index + 1, curr + [nums[index]], combinations)\n    \n    combinations = []\n    helper(nums, target, k, 0, [], combinations)\n    return combinations", "solution_func": "def g() -> Tuple[List[int], int, int]:\n    \"\"\"\n    Generate input values for Puzzle 5.\n    \"\"\"\n    nums = [2, 3, 4, 5]\n    target = 7\n    k = 2\n    return nums, target, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: arr = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is achieved by taking the XOR of 5 and 25, resulting in 28.\n\n    Input: arr = [0, 1, 2, 3, 4, 5]\n    Output: 7\n    Explanation: The maximum XOR value is achieved by taking the XOR of 3 and 4, resulting in 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: arr = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is achieved by taking the XOR of 5 and 25, resulting in 28.\n\n    Input: arr = [0, 1, 2, 3, 4, 5]\n    Output: 7\n    Explanation: The maximum XOR value is achieved by taking the XOR of 3 and 4, resulting in 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return their indices as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Input: nums = [3, 2, 4], target = 6\n    Output: [1, 2]\n    Explanation: The numbers at indices 1 and 2 (2 and 4) add up to 6.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return their indices as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Input: nums = [3, 2, 4], target = 6\n    Output: [1, 2]\n    Explanation: The numbers at indices 1 and 2 (2 and 4) add up to 6.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n    Explanation: The new list is obtained by multiplying all the numbers in the original list except the one at each index.\n\n    Input: nums = [3, 2, 1]\n    Output: [2, 3, 6]\n    Explanation: The new list is obtained by multiplying all the numbers in the original list except the one at each index.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n    \n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 362, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n    Explanation: The new list is obtained by multiplying all the numbers in the original list except the one at each index.\n\n    Input: nums = [3, 2, 1]\n    Output: [2, 3, 6]\n    Explanation: The new list is obtained by multiplying all the numbers in the original list except the one at each index.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n    \n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any two numbers in the list is 20 (4 * 5).\n\n    Therefore, the function should return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 362, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any two numbers in the list is 20 (4 * 5).\n\n    Therefore, the function should return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"Find k numbers from the range 1 to n (inclusive) which sum up to target_sum.\"\"\"\n    def count_combinations(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        return count_combinations(n-1, k-1) + count_combinations(n-1, k)\n    \n    return count_combinations(n, k) == target_sum\n\ndef g(n=10, k=3, target_sum=120):\n    return [n, k, target_sum]\n\nassert f(*g())\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"Find k numbers from the range 1 to n (inclusive) which sum up to target_sum.\"\"\"\n    def count_combinations(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        return count_combinations(n-1, k-1) + count_combinations(n-1, k)\n    \n    return count_combinations(n, k) == target_sum", "solution_func": "def g(n=10, k=3, target_sum=120):\n    return [n, k, target_sum]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(num: int, k: int) -> bool:\n    \"\"\"Check if the k-th bit of the binary representation of num is set (equal to 1).\"\"\"\n    binary = bin(num)[2:]\n    return binary[-k] == '1'\n\ndef g(num=42, k=3):\n    return [num, k]\n\nassert f(*g())\n", "emb": null, "idx_generation": 363, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(num: int, k: int) -> bool:\n    \"\"\"Check if the k-th bit of the binary representation of num is set (equal to 1).\"\"\"\n    binary = bin(num)[2:]\n    return binary[-k] == '1'", "solution_func": "def g(num=42, k=3):\n    return [num, k]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=17):\n    return [n]\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g(n=17):\n    return [n]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest increasing subsequence (LIS) in the array.\n    An increasing subsequence is a sequence of numbers where each number is greater than the previous number.\n\n    Return the length of the LIS.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    # Initialize an array to store the lengths of the LIS ending at each index\n    dp = [1] * n\n\n    # Iterate through the array\n    for i in range(1, n):\n        # Check all previous elements\n        for j in range(i):\n            # If the current element is greater than the previous element and the length of the LIS ending at the previous element plus 1 is greater than the current length,\n            # update the current length\n            if nums[i] > nums[j] and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n\n    # Return the maximum length of the LIS\n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)\n\nassert f(*g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest increasing subsequence (LIS) in the array.\n    An increasing subsequence is a sequence of numbers where each number is greater than the previous number.\n\n    Return the length of the LIS.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    # Initialize an array to store the lengths of the LIS ending at each index\n    dp = [1] * n\n\n    # Iterate through the array\n    for i in range(1, n):\n        # Check all previous elements\n        for j in range(i):\n            # If the current element is greater than the previous element and the length of the LIS ending at the previous element plus 1 is greater than the current length,\n            # update the current length\n            if nums[i] > nums[j] and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n\n    # Return the maximum length of the LIS\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and an integer n,\n    determine if the graph is bipartite.\n\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n\n    Return True if the graph is bipartite, False otherwise.\n\n    Example:\n    Input: n = 4, edges = [[0,1],[1,2],[2,3],[3,0]]\n    Output: False\n    Explanation: The graph contains a cycle with odd length, so it is not bipartite.\n    \"\"\"\n\n    # Initialize a color array to store the color of each vertex\n    color = [-1] * n\n\n    # Set the color of the first vertex to 0\n    color[0] = 0\n\n    # Initialize a queue for BFS traversal\n    queue = []\n    queue.append(0)\n\n    # While the queue is not empty\n    while queue:\n        # Dequeue a vertex\n        u = queue.pop(0)\n\n        # Traverse all adjacent vertices of u\n        for v in edges[u]:\n            # If the adjacent vertex v is not colored\n            if color[v] == -1:\n                # Color the adjacent vertex with a different color than u\n                color[v] = 1 - color[u]\n                queue.append(v)\n            # If the adjacent vertex v is already colored with the same color as u, the graph is not bipartite\n            elif color[v] == color[u]:\n                return False\n\n    return True\n\n\ndef g():\n    n = 4\n    edges = [[0,1],[1,2],[2,3],[3,0]]\n    return (n, edges)\n\nassert f(*g()) == False\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 363, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and an integer n,\n    determine if the graph is bipartite.\n\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n\n    Return True if the graph is bipartite, False otherwise.\n\n    Example:\n    Input: n = 4, edges = [[0,1],[1,2],[2,3],[3,0]]\n    Output: False\n    Explanation: The graph contains a cycle with odd length, so it is not bipartite.\n    \"\"\"\n\n    # Initialize a color array to store the color of each vertex\n    color = [-1] * n\n\n    # Set the color of the first vertex to 0\n    color[0] = 0\n\n    # Initialize a queue for BFS traversal\n    queue = []\n    queue.append(0)\n\n    # While the queue is not empty\n    while queue:\n        # Dequeue a vertex\n        u = queue.pop(0)\n\n        # Traverse all adjacent vertices of u\n        for v in edges[u]:\n            # If the adjacent vertex v is not colored\n            if color[v] == -1:\n                # Color the adjacent vertex with a different color than u\n                color[v] = 1 - color[u]\n                queue.append(v)\n            # If the adjacent vertex v is already colored with the same color as u, the graph is not bipartite\n            elif color[v] == color[u]:\n                return False\n\n    return True", "solution_func": "def g():\n    n = 4\n    edges = [[0,1],[1,2],[2,3],[3,0]]\n    return (n, edges)", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    update the grid such that each empty cell is filled with the minimum distance to a wall.\n    The distance is the number of steps required to reach the nearest wall (the nearest 1).\n\n    Return the updated grid.\n\n    Example:\n    Input: [[0,0,0],[0,1,0],[1,1,1]]\n    Output: [[1,2,1],[2,1,2],[3,2,2]]\n    \"\"\"\n\n    # Get the number of rows and columns in the grid\n    rows, cols = len(matrix), len(matrix[0])\n\n    # Initialize a queue for BFS traversal\n    queue = []\n\n    # Iterate through the grid and enqueue all wall cells\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                queue.append((i, j))\n\n    # Initialize a distance array to store the distance of each cell from the nearest wall\n    distance = [[float('inf')] * cols for _ in range(rows)]\n\n    # Initialize the distance of wall cells to 0\n    for i, j in queue:\n        distance[i][j] = 0\n\n    # Define the possible directions for traversal\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    # Perform BFS traversal starting from the wall cells\n    while queue:\n        # Dequeue a cell\n        row, col = queue.pop(0)\n\n        # Traverse all adjacent cells\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            # If the adjacent cell is within the grid and the distance from the wall cell plus 1 is smaller than the current distance,\n            # update the distance and enqueue the adjacent cell\n            if 0 <= new_row < rows and 0 <= new_col < cols and distance[new_row][new_col] > distance[row][col] + 1:\n                distance[new_row][new_col] = distance[row][col] + 1\n                queue.append((new_row, new_col))\n\n    return distance\n\n\ndef g():\n    matrix = [[0,0,0],[0,1,0],[1,1,1]]\n    return (matrix,)\n\nassert f(*g()) == [[1,2,1],[2,1,2],[3,2,2]]\n\n", "emb": null, "idx_generation": 363, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    update the grid such that each empty cell is filled with the minimum distance to a wall.\n    The distance is the number of steps required to reach the nearest wall (the nearest 1).\n\n    Return the updated grid.\n\n    Example:\n    Input: [[0,0,0],[0,1,0],[1,1,1]]\n    Output: [[1,2,1],[2,1,2],[3,2,2]]\n    \"\"\"\n\n    # Get the number of rows and columns in the grid\n    rows, cols = len(matrix), len(matrix[0])\n\n    # Initialize a queue for BFS traversal\n    queue = []\n\n    # Iterate through the grid and enqueue all wall cells\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1:\n                queue.append((i, j))\n\n    # Initialize a distance array to store the distance of each cell from the nearest wall\n    distance = [[float('inf')] * cols for _ in range(rows)]\n\n    # Initialize the distance of wall cells to 0\n    for i, j in queue:\n        distance[i][j] = 0\n\n    # Define the possible directions for traversal\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    # Perform BFS traversal starting from the wall cells\n    while queue:\n        # Dequeue a cell\n        row, col = queue.pop(0)\n\n        # Traverse all adjacent cells\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            # If the adjacent cell is within the grid and the distance from the wall cell plus 1 is smaller than the current distance,\n            # update the distance and enqueue the adjacent cell\n            if 0 <= new_row < rows and 0 <= new_col < cols and distance[new_row][new_col] > distance[row][col] + 1:\n                distance[new_row][new_col] = distance[row][col] + 1\n                queue.append((new_row, new_col))\n\n    return distance", "solution_func": "def g():\n    matrix = [[0,0,0],[0,1,0],[1,1,1]]\n    return (matrix,)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of 2 and contains the digit 5.\"\"\"\n    return n != 0 and (n & (n - 1)) == 0 and '5' in str(n)\n\ndef g():\n    return 32\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 363, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of 2 and contains the digit 5.\"\"\"\n    return n != 0 and (n & (n - 1)) == 0 and '5' in str(n)", "solution_func": "def g():\n    return 32", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome and contains only alphabetic characters.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalpha())\n    return s == s[::-1]\n\ndef g():\n    return \"Able was I saw Elba\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome and contains only alphabetic characters.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalpha())\n    return s == s[::-1]", "solution_func": "def g():\n    return \"Able was I saw Elba\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if a given string has a length divisible by k and contains at least one uppercase character.\"\"\"\n    return len(s) % k == 0 and any(c.isupper() for c in s)\n\ndef g(k: int = 3):\n    return \"Python\"\n\nassert f(g(), k=3) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if a given string has a length divisible by k and contains at least one uppercase character.\"\"\"\n    return len(s) % k == 0 and any(c.isupper() for c in s)", "solution_func": "def g(k: int = 3):\n    return \"Python\"", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any two distinct numbers is 20 (4 * 5).\n\n    Therefore, the function should return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 363, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any two distinct numbers is 20 (4 * 5).\n\n    Therefore, the function should return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a Fibonacci number.\"\"\"\n\n    def is_perfect_square(x: int) -> bool:\n        sqrt_x = int(x ** 0.5)\n        return sqrt_x * sqrt_x == x\n\n    def is_fibonacci(n: int) -> bool:\n        return is_perfect_square(5 * (n * n) + 4) or is_perfect_square(5 * (n * n) - 4)\n\n    return is_fibonacci(n)\n\ndef g() -> int:\n    \"\"\"\n    Find the smallest Fibonacci number greater than or equal to 1000.\n    \"\"\"\n\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    i = 0\n    while fibonacci(i) < 1000:\n        i += 1\n\n    return fibonacci(i)\n    \nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a Fibonacci number.\"\"\"\n\n    def is_perfect_square(x: int) -> bool:\n        sqrt_x = int(x ** 0.5)\n        return sqrt_x * sqrt_x == x\n\n    def is_fibonacci(n: int) -> bool:\n        return is_perfect_square(5 * (n * n) + 4) or is_perfect_square(5 * (n * n) - 4)\n\n    return is_fibonacci(n)", "solution_func": "def g() -> int:\n    \"\"\"\n    Find the smallest Fibonacci number greater than or equal to 1000.\n    \"\"\"\n\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    i = 0\n    while fibonacci(i) < 1000:\n        i += 1\n\n    return fibonacci(i)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(n)\n\ndef g() -> int:\n    \"\"\"\n    Find the smallest prime number greater than or equal to 1000.\n    \"\"\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    i = 1000\n    while not is_prime(i):\n        i += 1\n\n    return i\n    \nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(n)", "solution_func": "def g() -> int:\n    \"\"\"\n    Find the smallest prime number greater than or equal to 1000.\n    \"\"\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    i = 1000\n    while not is_prime(i):\n        i += 1\n\n    return i", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n\n    def is_perfect_square(n: int) -> bool:\n        sqrt_n = int(n ** 0.5)\n        return sqrt_n * sqrt_n == n\n\n    return is_perfect_square(n)\n\ndef g() -> int:\n    \"\"\"\n    Find the smallest perfect square greater than or equal to 1000.\n    \"\"\"\n\n    i = 32\n    while i * i < 1000:\n        i += 1\n\n    return i * i\n    \nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n\n    def is_perfect_square(n: int) -> bool:\n        sqrt_n = int(n ** 0.5)\n        return sqrt_n * sqrt_n == n\n\n    return is_perfect_square(n)", "solution_func": "def g() -> int:\n    \"\"\"\n    Find the smallest perfect square greater than or equal to 1000.\n    \"\"\"\n\n    i = 32\n    while i * i < 1000:\n        i += 1\n\n    return i * i", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return indices of the two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate an array of integers and a target integer.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return indices of the two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i", "solution_func": "def g() -> (List[int], int):\n    \"\"\"\n    Generate an array of integers and a target integer.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 25\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 25\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, check if the sum of each row and each column is the same.\n\n    Example:\n    grid = [\n        [4, 9, 2],\n        [3, 5, 7],\n        [8, 1, 6]\n    ]\n\n    f(grid) => True\n\n    Explanation: The sum of each row and each column is 15.\n    \"\"\"\n\n    n = len(grid)\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n\n    target_sum = row_sums[0]\n\n    for i in range(n):\n        if row_sums[i] != target_sum or col_sums[i] != target_sum:\n            return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    return [\n        [4, 9, 2],\n        [3, 5, 7],\n        [8, 1, 6]\n    ]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 364, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, check if the sum of each row and each column is the same.\n\n    Example:\n    grid = [\n        [4, 9, 2],\n        [3, 5, 7],\n        [8, 1, 6]\n    ]\n\n    f(grid) => True\n\n    Explanation: The sum of each row and each column is 15.\n    \"\"\"\n\n    n = len(grid)\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n\n    target_sum = row_sums[0]\n\n    for i in range(n):\n        if row_sums[i] != target_sum or col_sums[i] != target_sum:\n            return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [4, 9, 2],\n        [3, 5, 7],\n        [8, 1, 6]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid parentheses sequence.\n\n    Example:\n    s = \"()((())())\"\n\n    f(s) => True\n\n    Explanation: The string contains a valid parentheses sequence.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"()((())())\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 364, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid parentheses sequence.\n\n    Example:\n    s = \"()((())())\"\n\n    f(s) => True\n\n    Explanation: The string contains a valid parentheses sequence.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0", "solution_func": "def g() -> str:\n    return \"()((())())\"", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a subgrid with dimensions 2x2.\n\n    Example:\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n\n    f(grid) => 66\n\n    Explanation: The maximum sum of a 2x2 subgrid is 66, obtained from the subgrid [[10, 11], [14, 15]].\n    \"\"\"\n\n    max_sum = float('-inf')\n    n = len(grid)\n\n    for i in range(n - 1):\n        for j in range(n - 1):\n            subgrid_sum = grid[i][j] + grid[i][j+1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n\nassert f(g()) == 66\n", "emb": null, "idx_generation": 364, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of a subgrid with dimensions 2x2.\n\n    Example:\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n\n    f(grid) => 66\n\n    Explanation: The maximum sum of a 2x2 subgrid is 66, obtained from the subgrid [[10, 11], [14, 15]].\n    \"\"\"\n\n    max_sum = float('-inf')\n    n = len(grid)\n\n    for i in range(n - 1):\n        for j in range(n - 1):\n            subgrid_sum = grid[i][j] + grid[i][j+1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of elements to remove from the list\n    in order to make the sum of the remaining elements equal to the target.\n\n    Example:\n    nums = [5, 2, 3, 10]\n    target = 15\n\n    The target sum can be achieved by removing the element 10. Therefore, the function should return 1.\n    \"\"\"\n\n    def subset_sum(nums, target):\n        \"\"\"\n        Returns the minimum number of elements to remove from nums to achieve the target sum.\n        \"\"\"\n        n = len(nums)\n        dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1)\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][target]\n    \n    return subset_sum(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    return ([5, 2, 3, 10], 15)\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 364, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of elements to remove from the list\n    in order to make the sum of the remaining elements equal to the target.\n\n    Example:\n    nums = [5, 2, 3, 10]\n    target = 15\n\n    The target sum can be achieved by removing the element 10. Therefore, the function should return 1.\n    \"\"\"\n\n    def subset_sum(nums, target):\n        \"\"\"\n        Returns the minimum number of elements to remove from nums to achieve the target sum.\n        \"\"\"\n        n = len(nums)\n        dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1)\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][target]\n    \n    return subset_sum(nums, target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([5, 2, 3, 10], 15)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest path formed by adjacent characters that are in alphabetical order.\n    The path can be formed by moving in any of the four cardinal directions (up, down, left, or right) from one character to another.\n\n    Return the length of the longest path.\n\n    Example:\n    grid = [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\n    f(grid) => 9\n    Explanation: The longest path in the grid is ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'].\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_length = 0\n\n    def dfs(row, col, length, prev_char):\n        nonlocal max_length\n\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] <= prev_char:\n            max_length = max(max_length, length)\n            return\n\n        # Update the previous character\n        prev_char = grid[row][col]\n\n        # Mark the current character as visited\n        temp = grid[row][col]\n        grid[row][col] = '#'\n\n        # Recursively explore all four directions\n        dfs(row + 1, col, length + 1, prev_char)\n        dfs(row - 1, col, length + 1, prev_char)\n        dfs(row, col + 1, length + 1, prev_char)\n        dfs(row, col - 1, length + 1, prev_char)\n\n        # Restore the current character\n        grid[row][col] = temp\n\n    for row in range(rows):\n        for col in range(cols):\n            dfs(row, col, 0, chr(ord('a') - 1))\n\n    return max_length\n\ndef g():\n    return [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 365, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest path formed by adjacent characters that are in alphabetical order.\n    The path can be formed by moving in any of the four cardinal directions (up, down, left, or right) from one character to another.\n\n    Return the length of the longest path.\n\n    Example:\n    grid = [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\n    f(grid) => 9\n    Explanation: The longest path in the grid is ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'].\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_length = 0\n\n    def dfs(row, col, length, prev_char):\n        nonlocal max_length\n\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] <= prev_char:\n            max_length = max(max_length, length)\n            return\n\n        # Update the previous character\n        prev_char = grid[row][col]\n\n        # Mark the current character as visited\n        temp = grid[row][col]\n        grid[row][col] = '#'\n\n        # Recursively explore all four directions\n        dfs(row + 1, col, length + 1, prev_char)\n        dfs(row - 1, col, length + 1, prev_char)\n        dfs(row, col + 1, length + 1, prev_char)\n        dfs(row, col - 1, length + 1, prev_char)\n\n        # Restore the current character\n        grid[row][col] = temp\n\n    for row in range(rows):\n        for col in range(cols):\n            dfs(row, col, 0, chr(ord('a') - 1))\n\n    return max_length", "solution_func": "def g():\n    return [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by taking the XOR of any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    f(nums) => 28\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 25, which is 28.\n\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if target_xor ^ prefix in prefixes:\n                max_xor = target_xor\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by taking the XOR of any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    f(nums) => 28\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 25, which is 28.\n\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if target_xor ^ prefix in prefixes:\n                max_xor = target_xor\n                break\n\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to form the string s by concatenating the words in any order.\n    Return True if the string can be formed, False otherwise.\n\n    Example:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    f(s, words) => True\n    Explanation: The string \"leetcode\" can be formed by concatenating \"leet\" and \"code\".\n\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(s):\n            return True\n\n        for word in words:\n            if s.startswith(word, start):\n                if backtrack(start + len(word)):\n                    return True\n\n        return False\n\n    return backtrack(0)\n\ndef g():\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to form the string s by concatenating the words in any order.\n    Return True if the string can be formed, False otherwise.\n\n    Example:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    f(s, words) => True\n    Explanation: The string \"leetcode\" can be formed by concatenating \"leet\" and \"code\".\n\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(s):\n            return True\n\n        for word in words:\n            if s.startswith(word, start):\n                if backtrack(start + len(word)):\n                    return True\n\n        return False\n\n    return backtrack(0)", "solution_func": "def g():\n    return \"leetcode\", [\"leet\", \"code\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes 'start' and 'end',\n    determine if there is a path from 'start' to 'end' with a bitwise XOR of at most 'k'.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    start = 0\n    end = 3\n    k = 2\n\n    Output:\n    True\n\n    Explanation:\n    The path from node 0 to node 3 with a bitwise XOR of at most 2 is:\n    0 -> 1 -> 0 -> 1 -> 0 -> 1 -> 0 -> 3\n    The bitwise XOR of the edges in this path is 2.\n    Therefore, the output is True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, k, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, k: int, visited: List[bool]) -> bool:\n    if curr == end:\n        return True\n    visited[curr] = True\n    for i in range(len(graph)):\n        if graph[curr][i] != 0 and not visited[i] and (k ^ graph[curr][i]) <= k:\n            if dfs(graph, i, end, k ^ graph[curr][i], visited):\n                return True\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int, int]:\n    \"\"\"\n    Generate a graph, start node, end node, and k value such that there is a path from start to end\n    with a bitwise XOR of at most k.\n    \"\"\"\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    start = 0\n    end = 3\n    k = 2\n    return (graph, start, end, k)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 365, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes 'start' and 'end',\n    determine if there is a path from 'start' to 'end' with a bitwise XOR of at most 'k'.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    start = 0\n    end = 3\n    k = 2\n\n    Output:\n    True\n\n    Explanation:\n    The path from node 0 to node 3 with a bitwise XOR of at most 2 is:\n    0 -> 1 -> 0 -> 1 -> 0 -> 1 -> 0 -> 3\n    The bitwise XOR of the edges in this path is 2.\n    Therefore, the output is True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, k, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, k: int, visited: List[bool]) -> bool:\n    if curr == end:\n        return True\n    visited[curr] = True\n    for i in range(len(graph)):\n        if graph[curr][i] != 0 and not visited[i] and (k ^ graph[curr][i]) <= k:\n            if dfs(graph, i, end, k ^ graph[curr][i], visited):\n                return True\n    return False", "solution_func": "def g() -> Tuple[List[List[int]], int, int, int]:\n    \"\"\"\n    Generate a graph, start node, end node, and k value such that there is a path from start to end\n    with a bitwise XOR of at most k.\n    \"\"\"\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    start = 0\n    end = 3\n    k = 2\n    return (graph, start, end, k)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes 'start' and 'end',\n    determine if there is a path from 'start' to 'end' with a bitwise AND of at least 'k'.\n\n    Example:\n    Input:\n    graph = [[1, 1, 0, 1],\n             [1, 1, 1, 0],\n             [0, 1, 1, 1],\n             [1, 0, 1, 1]]\n    start = 0\n    end = 3\n    k = 2\n\n    Output:\n    True\n\n    Explanation:\n    The path from node 0 to node 3 with a bitwise AND of at least 2 is:\n    0 -> 1 -> 0 -> 1 -> 0 -> 1 -> 0 -> 3\n    The bitwise AND of the edges in this path is 2.\n    Therefore, the output is True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, k, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, k: int, visited: List[bool]) -> bool:\n    if curr == end:\n        return True\n    visited[curr] = True\n    for i in range(len(graph)):\n        if graph[curr][i] != 0 and not visited[i] and (k & graph[curr][i]) >= k:\n            if dfs(graph, i, end, k & graph[curr][i], visited):\n                return True\n    return False\n\ndef g() -> Tuple[List[List[int]], int, int, int]:\n    \"\"\"\n    Generate a graph, start node, end node, and k value such that there is a path from start to end\n    with a bitwise AND of at least k.\n    \"\"\"\n    graph = [[1, 1, 0, 1],\n             [1, 1, 1, 0],\n             [0, 1, 1, 1],\n             [1, 0, 1, 1]]\n    start = 0\n    end = 3\n    k = 2\n    return (graph, start, end, k)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 365, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes 'start' and 'end',\n    determine if there is a path from 'start' to 'end' with a bitwise AND of at least 'k'.\n\n    Example:\n    Input:\n    graph = [[1, 1, 0, 1],\n             [1, 1, 1, 0],\n             [0, 1, 1, 1],\n             [1, 0, 1, 1]]\n    start = 0\n    end = 3\n    k = 2\n\n    Output:\n    True\n\n    Explanation:\n    The path from node 0 to node 3 with a bitwise AND of at least 2 is:\n    0 -> 1 -> 0 -> 1 -> 0 -> 1 -> 0 -> 3\n    The bitwise AND of the edges in this path is 2.\n    Therefore, the output is True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, k, visited)\n\ndef dfs(graph: List[List[int]], curr: int, end: int, k: int, visited: List[bool]) -> bool:\n    if curr == end:\n        return True\n    visited[curr] = True\n    for i in range(len(graph)):\n        if graph[curr][i] != 0 and not visited[i] and (k & graph[curr][i]) >= k:\n            if dfs(graph, i, end, k & graph[curr][i], visited):\n                return True\n    return False", "solution_func": "def g() -> Tuple[List[List[int]], int, int, int]:\n    \"\"\"\n    Generate a graph, start node, end node, and k value such that there is a path from start to end\n    with a bitwise AND of at least k.\n    \"\"\"\n    graph = [[1, 1, 0, 1],\n             [1, 1, 1, 0],\n             [0, 1, 1, 1],\n             [1, 0, 1, 1]]\n    start = 0\n    end = 3\n    k = 2\n    return (graph, start, end, k)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the maximum bitwise XOR value\n    between any two nodes in the graph.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n\n    Output:\n    3\n\n    Explanation:\n    The maximum bitwise XOR value between any two nodes in the graph is 3, which can be obtained\n    by XORing the edges in the path: 0 -> 1 -> 2 -> 3.\n    Therefore, the output is 3.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(graph)):\n        for j in range(i + 1, len(graph)):\n            max_xor = max(max_xor, graph[i][j])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph such that the maximum bitwise XOR value between any two nodes is the desired output.\n    \"\"\"\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    return graph\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 365, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the maximum bitwise XOR value\n    between any two nodes in the graph.\n\n    Example:\n    Input:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n\n    Output:\n    3\n\n    Explanation:\n    The maximum bitwise XOR value between any two nodes in the graph is 3, which can be obtained\n    by XORing the edges in the path: 0 -> 1 -> 2 -> 3.\n    Therefore, the output is 3.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(graph)):\n        for j in range(i + 1, len(graph)):\n            max_xor = max(max_xor, graph[i][j])\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph such that the maximum bitwise XOR value between any two nodes is the desired output.\n    \"\"\"\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, find the maximum depth of the tree.\n    The depth of a tree is defined as the maximum number of edges from the root to any leaf node.\n    \"\"\"\n    def dfs(node, depth):\n        max_depth = depth\n        for neighbor in edges[node]:\n            max_depth = max(max_depth, dfs(neighbor, depth + 1))\n        return max_depth\n    \n    # Start the depth-first search from the root node (node 0)\n    return dfs(0, 0)\n\ndef g(n=7, edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]):\n    return n, edges\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 365, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, find the maximum depth of the tree.\n    The depth of a tree is defined as the maximum number of edges from the root to any leaf node.\n    \"\"\"\n    def dfs(node, depth):\n        max_depth = depth\n        for neighbor in edges[node]:\n            max_depth = max(max_depth, dfs(neighbor, depth + 1))\n        return max_depth\n    \n    # Start the depth-first search from the root node (node 0)\n    return dfs(0, 0)", "solution_func": "def g(n=7, edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]]):\n    return n, edges", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n    This is equivalent to calculating the binomial coefficient (n choose k).\n    \"\"\"\n    def binomial_coefficient(n, k):\n        # Base cases\n        if k == 0 or k == n:\n            return 1\n        if k > n:\n            return 0\n\n        # Recursive formula\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n\n    # Calculate the binomial coefficient\n    return binomial_coefficient(n, k)\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n    This is equivalent to calculating the binomial coefficient (n choose k).\n    \"\"\"\n    def binomial_coefficient(n, k):\n        # Base cases\n        if k == 0 or k == n:\n            return 1\n        if k > n:\n            return 0\n\n        # Recursive formula\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n\n    # Calculate the binomial coefficient\n    return binomial_coefficient(n, k)", "solution_func": "def g(n=5, k=3):\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, determine if the graph is a tree.\n    A graph is a tree if it is connected and contains no cycles.\n    \"\"\"\n    def is_tree(n, edges):\n        # Create a list to store the visited status of each node\n        visited = [False] * n\n\n        # Recursive function to check for cycles\n        def has_cycle(node, parent):\n            visited[node] = True\n            for neighbor in edges[node]:\n                if not visited[neighbor]:\n                    if has_cycle(neighbor, node):\n                        return True\n                elif neighbor != parent:\n                    return True\n            return False\n\n        # Check if the graph has a cycle\n        if has_cycle(0, -1):\n            return False\n\n        # Check if all nodes are visited\n        return all(visited)\n\n    # Check if the graph is a tree\n    return is_tree(n, edges)\n\ndef g(n=6, edges=[[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]]):\n    return n, edges\n\nassert f(*g())\n\n", "emb": null, "idx_generation": 365, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, determine if the graph is a tree.\n    A graph is a tree if it is connected and contains no cycles.\n    \"\"\"\n    def is_tree(n, edges):\n        # Create a list to store the visited status of each node\n        visited = [False] * n\n\n        # Recursive function to check for cycles\n        def has_cycle(node, parent):\n            visited[node] = True\n            for neighbor in edges[node]:\n                if not visited[neighbor]:\n                    if has_cycle(neighbor, node):\n                        return True\n                elif neighbor != parent:\n                    return True\n            return False\n\n        # Check if the graph has a cycle\n        if has_cycle(0, -1):\n            return False\n\n        # Check if all nodes are visited\n        return all(visited)\n\n    # Check if the graph is a tree\n    return is_tree(n, edges)", "solution_func": "def g(n=6, edges=[[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]]):\n    return n, edges", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 365, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if there exists a pair of numbers in the array that add up to the target number.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There exists a pair of numbers in the array [3, 4] that add up to the target number 7.\n\n    Constraints:\n    - The input array is sorted in ascending order.\n    - The length of the array is at most 10^5.\n    - The target number is an integer.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=7) -> Tuple[List[int], int]:\n    return arr, target\n\nassert f(*g())\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if there exists a pair of numbers in the array that add up to the target number.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There exists a pair of numbers in the array [3, 4] that add up to the target number 7.\n\n    Constraints:\n    - The input array is sorted in ascending order.\n    - The length of the array is at most 10^5.\n    - The target number is an integer.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(arr=[1, 2, 3, 4, 5], target=7) -> Tuple[List[int], int]:\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, sort the words in lexicographic (dictionary) order, but with words that start with a vowel first.\n\n    Example:\n    Input: words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    Output: [\"apple\", \"orange\", \"banana\", \"kiwi\"]\n\n    Explanation: The words \"apple\" and \"orange\" start with a vowel, so they are placed before \"banana\" and \"kiwi\" in lexicographic order.\n\n    Constraints:\n    - The input list contains at most 10^4 words.\n    - Each word consists of only lowercase English letters.\n    \"\"\"\n\n    vowels = set(\"aeiou\")\n    words.sort(key=lambda word: (word[0] in vowels, word))\n\n    return words\n\ndef g(words=[\"apple\", \"banana\", \"orange\", \"kiwi\"]) -> List[str]:\n    return words\n\nassert f(g()) == [\"apple\", \"orange\", \"banana\", \"kiwi\"]\n\n", "emb": null, "idx_generation": 366, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, sort the words in lexicographic (dictionary) order, but with words that start with a vowel first.\n\n    Example:\n    Input: words = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    Output: [\"apple\", \"orange\", \"banana\", \"kiwi\"]\n\n    Explanation: The words \"apple\" and \"orange\" start with a vowel, so they are placed before \"banana\" and \"kiwi\" in lexicographic order.\n\n    Constraints:\n    - The input list contains at most 10^4 words.\n    - Each word consists of only lowercase English letters.\n    \"\"\"\n\n    vowels = set(\"aeiou\")\n    words.sort(key=lambda word: (word[0] in vowels, word))\n\n    return words", "solution_func": "def g(words=[\"apple\", \"banana\", \"orange\", \"kiwi\"]) -> List[str]:\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of numbers in a rectangle subgrid within the grid.\n\n    Example:\n    Input: grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n\n    Explanation: The maximum sum can be obtained by selecting the subgrid [4, 5, 6], [7, 8, 9].\n\n    Constraints:\n    - The input grid is a rectangular grid containing at most 10^3 rows and columns.\n    - Each element in the grid is an integer.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = sum(grid[x][y] for x in range(i, k+1) for y in range(j, l+1))\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 45\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0], "idx_generation": 366, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of numbers in a rectangle subgrid within the grid.\n\n    Example:\n    Input: grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n\n    Explanation: The maximum sum can be obtained by selecting the subgrid [4, 5, 6], [7, 8, 9].\n\n    Constraints:\n    - The input grid is a rectangular grid containing at most 10^3 rows and columns.\n    - Each element in the grid is an integer.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = sum(grid[x][y] for x in range(i, k+1) for y in range(j, l+1))\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return grid", "map_ix": [1, 1, 0, 1, 0, 0, 1, 1, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target integer, determine if it is possible to obtain the target value by performing bitwise XOR operation on a subset of the matrix elements. The XOR operation is performed on the elements in the same row or same column.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def helper(row: int, col: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if row == rows or col == cols:\n            return False\n\n        # Exclude the current element\n        exclude = helper(row + 1, col, curr) or helper(row, col + 1, curr)\n\n        # Include the current element\n        include = helper(row + 1, col, curr ^ matrix[row][col]) or helper(row, col + 1, curr ^ matrix[row][col])\n\n        return exclude or include\n\n    return helper(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 3.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 14) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target integer, determine if it is possible to obtain the target value by performing bitwise XOR operation on a subset of the matrix elements. The XOR operation is performed on the elements in the same row or same column.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def helper(row: int, col: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if row == rows or col == cols:\n            return False\n\n        # Exclude the current element\n        exclude = helper(row + 1, col, curr) or helper(row, col + 1, curr)\n\n        # Include the current element\n        include = helper(row + 1, col, curr ^ matrix[row][col]) or helper(row, col + 1, curr ^ matrix[row][col])\n\n        return exclude or include\n\n    return helper(0, 0, 0)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 3.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their corresponding list of neighbors,\n    determine if there exists a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n        \n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as a dictionary, and randomly choose a start and end node.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5]}\n    start = 1\n    end = 5\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their corresponding list of neighbors,\n    determine if there exists a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n        \n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n\n    visited = set()\n    return dfs(start, visited)", "solution_func": "def g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as a dictionary, and randomly choose a start and end node.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5]}\n    start = 1\n    end = 5\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of inversions in the list.\n    An inversion occurs when there are two elements i and j such that i < j but nums[i] > nums[j].\n    Return the count of inversions in the list.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n    There are 3 inversions: (2, 1), (4, 1), and (4, 3)\n    Return 3\n    \"\"\"\n    count = 0\n    stack = []\n    for num in nums:\n        while stack and stack[-1] > num:\n            count += 1\n            stack.pop()\n        stack.append(num)\n    return count\n\ndef g():\n    return [2, 4, 1, 3, 5]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 366, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of inversions in the list.\n    An inversion occurs when there are two elements i and j such that i < j but nums[i] > nums[j].\n    Return the count of inversions in the list.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n    There are 3 inversions: (2, 1), (4, 1), and (4, 3)\n    Return 3\n    \"\"\"\n    count = 0\n    stack = []\n    for num in nums:\n        while stack and stack[-1] > num:\n            count += 1\n            stack.pop()\n        stack.append(num)\n    return count", "solution_func": "def g():\n    return [2, 4, 1, 3, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer target, determine if it is possible to obtain the target by adding or subtracting elements from the list.\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n    It is possible to obtain 5 by subtracting 2 and adding 3, so the function should return True.\n\n    nums = [1, 2, 3, 4]\n    target = 10\n    It is not possible to obtain 10 from the given list, so the function should return False.\n    \"\"\"\n    queue = [0]\n    for num in nums:\n        new_queue = []\n        for val in queue:\n            new_queue.append(val + num)\n            new_queue.append(val - num)\n        queue = new_queue\n    return target in queue\n\ndef g():\n    return [1, 2, 3, 4], 5\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 366, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer target, determine if it is possible to obtain the target by adding or subtracting elements from the list.\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n    It is possible to obtain 5 by subtracting 2 and adding 3, so the function should return True.\n\n    nums = [1, 2, 3, 4]\n    target = 10\n    It is not possible to obtain 10 from the given list, so the function should return False.\n    \"\"\"\n    queue = [0]\n    for num in nums:\n        new_queue = []\n        for val in queue:\n            new_queue.append(val + num)\n            new_queue.append(val - num)\n        queue = new_queue\n    return target in queue", "solution_func": "def g():\n    return [1, 2, 3, 4], 5", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray.\n    A subarray is a contiguous portion of the list.\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The subarray with the maximum sum is [4, -1, 2, 1], and the maximum sum is 6.\n    Return 6\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        max_sum = max(max_sum, curr_sum)\n        if curr_sum < 0:\n            curr_sum = 0\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 366, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray.\n    A subarray is a contiguous portion of the list.\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The subarray with the maximum sum is [4, -1, 2, 1], and the maximum sum is 6.\n    Return 6\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        max_sum = max(max_sum, curr_sum)\n        if curr_sum < 0:\n            curr_sum = 0\n    return max_sum", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list that contains only the prime numbers from the original list.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [num for num in nums if is_prime(num)]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [2, 3, 5, 7]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 366, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list that contains only the prime numbers from the original list.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [num for num in nums if is_prime(num)]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find if there is a path from start to end\n    where the string formed by concatenating the values of the nodes in the path matches the given path.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    start = 0\n    end = 3\n    path = \"0213\"\n\n    The path from node 0 to node 3 is: [0, 2, 3]\n\n    The string formed by concatenating the node values is: \"023\"\n\n    Since \"023\" matches the given path \"0213\", the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [(start, \"\")]\n    while stack:\n        node, current_path = stack.pop()\n        if node == end:\n            if current_path == path:\n                return True\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, current_path + str(neighbor)))\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, \"0213\"\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 367, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find if there is a path from start to end\n    where the string formed by concatenating the values of the nodes in the path matches the given path.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    start = 0\n    end = 3\n    path = \"0213\"\n\n    The path from node 0 to node 3 is: [0, 2, 3]\n\n    The string formed by concatenating the node values is: \"023\"\n\n    Since \"023\" matches the given path \"0213\", the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [(start, \"\")]\n    while stack:\n        node, current_path = stack.pop()\n        if node == end:\n            if current_path == path:\n                return True\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, current_path + str(neighbor)))\n    return False", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, \"0213\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, target: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find a path from the start node to the\n    end node such that the bitwise XOR of all the values in the path is equal to the given target.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    target = 6\n\n    There are multiple paths that satisfy the condition:\n    [0, 1, 2, 3] -> 0 XOR 1 XOR 2 XOR 3 = 0 XOR 1 XOR 0 XOR 1 = 0 XOR 0 = 0\n    [0, 2, 3] -> 0 XOR 1 XOR 0 XOR 1 = 0 XOR 0 = 0\n\n    The function should return any of the valid paths, for example [0, 1, 2, 3].\n\n    If there is no path that satisfies the condition, the function should return an empty list [].\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [(start, [start])]\n    while stack:\n        node, current_path = stack.pop()\n        if node == end:\n            xor_value = current_path[0]\n            for i in range(1, len(current_path)):\n                xor_value ^= current_path[i]\n            if xor_value == target:\n                return current_path\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, current_path + [neighbor]))\n    return []\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, 6\n\nassert f(*g()) == [0, 1, 2, 3]\n", "emb": null, "idx_generation": 367, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, target: int) -> List[int]:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find a path from the start node to the\n    end node such that the bitwise XOR of all the values in the path is equal to the given target.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    target = 6\n\n    There are multiple paths that satisfy the condition:\n    [0, 1, 2, 3] -> 0 XOR 1 XOR 2 XOR 3 = 0 XOR 1 XOR 0 XOR 1 = 0 XOR 0 = 0\n    [0, 2, 3] -> 0 XOR 1 XOR 0 XOR 1 = 0 XOR 0 = 0\n\n    The function should return any of the valid paths, for example [0, 1, 2, 3].\n\n    If there is no path that satisfies the condition, the function should return an empty list [].\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [(start, [start])]\n    while stack:\n        node, current_path = stack.pop()\n        if node == end:\n            xor_value = current_path[0]\n            for i in range(1, len(current_path)):\n                xor_value ^= current_path[i]\n            if xor_value == target:\n                return current_path\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, current_path + [neighbor]))\n    return []", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, 6", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, word: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find if there is a path from the start node to the\n    end node where the string formed by concatenating the labels of the nodes in the path contains the given word.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    start = 0\n    end = 3\n    word = \"dog\"\n\n    The path from node 0 to node 3 is: [0, 2, 3]\n\n    The string formed by concatenating the node labels is: \"023\"\n\n    Since \"023\" contains the word \"dog\", the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [(start, \"\")]\n    while stack:\n        node, current_word = stack.pop()\n        if node == end:\n            if word in current_word:\n                return True\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, current_word + str(neighbor)))\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, \"dog\"\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 367, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, word: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find if there is a path from the start node to the\n    end node where the string formed by concatenating the labels of the nodes in the path contains the given word.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    start = 0\n    end = 3\n    word = \"dog\"\n\n    The path from node 0 to node 3 is: [0, 2, 3]\n\n    The string formed by concatenating the node labels is: \"023\"\n\n    Since \"023\" contains the word \"dog\", the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [(start, \"\")]\n    while stack:\n        node, current_word = stack.pop()\n        if node == end:\n            if word in current_word:\n                return True\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append((neighbor, current_word + str(neighbor)))\n    return False", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, \"dog\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 add up to the target number 9.\n    \"\"\"\n\n    def two_sum(nums, target):\n        num_dict = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in num_dict:\n                return [num_dict[complement], i]\n            num_dict[nums[i]] = i\n        return []\n\n    return two_sum(nums, target)\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 add up to the target number 9.\n    \"\"\"\n\n    def two_sum(nums, target):\n        num_dict = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in num_dict:\n                return [num_dict[complement], i]\n            num_dict[nums[i]] = i\n        return []\n\n    return two_sum(nums, target)", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed.\n\n    Example:\n    Input: words = [\"hello\", \"world\", \"python\"]\n    Output: [\"olleh\", \"dlrow\", \"nohtyp\"]\n    \"\"\"\n\n    def reverse_words(words):\n        return [word[::-1] for word in words]\n\n    return reverse_words(words)\n\ndef g():\n    words = [\"hello\", \"world\", \"python\"]\n    return words\n\nassert f(g()) == [\"olleh\", \"dlrow\", \"nohtyp\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed.\n\n    Example:\n    Input: words = [\"hello\", \"world\", \"python\"]\n    Output: [\"olleh\", \"dlrow\", \"nohtyp\"]\n    \"\"\"\n\n    def reverse_words(words):\n        return [word[::-1] for word in words]\n\n    return reverse_words(words)", "solution_func": "def g():\n    words = [\"hello\", \"world\", \"python\"]\n    return words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each number is multiplied by 2.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [2, 4, 6, 8, 10]\n    \"\"\"\n\n    def multiply_by_two(nums):\n        return [num * 2 for num in nums]\n\n    return multiply_by_two(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [2, 4, 6, 8, 10]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 367, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each number is multiplied by 2.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [2, 4, 6, 8, 10]\n    \"\"\"\n\n    def multiply_by_two(nums):\n        return [num * 2 for num in nums]\n\n    return multiply_by_two(nums)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target number 9.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target number 9.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are multiples of 3 or 7.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 24\n    Explanation: The numbers that are multiples of 3 or 7 are 3, 6, 7, and 9. Their sum is 3 + 6 + 7 + 9 = 24.\n\n    \"\"\"\n    total_sum = 0\n    for num in nums:\n        if num % 3 == 0 or num % 7 == 0:\n            total_sum += num\n    return total_sum\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 24\n", "emb": null, "idx_generation": 367, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are multiples of 3 or 7.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 24\n    Explanation: The numbers that are multiples of 3 or 7 are 3, 6, 7, and 9. Their sum is 3 + 6 + 7 + 9 = 24.\n\n    \"\"\"\n    total_sum = 0\n    for num in nums:\n        if num % 3 == 0 or num % 7 == 0:\n            total_sum += num\n    return total_sum", "solution_func": "def g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 30\n    Explanation: The even numbers in the list are 2, 4, 6, 8, and 10. Their sum is 2 + 4 + 6 + 8 + 10 = 30.\n\n    \"\"\"\n    total_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            total_sum += num\n    return total_sum\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 30\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 367, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 30\n    Explanation: The even numbers in the list are 2, 4, 6, 8, and 10. Their sum is 2 + 4 + 6 + 8 + 10 = 30.\n\n    \"\"\"\n    total_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            total_sum += num\n    return total_sum", "solution_func": "def g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix where the sum of elements is less than or equal to a target value.\n    Return the maximum sum.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 15\n\n    f(matrix, target) => 14\n\n    Explanation: The maximum sum of a submatrix with sum less than or equal to 15 is obtained by selecting the submatrix [[1, 2], [4, 5]] which has a sum of 14.\n    \"\"\"\n\n    def find_max_sum(nums: List[int]) -> int:\n        n = len(nums)\n        max_sum = float('-inf')\n        for i in range(n):\n            curr_sum = 0\n            for j in range(i, n):\n                curr_sum += nums[j]\n                if curr_sum <= target:\n                    max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    m = len(matrix)\n    n = len(matrix[0])\n    max_sum = float('-inf')\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                submatrix = [matrix[r][j:k+1] for r in range(i, k+1)]\n                column_sums = [sum(col) for col in zip(*submatrix)]\n                max_sum = max(max_sum, find_max_sum(column_sums))\n    return max_sum\n\ndef g() -> Tuple[List[List[int]]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix,\n\nassert f(*g()) == 14\n", "emb": null, "idx_generation": 367, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix where the sum of elements is less than or equal to a target value.\n    Return the maximum sum.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 15\n\n    f(matrix, target) => 14\n\n    Explanation: The maximum sum of a submatrix with sum less than or equal to 15 is obtained by selecting the submatrix [[1, 2], [4, 5]] which has a sum of 14.\n    \"\"\"\n\n    def find_max_sum(nums: List[int]) -> int:\n        n = len(nums)\n        max_sum = float('-inf')\n        for i in range(n):\n            curr_sum = 0\n            for j in range(i, n):\n                curr_sum += nums[j]\n                if curr_sum <= target:\n                    max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n    m = len(matrix)\n    n = len(matrix[0])\n    max_sum = float('-inf')\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                submatrix = [matrix[r][j:k+1] for r in range(i, k+1)]\n                column_sums = [sum(col) for col in zip(*submatrix)]\n                max_sum = max(max_sum, find_max_sum(column_sums))\n    return max_sum", "solution_func": "def g() -> Tuple[List[List[int]]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix,", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list that sum up to the target number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list that sum up to the target number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n    \"\"\"\n    total = 0\n    for num in arr:\n        if num % 2 == 0:\n            total += num\n    return total\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 6\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n    \"\"\"\n    total = 0\n    for num in arr:\n        if num % 2 == 0:\n            total += num\n    return total", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n    return arr, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: 60\n    Explanation: The maximum product of any three numbers in the list is 4 * 5 * 3 = 60.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: 60\n    Explanation: The maximum product of any three numbers in the list is 4 * 5 * 3 = 60.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down, right, or diagonally.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output: 15\n    Explanation: The minimum sum path is 1 -> 2 -> 3 -> 6 -> 9, which has a sum of 15.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down, right, or diagonally.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output: 15\n    Explanation: The minimum sum path is 1 -> 2 -> 3 -> 6 -> 9, which has a sum of 15.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[-1][-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median of the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: 3\n    Explanation: The median of the list is 3.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[(n // 2) - 1]) / 2\n    else:\n        return nums[n // 2]\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median of the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: 3\n    Explanation: The median of the list is 3.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[(n // 2) - 1]) / 2\n    else:\n        return nums[n // 2]", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1, which are 2 and 7, add up to 9.\n    \"\"\"\n\n    n = len(nums)\n    num_dict = {}\n\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1, which are 2 and 7, add up to 9.\n    \"\"\"\n\n    n = len(nums)\n    num_dict = {}\n\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = nums[0]\n    curr_sum = nums[0]\n\n    for i in range(1, n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 368, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = nums[0]\n    curr_sum = nums[0]\n\n    for i in range(1, n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find all subarrays of length k with maximum sum.\n    Return the subarrays.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], k = 3\n    Output: [[3, 4, 5]]\n\n    Explanation: The subarray [3, 4, 5] has the maximum sum of 12.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    max_sum_subarrays = []\n\n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        subarray_sum = sum(subarray)\n\n        if subarray_sum > max_sum:\n            max_sum = subarray_sum\n            max_sum_subarrays = [subarray]\n        elif subarray_sum == max_sum:\n            max_sum_subarrays.append(subarray)\n\n    return max_sum_subarrays\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [[3, 4, 5]]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 368, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find all subarrays of length k with maximum sum.\n    Return the subarrays.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], k = 3\n    Output: [[3, 4, 5]]\n\n    Explanation: The subarray [3, 4, 5] has the maximum sum of 12.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    max_sum_subarrays = []\n\n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        subarray_sum = sum(subarray)\n\n        if subarray_sum > max_sum:\n            max_sum = subarray_sum\n            max_sum_subarrays = [subarray]\n        elif subarray_sum == max_sum:\n            max_sum_subarrays.append(subarray)\n\n    return max_sum_subarrays", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, return a list of the degrees of each node in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    The degrees of the nodes in the graph are [2, 2, 2, 2].\n\n    Therefore, the function should return [2, 2, 2, 2].\n    \"\"\"\n    degrees = []\n\n    for node in range(len(graph)):\n        degree = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                degree += 1\n        degrees.append(degree)\n\n    return degrees\n\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == [2, 2, 2, 2]\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 368, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, return a list of the degrees of each node in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    The degrees of the nodes in the graph are [2, 2, 2, 2].\n\n    Therefore, the function should return [2, 2, 2, 2].\n    \"\"\"\n    degrees = []\n\n    for node in range(len(graph)):\n        degree = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                degree += 1\n        degrees.append(degree)\n\n    return degrees", "solution_func": "def g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n    return graph", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of distinct binary trees that can be formed with n nodes.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    \n    return dp[n]\n\ndef g() -> int:\n    n = 4\n    return n\n\nassert f(g()) == 14\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of distinct binary trees that can be formed with n nodes.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    \n    return dp[n]", "solution_func": "def g() -> int:\n    n = 4\n    return n", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    output = [1] * n\n    \n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output[i] = left_product[i] * right_product[i]\n    \n    return output\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 369, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    output = [1] * n\n    \n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output[i] = left_product[i] * right_product[i]\n    \n    return output", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    f(nums) => 28\n    Explanation: The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.is_end = True\n\n    def find_max_xor(num, root):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit ^ 1 in node.children:\n                xor |= (1 << i)\n                node = node.children[bit ^ 1]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(num, root)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 369, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    f(nums) => 28\n    Explanation: The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.is_end = True\n\n    def find_max_xor(num, root):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit ^ 1 in node.children:\n                xor |= (1 << i)\n                node = node.children[bit ^ 1]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(num, root)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path in the grid where each cell is greater than the previous cell.\n    Return the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    f(grid) => 4\n    Explanation: The longest increasing path is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(row, col):\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        longest_path = 1\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if new_row >= 0 and new_row < rows and new_col >= 0 and new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                longest_path = max(longest_path, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = longest_path\n        return longest_path\n\n    max_path = 0\n    for row in range(rows):\n        for col in range(cols):\n            max_path = max(max_path, dfs(row, col))\n\n    return max_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path in the grid where each cell is greater than the previous cell.\n    Return the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    f(grid) => 4\n    Explanation: The longest increasing path is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(row, col):\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        longest_path = 1\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if new_row >= 0 and new_row < rows and new_col >= 0 and new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                longest_path = max(longest_path, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = longest_path\n        return longest_path\n\n    max_path = 0\n    for row in range(rows):\n        for col in range(cols):\n            max_path = max(max_path, dfs(row, col))\n\n    return max_path", "solution_func": "def g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all valid paths from the top-left cell to the bottom-right cell.\n    A valid path is a path in the grid where the sum of the numbers along the path is divisible by 3.\n    Return the sum of all valid paths.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(grid) => 24\n    Explanation: There are 4 valid paths: [1, 2, 3, 6, 9], [1, 2, 5, 8, 9], [1, 4, 5, 8, 9], [4, 5, 8, 9].\n    The sum of all valid paths is 24.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0)]\n\n    def dfs(row, col, path_sum):\n        path_sum += grid[row][col]\n\n        if row == rows - 1 and col == cols - 1:\n            return path_sum % 3 == 0\n\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        count = 0\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if new_row < rows and new_col < cols:\n                count += dfs(new_row, new_col, path_sum)\n\n        memo[row][col] = count\n        return count\n\n    return dfs(0, 0, 0)\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 24\n\n", "emb": null, "idx_generation": 369, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all valid paths from the top-left cell to the bottom-right cell.\n    A valid path is a path in the grid where the sum of the numbers along the path is divisible by 3.\n    Return the sum of all valid paths.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(grid) => 24\n    Explanation: There are 4 valid paths: [1, 2, 3, 6, 9], [1, 2, 5, 8, 9], [1, 4, 5, 8, 9], [4, 5, 8, 9].\n    The sum of all valid paths is 24.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0)]\n\n    def dfs(row, col, path_sum):\n        path_sum += grid[row][col]\n\n        if row == rows - 1 and col == cols - 1:\n            return path_sum % 3 == 0\n\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        count = 0\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if new_row < rows and new_col < cols:\n                count += dfs(new_row, new_col, path_sum)\n\n        memo[row][col] = count\n        return count\n\n    return dfs(0, 0, 0)", "solution_func": "def g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to obtain the target value by performing arithmetic operations (+, -, *, /) on the elements of the list, using each element exactly once.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 24\n\n    The possible arithmetic operations are:\n    - 2 + 3 * 5 - 7 = 24\n    - 2 * 5 + 3 - 7 = 24\n\n    Therefore, the function should return True.\n\n    Note:\n    - The list nums will have at least 2 elements and at most 4 elements.\n    - The target value will be an integer.\n    \"\"\"\n\n    def dfs(nums, target, path):\n        if len(nums) == 1:\n            return path + str(nums[0]) == str(target)\n\n        for i in range(len(nums)):\n            remaining_nums = nums[:i] + nums[i+1:]\n            if dfs(remaining_nums, target - nums[i], path + str(nums[i]) + \"+\") or \\\n               dfs(remaining_nums, target + nums[i], path + str(nums[i]) + \"-\") or \\\n               dfs(remaining_nums, target * nums[i], path + str(nums[i]) + \"*\") or \\\n               (target % nums[i] == 0 and dfs(remaining_nums, target / nums[i], path + str(nums[i]) + \"/\")):\n                return True\n\n        return False\n\n    return dfs(nums, target, \"\")\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 3, 5, 7], 24\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 369, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to obtain the target value by performing arithmetic operations (+, -, *, /) on the elements of the list, using each element exactly once.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 24\n\n    The possible arithmetic operations are:\n    - 2 + 3 * 5 - 7 = 24\n    - 2 * 5 + 3 - 7 = 24\n\n    Therefore, the function should return True.\n\n    Note:\n    - The list nums will have at least 2 elements and at most 4 elements.\n    - The target value will be an integer.\n    \"\"\"\n\n    def dfs(nums, target, path):\n        if len(nums) == 1:\n            return path + str(nums[0]) == str(target)\n\n        for i in range(len(nums)):\n            remaining_nums = nums[:i] + nums[i+1:]\n            if dfs(remaining_nums, target - nums[i], path + str(nums[i]) + \"+\") or \\\n               dfs(remaining_nums, target + nums[i], path + str(nums[i]) + \"-\") or \\\n               dfs(remaining_nums, target * nums[i], path + str(nums[i]) + \"*\") or \\\n               (target % nums[i] == 0 and dfs(remaining_nums, target / nums[i], path + str(nums[i]) + \"/\")):\n                return True\n\n        return False\n\n    return dfs(nums, target, \"\")", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 3, 5, 7], 24", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n and a non-negative integer k, determine the number of k-digit positive integers such that the sum of their digits is equal to n.\n\n    Example:\n    n = 5\n    k = 2\n\n    The possible 2-digit positive integers with a sum of digits equal to 5 are:\n    - 14 (1 + 4 = 5)\n    - 23 (2 + 3 = 5)\n    - 32 (3 + 2 = 5)\n    - 41 (4 + 1 = 5)\n    - 50 (5 + 0 = 5)\n\n    Therefore, the function should return 5.\n\n    Note:\n    - The sum of digits of the positive integers can be greater than n.\n    - The number of digits k can be greater than the sum of digits n.\n    \"\"\"\n\n    def dfs(n, k, path):\n        if n == 0 and k == 0:\n            return 1\n\n        if n < 0 or k < 0:\n            return 0\n\n        count = 0\n        for i in range(10):\n            count += dfs(n - i, k - 1, path + str(i))\n\n        return count\n\n    return dfs(n, k, \"\")\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a positive integer n and a non-negative integer k.\n    \"\"\"\n    return 5, 2\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 369, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n and a non-negative integer k, determine the number of k-digit positive integers such that the sum of their digits is equal to n.\n\n    Example:\n    n = 5\n    k = 2\n\n    The possible 2-digit positive integers with a sum of digits equal to 5 are:\n    - 14 (1 + 4 = 5)\n    - 23 (2 + 3 = 5)\n    - 32 (3 + 2 = 5)\n    - 41 (4 + 1 = 5)\n    - 50 (5 + 0 = 5)\n\n    Therefore, the function should return 5.\n\n    Note:\n    - The sum of digits of the positive integers can be greater than n.\n    - The number of digits k can be greater than the sum of digits n.\n    \"\"\"\n\n    def dfs(n, k, path):\n        if n == 0 and k == 0:\n            return 1\n\n        if n < 0 or k < 0:\n            return 0\n\n        count = 0\n        for i in range(10):\n            count += dfs(n - i, k - 1, path + str(i))\n\n        return count\n\n    return dfs(n, k, \"\")", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a positive integer n and a non-negative integer k.\n    \"\"\"\n    return 5, 2", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if it is possible to form the target word by concatenating the words in the list in any order.\n\n    Example:\n    words = [\"good\", \"morning\", \"world\"]\n    target = \"goodmorningworld\"\n\n    The words can be concatenated in the following order:\n    - \"good\" + \"morning\" + \"world\" = \"goodmorningworld\"\n\n    Therefore, the function should return True.\n\n    Note:\n    - The words in the list will only contain lowercase letters.\n    - The target word will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(words, target, path):\n        if not target:\n            return True\n\n        for i in range(len(words)):\n            if target.startswith(words[i]):\n                remaining_words = words[:i] + words[i+1:]\n                if dfs(remaining_words, target[len(words[i]):], path + words[i]):\n                    return True\n\n        return False\n\n    return dfs(words, target, \"\")\n\ndef g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate a list of words and a target word.\n    \"\"\"\n    return [\"good\", \"morning\", \"world\"], \"goodmorningworld\"\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 369, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if it is possible to form the target word by concatenating the words in the list in any order.\n\n    Example:\n    words = [\"good\", \"morning\", \"world\"]\n    target = \"goodmorningworld\"\n\n    The words can be concatenated in the following order:\n    - \"good\" + \"morning\" + \"world\" = \"goodmorningworld\"\n\n    Therefore, the function should return True.\n\n    Note:\n    - The words in the list will only contain lowercase letters.\n    - The target word will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(words, target, path):\n        if not target:\n            return True\n\n        for i in range(len(words)):\n            if target.startswith(words[i]):\n                remaining_words = words[:i] + words[i+1:]\n                if dfs(remaining_words, target[len(words[i]):], path + words[i]):\n                    return True\n\n        return False\n\n    return dfs(words, target, \"\")", "solution_func": "def g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate a list of words and a target word.\n    \"\"\"\n    return [\"good\", \"morning\", \"world\"], \"goodmorningworld\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of unique combinations of numbers that add up to a target value.\n    You can use each number in the list multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations are:\n    - [1, 1, 1, 1]\n    - [1, 1, 2]\n    - [1, 3]\n    - [2, 2]\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def count_combinations(nums: List[int], target: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(nums, target - num)\n\n        return count\n\n    return count_combinations(nums, sum(nums))\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 369, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of unique combinations of numbers that add up to a target value.\n    You can use each number in the list multiple times.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations are:\n    - [1, 1, 1, 1]\n    - [1, 1, 2]\n    - [1, 3]\n    - [2, 2]\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def count_combinations(nums: List[int], target: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(nums, target - num)\n\n        return count\n\n    return count_combinations(nums, sum(nums))", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 370, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    There are two unique paths: 1 -> 3 -> 1 -> 1 -> 1 and 1 -> 1 -> 1 -> 3 -> 1.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 370, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    2\n\n    Explanation:\n    There are two unique paths: 1 -> 3 -> 1 -> 1 -> 1 and 1 -> 1 -> 1 -> 3 -> 1.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, convert each number to its binary representation and reverse the bits.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [1, 1, 3, 2, 5] (1 in binary is 1, 2 in binary is 10, 3 in binary is 11, 4 in binary is 100, 5 in binary is 101)\n\n    Hint: Use bit manipulation to reverse the bits of each number in the list.\n    \"\"\"\n    reversed_bits_list = []\n    for num in nums:\n        binary = bin(num)[2:]\n        reversed_bits = binary[::-1]\n        reversed_bits_list.append(int(reversed_bits, 2))\n    \n    return reversed_bits_list\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 1, 3, 2, 5]\n", "emb": null, "idx_generation": 370, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, convert each number to its binary representation and reverse the bits.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [1, 1, 3, 2, 5] (1 in binary is 1, 2 in binary is 10, 3 in binary is 11, 4 in binary is 100, 5 in binary is 101)\n\n    Hint: Use bit manipulation to reverse the bits of each number in the list.\n    \"\"\"\n    reversed_bits_list = []\n    for num in nums:\n        binary = bin(num)[2:]\n        reversed_bits = binary[::-1]\n        reversed_bits_list.append(int(reversed_bits, 2))\n    \n    return reversed_bits_list", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, remove all vowels from each word.\n\n    Example:\n    Input: [\"hello\", \"world\", \"python\"]\n    Output: [\"hll\", \"wrld\", \"pythn\"]\n\n    Hint: Use string manipulation to remove vowels from each word.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    no_vowels_list = []\n    for word in words:\n        no_vowels = ''.join([char for char in word if char.lower() not in vowels])\n        no_vowels_list.append(no_vowels)\n    \n    return no_vowels_list\n\ndef g():\n    return [\"hello\", \"world\", \"python\"]\n\nassert f(g()) == [\"hll\", \"wrld\", \"pythn\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, remove all vowels from each word.\n\n    Example:\n    Input: [\"hello\", \"world\", \"python\"]\n    Output: [\"hll\", \"wrld\", \"pythn\"]\n\n    Hint: Use string manipulation to remove vowels from each word.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    no_vowels_list = []\n    for word in words:\n        no_vowels = ''.join([char for char in word if char.lower() not in vowels])\n        no_vowels_list.append(no_vowels)\n    \n    return no_vowels_list", "solution_func": "def g():\n    return [\"hello\", \"world\", \"python\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort the words in increasing order of their lengths.\n\n    Example:\n    Input: [\"cat\", \"elephant\", \"dog\", \"tiger\"]\n    Output: [\"cat\", \"dog\", \"tiger\", \"elephant\"]\n\n    Hint: Use sorting algorithms to sort the list of words based on their lengths.\n    \"\"\"\n    sorted_words = sorted(words, key=len)\n    return sorted_words\n\ndef g():\n    return [\"cat\", \"elephant\", \"dog\", \"tiger\"]\n\nassert f(g()) == [\"cat\", \"dog\", \"tiger\", \"elephant\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort the words in increasing order of their lengths.\n\n    Example:\n    Input: [\"cat\", \"elephant\", \"dog\", \"tiger\"]\n    Output: [\"cat\", \"dog\", \"tiger\", \"elephant\"]\n\n    Hint: Use sorting algorithms to sort the list of words based on their lengths.\n    \"\"\"\n    sorted_words = sorted(words, key=len)\n    return sorted_words", "solution_func": "def g():\n    return [\"cat\", \"elephant\", \"dog\", \"tiger\"]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k items from a set of n items.\"\"\"\n    if k > n:\n        return False\n    if k == 0 or k == n:\n        return True\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n = 5, k = 3):\n    return f(n, k)\n\nassert f(g())\n", "emb": null, "idx_generation": 370, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k items from a set of n items.\"\"\"\n    if k > n:\n        return False\n    if k == 0 or k == n:\n        return True\n    return f(n-1, k-1) + f(n-1, k)", "solution_func": "def g(n = 5, k = 3):\n    return f(n, k)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Find the shortest path between two nodes in a graph.\"\"\"\n    n = len(graph)\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != 0:\n                dist[i][j] = graph[i][j]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist[0][n-1] != float('inf')\n\ndef g(graph = [[0, 1, 3, 0], [1, 0, 2, 0], [3, 2, 0, 1], [0, 0, 1, 0]]):\n    return f(graph)\n\nassert f(g())\n", "emb": null, "idx_generation": 370, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Find the shortest path between two nodes in a graph.\"\"\"\n    n = len(graph)\n    dist = [[float('inf') for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] != 0:\n                dist[i][j] = graph[i][j]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist[0][n-1] != float('inf')", "solution_func": "def g(graph = [[0, 1, 3, 0], [1, 0, 2, 0], [3, 2, 0, 1], [0, 0, 1, 0]]):\n    return f(graph)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find the longest common subsequence between two strings.\"\"\"\n    def lcs(s1, s2, m, n):\n        if m == 0 or n == 0:\n            return 0\n        if s1[m-1] == s2[n-1]:\n            return 1 + lcs(s1, s2, m-1, n-1)\n        else:\n            return max(lcs(s1, s2, m, n-1), lcs(s1, s2, m-1, n))\n    \n    return lcs(s, s[::-1], len(s), len(s)) == len(s)\n\ndef g(s = \"abcd\"):\n    return f(s)\n\nassert f(g())\n", "emb": null, "idx_generation": 370, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find the longest common subsequence between two strings.\"\"\"\n    def lcs(s1, s2, m, n):\n        if m == 0 or n == 0:\n            return 0\n        if s1[m-1] == s2[n-1]:\n            return 1 + lcs(s1, s2, m-1, n-1)\n        else:\n            return max(lcs(s1, s2, m, n-1), lcs(s1, s2, m-1, n))\n    \n    return lcs(s, s[::-1], len(s), len(s)) == len(s)", "solution_func": "def g(s = \"abcd\"):\n    return f(s)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Determine if it is possible to color n nodes of a graph with m colors such that no two adjacent nodes have the same color, given k pairs of nodes that must have different colors.\"\"\"\n    # function to check if coloring is valid\n    def is_valid(graph, color, node, c):\n        for neighbor in graph[node]:\n            if color[neighbor] == c:\n                return False\n        return True\n\n    # recursive function to color the graph\n    def color_graph(graph, color, node, m, k):\n        # base case: all nodes colored\n        if node == n:\n            return True\n\n        # try all possible colors for current node\n        for c in range(1, m+1):\n            # check if color is valid\n            if is_valid(graph, color, node, c):\n                # assign color to node\n                color[node] = c\n\n                # check if k pairs of nodes have different colors\n                if node < k:\n                    u, v = k_pairs[node]\n                    if color[u] == color[v]:\n                        color[node] = 0\n                        continue\n\n                # recursively color next node\n                if color_graph(graph, color, node+1, m, k):\n                    return True\n\n                # backtrack if coloring is not valid\n                color[node] = 0\n\n        return False\n\n    # create graph\n    graph = [[] for _ in range(n)]\n    k_pairs = []\n\n    # generate k pairs of nodes that must have different colors\n    for i in range(k):\n        u, v = i, i + k\n        graph[u].append(v)\n        graph[v].append(u)\n        k_pairs.append((u, v))\n\n    # initialize color array\n    color = [0] * n\n\n    # color the graph starting from the first node\n    return color_graph(graph, color, 0, m, k)\n\ndef g(n=4, m=3, k=2):\n    return n, m, k\n\nassert f(*g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 370, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Determine if it is possible to color n nodes of a graph with m colors such that no two adjacent nodes have the same color, given k pairs of nodes that must have different colors.\"\"\"\n    # function to check if coloring is valid\n    def is_valid(graph, color, node, c):\n        for neighbor in graph[node]:\n            if color[neighbor] == c:\n                return False\n        return True\n\n    # recursive function to color the graph\n    def color_graph(graph, color, node, m, k):\n        # base case: all nodes colored\n        if node == n:\n            return True\n\n        # try all possible colors for current node\n        for c in range(1, m+1):\n            # check if color is valid\n            if is_valid(graph, color, node, c):\n                # assign color to node\n                color[node] = c\n\n                # check if k pairs of nodes have different colors\n                if node < k:\n                    u, v = k_pairs[node]\n                    if color[u] == color[v]:\n                        color[node] = 0\n                        continue\n\n                # recursively color next node\n                if color_graph(graph, color, node+1, m, k):\n                    return True\n\n                # backtrack if coloring is not valid\n                color[node] = 0\n\n        return False\n\n    # create graph\n    graph = [[] for _ in range(n)]\n    k_pairs = []\n\n    # generate k pairs of nodes that must have different colors\n    for i in range(k):\n        u, v = i, i + k\n        graph[u].append(v)\n        graph[v].append(u)\n        k_pairs.append((u, v))\n\n    # initialize color array\n    color = [0] * n\n\n    # color the graph starting from the first node\n    return color_graph(graph, color, 0, m, k)", "solution_func": "def g(n=4, m=3, k=2):\n    return n, m, k", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list that add up to the target.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        sum = arr[left] + arr[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 4, 2, 7, 3, 9]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list that add up to the target.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        sum = arr[left] + arr[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g():\n    arr = [1, 4, 2, 7, 3, 9]\n    target = 10\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of ways to climb a staircase with n steps.\n    You can either climb 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n    prev1 = 1\n    prev2 = 1\n    for i in range(2, n+1):\n        current = prev1 + prev2\n        prev1 = prev2\n        prev2 = current\n    return prev2\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of ways to climb a staircase with n steps.\n    You can either climb 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n    prev1 = 1\n    prev2 = 1\n    for i in range(2, n+1):\n        current = prev1 + prev2\n        prev1 = prev2\n        prev2 = current\n    return prev2", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if s1 and s2 are anagrams of each other.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n    for c in count:\n        if c != 0:\n            return False\n    return True\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if s1 and s2 are anagrams of each other.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n    for c in count:\n        if c != 0:\n            return False\n    return True", "solution_func": "def g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=10, n=3) -> bool:\n    \"\"\"Find n distinct positive integers from nums that sum to target\"\"\"\n    from itertools import combinations\n    for comb in combinations(nums, n):\n        if sum(comb) == target:\n            return True\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 10, n = 3):\n    return nums\n\nassert f(g())\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=10, n=3) -> bool:\n    \"\"\"Find n distinct positive integers from nums that sum to target\"\"\"\n    from itertools import combinations\n    for comb in combinations(nums, n):\n        if sum(comb) == target:\n            return True\n    return False", "solution_func": "def g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 10, n = 3):\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=8) -> bool:\n    \"\"\"Find a path from the top-left corner to the bottom-right corner of the matrix, where the sum of the numbers along the path equals to target\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, path_sum):\n        if i >= m or j >= n:\n            return False\n        if path_sum + matrix[i][j] == target:\n            return True\n        return dfs(i+1, j, path_sum + matrix[i][j]) or dfs(i, j+1, path_sum + matrix[i][j])\n    \n    return dfs(0, 0, 0)\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 8):\n    return matrix\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target=8) -> bool:\n    \"\"\"Find a path from the top-left corner to the bottom-right corner of the matrix, where the sum of the numbers along the path equals to target\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, path_sum):\n        if i >= m or j >= n:\n            return False\n        if path_sum + matrix[i][j] == target:\n            return True\n        return dfs(i+1, j, path_sum + matrix[i][j]) or dfs(i, j+1, path_sum + matrix[i][j])\n    \n    return dfs(0, 0, 0)", "solution_func": "def g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 8):\n    return matrix", "map_ix": [0, 0, 1, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find the maximum subarray sum that is less than or equal to target\"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            if curr_sum <= target:\n                max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 10):\n    return nums\n\nassert f(g())\n", "emb": null, "idx_generation": 371, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find the maximum subarray sum that is less than or equal to target\"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            if curr_sum <= target:\n                max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 10):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Example:\n    s = \"racecar\"\n\n    The function should return True, since \"racecar\" is a palindrome.\n\n    s = \"hello\"\n\n    The function should return False, since \"hello\" is not a palindrome.\n    \"\"\"\n    s = s.lower()\n    s = ''.join(ch for ch in s if ch.isalnum())\n    \n    return s == s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 371, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Example:\n    s = \"racecar\"\n\n    The function should return True, since \"racecar\" is a palindrome.\n\n    s = \"hello\"\n\n    The function should return False, since \"hello\" is not a palindrome.\n    \"\"\"\n    s = s.lower()\n    s = ''.join(ch for ch in s if ch.isalnum())\n    \n    return s == s[::-1]", "solution_func": "def g():\n    s = \"A man, a plan, a canal: Panama\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a list containing the product of all the numbers except the current number at each index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The function should return [24, 12, 8, 6], since:\n    - The product of all the numbers except 1 is 24\n    - The product of all the numbers except 2 is 12\n    - The product of all the numbers except 3 is 8\n    - The product of all the numbers except 4 is 6\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 371, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a list containing the product of all the numbers except the current number at each index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The function should return [24, 12, 8, 6], since:\n    - The product of all the numbers except 1 is 24\n    - The product of all the numbers except 2 is 12\n    - The product of all the numbers except 3 is 8\n    - The product of all the numbers except 4 is 6\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n\n    return result", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The shortest path is: 1 -> 3 -> 1 -> 1 -> 1, which has a length of 5.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D memoization table to store the minimum distance to each cell\n    dist = [[float('inf')] * cols for _ in range(rows)]\n    dist[0][0] = grid[0][0]\n\n    # Create a queue to perform breadth-first search\n    queue = deque([(0, 0)])\n\n    # Define the possible directions to move\n    directions = [(1, 0), (0, 1), (1, 1)]\n\n    while queue:\n        row, col = queue.popleft()\n\n        # Explore all possible directions\n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n\n            # Check if the new cell is within the grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Calculate the distance to the new cell\n                new_dist = dist[row][col] + grid[nr][nc]\n\n                # Update the minimum distance if necessary\n                if new_dist < dist[nr][nc]:\n                    dist[nr][nc] = new_dist\n                    queue.append((nr, nc))\n\n    return dist[rows-1][cols-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 371, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The shortest path is: 1 -> 3 -> 1 -> 1 -> 1, which has a length of 5.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D memoization table to store the minimum distance to each cell\n    dist = [[float('inf')] * cols for _ in range(rows)]\n    dist[0][0] = grid[0][0]\n\n    # Create a queue to perform breadth-first search\n    queue = deque([(0, 0)])\n\n    # Define the possible directions to move\n    directions = [(1, 0), (0, 1), (1, 1)]\n\n    while queue:\n        row, col = queue.popleft()\n\n        # Explore all possible directions\n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n\n            # Check if the new cell is within the grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Calculate the distance to the new cell\n                new_dist = dist[row][col] + grid[nr][nc]\n\n                # Update the minimum distance if necessary\n                if new_dist < dist[nr][nc]:\n                    dist[nr][nc] = new_dist\n                    queue.append((nr, nc))\n\n    return dist[rows-1][cols-1]", "solution_func": "def g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n    return (nums, target)\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 371, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum, i.e. the sum of a contiguous subarray with the largest sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The subarray [4, -1, 2, 1] has the largest sum of 6)\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return ([-2, 1, -3, 4, -1, 2, 1, -5, 4],)\n\nassert f(*g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum, i.e. the sum of a contiguous subarray with the largest sum.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The subarray [4, -1, 2, 1] has the largest sum of 6)\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    return ([-2, 1, -3, 4, -1, 2, 1, -5, 4],)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (not necessarily contiguous).\n\n    Example:\n    Input: arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4 (The longest increasing subsequence is [2, 3, 7, 101])\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return ([10, 9, 2, 5, 3, 7, 101, 18],)\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (not necessarily contiguous).\n\n    Example:\n    Input: arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4 (The longest increasing subsequence is [2, 3, 7, 101])\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    return ([10, 9, 2, 5, 3, 7, 101, 18],)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find three numbers in the array that sum up to the target.\n    Return the indices of the three numbers.\n\n    Example:\n    Input: arr = [2, 7, 4, 0, 9, 5, 1, 3], target = 10\n    Output: [0, 2, 4] (The numbers at indices 0, 2, and 4, i.e. 2, 4, and 9, sum up to 10)\n\n    Hint: Use a combination of sorting and two-pointer technique to find the three numbers.\n    \"\"\"\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n\n            if current_sum == target:\n                return [i, left, right]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return []\n\ndef g():\n    return ([2, 7, 4, 0, 9, 5, 1, 3], 10)\n\nassert f(*g()) == [0, 2, 4]\n", "emb": null, "idx_generation": 372, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find three numbers in the array that sum up to the target.\n    Return the indices of the three numbers.\n\n    Example:\n    Input: arr = [2, 7, 4, 0, 9, 5, 1, 3], target = 10\n    Output: [0, 2, 4] (The numbers at indices 0, 2, and 4, i.e. 2, 4, and 9, sum up to 10)\n\n    Hint: Use a combination of sorting and two-pointer technique to find the three numbers.\n    \"\"\"\n\n    arr.sort()\n    n = len(arr)\n\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n\n            if current_sum == target:\n                return [i, left, right]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return []", "solution_func": "def g():\n    return ([2, 7, 4, 0, 9, 5, 1, 3], 10)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible combinations of k elements from a set of n elements.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n\n    Explanation:\n    There are 5 elements in the set: {1, 2, 3, 4, 5}.\n    We need to select 3 elements from the set.\n    The possible combinations are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    Hence, the output is 10.\n\n    Note: The order of the elements in a combination does not matter.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        \"\"\"\n        Helper function to calculate the factorial of a number.\n        \"\"\"\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    # Calculate the number of combinations using the formula C(n, k) = n! / (k! * (n-k)!)\n    num_combinations = factorial(n) // (factorial(k) * factorial(n - k))\n\n    return num_combinations\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible combinations of k elements from a set of n elements.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n\n    Explanation:\n    There are 5 elements in the set: {1, 2, 3, 4, 5}.\n    We need to select 3 elements from the set.\n    The possible combinations are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    Hence, the output is 10.\n\n    Note: The order of the elements in a combination does not matter.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        \"\"\"\n        Helper function to calculate the factorial of a number.\n        \"\"\"\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    # Calculate the number of combinations using the formula C(n, k) = n! / (k! * (n-k)!)\n    num_combinations = factorial(n) // (factorial(k) * factorial(n - k))\n\n    return num_combinations", "solution_func": "def g():\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of pairs with a bitwise XOR equal to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: 2\n\n    Explanation:\n    The pairs (2, 4) and (3, 5) have a bitwise XOR equal to 6.\n    Hence, the output is 2.\n\n    Note: Each pair should only be counted once, i.e., (2, 4) and (4, 2) should be considered as the same pair.\n    \"\"\"\n\n    count = 0\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            count += 1\n            complements.remove(num ^ target)\n        else:\n            complements.add(num)\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 372, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of pairs with a bitwise XOR equal to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: 2\n\n    Explanation:\n    The pairs (2, 4) and (3, 5) have a bitwise XOR equal to 6.\n    Hence, the output is 2.\n\n    Note: Each pair should only be counted once, i.e., (2, 4) and (4, 2) should be considered as the same pair.\n    \"\"\"\n\n    count = 0\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            count += 1\n            complements.remove(num ^ target)\n        else:\n            complements.add(num)\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 8, 2]\n    Output: 15\n\n    Explanation:\n    The maximum XOR value is achieved by the pair (10, 5), where 10 ^ 5 = 15.\n    Hence, the output is 15.\n\n    Note: The list can have duplicate elements, but each element should only be used once in a pair.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 8, 2]\n\nassert f(g()) == 15\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 8, 2]\n    Output: 15\n\n    Explanation:\n    The maximum XOR value is achieved by the pair (10, 5), where 10 ^ 5 = 15.\n    Hence, the output is 15.\n\n    Note: The list can have duplicate elements, but each element should only be used once in a pair.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 8, 2]", "map_ix": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all possible substrings of length k\n    that can be formed from s, in lexicographical order.\n\n    Example:\n    s = \"abcde\", k = 3\n    Output: [\"abc\", \"bcd\", \"cde\"]\n\n    s = \"hello\", k = 2\n    Output: [\"el\", \"he\", \"ll\", \"lo\"]\n\n    Note:\n    - The length of string s will be at least k.\n    - The length of string s will be at most 10^4.\n    - All characters in string s are lowercase letters.\n    \"\"\"\n    substrings = []\n    n = len(s)\n\n    for i in range(n - k + 1):\n        substrings.append(s[i:i+k])\n\n    return sorted(substrings)\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer k.\n    \"\"\"\n    return \"abcde\", 3\n\nassert f(*g()) == [\"abc\", \"bcd\", \"cde\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all possible substrings of length k\n    that can be formed from s, in lexicographical order.\n\n    Example:\n    s = \"abcde\", k = 3\n    Output: [\"abc\", \"bcd\", \"cde\"]\n\n    s = \"hello\", k = 2\n    Output: [\"el\", \"he\", \"ll\", \"lo\"]\n\n    Note:\n    - The length of string s will be at least k.\n    - The length of string s will be at most 10^4.\n    - All characters in string s are lowercase letters.\n    \"\"\"\n    substrings = []\n    n = len(s)\n\n    for i in range(n - k + 1):\n        substrings.append(s[i:i+k])\n\n    return sorted(substrings)", "solution_func": "def g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer k.\n    \"\"\"\n    return \"abcde\", 3", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each element is the product of all the\n    numbers in the original list except for the one at the corresponding index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n\n    nums = [2, 3, 5]\n    Output: [15, 10, 6]\n\n    Note:\n    - The length of the list will be at least 2.\n    - The length of the list will be at most 10^5.\n    - The numbers in the list will be in the range [-1000, 1000].\n    \"\"\"\n    n = len(nums)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n    result = []\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result.append(prefix_products[i] * suffix_products[i])\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers nums.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each element is the product of all the\n    numbers in the original list except for the one at the corresponding index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n\n    nums = [2, 3, 5]\n    Output: [15, 10, 6]\n\n    Note:\n    - The length of the list will be at least 2.\n    - The length of the list will be at most 10^5.\n    - The numbers in the list will be in the range [-1000, 1000].\n    \"\"\"\n    n = len(nums)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n    result = []\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result.append(prefix_products[i] * suffix_products[i])\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers nums.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum sum of a subsequence where the\n    subsequence contains no adjacent elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 9 (subsequence [1, 3, 5])\n\n    nums = [5, 1, 1, 5]\n    Output: 10 (subsequence [5, 5])\n\n    Note:\n    - The length of the list will be at least 1.\n    - The length of the list will be at most 10^4.\n    - The numbers in the list will be in the range [0, 10^4].\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of non-negative integers nums.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum sum of a subsequence where the\n    subsequence contains no adjacent elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 9 (subsequence [1, 3, 5])\n\n    nums = [5, 1, 1, 5]\n    Output: 10 (subsequence [5, 5])\n\n    Note:\n    - The length of the list will be at least 1.\n    - The length of the list will be at most 10^4.\n    - The numbers in the list will be in the range [0, 10^4].\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of non-negative integers nums.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return all unique combinations of nums where the\n    sum of the combinations is equal to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    f(nums, target) => [[2, 2, 3], [7]]\n\n    Explanation: In the given array, there are two unique combinations that sum up to the target 7: [2, 2, 3] and [7].\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n        for i in range(start, len(nums)):\n            backtrack(nums, target - nums[i], i, path + [nums[i]], result)\n\n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 372, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return all unique combinations of nums where the\n    sum of the combinations is equal to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    f(nums, target) => [[2, 2, 3], [7]]\n\n    Explanation: In the given array, there are two unique combinations that sum up to the target 7: [2, 2, 3] and [7].\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n        for i in range(start, len(nums)):\n            backtrack(nums, target - nums[i], i, path + [nums[i]], result)\n\n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return result", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that adds up to the target.\n\n    Example:\n    nums = [1, 5, 11, 5]\n    target = 16\n\n    f(nums, target) => True\n\n    Explanation: The subset [1, 5, 5, 5] adds up to the target 16.\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        if helper(nums, target - nums[index], index + 1):\n            return True\n        return helper(nums, target, index + 1)\n\n    return helper(nums, target, 0)\n\ndef g():\n    nums = [1, 5, 11, 5]\n    target = 16\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that adds up to the target.\n\n    Example:\n    nums = [1, 5, 11, 5]\n    target = 16\n\n    f(nums, target) => True\n\n    Explanation: The subset [1, 5, 5, 5] adds up to the target 16.\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        if helper(nums, target - nums[index], index + 1):\n            return True\n        return helper(nums, target, index + 1)\n\n    return helper(nums, target, 0)", "solution_func": "def g():\n    nums = [1, 5, 11, 5]\n    target = 16\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given a number of nodes n and a list of edges between nodes, find the maximum number of edges you can remove from the graph such that after removing the edges, the graph is still connected.\n\n    Example:\n    n = 5\n    edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]\n\n    f(n, edges) => 1\n\n    Explanation: By removing the edge (1, 5), the graph is still connected.\n\n    \"\"\"\n\n    def dfs(node: int, parent: int) -> int:\n        nonlocal max_edges_removed\n\n        # Count the number of nodes in the subtree\n        count = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                count += dfs(neighbor, node)\n\n        # If the number of nodes in the subtree is even, remove the edge\n        if count % 2 == 0 and parent != -1:\n            max_edges_removed += 1\n\n        return count\n\n    max_edges_removed = 0\n\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Perform the depth-first search\n    dfs(1, -1)\n\n    return max_edges_removed\n\ndef g():\n    n = 5\n    edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]\n    return n, edges\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 373, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given a number of nodes n and a list of edges between nodes, find the maximum number of edges you can remove from the graph such that after removing the edges, the graph is still connected.\n\n    Example:\n    n = 5\n    edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]\n\n    f(n, edges) => 1\n\n    Explanation: By removing the edge (1, 5), the graph is still connected.\n\n    \"\"\"\n\n    def dfs(node: int, parent: int) -> int:\n        nonlocal max_edges_removed\n\n        # Count the number of nodes in the subtree\n        count = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                count += dfs(neighbor, node)\n\n        # If the number of nodes in the subtree is even, remove the edge\n        if count % 2 == 0 and parent != -1:\n            max_edges_removed += 1\n\n        return count\n\n    max_edges_removed = 0\n\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Perform the depth-first search\n    dfs(1, -1)\n\n    return max_edges_removed", "solution_func": "def g():\n    n = 5\n    edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]\n    return n, edges", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    Example:\n    s = \"babad\"\n\n    f(s) => \"bab\"\n\n    Explanation: The longest palindromic substring in s is \"bab\".\n    \"\"\"\n\n    def expand_center(s: str, left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    start = 0\n    end = 0\n\n    for i in range(len(s)):\n        len1 = expand_center(s, i, i)\n        len2 = expand_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n\n    return s[start:end+1]\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(*g()) == \"bab\"\n", "emb": null, "idx_generation": 373, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    Example:\n    s = \"babad\"\n\n    f(s) => \"bab\"\n\n    Explanation: The longest palindromic substring in s is \"bab\".\n    \"\"\"\n\n    def expand_center(s: str, left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    start = 0\n    end = 0\n\n    for i in range(len(s)):\n        len1 = expand_center(s, i, i)\n        len2 = expand_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n\n    return s[start:end+1]", "solution_func": "def g():\n    s = \"babad\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle with n rows.\n\n    Pascal's triangle is a triangular array of binomial coefficients. Each number is the sum of the two numbers above it.\n    The first row is [1], and each subsequent row is constructed by adding the adjacent numbers from the previous row.\n\n    Return the Pascal's triangle as a 2D list.\n\n    Example:\n    Input: n = 5\n    Output: [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n    \"\"\"\n    triangle = []\n\n    for i in range(n):\n        row = [1] * (i + 1)\n\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n\n        triangle.append(row)\n\n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [\n    [1],\n    [1, 1],\n    [1, 2, 1],\n    [1, 3, 3, 1],\n    [1, 4, 6, 4, 1]\n]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle with n rows.\n\n    Pascal's triangle is a triangular array of binomial coefficients. Each number is the sum of the two numbers above it.\n    The first row is [1], and each subsequent row is constructed by adding the adjacent numbers from the previous row.\n\n    Return the Pascal's triangle as a 2D list.\n\n    Example:\n    Input: n = 5\n    Output: [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n    \"\"\"\n    triangle = []\n\n    for i in range(n):\n        row = [1] * (i + 1)\n\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n\n        triangle.append(row)\n\n    return triangle", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones.\n    The sequence starts with 0 and 1.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th Fibonacci number is 8.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones.\n    The sequence starts with 0 and 1.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th Fibonacci number is 8.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]", "solution_func": "def g():\n    n = 6\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest consecutive subsequence.\n\n    A consecutive subsequence is a sequence of numbers where each number appears exactly once and the difference between\n    consecutive numbers is exactly 1.\n\n    Return the length of the longest consecutive subsequence.\n\n    Example:\n    Input: nums = [100, 4, 200, 1, 3, 2]\n    Output: 4\n    Explanation: The longest consecutive subsequence is [1, 2, 3, 4], which has a length of 4.\n    \"\"\"\n    num_set = set(nums)\n    longest_streak = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n\ndef g():\n    nums = [100, 4, 200, 1, 3, 2]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest consecutive subsequence.\n\n    A consecutive subsequence is a sequence of numbers where each number appears exactly once and the difference between\n    consecutive numbers is exactly 1.\n\n    Return the length of the longest consecutive subsequence.\n\n    Example:\n    Input: nums = [100, 4, 200, 1, 3, 2]\n    Output: 4\n    Explanation: The longest consecutive subsequence is [1, 2, 3, 4], which has a length of 4.\n    \"\"\"\n    num_set = set(nums)\n    longest_streak = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak", "solution_func": "def g():\n    nums = [100, 4, 200, 1, 3, 2]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the value of the binomial coefficient C(n, k).\n\n    Example:\n    n = 5, k = 2\n\n    The binomial coefficient C(5, 2) is calculated as (5!)/(2!*(5-2)!) = 10.\n\n    Therefore, the function should return 10.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        return f(n-1, k-1) + f(n-1, k)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two random integers n and k.\n    \"\"\"\n    return [5, 2]\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the value of the binomial coefficient C(n, k).\n\n    Example:\n    n = 5, k = 2\n\n    The binomial coefficient C(5, 2) is calculated as (5!)/(2!*(5-2)!) = 10.\n\n    Therefore, the function should return 10.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        return f(n-1, k-1) + f(n-1, k)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate two random integers n and k.\n    \"\"\"\n    return [5, 2]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The pair of numbers that add up to the target value 9 is [2, 7].\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return [num_map[complement], i]\n        \n        num_map[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [[2, 7, 11, 15], 9]\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 373, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The pair of numbers that add up to the target value 9 is [2, 7].\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return [num_map[complement], i]\n        \n        num_map[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [[2, 7, 11, 15], 9]", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct subsequences that sum up to zero.\n\n    Example:\n    nums = [1, -1, 1, -1, 1]\n\n    The distinct subsequences that sum up to zero are [1, -1], [-1, 1], and [1, -1, 1, -1].\n\n    Therefore, the function should return 3.\n    \"\"\"\n    prefix_sum = 0\n    seen_sum = {}\n    count = 0\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == 0:\n            count += 1\n        \n        if prefix_sum in seen_sum:\n            count += seen_sum[prefix_sum]\n        \n        if prefix_sum in seen_sum:\n            seen_sum[prefix_sum] += 1\n        else:\n            seen_sum[prefix_sum] = 1\n    \n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -1, 1, -1, 1]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 373, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct subsequences that sum up to zero.\n\n    Example:\n    nums = [1, -1, 1, -1, 1]\n\n    The distinct subsequences that sum up to zero are [1, -1], [-1, 1], and [1, -1, 1, -1].\n\n    Therefore, the function should return 3.\n    \"\"\"\n    prefix_sum = 0\n    seen_sum = {}\n    count = 0\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == 0:\n            count += 1\n        \n        if prefix_sum in seen_sum:\n            count += seen_sum[prefix_sum]\n        \n        if prefix_sum in seen_sum:\n            seen_sum[prefix_sum] += 1\n        else:\n            seen_sum[prefix_sum] = 1\n    \n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -1, 1, -1, 1]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the minimum difference between any two elements in the list.\n\n    Example:\n    nums = [1, 5, 9, 2, 12, 7]\n    Output: 1\n    Explanation: The minimum difference can be obtained by subtracting 7 and 9.\n\n    \"\"\"\n    nums.sort()\n    min_diff = float('inf')\n    for i in range(len(nums) - 1):\n        diff = nums[i + 1] - nums[i]\n        min_diff = min(min_diff, diff)\n    return min_diff\n\ndef g():\n    return [1, 5, 9, 2, 12, 7]\n\nassert f(g()) == 1\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 373, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the minimum difference between any two elements in the list.\n\n    Example:\n    nums = [1, 5, 9, 2, 12, 7]\n    Output: 1\n    Explanation: The minimum difference can be obtained by subtracting 7 and 9.\n\n    \"\"\"\n    nums.sort()\n    min_diff = float('inf')\n    for i in range(len(nums) - 1):\n        diff = nums[i + 1] - nums[i]\n        min_diff = min(min_diff, diff)\n    return min_diff", "solution_func": "def g():\n    return [1, 5, 9, 2, 12, 7]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the shortest path between two nodes.\n    Return the length of the shortest path, or -1 if no path exists.\n\n    Sample input:\n    [\n        [1, 2],\n        [0, 3, 4],\n        [0, 5, 6],\n        [1, 7],\n        [1],\n        [2],\n        [2],\n        [3]\n    ]\n\n    Sample output:\n    3\n\n    Explanation:\n    The shortest path from node 0 to node 7 is [0, 1, 3, 7], with a length of 3.\n    \"\"\"\n    start = 0\n    end = 7\n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        node, distance = queue.pop(0)\n        \n        if node == end:\n            return distance\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            queue.append((neighbor, distance + 1))\n    \n    return -1\n\ndef g():\n    return [\n        [1, 2],\n        [0, 3, 4],\n        [0, 5, 6],\n        [1, 7],\n        [1],\n        [2],\n        [2],\n        [3]\n    ]\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 374, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the shortest path between two nodes.\n    Return the length of the shortest path, or -1 if no path exists.\n\n    Sample input:\n    [\n        [1, 2],\n        [0, 3, 4],\n        [0, 5, 6],\n        [1, 7],\n        [1],\n        [2],\n        [2],\n        [3]\n    ]\n\n    Sample output:\n    3\n\n    Explanation:\n    The shortest path from node 0 to node 7 is [0, 1, 3, 7], with a length of 3.\n    \"\"\"\n    start = 0\n    end = 7\n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        node, distance = queue.pop(0)\n        \n        if node == end:\n            return distance\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            queue.append((neighbor, distance + 1))\n    \n    return -1", "solution_func": "def g():\n    return [\n        [1, 2],\n        [0, 3, 4],\n        [0, 5, 6],\n        [1, 7],\n        [1],\n        [2],\n        [2],\n        [3]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list, find a path from the start node to the end node with the maximum sum of weights.\n    Return the path as a list of nodes.\n\n    Sample input:\n    [\n        [(1, 2), (2, 3)],\n        [(3, 4), (4, 5)],\n        [(4, 6)],\n        [(5, 7)],\n        [(6, 8)],\n        [(7, 9)],\n        [(8, 10)],\n        [(9, 11)],\n        [(10, 12)],\n        [(11, 13)],\n        [(12, 14)],\n        []\n    ]\n\n    Sample output:\n    [0, 1, 3, 5, 7, 9, 11, 13]\n\n    Explanation:\n    The path with the maximum sum of weights from node 0 to node 13 is [0, 1, 3, 5, 7, 9, 11, 13], with a sum of 56.\n    \"\"\"\n    dp = [float('-inf')] * len(graph)\n    dp[start] = 0\n    parent = [-1] * len(graph)\n    \n    for i in range(start, end + 1):\n        for neighbor, weight in graph[i]:\n            if dp[i] + weight > dp[neighbor]:\n                dp[neighbor] = dp[i] + weight\n                parent[neighbor] = i\n    \n    path = []\n    node = end\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    \n    return path[::-1]\n\ndef g():\n    return [\n        [(1, 2), (2, 3)],\n        [(3, 4), (4, 5)],\n        [(4, 6)],\n        [(5, 7)],\n        [(6, 8)],\n        [(7, 9)],\n        [(8, 10)],\n        [(9, 11)],\n        [(10, 12)],\n        [(11, 13)],\n        [(12, 14)],\n        []\n    ]\n\nassert f(g(), start=0, end=13) == [0, 1, 3, 5, 7, 9, 11, 13]\n", "emb": null, "idx_generation": 374, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list, find a path from the start node to the end node with the maximum sum of weights.\n    Return the path as a list of nodes.\n\n    Sample input:\n    [\n        [(1, 2), (2, 3)],\n        [(3, 4), (4, 5)],\n        [(4, 6)],\n        [(5, 7)],\n        [(6, 8)],\n        [(7, 9)],\n        [(8, 10)],\n        [(9, 11)],\n        [(10, 12)],\n        [(11, 13)],\n        [(12, 14)],\n        []\n    ]\n\n    Sample output:\n    [0, 1, 3, 5, 7, 9, 11, 13]\n\n    Explanation:\n    The path with the maximum sum of weights from node 0 to node 13 is [0, 1, 3, 5, 7, 9, 11, 13], with a sum of 56.\n    \"\"\"\n    dp = [float('-inf')] * len(graph)\n    dp[start] = 0\n    parent = [-1] * len(graph)\n    \n    for i in range(start, end + 1):\n        for neighbor, weight in graph[i]:\n            if dp[i] + weight > dp[neighbor]:\n                dp[neighbor] = dp[i] + weight\n                parent[neighbor] = i\n    \n    path = []\n    node = end\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    \n    return path[::-1]", "solution_func": "def g():\n    return [\n        [(1, 2), (2, 3)],\n        [(3, 4), (4, 5)],\n        [(4, 6)],\n        [(5, 7)],\n        [(6, 8)],\n        [(7, 9)],\n        [(8, 10)],\n        [(9, 11)],\n        [(10, 12)],\n        [(11, 13)],\n        [(12, 14)],\n        []\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest palindrome that can be formed using the characters in the grid.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    You can only form a palindrome using characters from the same row or the same column in the grid.\n\n    Sample input:\n    [\n        ['A', 'B', 'C'],\n        ['B', 'D', 'E'],\n        ['C', 'E', 'F']\n    ]\n\n    Sample output:\n    5\n\n    Explanation:\n    The longest palindrome that can be formed using the characters in the grid is 'ABCDE', with a length of 5.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row_counts = [0] * rows\n    col_counts = [0] * cols\n    \n    for i in range(rows):\n        for j in range(cols):\n            row_counts[i] += grid[i][j]\n            col_counts[j] += grid[i][j]\n    \n    palindrome_length = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if row_counts[i] % 2 != 0:\n                palindrome_length += 1\n                row_counts[i] -= 1\n            if col_counts[j] % 2 != 0:\n                palindrome_length += 1\n                col_counts[j] -= 1\n    \n    return palindrome_length\n\ndef g():\n    return [\n        ['A', 'B', 'C'],\n        ['B', 'D', 'E'],\n        ['C', 'E', 'F']\n    ]\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 374, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest palindrome that can be formed using the characters in the grid.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    You can only form a palindrome using characters from the same row or the same column in the grid.\n\n    Sample input:\n    [\n        ['A', 'B', 'C'],\n        ['B', 'D', 'E'],\n        ['C', 'E', 'F']\n    ]\n\n    Sample output:\n    5\n\n    Explanation:\n    The longest palindrome that can be formed using the characters in the grid is 'ABCDE', with a length of 5.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row_counts = [0] * rows\n    col_counts = [0] * cols\n    \n    for i in range(rows):\n        for j in range(cols):\n            row_counts[i] += grid[i][j]\n            col_counts[j] += grid[i][j]\n    \n    palindrome_length = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if row_counts[i] % 2 != 0:\n                palindrome_length += 1\n                row_counts[i] -= 1\n            if col_counts[j] % 2 != 0:\n                palindrome_length += 1\n                col_counts[j] -= 1\n    \n    return palindrome_length", "solution_func": "def g():\n    return [\n        ['A', 'B', 'C'],\n        ['B', 'D', 'E'],\n        ['C', 'E', 'F']\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix)\n\n        temp_max = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp_max ^ prefix in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(*g()) == 28\n\n", "emb": null, "idx_generation": 374, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix = num & mask\n            prefix_set.add(prefix)\n\n        temp_max = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp_max ^ prefix in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two distinct numbers in the list whose sum is equal to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 10, 1], target = 11\n    Output: [1, 2]\n\n    Explanation: The numbers at indices 1 and 2 in the list are 7 and 2, and their sum is equal to the target 11.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [4, 7, 2, 9, 10, 1]\n    target = 11\n    return nums, target\n\nassert f(*g()) == [1, 2]\n\n", "emb": null, "idx_generation": 374, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two distinct numbers in the list whose sum is equal to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 10, 1], target = 11\n    Output: [1, 2]\n\n    Explanation: The numbers at indices 1 and 2 in the list are 7 and 2, and their sum is equal to the target 11.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [4, 7, 2, 9, 10, 1]\n    target = 11\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum sum of any contiguous subarray of size k.\n\n    Example:\n    Input: nums = [2, 1, 5, 1, 3, 2], k = 3\n    Output: 9\n\n    Explanation: The maximum sum of a subarray of size 3 is obtained by adding the numbers at indices 2, 3, and 4, which gives 9.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    left = 0\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        if right - left + 1 == k:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= nums[left]\n            left += 1\n\n    return max_sum\n\ndef g():\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 9\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 374, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum sum of any contiguous subarray of size k.\n\n    Example:\n    Input: nums = [2, 1, 5, 1, 3, 2], k = 3\n    Output: 9\n\n    Explanation: The maximum sum of a subarray of size 3 is obtained by adding the numbers at indices 2, 3, and 4, which gives 9.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    left = 0\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        if right - left + 1 == k:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= nums[left]\n            left += 1\n\n    return max_sum", "solution_func": "def g():\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the length of the longest path from the top-left corner to the bottom-right corner,\n    without passing through any walls. You can only move down or right.\n\n    Return the length of the longest path.\n\n    Example:\n    grid = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    The longest path from the top-left corner to the bottom-right corner without passing through any walls is highlighted below:\n\n    0 -> 0 -> 0 -> 0\n              |\n    0 -> 0     0\n        |\n    0    0 -> 0 -> 0\n\n    Therefore, the function should return 8.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + 1\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n\n    return dp[m-1][n-1]\n\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 374, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the length of the longest path from the top-left corner to the bottom-right corner,\n    without passing through any walls. You can only move down or right.\n\n    Return the length of the longest path.\n\n    Example:\n    grid = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    The longest path from the top-left corner to the bottom-right corner without passing through any walls is highlighted below:\n\n    0 -> 0 -> 0 -> 0\n              |\n    0 -> 0     0\n        |\n    0    0 -> 0 -> 0\n\n    Therefore, the function should return 8.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + 1\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix in-place by 90 degrees (clockwise).\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    After rotating the matrix by 90 degrees clockwise, it becomes:\n\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Therefore, the function should return:\n\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix in-place by 90 degrees (clockwise).\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    After rotating the matrix by 90 degrees clockwise, it becomes:\n\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Therefore, the function should return:\n\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the minimum number of bombs required to destroy all the walls in the grid.\n    Each bomb can destroy all the walls in its row and column simultaneously.\n\n    Return the minimum number of bombs required.\n\n    Example:\n    grid = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    In this example, the minimum number of bombs required to destroy all the walls is 2.\n    One possible way to do it is by placing bombs in the second row and second column:\n\n    0    0    0    0\n    0    0    1    0\n    0    0    0    0\n    0    0    0    0\n\n    Therefore, the function should return 2.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n                cols[j] += 1\n\n    max_bombs = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                max_bombs = max(max_bombs, rows[i] + cols[j] - 1)\n\n    return max_bombs\n\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 374, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the minimum number of bombs required to destroy all the walls in the grid.\n    Each bomb can destroy all the walls in its row and column simultaneously.\n\n    Return the minimum number of bombs required.\n\n    Example:\n    grid = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    In this example, the minimum number of bombs required to destroy all the walls is 2.\n    One possible way to do it is by placing bombs in the second row and second column:\n\n    0    0    0    0\n    0    0    1    0\n    0    0    0    0\n    0    0    0    0\n\n    Therefore, the function should return 2.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n                cols[j] += 1\n\n    max_bombs = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                max_bombs = max(max_bombs, rows[i] + cols[j] - 1)\n\n    return max_bombs", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [1, 1, 1, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value, determine if there exists a pair of numbers in the list that add up to the target value.\n\n    Example:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n\n    The pair of numbers (2, 7) add up to the target value 9.\n\n    Therefore, the function should return True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 374, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value, determine if there exists a pair of numbers in the list that add up to the target value.\n\n    Example:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n\n    The pair of numbers (2, 7) add up to the target value 9.\n\n    Therefore, the function should return True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that is a prime number.\n    \"\"\"\n    return 17\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n that is a prime number.\n    \"\"\"\n    return 17", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n for finding the nth Fibonacci number.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n-1) + f(n-2)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n for finding the nth Fibonacci number.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all even numbers less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n % 2 != 0:\n        n -= 1\n    return n * (n + 2) // 4\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n for finding the sum of all even numbers less than or equal to n.\n    \"\"\"\n    return 10\n\nassert f(g()) == 30\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all even numbers less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n % 2 != 0:\n        n -= 1\n    return n * (n + 2) // 4", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n for finding the sum of all even numbers less than or equal to n.\n    \"\"\"\n    return 10", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the nth Fibonacci number using recursion.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the number of ways to arrange n items in a row if there are k groups of identical items.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n <= 1:\n            return 1\n        return n * factorial(n-1)\n    \n    def count_arrangements(n: int, groups: List[int]) -> int:\n        total = factorial(n)\n        for group in groups:\n            total //= factorial(group)\n        return total\n    \n    return count_arrangements(n, [2, 3])\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the number of ways to arrange n items in a row if there are k groups of identical items.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n <= 1:\n            return 1\n        return n * factorial(n-1)\n    \n    def count_arrangements(n: int, groups: List[int]) -> int:\n        total = factorial(n)\n        for group in groups:\n            total //= factorial(group)\n        return total\n    \n    return count_arrangements(n, [2, 3])", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def count_paths(i: int, j: int) -> int:\n        if i == m-1 and j == n-1:\n            return 1\n        if i >= m or j >= n:\n            return 0\n        return count_paths(i+1, j) + count_paths(i, j+1)\n    \n    return count_paths(0, 0)\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def count_paths(i: int, j: int) -> int:\n        if i == m-1 and j == n-1:\n            return 1\n        if i >= m or j >= n:\n            return 0\n        return count_paths(i+1, j) + count_paths(i, j+1)\n    \n    return count_paths(0, 0)", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique combinations of the integers, where each combination is sorted in ascending order.\n\n    Example:\n    nums = [2, 1, 3]\n\n    f(nums) => [[1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Explanation: The unique combinations of the integers in nums are [1, 2], [1, 3], [2, 3], [1, 2, 3]. All combinations are sorted in ascending order.\n\n    \"\"\"\n\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i+1, path)\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [])\n    return result\n\ndef g() -> List[int]:\n    return [2, 1, 3]\n\nassert f(g()) == [[1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 375, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique combinations of the integers, where each combination is sorted in ascending order.\n\n    Example:\n    nums = [2, 1, 3]\n\n    f(nums) => [[1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Explanation: The unique combinations of the integers in nums are [1, 2], [1, 3], [2, 3], [1, 2, 3]. All combinations are sorted in ascending order.\n\n    \"\"\"\n\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i+1, path)\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [])\n    return result", "solution_func": "def g() -> List[int]:\n    return [2, 1, 3]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, return a list of all unique combinations of the integers that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    f(nums, target) => [[2, 2, 3], [7]]\n\n    Explanation: The unique combinations of the integers in nums that sum up to the target 7 are [2, 2, 3] and [7].\n\n    \"\"\"\n\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i, path, target-nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, return a list of all unique combinations of the integers that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    f(nums, target) => [[2, 2, 3], [7]]\n\n    Explanation: The unique combinations of the integers in nums that sum up to the target 7 are [2, 2, 3] and [7].\n\n    \"\"\"\n\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i, path, target-nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], target)\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    return [2, 3, 6, 7], 7", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique permutations of the integers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    f(nums) => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation: The unique permutations of the integers in nums are [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]].\n\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start+1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    result = []\n    backtrack(0)\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3]\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 375, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return a list of all unique permutations of the integers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    f(nums) => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation: The unique permutations of the integers in nums are [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]].\n\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start+1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    result = []\n    backtrack(0)\n    return result", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum distance between any two points.\n\n    Example:\n    points = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    Output: 2\n    Explanation: The minimum distance is between points [3, 4] and [5, 6], which is sqrt(2^2 + 2^2) = 2.\n\n    \"\"\"\n    import math\n\n    def distance(p1: List[int], p2: List[int]) -> float:\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_distance:\n                min_distance = dist\n\n    return min_distance\n\ndef g():\n    return [[1, 2], [3, 4], [5, 6], [7, 8]]\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 375, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum distance between any two points.\n\n    Example:\n    points = [[1, 2], [3, 4], [5, 6], [7, 8]]\n    Output: 2\n    Explanation: The minimum distance is between points [3, 4] and [5, 6], which is sqrt(2^2 + 2^2) = 2.\n\n    \"\"\"\n    import math\n\n    def distance(p1: List[int], p2: List[int]) -> float:\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_distance:\n                min_distance = dist\n\n    return min_distance", "solution_func": "def g():\n    return [[1, 2], [3, 4], [5, 6], [7, 8]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a submatrix such that:\n        - The sum of all the elements in the submatrix is even.\n        - The number of even elements in the submatrix is greater than the number of odd elements.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    submatrix_sum = 0\n                    count_even = 0\n                    count_odd = 0\n                    for r in range(i, x + 1):\n                        for c in range(j, y + 1):\n                            submatrix_sum += matrix[r][c]\n                            if matrix[r][c] % 2 == 0:\n                                count_even += 1\n                            else:\n                                count_odd += 1\n                    if submatrix_sum % 2 == 0 and count_even > count_odd:\n                        return True\n    return False\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 376, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a submatrix such that:\n        - The sum of all the elements in the submatrix is even.\n        - The number of even elements in the submatrix is greater than the number of odd elements.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    submatrix_sum = 0\n                    count_even = 0\n                    count_odd = 0\n                    for r in range(i, x + 1):\n                        for c in range(j, y + 1):\n                            submatrix_sum += matrix[r][c]\n                            if matrix[r][c] % 2 == 0:\n                                count_even += 1\n                            else:\n                                count_odd += 1\n                    if submatrix_sum % 2 == 0 and count_even > count_odd:\n                        return True\n    return False", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 1, 0, 1, 0, 0, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list that contains only the words that can be formed by rearranging the letters of other words in the list.\n    \"\"\"\n    valid_words = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j and sorted(words[i]) == sorted(words[j]):\n                valid_words.append(words[i])\n                break\n    return valid_words\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [\"eat\", \"tea\", \"ate\"]\n", "emb": null, "idx_generation": 376, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list that contains only the words that can be formed by rearranging the letters of other words in the list.\n    \"\"\"\n    valid_words = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j and sorted(words[i]) == sorted(words[j]):\n                valid_words.append(words[i])\n                break\n    return valid_words", "solution_func": "def g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest subarray that has the same number of even and odd elements.\n    \"\"\"\n    prefix_sum = 0\n    max_length = 0\n    prefix_sums = {0: -1}\n    count_even = 0\n    count_odd = 0\n\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n        diff = count_even - count_odd\n\n        if diff in prefix_sums:\n            length = i - prefix_sums[diff]\n            max_length = max(max_length, length)\n        else:\n            prefix_sums[diff] = i\n\n    return max_length\n\ndef g():\n    nums = [2, 2, 1, 7, 5, 3, 8, 6, 4]\n    return nums\n\nassert f(g()) == 8\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 376, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest subarray that has the same number of even and odd elements.\n    \"\"\"\n    prefix_sum = 0\n    max_length = 0\n    prefix_sums = {0: -1}\n    count_even = 0\n    count_odd = 0\n\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n        diff = count_even - count_odd\n\n        if diff in prefix_sums:\n            length = i - prefix_sums[diff]\n            max_length = max(max_length, length)\n        else:\n            prefix_sums[diff] = i\n\n    return max_length", "solution_func": "def g():\n    nums = [2, 2, 1, 7, 5, 3, 8, 6, 4]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n\n    Example:\n    arr = [4, 2, 7, 1, 5]\n    output: [1, 2, 4, 5, 7]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g(arr=[4, 2, 7, 1, 5]):\n    return arr\n\nassert f(g()) == [1, 2, 4, 5, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\n\n    Example:\n    arr = [4, 2, 7, 1, 5]\n    output: [1, 2, 4, 5, 7]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr", "solution_func": "def g(arr=[4, 2, 7, 1, 5]):\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Generate all possible permutations of the numbers from 1 to n.\n\n    Example:\n    n = 3\n    output: [['1', '2', '3'], ['1', '3', '2'], ['2', '1', '3'], ['2', '3', '1'], ['3', '1', '2'], ['3', '2', '1']]\n    \"\"\"\n    def backtrack(nums, path, visited):\n        if len(path) == n:\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            if not visited[i]:\n                visited[i] = True\n                backtrack(nums, path + [nums[i]], visited)\n                visited[i] = False\n\n    result = []\n    nums = [str(i) for i in range(1, n+1)]\n    visited = [False] * n\n    backtrack(nums, [], visited)\n    return result\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [['1', '2', '3'], ['1', '3', '2'], ['2', '1', '3'], ['2', '3', '1'], ['3', '1', '2'], ['3', '2', '1']]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Generate all possible permutations of the numbers from 1 to n.\n\n    Example:\n    n = 3\n    output: [['1', '2', '3'], ['1', '3', '2'], ['2', '1', '3'], ['2', '3', '1'], ['3', '1', '2'], ['3', '2', '1']]\n    \"\"\"\n    def backtrack(nums, path, visited):\n        if len(path) == n:\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            if not visited[i]:\n                visited[i] = True\n                backtrack(nums, path + [nums[i]], visited)\n                visited[i] = False\n\n    result = []\n    nums = [str(i) for i in range(1, n+1)]\n    visited = [False] * n\n    backtrack(nums, [], visited)\n    return result", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nfrom typing import Optional\n\ndef f(root: Optional[TreeNode]) -> int:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n    - The left subtree of a node contains only nodes with keys less than the node's key.\n    - The right subtree of a node contains only nodes with keys greater than the node's key.\n    - Both the left and right subtrees must also be binary search trees.\n\n    Example:\n    Input: [2,1,3]\n         2\n        / \\\n       1   3\n    Output: True\n\n    Input: [5,1,4,null,null,3,6]\n         5\n        / \\\n       1   4\n          / \\\n         3   6\n    Output: False\n    \"\"\"\n    def isValidBSTUtil(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return (isValidBSTUtil(node.left, min_val, node.val) and\n                isValidBSTUtil(node.right, node.val, max_val))\n\n    return isValidBSTUtil(root, float('-inf'), float('inf'))\n\ndef g():\n    \"\"\"\n    Create the following binary search tree (BST):\n         5\n        / \\\n       1   4\n          / \\\n         3   6\n    \"\"\"\n    root = TreeNode(5)\n    root.left = TreeNode(1)\n    root.right = TreeNode(4)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(6)\n    return root\n\nassert f(g()) == False\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nfrom typing import Optional\n\ndef f(root: Optional[TreeNode]) -> int:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n    - The left subtree of a node contains only nodes with keys less than the node's key.\n    - The right subtree of a node contains only nodes with keys greater than the node's key.\n    - Both the left and right subtrees must also be binary search trees.\n\n    Example:\n    Input: [2,1,3]\n         2\n        / \\\n       1   3\n    Output: True\n\n    Input: [5,1,4,null,null,3,6]\n         5\n        / \\\n       1   4\n          / \\\n         3   6\n    Output: False\n    \"\"\"\n    def isValidBSTUtil(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return (isValidBSTUtil(node.left, min_val, node.val) and\n                isValidBSTUtil(node.right, node.val, max_val))\n\n    return isValidBSTUtil(root, float('-inf'), float('inf'))", "solution_func": "def g():\n    \"\"\"\n    Create the following binary search tree (BST):\n         5\n        / \\\n       1   4\n          / \\\n         3   6\n    \"\"\"\n    root = TreeNode(5)\n    root.left = TreeNode(1)\n    root.right = TreeNode(4)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(6)\n    return root", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index of the target value if it is found in the array,\n    or -1 if it is not found.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return arr, target\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index of the target value if it is found in the array,\n    or -1 if it is not found.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [0, 2],\n        2: [0, 1, 3],\n        3: [2, 4],\n        4: [3]\n    }\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 376, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False", "solution_func": "def g():\n    graph = {\n        0: [1, 2],\n        1: [0, 2],\n        2: [0, 1, 3],\n        3: [2, 4],\n        4: [3]\n    }\n    start = 0\n    end = 4\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string consisting of parentheses, brackets, and curly braces, determine if the string is balanced.\n    A string is balanced if every opening parenthesis, bracket, or curly brace has a corresponding closing parenthesis,\n    bracket, or curly brace in the correct order.\n    \"\"\"\n    stack = []\n    opening = set(['(', '[', '{'])\n    closing = set([')', ']', '}'])\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] != '(':\n                return False\n            if char == ']' and stack[-1] != '[':\n                return False\n            if char == '}' and stack[-1] != '{':\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    s = \"((()))\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 376, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string consisting of parentheses, brackets, and curly braces, determine if the string is balanced.\n    A string is balanced if every opening parenthesis, bracket, or curly brace has a corresponding closing parenthesis,\n    bracket, or curly brace in the correct order.\n    \"\"\"\n    stack = []\n    opening = set(['(', '[', '{'])\n    closing = set([')', ']', '}'])\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] != '(':\n                return False\n            if char == ']' and stack[-1] != '[':\n                return False\n            if char == '}' and stack[-1] != '{':\n                return False\n            stack.pop()\n    \n    return len(stack) == 0", "solution_func": "def g():\n    s = \"((()))\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number,\n    find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    The two numbers that add up to the target are 2 and 5,\n    located at indices 1 and 4 respectively.\n\n    Therefore, the function should return [1, 4].\n    \"\"\"\n\n    # Initialize two pointers, one at the start of the list and one at the end\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        # Calculate the sum of the two numbers at the current pointers\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            # Return the indices of the two numbers if their sum is equal to the target\n            return [left, right]\n        elif current_sum < target:\n            # If the sum is less than the target, move the left pointer to the right\n            left += 1\n        else:\n            # If the sum is greater than the target, move the right pointer to the left\n            right -= 1\n\n    # Return an empty list if no pair of numbers adds up to the target\n    return []\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [1, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 376, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number,\n    find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    The two numbers that add up to the target are 2 and 5,\n    located at indices 1 and 4 respectively.\n\n    Therefore, the function should return [1, 4].\n    \"\"\"\n\n    # Initialize two pointers, one at the start of the list and one at the end\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        # Calculate the sum of the two numbers at the current pointers\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            # Return the indices of the two numbers if their sum is equal to the target\n            return [left, right]\n        elif current_sum < target:\n            # If the sum is less than the target, move the left pointer to the right\n            left += 1\n        else:\n            # If the sum is greater than the target, move the right pointer to the left\n            right -= 1\n\n    # Return an empty list if no pair of numbers adds up to the target\n    return []", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the XOR of all the elements in the\n    original list except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The XOR of all elements except 1 is 2 ^ 3 ^ 4 = 5.\n    The XOR of all elements except 2 is 1 ^ 3 ^ 4 = 6.\n    The XOR of all elements except 3 is 1 ^ 2 ^ 4 = 7.\n    The XOR of all elements except 4 is 1 ^ 2 ^ 3 = 4.\n\n    Therefore, the function should return [5, 6, 7, 4].\n    \"\"\"\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n    \n    result = []\n    for num in nums:\n        result.append(xor_all ^ num)\n    \n    return result\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return (nums,)\n\nassert f(g()) == [5, 6, 7, 4]\n", "emb": null, "idx_generation": 377, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the XOR of all the elements in the\n    original list except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The XOR of all elements except 1 is 2 ^ 3 ^ 4 = 5.\n    The XOR of all elements except 2 is 1 ^ 3 ^ 4 = 6.\n    The XOR of all elements except 3 is 1 ^ 2 ^ 4 = 7.\n    The XOR of all elements except 4 is 1 ^ 2 ^ 3 = 4.\n\n    Therefore, the function should return [5, 6, 7, 4].\n    \"\"\"\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n    \n    result = []\n    for num in nums:\n        result.append(xor_all ^ num)\n    \n    return result", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return (nums,)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the reverse of the string without reversing the individual words.\n\n    Example:\n    s = \"Hello World\"\n\n    The reverse of the string without reversing the individual words is \"World Hello\".\n\n    Therefore, the function should return \"World Hello\".\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return (s,)\n\nassert f(g()) == \"World Hello\"\n", "emb": null, "idx_generation": 377, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the reverse of the string without reversing the individual words.\n\n    Example:\n    s = \"Hello World\"\n\n    The reverse of the string without reversing the individual words is \"World Hello\".\n\n    Therefore, the function should return \"World Hello\".\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "solution_func": "def g():\n    s = \"Hello World\"\n    return (s,)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits required to represent n in binary.\n\n    Example:\n    n = 10\n\n    The binary representation of 10 is '1010', which requires 4 bits.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    return len(bin(n)) - 2\n\ndef g():\n    n = 10\n    return (n,)\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 377, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits required to represent n in binary.\n\n    Example:\n    n = 10\n\n    The binary representation of 10 is '1010', which requires 4 bits.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    return len(bin(n)) - 2", "solution_func": "def g():\n    n = 10\n    return (n,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n\n    Output:\n    3\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n\n    Output:\n    3\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the maximum sum of values that can be obtained by starting at the top-left cell and moving only right and down to the bottom-right cell.\n    You can only move to adjacent cells (right or down).\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(*g()) == 12\n\n", "emb": null, "idx_generation": 377, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the maximum sum of values that can be obtained by starting at the top-left cell and moving only right and down to the bottom-right cell.\n    You can only move to adjacent cells (right or down).\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    12\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 377, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value, find the index of the target value in the list.\n    If the target is not found, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 7\n    Output: -1\n\n    Explanation:\n    The target value 7 is not found in the list, so -1 is returned.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nnums = [1, 3, 5, 7, 9]\ntarget = 5\nassert f(*g(nums, target)) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value, find the index of the target value in the list.\n    If the target is not found, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 7\n    Output: -1\n\n    Explanation:\n    The target value 7 is not found in the list, so -1 is returned.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g(nums: List[int], target: int):\n    return nums, target\n\nnums = [1, 3, 5, 7, 9]\ntarget = 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique permutations of the numbers from 1 to n.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation:\n    The unique permutations of [1, 2, 3] are:\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n    \"\"\"\n    def backtrack(nums, used, perm, perms):\n        if len(perm) == len(nums):\n            perms.append(perm[:])\n        else:\n            for i in range(len(nums)):\n                if not used[i]:\n                    used[i] = True\n                    perm.append(nums[i])\n                    backtrack(nums, used, perm, perms)\n                    used[i] = False\n                    perm.pop()\n\n    nums = list(range(1, n+1))\n    used = [False] * n\n    perm = []\n    perms = []\n    backtrack(nums, used, perm, perms)\n\n    return len(perms)\n\ndef g(n: int):\n    return n\n\nn = 3\nassert f(g(n)) == 6\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique permutations of the numbers from 1 to n.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation:\n    The unique permutations of [1, 2, 3] are:\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n    \"\"\"\n    def backtrack(nums, used, perm, perms):\n        if len(perm) == len(nums):\n            perms.append(perm[:])\n        else:\n            for i in range(len(nums)):\n                if not used[i]:\n                    used[i] = True\n                    perm.append(nums[i])\n                    backtrack(nums, used, perm, perms)\n                    used[i] = False\n                    perm.pop()\n\n    nums = list(range(1, n+1))\n    used = [False] * n\n    perm = []\n    perms = []\n    backtrack(nums, used, perm, perms)\n\n    return len(perms)", "solution_func": "def g(n: int):\n    return n\n\nn = 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine whether it is bipartite or not.\n\n    Example:\n    Input: graph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    Output: True\n\n    Explanation:\n    The graph can be divided into two sets {0, 2} and {1} such that there are no edges between nodes in the same set.\n\n    Input: graph = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    Output: False\n\n    Explanation:\n    The graph cannot be divided into two sets without having edges between nodes in the same set.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                    return False\n        \n        return True\n\n    colors = [0] * len(graph)\n\n    for node in range(len(graph)):\n        if colors[node] == 0 and not dfs(node, 1):\n            return False\n    \n    return True\n\ndef g(graph: List[List[int]]):\n    return graph\n\ngraph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\nassert f(g(graph)) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine whether it is bipartite or not.\n\n    Example:\n    Input: graph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    Output: True\n\n    Explanation:\n    The graph can be divided into two sets {0, 2} and {1} such that there are no edges between nodes in the same set.\n\n    Input: graph = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    Output: False\n\n    Explanation:\n    The graph cannot be divided into two sets without having edges between nodes in the same set.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                    return False\n        \n        return True\n\n    colors = [0] * len(graph)\n\n    for node in range(len(graph)):\n        if colors[node] == 0 and not dfs(node, 1):\n            return False\n    \n    return True", "solution_func": "def g(graph: List[List[int]]):\n    return graph\n\ngraph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return True if its length is greater than or equal to 3.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) >= 3\n\ndef g():\n    nums = [1, 3, 2, 4, 5, 6, 4, 7, 8]\n    return nums\n\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 377, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return True if its length is greater than or equal to 3.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) >= 3", "solution_func": "def g():\n    nums = [1, 3, 2, 4, 5, 6, 4, 7, 8]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the median of the list.\n\n    Example:\n    nums = [5, 2, 9, 1, 7, 6, 3]\n    output: 5\n\n    Explanation:\n    The median is the middle value of a sorted list of numbers. In this case, when the list is sorted, the median is 5.\n    If the list has an even number of elements, the median is the average of the two middle values.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        median = (nums[n//2-1] + nums[n//2]) / 2\n    else:\n        median = nums[n//2]\n    return median\n\ndef g() -> List[int]:\n    nums = [5, 2, 9, 1, 7, 6, 3]\n    return nums\n\nassert f(g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the median of the list.\n\n    Example:\n    nums = [5, 2, 9, 1, 7, 6, 3]\n    output: 5\n\n    Explanation:\n    The median is the middle value of a sorted list of numbers. In this case, when the list is sorted, the median is 5.\n    If the list has an even number of elements, the median is the average of the two middle values.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        median = (nums[n//2-1] + nums[n//2]) / 2\n    else:\n        median = nums[n//2]\n    return median", "solution_func": "def g() -> List[int]:\n    nums = [5, 2, 9, 1, 7, 6, 3]\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the permutations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n    output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation:\n    A permutation is an arrangement of elements where order matters. In this case, we need to find all possible permutations of the list [1, 2, 3].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n\n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the permutations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n    output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation:\n    A permutation is an arrangement of elements where order matters. In this case, we need to find all possible permutations of the list [1, 2, 3].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n\n    res = []\n    backtrack(nums, [], res)\n    return res", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if it is a palindrome list.\n\n    Example:\n    nums = [1, 2, 3, 2, 1]\n    output: True\n\n    Explanation:\n    A palindrome list is a list that remains the same when its elements are reversed. In this case, the list [1, 2, 3, 2, 1] is a palindrome.\n    \"\"\"\n    return nums == nums[::-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if it is a palindrome list.\n\n    Example:\n    nums = [1, 2, 3, 2, 1]\n    output: True\n\n    Explanation:\n    A palindrome list is a list that remains the same when its elements are reversed. In this case, the list [1, 2, 3, 2, 1] is a palindrome.\n    \"\"\"\n    return nums == nums[::-1]", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 2, 1]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Return the length of the LIS.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Return the length of the LIS.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "solution_func": "def g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n\n    Return the number of unique paths.\n\n    Example:\n    n = 3, m = 7\n\n    There are 28 unique paths from the top-left corner to the bottom-right corner of a 3 x 7 grid.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g():\n    return 3, 7\n\nassert f(*g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n\n    Return the number of unique paths.\n\n    Example:\n    n = 3, m = 7\n\n    There are 28 unique paths from the top-left corner to the bottom-right corner of a 3 x 7 grid.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]", "solution_func": "def g():\n    return 3, 7", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum XOR value between two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 8, 2]\n\n    The maximum XOR value is 15, which is obtained by XORing 5 and 10.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 8, 2]\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum XOR value between two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 8, 2]\n\n    The maximum XOR value is 15, which is obtained by XORing 5 and 10.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 8, 2]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    Input: 3\n    Output: 3\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n\n    Hint: Use dynamic programming to solve this problem. The number of ways to reach the current step is the sum of the number\n    of ways to reach the previous step and the number of ways to reach the step two steps before.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    Input: 3\n    Output: 3\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n\n    Hint: Use dynamic programming to solve this problem. The number of ways to reach the current step is the sum of the number\n    of ways to reach the previous step and the number of ways to reach the step two steps before.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]", "solution_func": "def g():\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, determine if s2 is a rotation of s1.\n\n    Example:\n    Input: s1 = \"abcde\", s2 = \"cdeab\"\n    Output: True\n    Explanation: s2 is a rotation of s1, where s1 = \"abcde\" and s2 = \"cdeab\"\n\n    Hint: Check if s2 is a substring of s1 concatenated with itself. If it is, then s2 is a rotation of s1.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    return s2 in s1 + s1\n\ndef g():\n    return \"abcde\", \"cdeab\"\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, determine if s2 is a rotation of s1.\n\n    Example:\n    Input: s1 = \"abcde\", s2 = \"cdeab\"\n    Output: True\n    Explanation: s2 is a rotation of s1, where s1 = \"abcde\" and s2 = \"cdeab\"\n\n    Hint: Check if s2 is a substring of s1 concatenated with itself. If it is, then s2 is a rotation of s1.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    return s2 in s1 + s1", "solution_func": "def g():\n    return \"abcde\", \"cdeab\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the numbers sum to target.\n    Each number in nums may only be used once in the combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Hint: Use backtracking to generate all possible combinations. Sort the nums array to handle duplicate numbers.\n    \"\"\"\n    def backtrack(nums, target, path, start):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if nums[i] > target:\n                break\n            backtrack(nums, target - nums[i], path + [nums[i]], i + 1)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, [], 0)\n    return res\n\ndef g():\n    return [10, 1, 2, 7, 6, 1, 5], 8\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the numbers sum to target.\n    Each number in nums may only be used once in the combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Hint: Use backtracking to generate all possible combinations. Sort the nums array to handle duplicate numbers.\n    \"\"\"\n    def backtrack(nums, target, path, start):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if nums[i] > target:\n                break\n            backtrack(nums, target - nums[i], path + [nums[i]], i + 1)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, [], 0)\n    return res", "solution_func": "def g():\n    return [10, 1, 2, 7, 6, 1, 5], 8", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 378, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers arr and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n    def two_sum(arr: List[int], target: int, left: int, right: int) -> List[int]:\n        if left >= right:\n            return []\n        \n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            return two_sum(arr, target, left + 1, right)\n        else:\n            return two_sum(arr, target, left, right - 1)\n\n    return two_sum(arr, target, 0, len(arr) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5, 6, 7, 8], 9)\n\nassert f(*g()) == [1, 5]\n", "emb": null, "idx_generation": 379, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers arr and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n    def two_sum(arr: List[int], target: int, left: int, right: int) -> List[int]:\n        if left >= right:\n            return []\n        \n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            return two_sum(arr, target, left + 1, right)\n        else:\n            return two_sum(arr, target, left, right - 1)\n\n    return two_sum(arr, target, 0, len(arr) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5, 6, 7, 8], 9)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n    \"\"\"\n    def reverse_words(s: str) -> str:\n        words = s.split()\n        reversed_words = words[::-1]\n        return ' '.join(reversed_words)\n\n    return reverse_words(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 379, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n    \"\"\"\n    def reverse_words(s: str) -> str:\n        words = s.split()\n        reversed_words = words[::-1]\n        return ' '.join(reversed_words)\n\n    return reverse_words(s)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, world!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    return factorial(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a non-negative integer.\n    \"\"\"\n    return 5\n\nassert f(g()) == 120\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 379, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    return factorial(n)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a non-negative integer.\n    \"\"\"\n    return 5", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 379, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "solution_func": "def g():\n    return 13", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k objects from a set of n objects.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    if k > n or k < 0:\n        return 0\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g())\n", "emb": null, "idx_generation": 379, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k objects from a set of n objects.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    if k > n or k < 0:\n        return 0\n    return f(n-1, k-1) + f(n-1, k)", "solution_func": "def g(n=5, k=2):\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the sum of the first n natural numbers.\"\"\"\n    if n <= 0:\n        return 0\n    return n + f(n-1)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 379, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the sum of the first n natural numbers.\"\"\"\n    if n <= 0:\n        return 0\n    return n + f(n-1)", "solution_func": "def g(n=5):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of subarrays whose sum is equal to the target.\n\n    Example:\n    Input: nums = [1, 3, 2, 4, 6, -1, -5], target = 5\n    Output: 3\n\n    Explanation: There are 3 subarrays with sum equal to 5: [1, 3, 2, -1] , [2, 4, -1], and [5].\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            count += prefix_sums[prefix_sum - target]\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g():\n    nums = [1, 3, 2, 4, 6, -1, -5]\n    target = 5\n    return (nums, target)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 379, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of subarrays whose sum is equal to the target.\n\n    Example:\n    Input: nums = [1, 3, 2, 4, 6, -1, -5], target = 5\n    Output: 3\n\n    Explanation: There are 3 subarrays with sum equal to 5: [1, 3, 2, -1] , [2, 4, -1], and [5].\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            count += prefix_sums[prefix_sum - target]\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n\n    return count", "solution_func": "def g():\n    nums = [1, 3, 2, 4, 6, -1, -5]\n    target = 5\n    return (nums, target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any pair of elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        current_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if current_max ^ prefix in prefixes:\n                max_xor = current_max\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return (nums,)\n\nassert f(g()) == 28\n", "emb": null, "idx_generation": 379, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any pair of elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        current_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if current_max ^ prefix in prefixes:\n                max_xor = current_max\n                break\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return (nums,)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list\n    except the element at that position.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n\n    Explanation: The product of all elements except the first one is 2 * 3 * 4 * 5 = 120. The product of all elements except\n    the second one is 1 * 3 * 4 * 5 = 60, and so on.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = []\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result.append(left_products[i] * right_products[i])\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": null, "idx_generation": 379, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list\n    except the element at that position.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n\n    Explanation: The product of all elements except the first one is 2 * 3 * 4 * 5 = 120. The product of all elements except\n    the second one is 1 * 3 * 4 * 5 = 60, and so on.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = []\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result.append(left_products[i] * right_products[i])\n\n    return result", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of all possible combinations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n    output: 7\n\n    Explanation:\n    A combination is a selection of items from a larger set where order does not matter. In this case, we need to find the number of all possible combinations of the list [1, 2, 3].\n    The combinations are: [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3].\n    \"\"\"\n    def backtrack(start, path):\n        nonlocal count\n        count += 1\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    count = 0\n    backtrack(0, [])\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 7\n\n\n", "emb": null, "idx_generation": 379, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of all possible combinations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n    output: 7\n\n    Explanation:\n    A combination is a selection of items from a larger set where order does not matter. In this case, we need to find the number of all possible combinations of the list [1, 2, 3].\n    The combinations are: [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3].\n    \"\"\"\n    def backtrack(start, path):\n        nonlocal count\n        count += 1\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    count = 0\n    backtrack(0, [])\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n\n    The maximum sum of a subarray with no adjacent numbers is 12, which can be obtained by selecting subarray [2, 9, 1].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 2] + arr[i], dp[i - 1])\n\n    return dp[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 9, 3, 1]\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n\n    The maximum sum of a subarray with no adjacent numbers is 12, which can be obtained by selecting subarray [2, 9, 1].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 2] + arr[i], dp[i - 1])\n\n    return dp[-1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 9, 3, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers matrix, find the maximum sum of a path from the top-left cell to the bottom-right cell. \n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The maximum sum of a path from the top-left cell to the bottom-right cell is 7, which can be obtained by selecting the path 1 -> 3 -> 1 -> 1 -> 1.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 4.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 380, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers matrix, find the maximum sum of a path from the top-left cell to the bottom-right cell. \n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The maximum sum of a path from the top-left cell to the bottom-right cell is 7, which can be obtained by selecting the path 1 -> 3 -> 1 -> 1 -> 1.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[m - 1][n - 1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 4.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the\n    numbers sum to target. Each number in nums may only be used once in the combination.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    A solution set is:\n    [\n        [1, 1, 6],\n        [1, 2, 5],\n        [1, 7],\n        [2, 6]\n    ]\n\n    Therefore, the function should return [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]].\n    \"\"\"\n    result = []\n    nums.sort()\n    n = len(nums)\n\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, n):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(i + 1, path, target - nums[i])\n            path.pop()\n\n    backtrack(0, [], target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple of an array of integers and an integer for Puzzle 5.\n    \"\"\"\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the\n    numbers sum to target. Each number in nums may only be used once in the combination.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    A solution set is:\n    [\n        [1, 1, 6],\n        [1, 2, 5],\n        [1, 7],\n        [2, 6]\n    ]\n\n    Therefore, the function should return [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]].\n    \"\"\"\n    result = []\n    nums.sort()\n    n = len(nums)\n\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, n):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(i + 1, path, target - nums[i])\n            path.pop()\n\n    backtrack(0, [], target)\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple of an array of integers and an integer for Puzzle 5.\n    \"\"\"\n    return ([10, 1, 2, 7, 6, 1, 5], 8)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two integers in the list that sum up to the target value. Return True if such integers exist, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two integers in the list that sum up to the target value. Return True if such integers exist, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of possible combinations of k elements from a list of n elements.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g():\n    n = 6\n    k = 3\n    return n, k\n\nassert f(*g()) == 20\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of possible combinations of k elements from a list of n elements.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))", "solution_func": "def g():\n    n = 6\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs (i, j) such that i < j and nums[i] & nums[j] > 0, where '&' represents the bitwise AND operation.\n    \"\"\"\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] & nums[j] > 0:\n                count += 1\n\n    return count\n\ndef g():\n    return [3, 6, 9, 12, 15]\n\nassert f(g()) == 10\n\n", "emb": null, "idx_generation": 380, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of pairs (i, j) such that i < j and nums[i] & nums[j] > 0, where '&' represents the bitwise AND operation.\n    \"\"\"\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] & nums[j] > 0:\n                count += 1\n\n    return count", "solution_func": "def g():\n    return [3, 6, 9, 12, 15]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list.\n    If the target is not found, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    The target value is guaranteed to be in the list.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list.\n    If the target is not found, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    The target value is guaranteed to be in the list.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value between two elements in the list is 28 (3 ^ 25).\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 380, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value between two elements in the list is 28 (3 ^ 25).\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list using the bubble sort algorithm and return the sorted list.\n\n    Example:\n    Input: nums = [5, 2, 8, 1, 9]\n    Output: [1, 2, 5, 8, 9]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 8, 1, 9]\n\nassert f(g()) == [1, 2, 5, 8, 9]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 380, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list using the bubble sort algorithm and return the sorted list.\n\n    Example:\n    Input: nums = [5, 2, 8, 1, 9]\n    Output: [1, 2, 5, 8, 9]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 8, 1, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    12\n    Explanation: The even numbers in the list are 2, 4, and 6. Their sum is 12.\n\n    Sample Input:\n    nums = [3, 6, 9, 12, 15]\n\n    Sample Output:\n    18\n    Explanation: The even numbers in the list are 6 and 12. Their sum is 18.\n\n    \"\"\"\n\n    sum_even = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            sum_even += num\n\n    return sum_even\n\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return (nums,)\n\n\nassert f(*g()) == 12\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 380, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    12\n    Explanation: The even numbers in the list are 2, 4, and 6. Their sum is 12.\n\n    Sample Input:\n    nums = [3, 6, 9, 12, 15]\n\n    Sample Output:\n    18\n    Explanation: The even numbers in the list are 6 and 12. Their sum is 18.\n\n    \"\"\"\n\n    sum_even = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            sum_even += num\n\n    return sum_even", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6]):\n    return (nums,)", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique combinations of k numbers from the range 1 to n, inclusive.\n\n    Example:\n    n = 4\n    k = 2\n    Output: 6\n\n    Explanation:\n    The possible combinations are: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]\n    \"\"\"\n\n    def dfs(start: int, path: List[int]) -> None:\n        if len(path) == k:\n            combinations.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            path.append(i)\n            dfs(i + 1, path)\n            path.pop()\n\n    combinations = []\n    dfs(1, [])\n    return len(combinations)\n\ndef g() -> List[int]:\n    return [4, 2]\n\nassert f(*g()) == 6\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique combinations of k numbers from the range 1 to n, inclusive.\n\n    Example:\n    n = 4\n    k = 2\n    Output: 6\n\n    Explanation:\n    The possible combinations are: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]\n    \"\"\"\n\n    def dfs(start: int, path: List[int]) -> None:\n        if len(path) == k:\n            combinations.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            path.append(i)\n            dfs(i + 1, path)\n            path.pop()\n\n    combinations = []\n    dfs(1, [])\n    return len(combinations)", "solution_func": "def g() -> List[int]:\n    return [4, 2]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the number of connected components in the graph.\n\n    Example:\n    n = 5\n    m = 3\n    edges = [[0, 1], [1, 2], [3, 4]]\n    Output: 2\n\n    Explanation:\n    The graph can be visualized as follows:\n    0 -- 1 -- 2\n    3 -- 4\n\n    The connected components are [0, 1, 2] and [3, 4].\n    \"\"\"\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    components = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n\n    return components\n\ndef g() -> List:\n    return [5, 3, [[0, 1], [1, 2], [3, 4]]]\n\nassert f(*g()) == 2\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the number of connected components in the graph.\n\n    Example:\n    n = 5\n    m = 3\n    edges = [[0, 1], [1, 2], [3, 4]]\n    Output: 2\n\n    Explanation:\n    The graph can be visualized as follows:\n    0 -- 1 -- 2\n    3 -- 4\n\n    The connected components are [0, 1, 2] and [3, 4].\n    \"\"\"\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    components = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n\n    return components", "solution_func": "def g() -> List:\n    return [5, 3, [[0, 1], [1, 2], [3, 4]]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if it is a palindrome, and False otherwise.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Example:\n    s = \"racecar\"\n    Output: True\n\n    s = \"hello\"\n    Output: False\n    \"\"\"\n\n    def is_palindrome(left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s) - 1)\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if it is a palindrome, and False otherwise.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Example:\n    s = \"racecar\"\n    Output: True\n\n    s = \"hello\"\n    Output: False\n    \"\"\"\n\n    def is_palindrome(left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s) - 1)", "solution_func": "def g() -> str:\n    return \"racecar\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, return a list of two numbers from nums that sum up to the target.\n\n    Example:\n    nums = [2, 4, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7], since 2 + 7 = 9.\n\n    Constraints:\n    - The input list nums will have at least two elements.\n    - There will always be exactly one solution.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use two pointers to find the two numbers that sum up to the target\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value that can be used as input for the function f.\n    \"\"\"\n    return [2, 11, 4, 15, 7], 9\n\nassert f(*g()) == [2, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, return a list of two numbers from nums that sum up to the target.\n\n    Example:\n    nums = [2, 4, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7], since 2 + 7 = 9.\n\n    Constraints:\n    - The input list nums will have at least two elements.\n    - There will always be exactly one solution.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use two pointers to find the two numbers that sum up to the target\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value that can be used as input for the function f.\n    \"\"\"\n    return [2, 11, 4, 15, 7], 9", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of possible unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n\n    The function should return 6, since there are 6 possible unique paths:\n    [\"RRD\", \"RDR\", \"DRR\", \"DDR\", \"DRD\", \"RDD\"]\n\n    Constraints:\n    - The input integer n will be greater than 0.\n    \"\"\"\n\n    # Create a 2D grid with dimensions (n+1) x (n+1) and initialize all values to 0\n    grid = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: there is only one possible path from the top-left corner to any point in the first row or first column\n    for i in range(n + 1):\n        grid[i][0] = 1\n        grid[0][i] = 1\n\n    # Dynamic programming: calculate the number of possible paths for each point in the grid\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n\n    # The value at the bottom-right corner of the grid represents the number of possible paths from the top-left corner to the bottom-right corner\n    return grid[n][n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer that can be used as input for the function f.\n    \"\"\"\n    return 3\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 381, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of possible unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    n = 3\n\n    The function should return 6, since there are 6 possible unique paths:\n    [\"RRD\", \"RDR\", \"DRR\", \"DDR\", \"DRD\", \"RDD\"]\n\n    Constraints:\n    - The input integer n will be greater than 0.\n    \"\"\"\n\n    # Create a 2D grid with dimensions (n+1) x (n+1) and initialize all values to 0\n    grid = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: there is only one possible path from the top-left corner to any point in the first row or first column\n    for i in range(n + 1):\n        grid[i][0] = 1\n        grid[0][i] = 1\n\n    # Dynamic programming: calculate the number of possible paths for each point in the grid\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n\n    # The value at the bottom-right corner of the grid represents the number of possible paths from the top-left corner to the bottom-right corner\n    return grid[n][n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer that can be used as input for the function f.\n    \"\"\"\n    return 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, return a list of three numbers from nums that sum up to the target.\n\n    Example:\n    nums = [2, 4, 1, 7, 11, 15]\n    target = 19\n\n    The function should return [2, 7, 11], since 2 + 7 + 11 = 19.\n\n    Constraints:\n    - The input list nums will have at least three elements.\n    - There will always be exactly one solution.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use three pointers to find the three numbers that sum up to the target\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value that can be used as input for the function f.\n    \"\"\"\n    return [2, 11, 4, 15, 7, 1], 19\n\nassert f(*g()) == [2, 7, 11]\n", "emb": null, "idx_generation": 381, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, return a list of three numbers from nums that sum up to the target.\n\n    Example:\n    nums = [2, 4, 1, 7, 11, 15]\n    target = 19\n\n    The function should return [2, 7, 11], since 2 + 7 + 11 = 19.\n\n    Constraints:\n    - The input list nums will have at least three elements.\n    - There will always be exactly one solution.\n    \"\"\"\n\n    # Sort the list in ascending order\n    nums.sort()\n\n    # Use three pointers to find the three numbers that sum up to the target\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value that can be used as input for the function f.\n    \"\"\"\n    return [2, 11, 4, 15, 7, 1], 19", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target integer,\n    return True if there are two distinct indices i and j in the list\n    such that arr[i] + arr[j] == target, and False otherwise.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    return arr, target\n\nassert f(g([1, 2, 3, 4, 5], 9), 9)\n", "emb": null, "idx_generation": 381, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target integer,\n    return True if there are two distinct indices i and j in the list\n    such that arr[i] + arr[j] == target, and False otherwise.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target integer.\n    \"\"\"\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    output: 3\n\n    Explanation: There are three distinct ways to climb to the top:\n    - 1 step + 1 step + 1 step\n    - 1 step + 2 steps\n    - 2 steps + 1 step\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(4)) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    output: 3\n\n    Explanation: There are three distinct ways to climb to the top:\n    - 1 step + 1 step + 1 step\n    - 1 step + 2 steps\n    - 2 steps + 1 step\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, sort the list in non-decreasing order using the bubble sort algorithm.\n    Return the sorted list.\n\n    Example:\n    arr = [5, 2, 1, 9, 3]\n    output: [1, 2, 3, 5, 9]\n    \"\"\"\n\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr\n\nassert f(g([5, 2, 1, 9, 3])) == [1, 2, 3, 5, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, sort the list in non-decreasing order using the bubble sort algorithm.\n    Return the sorted list.\n\n    Example:\n    arr = [5, 2, 1, 9, 3]\n    output: [1, 2, 3, 5, 9]\n    \"\"\"\n\n    n = len(arr)\n\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n    return arr", "solution_func": "def g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicates removed.\n\n    Example:\n    Input: [1, 2, 3, 3, 4, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(set(nums))\n\ndef g(nums = [1, 2, 3, 3, 4, 4, 5]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 381, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicates removed.\n\n    Example:\n    Input: [1, 2, 3, 3, 4, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n    return list(set(nums))", "solution_func": "def g(nums = [1, 2, 3, 3, 4, 4, 5]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two numbers in the array is 28 (5 XOR 25).\n\n    Therefore, the function should return 28.\n    \"\"\"\n    def findMaximumXOR(nums):\n        MAX_BITS = 32\n        result = 0\n\n        for i in range(MAX_BITS-1, -1, -1):\n            result <<= 1\n            prefixSet = set([num >> i for num in nums])\n\n            currMax = result | 1\n            for prefix in prefixSet:\n                if currMax ^ prefix in prefixSet:\n                    result |= 1\n                    break\n\n        return result\n\n    return findMaximumXOR(nums)\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 382, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two numbers in the array is 28 (5 XOR 25).\n\n    Therefore, the function should return 28.\n    \"\"\"\n    def findMaximumXOR(nums):\n        MAX_BITS = 32\n        result = 0\n\n        for i in range(MAX_BITS-1, -1, -1):\n            result <<= 1\n            prefixSet = set([num >> i for num in nums])\n\n            currMax = result | 1\n            for prefix in prefixSet:\n                if currMax ^ prefix in prefixSet:\n                    result |= 1\n                    break\n\n        return result\n\n    return findMaximumXOR(nums)", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: Tuple[Tuple[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    You can move up, down, left, or right from each cell. The path can start from any cell and follow the adjacent cells\n    in the grid.\n\n    Example:\n    grid = (\n        (9, 9, 4),\n        (6, 6, 8),\n        (2, 1, 1)\n    )\n\n    The longest increasing path in the grid is [1, 2, 6, 9], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def longestIncreasingPath(matrix):\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n\n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n\n            val = matrix[i][j]\n            dp[i][j] = 1 + max(\n                dfs(i-1, j) if i > 0 and val < matrix[i-1][j] else 0,\n                dfs(i+1, j) if i < rows-1 and val < matrix[i+1][j] else 0,\n                dfs(i, j-1) if j > 0 and val < matrix[i][j-1] else 0,\n                dfs(i, j+1) if j < cols-1 and val < matrix[i][j+1] else 0\n            )\n\n            return dp[i][j]\n\n        maxPath = 0\n        for i in range(rows):\n            for j in range(cols):\n                maxPath = max(maxPath, dfs(i, j))\n\n        return maxPath\n\n    return longestIncreasingPath(grid)\n\ndef g():\n    grid = (\n        (9, 9, 4),\n        (6, 6, 8),\n        (2, 1, 1)\n    )\n    return grid\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: Tuple[Tuple[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    You can move up, down, left, or right from each cell. The path can start from any cell and follow the adjacent cells\n    in the grid.\n\n    Example:\n    grid = (\n        (9, 9, 4),\n        (6, 6, 8),\n        (2, 1, 1)\n    )\n\n    The longest increasing path in the grid is [1, 2, 6, 9], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def longestIncreasingPath(matrix):\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n\n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n\n            val = matrix[i][j]\n            dp[i][j] = 1 + max(\n                dfs(i-1, j) if i > 0 and val < matrix[i-1][j] else 0,\n                dfs(i+1, j) if i < rows-1 and val < matrix[i+1][j] else 0,\n                dfs(i, j-1) if j > 0 and val < matrix[i][j-1] else 0,\n                dfs(i, j+1) if j < cols-1 and val < matrix[i][j+1] else 0\n            )\n\n            return dp[i][j]\n\n        maxPath = 0\n        for i in range(rows):\n            for j in range(cols):\n                maxPath = max(maxPath, dfs(i, j))\n\n        return maxPath\n\n    return longestIncreasingPath(grid)", "solution_func": "def g():\n    grid = (\n        (9, 9, 4),\n        (6, 6, 8),\n        (2, 1, 1)\n    )\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in the array is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def lengthOfLIS(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return lengthOfLIS(nums)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in the array is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def lengthOfLIS(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return lengthOfLIS(nums)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of triplets (a, b, c) such that a < b < c and nums[a] < nums[b] < nums[c].\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    10\n    \n    Explanation:\n    There are 10 possible triplets: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] < nums[j] < nums[k]:\n                    count += 1\n    \n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 10\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of triplets (a, b, c) such that a < b < c and nums[a] < nums[b] < nums[c].\n    \n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    10\n    \n    Explanation:\n    There are 10 possible triplets: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] < nums[j] < nums[k]:\n                    count += 1\n    \n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays with an odd sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    9\n    \n    Explanation:\n    There are 9 possible subarrays with an odd sum: [1], [2, 3], [2, 3, 4, 5], [3, 4], [3, 4, 5], [4, 5], [1, 2, 3, 4, 5], [2, 3, 4], [1, 2, 3, 4].\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            subarray = nums[i:j+1]\n            if sum(subarray) % 2 == 1:\n                count += 1\n    \n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays with an odd sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    Output:\n    9\n    \n    Explanation:\n    There are 9 possible subarrays with an odd sum: [1], [2, 3], [2, 3, 4, 5], [3, 4], [3, 4, 5], [4, 5], [1, 2, 3, 4, 5], [2, 3, 4], [1, 2, 3, 4].\n    \"\"\"\n\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            subarray = nums[i:j+1]\n            if sum(subarray) % 2 == 1:\n                count += 1\n    \n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    \n    Output:\n    12\n    \n    Explanation:\n    The subarrays with length at most 3 are: [1], [2], [3], [4], [5], [1, 2], [2, 3], [3, 4], [4, 5], [1, 2, 3], [2, 3, 4], [3, 4, 5].\n    The maximum sum is 12, which can be achieved by the subarray [3, 4, 5].\n    \"\"\"\n\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i, min(i + k, len(nums))):\n            subarray = nums[i:j+1]\n            max_sum = max(max_sum, sum(subarray))\n    \n    return max_sum\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 382, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with length at most k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    \n    Output:\n    12\n    \n    Explanation:\n    The subarrays with length at most 3 are: [1], [2], [3], [4], [5], [1, 2], [2, 3], [3, 4], [4, 5], [1, 2, 3], [2, 3, 4], [3, 4, 5].\n    The maximum sum is 12, which can be achieved by the subarray [3, 4, 5].\n    \"\"\"\n\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i, min(i + k, len(nums))):\n            subarray = nums[i:j+1]\n            max_sum = max(max_sum, sum(subarray))\n    \n    return max_sum", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    return nums, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [2, 7]\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> int:\n        \"\"\"\n        Perform a binary search on a sorted array to find the index of the target value.\n        Returns -1 if the target value is not found in the array.\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    nums.sort()\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        index = binary_search(nums, complement)\n        if index != -1 and index != i:\n            return [nums[i], nums[index]]\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [3, 5, 8, 12, 16, 18, 20]\n    target = 28\n    return nums, target\n\nassert f(*g()) == [8, 20]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [2, 7]\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int) -> int:\n        \"\"\"\n        Perform a binary search on a sorted array to find the index of the target value.\n        Returns -1 if the target value is not found in the array.\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n\n        return -1\n\n    nums.sort()\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        index = binary_search(nums, complement)\n        if index != -1 and index != i:\n            return [nums[i], nums[index]]\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [3, 5, 8, 12, 16, 18, 20]\n    target = 28\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product that can be obtained from any three integers in the list.\n\n    Example:\n    nums = [-10, -10, 1, 3, 2]\n    output: 300\n    \"\"\"\n\n    max1 = max2 = max3 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for num in nums:\n        if num > max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max3 = max2\n            max2 = num\n        elif num > max3:\n            max3 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    return max(max1 * max2 * max3, max1 * min1 * min2)\n\ndef g() -> List[int]:\n    nums = [-10, -10, 1, 3, 2]\n    return nums\n\nassert f(g()) == 300\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product that can be obtained from any three integers in the list.\n\n    Example:\n    nums = [-10, -10, 1, 3, 2]\n    output: 300\n    \"\"\"\n\n    max1 = max2 = max3 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for num in nums:\n        if num > max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max3 = max2\n            max2 = num\n        elif num > max3:\n            max3 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    return max(max1 * max2 * max3, max1 * min1 * min2)", "solution_func": "def g() -> List[int]:\n    nums = [-10, -10, 1, 3, 2]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth prime number.\n\n    Example:\n    n = 6\n    output: 13\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        \"\"\"\n        Check if a number is prime.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    prime = 2\n    while count < n:\n        if is_prime(prime):\n            count += 1\n        prime += 1\n\n    return prime - 1\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 13\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 382, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth prime number.\n\n    Example:\n    n = 6\n    output: 13\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        \"\"\"\n        Check if a number is prime.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    prime = 2\n    while count < n:\n        if is_prime(prime):\n            count += 1\n        prime += 1\n\n    return prime - 1", "solution_func": "def g() -> int:\n    n = 6\n    return n", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a positive integer n, return the maximum XOR value that can be obtained by selecting two integers from the list such that their bitwise XOR is less than or equal to n.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    n = 3\n\n    The maximum XOR value that can be obtained by selecting two integers from the list is 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val <= n:\n                max_xor = max(max_xor, xor_val)\n    return max_xor\n\ndef g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a list of random integers and a positive integer n.\n    \"\"\"\n    return 5, [random.randint(1, 10) for _ in range(5)]\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 382, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "import random\nfrom typing import*\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and a positive integer n, return the maximum XOR value that can be obtained by selecting two integers from the list such that their bitwise XOR is less than or equal to n.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    n = 3\n\n    The maximum XOR value that can be obtained by selecting two integers from the list is 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val <= n:\n                max_xor = max(max_xor, xor_val)\n    return max_xor", "solution_func": "def g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a list of random integers and a positive integer n.\n    \"\"\"\n    return 5, [random.randint(1, 10) for _ in range(5)]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the k-th digit from the right in the binary representation of n.\n    \"\"\"\n    binary = bin(n)[2:]\n    if k > len(binary):\n        return -1\n    return int(binary[-k])\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a positive integer n and a positive integer k for Puzzle 3.\n    \"\"\"\n    return (42, 2)\n\nassert f(*g()) == 1\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the k-th digit from the right in the binary representation of n.\n    \"\"\"\n    binary = bin(n)[2:]\n    if k > len(binary):\n        return -1\n    return int(binary[-k])", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a positive integer n and a positive integer k for Puzzle 3.\n    \"\"\"\n    return (42, 2)", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to represent n as a sum of 1, 3, and 4.\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    return f(n-1) + f(n-3) + f(n-4)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that can be represented as a sum of 1, 3, and 4 for Puzzle 5.\n    \"\"\"\n    return 7\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 383, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to represent n as a sum of 1, 3, and 4.\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    return f(n-1) + f(n-3) + f(n-4)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n that can be represented as a sum of 1, 3, and 4 for Puzzle 5.\n    \"\"\"\n    return 7", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        else:\n            return -1\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                return binary_search(nums, target, mid + 1, right)\n            else:\n                return binary_search(nums, target, left, mid - 1)\n        else:\n            return -1\n    \n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the k-th largest element in the list.\n    \"\"\"\n    def quick_select(nums: List[int], left: int, right: int, k: int) -> int:\n        pivot = nums[left]\n        i = left + 1\n        j = right\n        \n        while True:\n            while i <= j and nums[i] < pivot:\n                i += 1\n            while i <= j and nums[j] > pivot:\n                j -= 1\n            if i > j:\n                break\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        nums[left], nums[j] = nums[j], nums[left]\n        \n        if j == k - 1:\n            return nums[j]\n        elif j > k - 1:\n            return quick_select(nums, left, j - 1, k)\n        else:\n            return quick_select(nums, j + 1, right, k)\n    \n    return quick_select(nums, 0, len(nums) - 1, k)\n\ndef g():\n    nums = [5, 2, 1, 6, 4, 3]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 383, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the k-th largest element in the list.\n    \"\"\"\n    def quick_select(nums: List[int], left: int, right: int, k: int) -> int:\n        pivot = nums[left]\n        i = left + 1\n        j = right\n        \n        while True:\n            while i <= j and nums[i] < pivot:\n                i += 1\n            while i <= j and nums[j] > pivot:\n                j -= 1\n            if i > j:\n                break\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        nums[left], nums[j] = nums[j], nums[left]\n        \n        if j == k - 1:\n            return nums[j]\n        elif j > k - 1:\n            return quick_select(nums, left, j - 1, k)\n        else:\n            return quick_select(nums, j + 1, right, k)\n    \n    return quick_select(nums, 0, len(nums) - 1, k)", "solution_func": "def g():\n    nums = [5, 2, 1, 6, 4, 3]\n    k = 3\n    return nums, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target number, \n    determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    In this case, the function should return True, since 3 + 4 = 7.\n\n    Hint: Use binary search to find the complement of each number in the list.\n\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> bool:\n        \"\"\"\n        Perform binary search on a sorted list to find the target number.\n        \"\"\"\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n    for num in nums:\n        complement = target - num\n        if binary_search(nums, complement):\n            return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target number, \n    determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    In this case, the function should return True, since 3 + 4 = 7.\n\n    Hint: Use binary search to find the complement of each number in the list.\n\n    \"\"\"\n    def binary_search(arr: List[int], target: int) -> bool:\n        \"\"\"\n        Perform binary search on a sorted list to find the target number.\n        \"\"\"\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n    for num in nums:\n        complement = target - num\n        if binary_search(nums, complement):\n            return True\n    \n    return False", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 1, 4, 2, 5]\n    k = 3\n\n    In this case, the function should return 3, since the 3rd largest element in the list is 3.\n\n    Hint: Use a sorting algorithm to sort the list in descending order and return the kth element.\n\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a value k.\n    \"\"\"\n    nums = [3, 1, 4, 2, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 1, 4, 2, 5]\n    k = 3\n\n    In this case, the function should return 3, since the 3rd largest element in the list is 3.\n\n    Hint: Use a sorting algorithm to sort the list in descending order and return the kth element.\n\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers and a value k.\n    \"\"\"\n    nums = [3, 1, 4, 2, 5]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list that contains the squared values of the input list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    In this case, the function should return [1, 4, 9, 16, 25].\n\n    Hint: Use a list comprehension to iterate over the input list and square each element.\n\n    \"\"\"\n    return [num**2 for num in nums]\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [1, 4, 9, 16, 25]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list that contains the squared values of the input list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    In this case, the function should return [1, 4, 9, 16, 25].\n\n    Hint: Use a list comprehension to iterate over the input list and square each element.\n\n    \"\"\"\n    return [num**2 for num in nums]", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', determine if there exists a pair\n    of numbers in 'arr' whose sum is equal to 'target'. Return True if such a pair exists, False otherwise.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> bool:\n        \"\"\"\n        Perform a binary search on a sorted list 'arr' to find if 'target' exists in the list.\n        Return True if 'target' is found, False otherwise.\n        \"\"\"\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False\n\n    n = len(arr)\n    for i in range(n):\n        complement = target - arr[i]\n        if binary_search(arr[i+1:], complement):\n            return True\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 383, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', determine if there exists a pair\n    of numbers in 'arr' whose sum is equal to 'target'. Return True if such a pair exists, False otherwise.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> bool:\n        \"\"\"\n        Perform a binary search on a sorted list 'arr' to find if 'target' exists in the list.\n        Return True if 'target' is found, False otherwise.\n        \"\"\"\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False\n\n    n = len(arr)\n    for i in range(n):\n        complement = target - arr[i]\n        if binary_search(arr[i+1:], complement):\n            return True\n\n    return False", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers arr, determine if there exists two distinct indices i and j in the array such that\n    arr[i] + arr[j] = target. Implement your solution with a time complexity of O(n), where n is the length of arr.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation:\n    There exist distinct indices 2 and 3 such that arr[2] + arr[3] = 3 + 4 = 7.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    return arr\n\narr = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(arr, target), target)\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers arr, determine if there exists two distinct indices i and j in the array such that\n    arr[i] + arr[j] = target. Implement your solution with a time complexity of O(n), where n is the length of arr.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation:\n    There exist distinct indices 2 and 3 such that arr[2] + arr[3] = 3 + 4 = 7.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(arr: List[int], target: int) -> List[int]:\n    return arr\n\narr = [1, 2, 3, 4, 5]\ntarget = 7", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace\n    and initial word order.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation:\n    The words \"Hello\" and \"World\" are reversed while the whitespace remains the same.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g(s: str) -> str:\n    return s\n\ns = \"Hello World\"\nassert f(g(s)) == \"olleH dlroW\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace\n    and initial word order.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation:\n    The words \"Hello\" and \"World\" are reversed while the whitespace remains the same.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)", "solution_func": "def g(s: str) -> str:\n    return s\n\ns = \"Hello World\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence using recursion.\n\n    Example:\n    Input: n = 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int) -> int:\n    return n\n\nn = 6\nassert f(g(n)) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence using recursion.\n\n    Example:\n    Input: n = 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g(n: int) -> int:\n    return n\n\nn = 6", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    If the target value is not found in the array, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 7) == 6\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    If the target value is not found in the array, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a graph, find the shortest path from the start node to the end node using breadth-first search.\n    Return the length of the shortest path.\n    If there is no path from the start node to the end node, return -1.\n    \"\"\"\n\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        node, distance = queue.pop(0)\n\n        if node == end:\n            return distance\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for neighbor, weight in enumerate(graph[node]):\n            if weight > 0:\n                queue.append((neighbor, distance + weight))\n\n    return -1\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0],\n        [0, 1, 1, 0, 1, 1],\n        [0, 0, 1, 1, 0, 1],\n        [0, 0, 0, 1, 1, 0]\n    ]\n\nassert f(g(), 0, 5) == 3\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0], "idx_generation": 384, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a graph, find the shortest path from the start node to the end node using breadth-first search.\n    Return the length of the shortest path.\n    If there is no path from the start node to the end node, return -1.\n    \"\"\"\n\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        node, distance = queue.pop(0)\n\n        if node == end:\n            return distance\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for neighbor, weight in enumerate(graph[node]):\n            if weight > 0:\n                queue.append((neighbor, distance + weight))\n\n    return -1", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0],\n        [0, 1, 1, 0, 1, 1],\n        [0, 0, 1, 1, 0, 1],\n        [0, 0, 0, 1, 1, 0]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int, steps: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return float('inf')\n\n        if (row, col) == (rows-1, cols-1):\n            return steps\n\n        grid[row][col] = 0\n\n        min_steps = float('inf')\n\n        min_steps = min(min_steps, dfs(row-1, col, steps+1))\n        min_steps = min(min_steps, dfs(row+1, col, steps+1))\n        min_steps = min(min_steps, dfs(row, col-1, steps+1))\n        min_steps = min(min_steps, dfs(row, col+1, steps+1))\n\n        grid[row][col] = 1\n\n        return min_steps\n\n    return dfs(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]\n\nassert f(g()) == 8\n\n", "emb": [0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int, steps: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return float('inf')\n\n        if (row, col) == (rows-1, cols-1):\n            return steps\n\n        grid[row][col] = 0\n\n        min_steps = float('inf')\n\n        min_steps = min(min_steps, dfs(row-1, col, steps+1))\n        min_steps = min(min_steps, dfs(row+1, col, steps+1))\n        min_steps = min(min_steps, dfs(row, col-1, steps+1))\n        min_steps = min(min_steps, dfs(row, col+1, steps+1))\n\n        grid[row][col] = 1\n\n        return min_steps\n\n    return dfs(0, 0, 0)", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]", "map_ix": [0, 1, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find two numbers in the list that sum up to the target.\n    Return a list containing these two numbers.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 12\n    Output: [2, 10]\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\nassert f(*g()) == [2, 10]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 384, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find two numbers in the list that sum up to the target.\n    Return a list containing these two numbers.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 12\n    Output: [2, 10]\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n    Return the maximum sum.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 384, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n    Return the maximum sum.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the index of the target number in the list using binary search.\n    If the target number is not in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 384, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the index of the target number in the list using binary search.\n    If the target number is not in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays that have an equal number of odd and even integers.\n\n    Example:\n    Input: [2, 4, 6, 8, 10]\n    Output: 0\n\n    Explanation: There are no subarrays with an equal number of odd and even integers.\n\n    Input: [1, 2, 3, 4, 5]\n    Output: 2\n\n    Explanation: The subarrays with an equal number of odd and even integers are [2, 3], [1, 2, 3, 4].\n    \"\"\"\n\n    count = 0\n    odd_count = 0\n    even_count = 0\n    prefix_sums = [0]\n\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        prefix_sums.append(odd_count - even_count)\n\n    freq = {}\n    for prefix_sum in prefix_sums:\n        if prefix_sum in freq:\n            count += freq[prefix_sum]\n            freq[prefix_sum] += 1\n        else:\n            freq[prefix_sum] = 1\n\n    return count\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return [nums]\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 384, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays that have an equal number of odd and even integers.\n\n    Example:\n    Input: [2, 4, 6, 8, 10]\n    Output: 0\n\n    Explanation: There are no subarrays with an equal number of odd and even integers.\n\n    Input: [1, 2, 3, 4, 5]\n    Output: 2\n\n    Explanation: The subarrays with an equal number of odd and even integers are [2, 3], [1, 2, 3, 4].\n    \"\"\"\n\n    count = 0\n    odd_count = 0\n    even_count = 0\n    prefix_sums = [0]\n\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        prefix_sums.append(odd_count - even_count)\n\n    freq = {}\n    for prefix_sum in prefix_sums:\n        if prefix_sum in freq:\n            count += freq[prefix_sum]\n            freq[prefix_sum] += 1\n        else:\n            freq[prefix_sum] = 1\n\n    return count", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return [nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Determine if string s can be transformed into string t by rearranging the characters.\n    \"\"\"\n    return sorted(s) == sorted(t)\ndef g():\n    return ('abc', 'bac')\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Determine if string s can be transformed into string t by rearranging the characters.\n    \"\"\"\n    return sorted(s) == sorted(t)", "solution_func": "def g():\n    return ('abc', 'bac')", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(g: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency matrix, determine if there exists a topological ordering of the nodes.\n    \"\"\"\n    n = len(g)\n    incomings = [0] * n\n    for row in g:\n        for col in range(n):\n            if row[col] == 1:\n                incomings[col] += 1\n    queue = []\n    for i in range(n):\n        if incomings[i] == 0:\n            queue.append(i)\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for col in range(n):\n            if g[node][col] == 1:\n                incomings[col] -= 1\n                if incomings[col] == 0:\n                    queue.append(col)\n    return len(order) == n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(g: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency matrix, determine if there exists a topological ordering of the nodes.\n    \"\"\"\n    n = len(g)\n    incomings = [0] * n\n    for row in g:\n        for col in range(n):\n            if row[col] == 1:\n                incomings[col] += 1\n    queue = []\n    for i in range(n):\n        if incomings[i] == 0:\n            queue.append(i)\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for col in range(n):\n            if g[node][col] == 1:\n                incomings[col] -= 1\n                if incomings[col] == 0:\n                    queue.append(col)\n    return len(order) == n", "solution_func": "def g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string s is a palindrome, considering only alphanumeric characters and ignoring cases.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\ndef g():\n    return 'A man, a plan, a canal: Panama'\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string s is a palindrome, considering only alphanumeric characters and ignoring cases.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]", "solution_func": "def g():\n    return 'A man, a plan, a canal: Panama'", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of unique combinations of numbers from the list that add up to the target value.\n    Return the count of such combinations.\n\n    Sample input:\n    nums = [2, 3, 5], target = 8\n\n    Sample output:\n    3\n\n    Explanation:\n    There are 3 unique combinations of numbers from the list [2, 3, 5] that add up to 8: [2, 2, 2, 2], [2, 3, 3], and [3, 5].\n    \"\"\"\n    nums.sort()\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if num > i:\n                break\n            dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [2, 3, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 385, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of unique combinations of numbers from the list that add up to the target value.\n    Return the count of such combinations.\n\n    Sample input:\n    nums = [2, 3, 5], target = 8\n\n    Sample output:\n    3\n\n    Explanation:\n    There are 3 unique combinations of numbers from the list [2, 3, 5] that add up to 8: [2, 2, 2, 2], [2, 3, 3], and [3, 5].\n    \"\"\"\n    nums.sort()\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if num > i:\n                break\n            dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    nums = [2, 3, 5]\n    target = 8\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr and an integer k, find the kth smallest element in the array.\n\n    Example:\n    arr = [7, 10, 4, 3, 20, 15]\n    k = 3\n\n    The function should return 7, since the 3rd smallest element in the array is 7.\n    \"\"\"\n    arr.sort()\n    return arr[k - 1]\n\ndef g():\n    arr = [7, 10, 4, 3, 20, 15]\n    k = 3\n    return arr, k\n\nassert f(*g()) == 7\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array arr and an integer k, find the kth smallest element in the array.\n\n    Example:\n    arr = [7, 10, 4, 3, 20, 15]\n    k = 3\n\n    The function should return 7, since the 3rd smallest element in the array is 7.\n    \"\"\"\n    arr.sort()\n    return arr[k - 1]", "solution_func": "def g():\n    arr = [7, 10, 4, 3, 20, 15]\n    k = 3\n    return arr, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of operations required to make the sum of the list equal to the target.\n    An operation involves either adding or subtracting a number from the list.\n    Return the minimum number of operations.\n\n    Sample input:\n    nums = [4, 2, 3], target = 7\n\n    Sample output:\n    2\n\n    Explanation:\n    The minimum number of operations required is 2. We can subtract 2 from the list to get [4, 1, 3], and then add 1 to the list to get [5, 1, 3], which sums up to the target value of 7.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    left = 0\n    right = n - 1\n    count = 0\n\n    while left <= right:\n        if nums[left] + nums[right] == target:\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] < target:\n            nums[left] = nums[left] + nums[right]\n            left += 1\n            count += 1\n        else:\n            nums[right] = nums[right] - nums[left]\n            right -= 1\n            count += 1\n\n    return count\n\ndef g():\n    nums = [4, 2, 3]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 385, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of operations required to make the sum of the list equal to the target.\n    An operation involves either adding or subtracting a number from the list.\n    Return the minimum number of operations.\n\n    Sample input:\n    nums = [4, 2, 3], target = 7\n\n    Sample output:\n    2\n\n    Explanation:\n    The minimum number of operations required is 2. We can subtract 2 from the list to get [4, 1, 3], and then add 1 to the list to get [5, 1, 3], which sums up to the target value of 7.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    left = 0\n    right = n - 1\n    count = 0\n\n    while left <= right:\n        if nums[left] + nums[right] == target:\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] < target:\n            nums[left] = nums[left] + nums[right]\n            left += 1\n            count += 1\n        else:\n            nums[right] = nums[right] - nums[left]\n            right -= 1\n            count += 1\n\n    return count", "solution_func": "def g():\n    nums = [4, 2, 3]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 385, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    dp = [1] * len(nums)\n    max_length = 1\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n\n    return max_length\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 385, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    dp = [1] * len(nums)\n    max_length = 1\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n\n    return max_length", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, count the number of connected components in the graph.\n    Return the count of connected components.\n\n    Example:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n\n    The graph has 2 connected components, so the function should return 2.\n    \"\"\"\n    visited = set()\n    count = 0\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                dfs(neighbor)\n\n    for node in range(len(graph)):\n        if node not in visited:\n            count += 1\n            dfs(node)\n\n    return count\n\ndef g():\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    return graph\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 385, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, count the number of connected components in the graph.\n    Return the count of connected components.\n\n    Example:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n\n    The graph has 2 connected components, so the function should return 2.\n    \"\"\"\n    visited = set()\n    count = 0\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                dfs(neighbor)\n\n    for node in range(len(graph)):\n        if node not in visited:\n            count += 1\n            dfs(node)\n\n    return count", "solution_func": "def g():\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g(nums=[-10, -10, 1, 3, 2]):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums\n\nassert f(*g()) == 300\n\n", "emb": null, "idx_generation": 386, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g(nums=[-10, -10, 1, 3, 2]):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    queue = [start]\n    \n    while queue:\n        node = queue.pop(0)\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    return False\n\ndef g(graph={0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}, start=2, end=3):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return graph, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 386, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    queue = [start]\n    \n    while queue:\n        node = queue.pop(0)\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    return False", "solution_func": "def g(graph={0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}, start=2, end=3):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n    \n    return factorial\n\ndef g(n=5):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return n\n\nassert f(g()) == 120\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n    \n    return factorial", "solution_func": "def g(n=5):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of bars in a histogram, find the largest rectangle that can be formed by the bars.\n    Return the area of the largest rectangle.\n\n    Example:\n    heights = [2, 1, 5, 6, 2, 3]\n    The largest rectangle that can be formed is [5, 6, 2], with an area of 10.\n    Therefore, the function should return 10.\n    \"\"\"\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i - stack[-1] - 1 if stack else i)\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g() -> List[int]:\n    return [2, 1, 5, 6, 2, 3]\n\nassert f(g()) == 10\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 386, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of bars in a histogram, find the largest rectangle that can be formed by the bars.\n    Return the area of the largest rectangle.\n\n    Example:\n    heights = [2, 1, 5, 6, 2, 3]\n    The largest rectangle that can be formed is [5, 6, 2], with an area of 10.\n    Therefore, the function should return 10.\n    \"\"\"\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i - stack[-1] - 1 if stack else i)\n        max_area = max(max_area, area)\n\n    return max_area", "solution_func": "def g() -> List[int]:\n    return [2, 1, 5, 6, 2, 3]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, find the number of paths from the source node to the destination node.\n    Return the number of paths.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    The number of paths from node 0 to node 3 is 2.\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node: int, destination: int) -> int:\n        if node == destination:\n            return 1\n        count = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                count += dfs(neighbor, destination)\n        return count\n\n    source = 0\n    destination = len(graph) - 1\n\n    return dfs(source, destination)\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, find the number of paths from the source node to the destination node.\n    Return the number of paths.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    The number of paths from node 0 to node 3 is 2.\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node: int, destination: int) -> int:\n        if node == destination:\n            return 1\n        count = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                count += dfs(neighbor, destination)\n        return count\n\n    source = 0\n    destination = len(graph) - 1\n\n    return dfs(source, destination)", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum possible by starting at the top-left corner and moving only down or right,\n    and ending at the bottom-right corner.\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The maximum sum possible is 7, following the path: 1 -> 3 -> 1 -> 1 -> 1\n    Therefore, the function should return 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 386, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum possible by starting at the top-left corner and moving only down or right,\n    and ending at the bottom-right corner.\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The maximum sum possible is 7, following the path: 1 -> 3 -> 1 -> 1 -> 1\n    Therefore, the function should return 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list whose XOR is equal to k\"\"\"\n    return any(nums[i] ^ nums[j] == k for i in range(len(nums)) for j in range(i+1, len(nums)))\n\ndef g(n: int, k: int):\n    nums = [i for i in range(n)]\n    return nums\n\nassert f(g(10, 5)) == True\n", "emb": null, "idx_generation": 386, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list whose XOR is equal to k\"\"\"\n    return any(nums[i] ^ nums[j] == k for i in range(len(nums)) for j in range(i+1, len(nums)))", "solution_func": "def g(n: int, k: int):\n    nums = [i for i in range(n)]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if there exists a substring of length k in s that contains all distinct characters\"\"\"\n    return any(len(set(s[i:i+k])) == k for i in range(len(s)-k+1))\n\ndef g(s: str, k: int):\n    return s\n\nassert f(g('abcabcde', 3)) == True\n", "emb": null, "idx_generation": 386, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if there exists a substring of length k in s that contains all distinct characters\"\"\"\n    return any(len(set(s[i:i+k])) == k for i in range(len(s)-k+1))", "solution_func": "def g(s: str, k: int):\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target\"\"\"\n    nums.sort()\n    i, j = 0, len(nums)-1\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return True\n        elif nums[i] + nums[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5], 7)) == True\n", "emb": null, "idx_generation": 386, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target\"\"\"\n    nums.sort()\n    i, j = 0, len(nums)-1\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return True\n        elif nums[i] + nums[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False", "solution_func": "def g(nums: List[int], target: int):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    # Function to find the maximum XOR value in a subarray\n    def max_xor_in_subarray(arr: List[int]) -> int:\n        n = len(arr)\n        max_xor = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                xor = arr[i] ^ arr[j]\n                max_xor = max(max_xor, xor)\n\n        return max_xor\n\n    # Sort the array in descending order\n    nums.sort(reverse=True)\n\n    # Find the maximum XOR value in the entire array\n    max_xor = max_xor_in_subarray(nums)\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 386, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    # Function to find the maximum XOR value in a subarray\n    def max_xor_in_subarray(arr: List[int]) -> int:\n        n = len(arr)\n        max_xor = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                xor = arr[i] ^ arr[j]\n                max_xor = max(max_xor, xor)\n\n        return max_xor\n\n    # Sort the array in descending order\n    nums.sort(reverse=True)\n\n    # Find the maximum XOR value in the entire array\n    max_xor = max_xor_in_subarray(nums)\n\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph, determine if there is a cycle in it.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3, 1]]\n\n    The graph contains a cycle: 1 -> 2 -> 3 -> 1\n\n    Therefore, the function should return True.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and detect cycles.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    graph = [[1, 2], [2, 3], [3, 1]]\n    return graph\n\nassert f(g())\n", "emb": null, "idx_generation": 387, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph, determine if there is a cycle in it.\n\n    Example:\n    graph = [[1, 2], [2, 3], [3, 1]]\n\n    The graph contains a cycle: 1 -> 2 -> 3 -> 1\n\n    Therefore, the function should return True.\n\n    Hint: Use depth-first search (DFS) to traverse the graph and detect cycles.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False", "solution_func": "def g():\n    graph = [[1, 2], [2, 3], [3, 1]]\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given positive integer n is a perfect square.\n\n    Example:\n    n = 25\n\n    25 is a perfect square since 5^2 = 25.\n\n    Therefore, the function should return True.\n\n    Hint: Use mathematical properties of perfect squares.\n    \"\"\"\n    if n < 0:\n        return False\n\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n\n\ndef g():\n    n = 25\n    return n\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given positive integer n is a perfect square.\n\n    Example:\n    n = 25\n\n    25 is a perfect square since 5^2 = 25.\n\n    Therefore, the function should return True.\n\n    Hint: Use mathematical properties of perfect squares.\n    \"\"\"\n    if n < 0:\n        return False\n\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n", "solution_func": "def g():\n    n = 25\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits in a binary representation of a given integer n.\n\n    Example:\n    n = 10\n\n    The binary representation of 10 is 1010, which contains 2 set bits.\n\n    Therefore, the function should return 2.\n\n    Hint: Use bitwise operations to count the set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits in a binary representation of a given integer n.\n\n    Example:\n    n = 10\n\n    The binary representation of 10 is 1010, which contains 2 set bits.\n\n    Therefore, the function should return 2.\n\n    Hint: Use bitwise operations to count the set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the target value in the array using binary search.\n    If the target value is found, return its index. Otherwise, return -1.\n\n    Example:\n    Input: arr = [2, 5, 7, 10, 15, 20], target = 10\n    Output: 3 (The target value 10 is found at index 3)\n\n    Hint: Use a binary search algorithm to efficiently search for the target value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 5, 7, 10, 15, 20], 10)\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the target value in the array using binary search.\n    If the target value is found, return its index. Otherwise, return -1.\n\n    Example:\n    Input: arr = [2, 5, 7, 10, 15, 20], target = 10\n    Output: 3 (The target value 10 is found at index 3)\n\n    Hint: Use a binary search algorithm to efficiently search for the target value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 5, 7, 10, 15, 20], 10)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n    A subarray is a contiguous subsequence of the array.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The maximum subarray sum is obtained from the subarray [4, -1, 2, 1])\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum in a single pass.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n    A subarray is a contiguous subsequence of the array.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The maximum subarray sum is obtained from the subarray [4, -1, 2, 1])\n\n    Hint: Use Kadane's algorithm to find the maximum subarray sum in a single pass.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: [0, 1] (The numbers at indices 0 and 1, i.e. 2 and 7, sum up to 9)\n\n    Hint: Use a two-pointer technique to find the two numbers that sum up to the target value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 387, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: [0, 1] (The numbers at indices 0 and 1, i.e. 2 and 7, sum up to 9)\n\n    Hint: Use a two-pointer technique to find the two numbers that sum up to the target value.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and a target integer, find two numbers such that they add up to the target.\n    Return the indices of the two numbers in the input array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of numbers at indices 0 and 1 is equal to the target value 9.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 387, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and a target integer, find two numbers such that they add up to the target.\n    Return the indices of the two numbers in the input array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of numbers at indices 0 and 1 is equal to the target value 9.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as a dictionary where the keys are nodes and the values are lists of neighboring nodes,\n    determine if the graph is bipartite. A graph is bipartite if it is possible to split its nodes into two independent sets,\n    such that there is no edge between nodes of the same set.\n\n    Example:\n    Input: graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}\n    Output: True\n\n    Explanation: The graph can be divided into two sets: {0, 2} and {1, 3}, and there are no edges between nodes of the same set.\n    \"\"\"\n    colors = {}\n\n    def dfs(node, color):\n        if node in colors:\n            return colors[node] == color\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not dfs(neighbor, 1 - color):\n                return False\n        return True\n\n    for node in graph:\n        if node not in colors:\n            if not dfs(node, 0):\n                return False\n\n    return True\n\ndef g():\n    graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}\n    return graph\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 387, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as a dictionary where the keys are nodes and the values are lists of neighboring nodes,\n    determine if the graph is bipartite. A graph is bipartite if it is possible to split its nodes into two independent sets,\n    such that there is no edge between nodes of the same set.\n\n    Example:\n    Input: graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}\n    Output: True\n\n    Explanation: The graph can be divided into two sets: {0, 2} and {1, 3}, and there are no edges between nodes of the same set.\n    \"\"\"\n    colors = {}\n\n    def dfs(node, color):\n        if node in colors:\n            return colors[node] == color\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not dfs(neighbor, 1 - color):\n                return False\n        return True\n\n    for node in graph:\n        if node not in colors:\n            if not dfs(node, 0):\n                return False\n\n    return True", "solution_func": "def g():\n    graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring in the string.\n\n    Example:\n    Input: string = \"babad\"\n    Output: \"bab\"\n\n    Explanation: The longest palindromic substring in the string is \"bab\".\n    \"\"\"\n    n = len(string)\n    longest_palindrome = \"\"\n\n    def expand_around_center(left, right):\n        while left >= 0 and right < n and string[left] == string[right]:\n            left -= 1\n            right += 1\n        return string[left + 1:right]\n\n    for i in range(n):\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n\n    return longest_palindrome\n\ndef g():\n    string = \"babad\"\n    return string\n\nassert f(*g()) == \"bab\"\n", "emb": null, "idx_generation": 387, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic substring in the string.\n\n    Example:\n    Input: string = \"babad\"\n    Output: \"bab\"\n\n    Explanation: The longest palindromic substring in the string is \"bab\".\n    \"\"\"\n    n = len(string)\n    longest_palindrome = \"\"\n\n    def expand_around_center(left, right):\n        while left >= 0 and right < n and string[left] == string[right]:\n            left -= 1\n            right += 1\n        return string[left + 1:right]\n\n    for i in range(n):\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n\n    return longest_palindrome", "solution_func": "def g():\n    string = \"babad\"\n    return string", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nPython\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return arr, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 387, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nPython\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(arr=[1, 3, 5, 7, 9], target=5):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum square submatrix where all elements are 1s.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4 (The maximum square submatrix with all 1s is the 2x2 submatrix in the top-left corner)\n\n    Hint: This problem can be solved using dynamic programming and bit manipulation.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_side = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side\n\ndef g():\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum square submatrix where all elements are 1s.\n\n    Example:\n    Input: \n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4 (The maximum square submatrix with all 1s is the 2x2 submatrix in the top-left corner)\n\n    Hint: This problem can be solved using dynamic programming and bit manipulation.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_side = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side", "solution_func": "def g():\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from top-left to bottom-right in a grid of size n x n,\n    where each cell can be either empty or blocked.\n\n    Example:\n    Input: 3\n    Output: 2 (There are 2 unique paths: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2))\n\n    Hint: This problem can be solved using dynamic programming and recursion.\n    \"\"\"\n    def count_paths(i: int, j: int, memo: dict) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n or grid[i][j] == 1:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        right_paths = count_paths(i, j+1, memo)\n        down_paths = count_paths(i+1, j, memo)\n        memo[(i, j)] = right_paths + down_paths\n        return memo[(i, j)]\n\n    grid = [[0] * n for _ in range(n)]\n    memo = {}\n    return count_paths(0, 0, memo)\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 388, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from top-left to bottom-right in a grid of size n x n,\n    where each cell can be either empty or blocked.\n\n    Example:\n    Input: 3\n    Output: 2 (There are 2 unique paths: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) and (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2))\n\n    Hint: This problem can be solved using dynamic programming and recursion.\n    \"\"\"\n    def count_paths(i: int, j: int, memo: dict) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n or grid[i][j] == 1:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        right_paths = count_paths(i, j+1, memo)\n        down_paths = count_paths(i+1, j, memo)\n        memo[(i, j)] = right_paths + down_paths\n        return memo[(i, j)]\n\n    grid = [[0] * n for _ in range(n)]\n    memo = {}\n    return count_paths(0, 0, memo)", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum product of a submatrix where all elements are positive.\n\n    Example:\n    Input:\n    matrix = [\n        [2, -1, 3],\n        [4, 2, -2],\n        [1, 3, 4]\n    ]\n    Output: 48 (The maximum product of a submatrix where all elements are positive is 2 * 4 * 3 * 4 = 48)\n\n    Hint: This problem can be solved using dynamic programming and recursion.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    max_product = float('-inf')\n    dp_max = [[0] * (n + 1) for _ in range(m + 1)]\n    dp_min = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] > 0:\n                dp_max[i][j] = max(dp_max[i - 1][j], dp_max[i][j - 1], dp_max[i - 1][j - 1]) * matrix[i - 1][j - 1]\n                dp_min[i][j] = min(dp_min[i - 1][j], dp_min[i][j - 1], dp_min[i - 1][j - 1]) * matrix[i - 1][j - 1]\n            elif matrix[i - 1][j - 1] < 0:\n                dp_max[i][j] = min(dp_min[i - 1][j], dp_min[i][j - 1], dp_min[i - 1][j - 1]) * matrix[i - 1][j - 1]\n                dp_min[i][j] = max(dp_max[i - 1][j], dp_max[i][j - 1], dp_max[i - 1][j - 1]) * matrix[i - 1][j - 1]\n            else:\n                dp_max[i][j] = 0\n                dp_min[i][j] = 0\n\n            max_product = max(max_product, dp_max[i][j])\n\n    return max_product\n\ndef g():\n    return [\n        [2, -1, 3],\n        [4, 2, -2],\n        [1, 3, 4]\n    ]\n\nassert f(g()) == 48\n\n", "emb": null, "idx_generation": 388, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum product of a submatrix where all elements are positive.\n\n    Example:\n    Input:\n    matrix = [\n        [2, -1, 3],\n        [4, 2, -2],\n        [1, 3, 4]\n    ]\n    Output: 48 (The maximum product of a submatrix where all elements are positive is 2 * 4 * 3 * 4 = 48)\n\n    Hint: This problem can be solved using dynamic programming and recursion.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    max_product = float('-inf')\n    dp_max = [[0] * (n + 1) for _ in range(m + 1)]\n    dp_min = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] > 0:\n                dp_max[i][j] = max(dp_max[i - 1][j], dp_max[i][j - 1], dp_max[i - 1][j - 1]) * matrix[i - 1][j - 1]\n                dp_min[i][j] = min(dp_min[i - 1][j], dp_min[i][j - 1], dp_min[i - 1][j - 1]) * matrix[i - 1][j - 1]\n            elif matrix[i - 1][j - 1] < 0:\n                dp_max[i][j] = min(dp_min[i - 1][j], dp_min[i][j - 1], dp_min[i - 1][j - 1]) * matrix[i - 1][j - 1]\n                dp_min[i][j] = max(dp_max[i - 1][j], dp_max[i][j - 1], dp_max[i - 1][j - 1]) * matrix[i - 1][j - 1]\n            else:\n                dp_max[i][j] = 0\n                dp_min[i][j] = 0\n\n            max_product = max(max_product, dp_max[i][j])\n\n    return max_product", "solution_func": "def g():\n    return [\n        [2, -1, 3],\n        [4, 2, -2],\n        [1, 3, 4]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water, count the number of islands. \n    An island is formed by connecting adjacent lands horizontally or vertically.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> None:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(i - 1, j, grid)\n        dfs(i + 1, j, grid)\n        dfs(i, j - 1, grid)\n        dfs(i, j + 1, grid)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j, grid)\n                count += 1\n\n    return count\n\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 388, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water, count the number of islands. \n    An island is formed by connecting adjacent lands horizontally or vertically.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> None:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(i - 1, j, grid)\n        dfs(i + 1, j, grid)\n        dfs(i, j - 1, grid)\n        dfs(i, j + 1, grid)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j, grid)\n                count += 1\n\n    return count", "solution_func": "def g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water,\n    find the perimeter of the island with the maximum area.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return 0\n\n        grid[i][j] = -1\n\n        perimeter = 4\n        perimeter -= dfs(i - 1, j, grid)\n        perimeter -= dfs(i + 1, j, grid)\n        perimeter -= dfs(i, j - 1, grid)\n        perimeter -= dfs(i, j + 1, grid)\n\n        return perimeter\n\n    max_area = 0\n    max_perimeter = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(i, j, grid)\n                if area > max_area:\n                    max_area = area\n                    max_perimeter = dfs(i, j, grid)\n\n    return max_perimeter\n\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\n\nassert f(g()) == 14\n", "emb": null, "idx_generation": 388, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water,\n    find the perimeter of the island with the maximum area.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return 0\n\n        grid[i][j] = -1\n\n        perimeter = 4\n        perimeter -= dfs(i - 1, j, grid)\n        perimeter -= dfs(i + 1, j, grid)\n        perimeter -= dfs(i, j - 1, grid)\n        perimeter -= dfs(i, j + 1, grid)\n\n        return perimeter\n\n    max_area = 0\n    max_perimeter = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(i, j, grid)\n                if area > max_area:\n                    max_area = area\n                    max_perimeter = dfs(i, j, grid)\n\n    return max_perimeter", "solution_func": "def g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water,\n    find the number of islands that have an area greater than or equal to k.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return 0\n\n        grid[i][j] = -1\n\n        area = 1\n        area += dfs(i - 1, j, grid)\n        area += dfs(i + 1, j, grid)\n        area += dfs(i, j - 1, grid)\n        area += dfs(i, j + 1, grid)\n\n        return area\n\n    count = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(i, j, grid)\n                if area >= k:\n                    count += 1\n\n    return count\n\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\n\nassert f(g(), k=5) == 2\n", "emb": null, "idx_generation": 388, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water,\n    find the number of islands that have an area greater than or equal to k.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return 0\n\n        grid[i][j] = -1\n\n        area = 1\n        area += dfs(i - 1, j, grid)\n        area += dfs(i + 1, j, grid)\n        area += dfs(i, j - 1, grid)\n        area += dfs(i, j + 1, grid)\n\n        return area\n\n    count = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                area = dfs(i, j, grid)\n                if area >= k:\n                    count += 1\n\n    return count", "solution_func": "def g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n    All occurrences of a character must be replaced with another character while preserving the order of characters.\n    No two characters may map to the same character, but a character may map to itself.\n\n    Sample Input:\n    s = \"egg\"\n    t = \"add\"\n\n    Sample Output:\n    True\n\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    mapping = {}\n    mapped_chars = set()\n    \n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n        \n        if char_s in mapping:\n            if mapping[char_s] != char_t:\n                return False\n        elif char_t in mapped_chars:\n            return False\n        else:\n            mapping[char_s] = char_t\n            mapped_chars.add(char_t)\n    \n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n    All occurrences of a character must be replaced with another character while preserving the order of characters.\n    No two characters may map to the same character, but a character may map to itself.\n\n    Sample Input:\n    s = \"egg\"\n    t = \"add\"\n\n    Sample Output:\n    True\n\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    mapping = {}\n    mapped_chars = set()\n    \n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n        \n        if char_s in mapping:\n            if mapping[char_s] != char_t:\n                return False\n        elif char_t in mapped_chars:\n            return False\n        else:\n            mapping[char_s] = char_t\n            mapped_chars.add(char_t)\n    \n    return True", "solution_func": "def g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth term of the count-and-say sequence.\n    The count-and-say sequence is the sequence of integers where each term is the description of the previous term.\n    The description of a term is formed by reading the previous term and counting the number of digits of each group of consecutive repeating digits.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    111221\n\n    Explanation:\n    The count-and-say sequence starts with \"1\".\n    The second term describes the first term as \"one 1\", which is \"11\".\n    The third term describes the second term as \"two 1s\", which is \"21\".\n    The fourth term describes the third term as \"one 2, then one 1\", which is \"1211\".\n    The fifth term describes the fourth term as \"one 1, then one 2, then two 1s\", which is \"111221\".\n\n    \"\"\"\n    if n == 1:\n        return \"1\"\n    \n    prev_term = f(n-1)\n    count = 1\n    result = \"\"\n    \n    for i in range(1, len(prev_term)):\n        if prev_term[i] != prev_term[i-1]:\n            result += str(count) + prev_term[i-1]\n            count = 1\n        else:\n            count += 1\n    \n    result += str(count) + prev_term[-1]\n    \n    return result\n\ndef g():\n    n = 5\n    return n\n\nassert f(*g()) == \"111221\"\n", "emb": null, "idx_generation": 388, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth term of the count-and-say sequence.\n    The count-and-say sequence is the sequence of integers where each term is the description of the previous term.\n    The description of a term is formed by reading the previous term and counting the number of digits of each group of consecutive repeating digits.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    111221\n\n    Explanation:\n    The count-and-say sequence starts with \"1\".\n    The second term describes the first term as \"one 1\", which is \"11\".\n    The third term describes the second term as \"two 1s\", which is \"21\".\n    The fourth term describes the third term as \"one 2, then one 1\", which is \"1211\".\n    The fifth term describes the fourth term as \"one 1, then one 2, then two 1s\", which is \"111221\".\n\n    \"\"\"\n    if n == 1:\n        return \"1\"\n    \n    prev_term = f(n-1)\n    count = 1\n    result = \"\"\n    \n    for i in range(1, len(prev_term)):\n        if prev_term[i] != prev_term[i-1]:\n            result += str(count) + prev_term[i-1]\n            count = 1\n        else:\n            count += 1\n    \n    result += str(count) + prev_term[-1]\n    \n    return result", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Sample Input:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    Sample Output:\n    5\n\n    Explanation:\n    The 2nd largest element in the list is 5.\n\n    \"\"\"\n    def partition(nums, low, high):\n        pivot = nums[low]\n        i = low + 1\n        j = high\n        \n        while True:\n            while i <= j and nums[i] <= pivot:\n                i += 1\n            while i <= j and nums[j] >= pivot:\n                j -= 1\n            \n            if i <= j:\n                nums[i], nums[j] = nums[j], nums[i]\n            else:\n                break\n        \n        nums[low], nums[j] = nums[j], nums[low]\n        \n        return j\n    \n    def quick_select(nums, low, high, k):\n        if low == high:\n            return nums[low]\n        \n        pivot_index = partition(nums, low, high)\n        \n        if pivot_index == k:\n            return nums[pivot_index]\n        elif pivot_index < k:\n            return quick_select(nums, pivot_index + 1, high, k)\n        else:\n            return quick_select(nums, low, pivot_index - 1, k)\n    \n    return quick_select(nums, 0, len(nums) - 1, len(nums) - k)\n\ndef g():\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    return nums, k\n\nassert f(*g()) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 388, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Sample Input:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    Sample Output:\n    5\n\n    Explanation:\n    The 2nd largest element in the list is 5.\n\n    \"\"\"\n    def partition(nums, low, high):\n        pivot = nums[low]\n        i = low + 1\n        j = high\n        \n        while True:\n            while i <= j and nums[i] <= pivot:\n                i += 1\n            while i <= j and nums[j] >= pivot:\n                j -= 1\n            \n            if i <= j:\n                nums[i], nums[j] = nums[j], nums[i]\n            else:\n                break\n        \n        nums[low], nums[j] = nums[j], nums[low]\n        \n        return j\n    \n    def quick_select(nums, low, high, k):\n        if low == high:\n            return nums[low]\n        \n        pivot_index = partition(nums, low, high)\n        \n        if pivot_index == k:\n            return nums[pivot_index]\n        elif pivot_index < k:\n            return quick_select(nums, pivot_index + 1, high, k)\n        else:\n            return quick_select(nums, low, pivot_index - 1, k)\n    \n    return quick_select(nums, 0, len(nums) - 1, len(nums) - k)", "solution_func": "def g():\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers arr and a target value target,\n    find a pair of numbers in the array that add up to the target.\n    Return the indices of the two numbers as a tuple.\n\n    Example:\n    arr = [1, 2, 3, 4, 5], target = 7\n\n    The sum of the numbers at indices 2 and 4 is 3 + 4 = 7.\n    Therefore, the function should return (2, 4).\n    \"\"\"\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return (-1, -1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == (2, 4)\n\n", "emb": null, "idx_generation": 388, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers arr and a target value target,\n    find a pair of numbers in the array that add up to the target.\n    Return the indices of the two numbers as a tuple.\n\n    Example:\n    arr = [1, 2, 3, 4, 5], target = 7\n\n    The sum of the numbers at indices 2 and 4 is 3 + 4 = 7.\n    Therefore, the function should return (2, 4).\n    \"\"\"\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return (-1, -1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers\n    such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same\n    element twice.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The sum of nums[0] + nums[1] equals 9, so the output is [0, 1].\n    \"\"\"\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []\n\ndef g(nums = [2, 7, 11, 15], target = 9):\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers\n    such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same\n    element twice.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The sum of nums[0] + nums[1] equals 9, so the output is [0, 1].\n    \"\"\"\n\n    complement_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n\n    return []", "solution_func": "def g(nums = [2, 7, 11, 15], target = 9):\n    return (nums, target)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n\n    The Fibonacci sequence is a series of numbers in which each number (Fibonacci number) is\n    the sum of the two preceding ones. It starts with 0 and 1.\n\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th number is 8.\n    \"\"\"\n\n    memo = {}\n\n    def fibonacci(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g(n = 6):\n    return (n,)\n\nassert f(*g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n\n    The Fibonacci sequence is a series of numbers in which each number (Fibonacci number) is\n    the sum of the two preceding ones. It starts with 0 and 1.\n\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th number is 8.\n    \"\"\"\n\n    memo = {}\n\n    def fibonacci(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)", "solution_func": "def g(n = 6):\n    return (n,)", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and an integer target, find the starting and ending position\n    of a given target value.\n\n    If target is not found in the array, return [-1, -1].\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    Input: nums = [5, 7, 7, 8, 8, 10], target = 8\n    Output: [3, 4]\n    \"\"\"\n\n    def binary_search(nums, target, left):\n        lo = 0\n        hi = len(nums)\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if nums[mid] > target or (left and target == nums[mid]):\n                hi = mid\n            else:\n                lo = mid + 1\n\n        return lo\n\n    left_index = binary_search(nums, target, True)\n    if left_index == len(nums) or nums[left_index] != target:\n        return [-1, -1]\n\n    right_index = binary_search(nums, target, False) - 1\n\n    return [left_index, right_index]\n\ndef g(nums = [5, 7, 7, 8, 8, 10], target = 8):\n    return (nums, target)\n\nassert f(*g()) == [3, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and an integer target, find the starting and ending position\n    of a given target value.\n\n    If target is not found in the array, return [-1, -1].\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    Input: nums = [5, 7, 7, 8, 8, 10], target = 8\n    Output: [3, 4]\n    \"\"\"\n\n    def binary_search(nums, target, left):\n        lo = 0\n        hi = len(nums)\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if nums[mid] > target or (left and target == nums[mid]):\n                hi = mid\n            else:\n                lo = mid + 1\n\n        return lo\n\n    left_index = binary_search(nums, target, True)\n    if left_index == len(nums) or nums[left_index] != target:\n        return [-1, -1]\n\n    right_index = binary_search(nums, target, False) - 1\n\n    return [left_index, right_index]", "solution_func": "def g(nums = [5, 7, 7, 8, 8, 10], target = 8):\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: 24\n\n    nums = [-1, -2, -3, -4]\n    Output: -6\n    \"\"\"\n\n    nums.sort()\n\n    # Check the product of the three largest numbers\n    prod1 = nums[-1] * nums[-2] * nums[-3]\n\n    # Check the product of the two smallest numbers and the largest number\n    prod2 = nums[0] * nums[1] * nums[-1]\n\n    # Return the maximum product\n    return max(prod1, prod2)\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: 24\n\n    nums = [-1, -2, -3, -4]\n    Output: -6\n    \"\"\"\n\n    nums.sort()\n\n    # Check the product of the three largest numbers\n    prod1 = nums[-1] * nums[-2] * nums[-3]\n\n    # Check the product of the two smallest numbers and the largest number\n    prod2 = nums[0] * nums[1] * nums[-1]\n\n    # Return the maximum product\n    return max(prod1, prod2)", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding numbers.\n\n    Example:\n    n = 10\n    Output: 10\n    Explanation: The even Fibonacci numbers less than or equal to 10 are 0, 2, and 8. Their sum is 10.\n    \"\"\"\n\n    fib = [0, 1]  # Initialize the Fibonacci sequence with the first two numbers\n\n    # Generate the Fibonacci sequence up to n\n    while fib[-1] <= n:\n        fib.append(fib[-1] + fib[-2])\n\n    # Calculate the sum of all even Fibonacci numbers\n    even_sum = sum(num for num in fib if num <= n and num % 2 == 0)\n\n    return even_sum\n\ndef g():\n    return 10\n\nassert f(g()) == 10\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding numbers.\n\n    Example:\n    n = 10\n    Output: 10\n    Explanation: The even Fibonacci numbers less than or equal to 10 are 0, 2, and 8. Their sum is 10.\n    \"\"\"\n\n    fib = [0, 1]  # Initialize the Fibonacci sequence with the first two numbers\n\n    # Generate the Fibonacci sequence up to n\n    while fib[-1] <= n:\n        fib.append(fib[-1] + fib[-2])\n\n    # Calculate the sum of all even Fibonacci numbers\n    even_sum = sum(num for num in fib if num <= n and num % 2 == 0)\n\n    return even_sum", "solution_func": "def g():\n    return 10", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the number of distinct subsequences of s that form the string \"abc\".\n\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n    Example:\n    s = \"abcabc\"\n    Output: 10\n    Explanation: The distinct subsequences that form the string \"abc\" are:\n    \"abc\", \"ab_c\", \"a_bc\", \"_bc\", \"a__c\", \"_b_c\", \"__c\", \"a___\", \"_b__\", \"____\"\n    \"\"\"\n\n    # Initialize the count of distinct subsequences\n    count = 0\n\n    # Initialize the count of subsequences that end with \"a\", \"b\", and \"c\"\n    count_a = 0\n    count_b = 0\n    count_c = 0\n\n    # Iterate through each character in the string\n    for char in s:\n        if char == \"a\":\n            # The number of subsequences that end with \"a\" is doubled and 1 is added\n            count_a = 2 * count_a + 1\n        elif char == \"b\":\n            # The number of subsequences that end with \"b\" is doubled and the count of subsequences that end with \"a\" is added\n            count_b = 2 * count_b + count_a\n        elif char == \"c\":\n            # The number of subsequences that end with \"c\" is doubled and the count of subsequences that end with \"b\" is added\n            count_c = 2 * count_c + count_b\n\n    # The number of distinct subsequences is the count of subsequences that end with \"c\"\n    count = count_c\n\n    return count\n\ndef g():\n    s = \"abcabc\"\n    return s\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 389, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the number of distinct subsequences of s that form the string \"abc\".\n\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n    Example:\n    s = \"abcabc\"\n    Output: 10\n    Explanation: The distinct subsequences that form the string \"abc\" are:\n    \"abc\", \"ab_c\", \"a_bc\", \"_bc\", \"a__c\", \"_b_c\", \"__c\", \"a___\", \"_b__\", \"____\"\n    \"\"\"\n\n    # Initialize the count of distinct subsequences\n    count = 0\n\n    # Initialize the count of subsequences that end with \"a\", \"b\", and \"c\"\n    count_a = 0\n    count_b = 0\n    count_c = 0\n\n    # Iterate through each character in the string\n    for char in s:\n        if char == \"a\":\n            # The number of subsequences that end with \"a\" is doubled and 1 is added\n            count_a = 2 * count_a + 1\n        elif char == \"b\":\n            # The number of subsequences that end with \"b\" is doubled and the count of subsequences that end with \"a\" is added\n            count_b = 2 * count_b + count_a\n        elif char == \"c\":\n            # The number of subsequences that end with \"c\" is doubled and the count of subsequences that end with \"b\" is added\n            count_c = 2 * count_c + count_b\n\n    # The number of distinct subsequences is the count of subsequences that end with \"c\"\n    count = count_c\n\n    return count", "solution_func": "def g():\n    s = \"abcabc\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items without repetition.\n    Return the result modulo 10^9 + 7.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items without repetition.\n    Return the result modulo 10^9 + 7.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))", "solution_func": "def g():\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 1 to n, where n is the length of the list.\n    Assume that the list contains unique numbers from the range 1 to n (inclusive), except for one missing number.\n    Return the missing number.\n\n    Sample Input:\n    arr = [1, 2, 3, 5, 6, 7, 8, 9]\n\n    Sample Output:\n    4\n\n    Explanation: The missing number in the range from 1 to 9 is 4.\n    \"\"\"\n    n = len(arr) + 1\n    total_sum = n * (n + 1) // 2\n    arr_sum = sum(arr)\n    return total_sum - arr_sum\n\ndef g():\n    arr = [1, 2, 3, 5, 6, 7, 8, 9]\n    return arr\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 1 to n, where n is the length of the list.\n    Assume that the list contains unique numbers from the range 1 to n (inclusive), except for one missing number.\n    Return the missing number.\n\n    Sample Input:\n    arr = [1, 2, 3, 5, 6, 7, 8, 9]\n\n    Sample Output:\n    4\n\n    Explanation: The missing number in the range from 1 to 9 is 4.\n    \"\"\"\n    n = len(arr) + 1\n    total_sum = n * (n + 1) // 2\n    arr_sum = sum(arr)\n    return total_sum - arr_sum", "solution_func": "def g():\n    arr = [1, 2, 3, 5, 6, 7, 8, 9]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n    def fibonacci(num: int) -> int:\n        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        return fibonacci(num - 1) + fibonacci(num - 2)\n\n    return fibonacci(n)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n    def fibonacci(num: int) -> int:\n        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        return fibonacci(num - 1) + fibonacci(num - 2)\n\n    return fibonacci(n)", "solution_func": "def g():\n    n = 6\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, return the k largest elements in the list in sorted order.\n    \"\"\"\n    nums.sort()\n    return nums[-k:]\n\ndef g():\n    nums = [10, 5, 8, 3, 2, 9, 7, 6, 1, 4]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [8, 9, 10]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 389, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, return the k largest elements in the list in sorted order.\n    \"\"\"\n    nums.sort()\n    return nums[-k:]", "solution_func": "def g():\n    nums = [10, 5, 8, 3, 2, 9, 7, 6, 1, 4]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the numbers that can be formed by taking the bitwise OR of any two numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: 7\n\n    Explanation:\n    The bitwise OR of all possible pairs of numbers in the list are as follows:\n    1 | 1 = 1\n    1 | 2 = 3\n    1 | 3 = 3\n    2 | 1 = 3\n    2 | 2 = 2\n    2 | 3 = 3\n    3 | 1 = 3\n    3 | 2 = 3\n    3 | 3 = 3\n\n    The sum of all these numbers is 1 + 3 + 3 + 3 + 2 + 3 + 3 + 3 + 3 = 22.\n    Hence, the output is 22.\n    \"\"\"\n\n    total = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(n):\n            total += nums[i] | nums[j]\n\n    return total\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(*g()) == 7\n\n", "emb": null, "idx_generation": 390, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the numbers that can be formed by taking the bitwise OR of any two numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: 7\n\n    Explanation:\n    The bitwise OR of all possible pairs of numbers in the list are as follows:\n    1 | 1 = 1\n    1 | 2 = 3\n    1 | 3 = 3\n    2 | 1 = 3\n    2 | 2 = 2\n    2 | 3 = 3\n    3 | 1 = 3\n    3 | 2 = 3\n    3 | 3 = 3\n\n    The sum of all these numbers is 1 + 3 + 3 + 3 + 2 + 3 + 3 + 3 + 3 = 22.\n    Hence, the output is 22.\n    \"\"\"\n\n    total = 0\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(n):\n            total += nums[i] | nums[j]\n\n    return total", "solution_func": "def g():\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of set bits (1s) in its binary representation.\n\n    Example:\n    Input: n = 12\n    Output: 2\n\n    Explanation:\n    The binary representation of 12 is 1100.\n    It contains two set bits (1s) at positions 2 and 3.\n    Hence, the output is 2.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n: int = 12):\n    return n\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of set bits (1s) in its binary representation.\n\n    Example:\n    Input: n = 12\n    Output: 2\n\n    Explanation:\n    The binary representation of 12 is 1100.\n    It contains two set bits (1s) at positions 2 and 3.\n    Hence, the output is 2.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count", "solution_func": "def g(n: int = 12):\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the next greater element to its right. If there is no greater element to the right, set it to -1.\n\n    Example:\n    Input: nums = [4, 5, 2, 25]\n    Output: [5, 25, 25, -1]\n\n    Explanation:\n    The next greater element to the right of 4 is 5.\n    The next greater element to the right of 5 is 25.\n    The next greater element to the right of 2 is 25.\n    There is no greater element to the right of 25, so it is set to -1.\n    Hence, the output is [5, 25, 25, -1].\n    \"\"\"\n\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n\n    for i in range(n-1, -1, -1):\n        while stack and stack[-1] <= nums[i]:\n            stack.pop()\n\n        if stack:\n            result[i] = stack[-1]\n\n        stack.append(nums[i])\n\n    return result\n\ndef g():\n    nums = [4, 5, 2, 25]\n    return nums\n\nassert f(*g()) == [5, 25, 25, -1]\n\n", "emb": null, "idx_generation": 390, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the next greater element to its right. If there is no greater element to the right, set it to -1.\n\n    Example:\n    Input: nums = [4, 5, 2, 25]\n    Output: [5, 25, 25, -1]\n\n    Explanation:\n    The next greater element to the right of 4 is 5.\n    The next greater element to the right of 5 is 25.\n    The next greater element to the right of 2 is 25.\n    There is no greater element to the right of 25, so it is set to -1.\n    Hence, the output is [5, 25, 25, -1].\n    \"\"\"\n\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n\n    for i in range(n-1, -1, -1):\n        while stack and stack[-1] <= nums[i]:\n            stack.pop()\n\n        if stack:\n            result[i] = stack[-1]\n\n        stack.append(nums[i])\n\n    return result", "solution_func": "def g():\n    nums = [4, 5, 2, 25]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the longest common prefix among them.\n    Return the length of the longest common prefix.\n    \"\"\"\n    if not words:\n        return 0\n    \n    prefix = \"\"\n    for i in range(len(words[0])):\n        char = words[0][i]\n        for word in words[1:]:\n            if i >= len(word) or word[i] != char:\n                return len(prefix)\n        prefix += char\n    \n    return len(prefix)\n\n\ndef g():\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words\n\nassert f(g()) == 2\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the longest common prefix among them.\n    Return the length of the longest common prefix.\n    \"\"\"\n    if not words:\n        return 0\n    \n    prefix = \"\"\n    for i in range(len(words[0])):\n        char = words[0][i]\n        for word in words[1:]:\n            if i >= len(word) or word[i] != char:\n                return len(prefix)\n        prefix += char\n    \n    return len(prefix)", "solution_func": "def g():\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words", "map_ix": [1, 0, 1, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes start and end,\n    check if there is a path from start to end in the graph.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    \n    return False\n\n\ndef g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"C\", \"D\"],\n        \"C\": [\"D\"],\n        \"D\": [\"E\"],\n        \"E\": []\n    }\n    start = \"A\"\n    end = \"E\"\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 390, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes start and end,\n    check if there is a path from start to end in the graph.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    \n    return False", "solution_func": "def g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"C\", \"D\"],\n        \"C\": [\"D\"],\n        \"D\": [\"E\"],\n        \"E\": []\n    }\n    start = \"A\"\n    end = \"E\"\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a given word in the grid.\n    The word can be found in horizontal, vertical, or diagonal directions.\n    Return the count.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def search(word: str, row: int, col: int, dr: int, dc: int) -> bool:\n        for char in word:\n            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != char:\n                return False\n            row += dr\n            col += dc\n        return True\n    \n    count = 0\n    directions = [(0, 1), (1, 0), (1, 1), (-1, 1)]\n    \n    for row in range(rows):\n        for col in range(cols):\n            for dr, dc in directions:\n                count += search(\"word\", row, col, dr, dc)\n    \n    return count\n\n\ndef g():\n    grid = [\n        [\"a\", \"b\", \"c\", \"d\"],\n        [\"e\", \"f\", \"g\", \"h\"],\n        [\"i\", \"j\", \"k\", \"l\"],\n        [\"m\", \"n\", \"o\", \"p\"]\n    ]\n    return grid\n\nassert f(g()) == 0\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a given word in the grid.\n    The word can be found in horizontal, vertical, or diagonal directions.\n    Return the count.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def search(word: str, row: int, col: int, dr: int, dc: int) -> bool:\n        for char in word:\n            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != char:\n                return False\n            row += dr\n            col += dc\n        return True\n    \n    count = 0\n    directions = [(0, 1), (1, 0), (1, 1), (-1, 1)]\n    \n    for row in range(rows):\n        for col in range(cols):\n            for dr, dc in directions:\n                count += search(\"word\", row, col, dr, dc)\n    \n    return count", "solution_func": "def g():\n    grid = [\n        [\"a\", \"b\", \"c\", \"d\"],\n        [\"e\", \"f\", \"g\", \"h\"],\n        [\"i\", \"j\", \"k\", \"l\"],\n        [\"m\", \"n\", \"o\", \"p\"]\n    ]\n    return grid", "map_ix": [0, 1, 0, 0, 0, 1, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, generate the first n terms of the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: [0, 1, 1, 2, 3, 5]\n    \"\"\"\n    fib = [0, 1]\n\n    for i in range(2, n):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[:n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 6\n    return n\n\nassert f(g()) == [0, 1, 1, 2, 3, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, generate the first n terms of the Fibonacci sequence.\n\n    Example:\n    n = 6\n    Output: [0, 1, 1, 2, 3, 5]\n    \"\"\"\n    fib = [0, 1]\n\n    for i in range(2, n):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[:n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 6\n    return n", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of size m x n, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    columns = len(matrix[0])\n    result = []\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = columns - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n\n        # Traverse right column\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n\n        if top <= bottom:\n            # Traverse bottom row\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n\n        if left <= right:\n            # Traverse left column\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 390, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of size m x n, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    columns = len(matrix[0])\n    result = []\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = columns - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n\n        # Traverse right column\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n\n        if top <= bottom:\n            # Traverse bottom row\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n\n        if left <= right:\n            # Traverse left column\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n\n    return result", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there are two distinct indices i and j in the list such that nums[i] + nums[j] is divisible by k.\n\n    Example:\n    Input: nums = [4, 6, 8, 10], k = 4\n    Output: True\n\n    Explanation:\n    The pairs (4, 8) and (6, 10) have a sum divisible by 4.\n    Hence, the output is True.\n\n    Note: The pairs are considered distinct if the indices are different, i.e., (4, 8) and (8, 4) are different pairs.\n    \"\"\"\n\n    remainder_counts = [0] * k\n\n    for num in nums:\n        remainder = num % k\n        remainder_counts[remainder] += 1\n\n    if remainder_counts[0] > 1:\n        return True\n\n    if k % 2 == 0 and remainder_counts[k // 2] > 1:\n        return True\n\n    for i in range(1, (k + 1) // 2):\n        if remainder_counts[i] != remainder_counts[k - i]:\n            return False\n\n    return True\n\ndef g():\n    nums = [4, 6, 8, 10]\n    k = 4\n    return nums, k\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 390, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there are two distinct indices i and j in the list such that nums[i] + nums[j] is divisible by k.\n\n    Example:\n    Input: nums = [4, 6, 8, 10], k = 4\n    Output: True\n\n    Explanation:\n    The pairs (4, 8) and (6, 10) have a sum divisible by 4.\n    Hence, the output is True.\n\n    Note: The pairs are considered distinct if the indices are different, i.e., (4, 8) and (8, 4) are different pairs.\n    \"\"\"\n\n    remainder_counts = [0] * k\n\n    for num in nums:\n        remainder = num % k\n        remainder_counts[remainder] += 1\n\n    if remainder_counts[0] > 1:\n        return True\n\n    if k % 2 == 0 and remainder_counts[k // 2] > 1:\n        return True\n\n    for i in range(1, (k + 1) // 2):\n        if remainder_counts[i] != remainder_counts[k - i]:\n            return False\n\n    return True", "solution_func": "def g():\n    nums = [4, 6, 8, 10]\n    k = 4\n    return nums, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray such that the sum is less than or equal to a given target.\n\n    Example:\n    nums = [1, -2, 3, 4, -1]\n    target = 5\n\n    f(nums, target) => 5\n    Explanation: The maximum sum of a subarray less than or equal to 5 is [3, 4, -1] with a sum of 6.\n\n    \"\"\"\n\n    def max_sum_subarray(nums, target):\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n        left = 0\n\n        for right in range(n):\n            curr_sum += nums[right]\n            while curr_sum > target:\n                curr_sum -= nums[left]\n                left += 1\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    return max_sum_subarray(nums, target)\n\ndef g():\n    return [1, -2, 3, 4, -1], 5\n\nassert f(*g()) == 5\n\n", "emb": null, "idx_generation": 391, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray such that the sum is less than or equal to a given target.\n\n    Example:\n    nums = [1, -2, 3, 4, -1]\n    target = 5\n\n    f(nums, target) => 5\n    Explanation: The maximum sum of a subarray less than or equal to 5 is [3, 4, -1] with a sum of 6.\n\n    \"\"\"\n\n    def max_sum_subarray(nums, target):\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n        left = 0\n\n        for right in range(n):\n            curr_sum += nums[right]\n            while curr_sum > target:\n                curr_sum -= nums[left]\n                left += 1\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    return max_sum_subarray(nums, target)", "solution_func": "def g():\n    return [1, -2, 3, 4, -1], 5", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    f(s) => 3\n    Explanation: The longest substring without repeating characters is \"abc\" with a length of 3.\n\n    \"\"\"\n\n    def longest_substring(s):\n        n = len(s)\n        max_length = 0\n        left = 0\n        char_index = {}\n\n        for right in range(n):\n            if s[right] in char_index:\n                left = max(left, char_index[s[right]] + 1)\n            char_index[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n    return longest_substring(s)\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 391, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    f(s) => 3\n    Explanation: The longest substring without repeating characters is \"abc\" with a length of 3.\n\n    \"\"\"\n\n    def longest_substring(s):\n        n = len(s)\n        max_length = 0\n        left = 0\n        char_index = {}\n\n        for right in range(n):\n            if s[right] in char_index:\n                left = max(left, char_index[s[right]] + 1)\n            char_index[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n    return longest_substring(s)", "solution_func": "def g():\n    return \"abcabcbb\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    f(nums) => 6\n    Explanation: The maximum sum of a subarray is [4, -1, 2, 1] with a sum of 6.\n\n    \"\"\"\n\n    def max_subarray_sum(nums):\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n\n        for i in range(n):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    return max_subarray_sum(nums)\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 391, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    f(nums) => 6\n    Explanation: The maximum sum of a subarray is [4, -1, 2, 1] with a sum of 6.\n\n    \"\"\"\n\n    def max_subarray_sum(nums):\n        n = len(nums)\n        max_sum = float('-inf')\n        curr_sum = 0\n\n        for i in range(n):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum\n\n    return max_subarray_sum(nums)", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5, 6, 7], target = 9\n    Output: True\n    Explanation: There are two numbers in the list, 2 and 7, that sum up to 9.\n    \"\"\"\n    def binary_search(arr: List[int], left: int, right: int, target: int) -> bool:\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] > target:\n            return binary_search(arr, left, mid - 1, target)\n        else:\n            return binary_search(arr, mid + 1, right, target)\n\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if binary_search(arr, i + 1, len(arr) - 1, complement):\n            return True\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5, 6, 7], 9)\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5, 6, 7], target = 9\n    Output: True\n    Explanation: There are two numbers in the list, 2 and 7, that sum up to 9.\n    \"\"\"\n    def binary_search(arr: List[int], left: int, right: int, target: int) -> bool:\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] > target:\n            return binary_search(arr, left, mid - 1, target)\n        else:\n            return binary_search(arr, mid + 1, right, target)\n\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if binary_search(arr, i + 1, len(arr) - 1, complement):\n            return True\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5, 6, 7], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of elements in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [2, 4, 6, 8, 10], target = 16\n    Output: 2\n    Explanation: The minimum number of elements that sum up to 16 is 2, which can be achieved by selecting 8 and 8 from the list.\n    \"\"\"\n    def subset_sum(arr: List[int], n: int, target: int) -> int:\n        if target == 0:\n            return 0\n        if n == 0 and target != 0:\n            return float('inf')\n        if arr[n-1] > target:\n            return subset_sum(arr, n-1, target)\n        return min(subset_sum(arr, n-1, target), 1 + subset_sum(arr, n-1, target-arr[n-1]))\n\n    return subset_sum(arr, len(arr), target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 4, 6, 8, 10], 16)\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of elements in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [2, 4, 6, 8, 10], target = 16\n    Output: 2\n    Explanation: The minimum number of elements that sum up to 16 is 2, which can be achieved by selecting 8 and 8 from the list.\n    \"\"\"\n    def subset_sum(arr: List[int], n: int, target: int) -> int:\n        if target == 0:\n            return 0\n        if n == 0 and target != 0:\n            return float('inf')\n        if arr[n-1] > target:\n            return subset_sum(arr, n-1, target)\n        return min(subset_sum(arr, n-1, target), 1 + subset_sum(arr, n-1, target-arr[n-1]))\n\n    return subset_sum(arr, len(arr), target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 4, 6, 8, 10], 16)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find the combination of elements in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: [2, 5]\n    Explanation: The elements 2 and 5 from the list sum up to 7.\n    \"\"\"\n    def find_combination(arr: List[int], target: int, current_combination: List[int], result: List[int]) -> None:\n        if target == 0:\n            result.extend(current_combination)\n            return\n        if not arr or target < 0:\n            return\n        \n        find_combination(arr[1:], target, current_combination, result)\n        find_combination(arr[1:], target - arr[0], current_combination + [arr[0]], result)\n\n    result = []\n    find_combination(arr, target, [], result)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == [2, 5]\n\n", "emb": null, "idx_generation": 391, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find the combination of elements in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: [2, 5]\n    Explanation: The elements 2 and 5 from the list sum up to 7.\n    \"\"\"\n    def find_combination(arr: List[int], target: int, current_combination: List[int], result: List[int]) -> None:\n        if target == 0:\n            result.extend(current_combination)\n            return\n        if not arr or target < 0:\n            return\n        \n        find_combination(arr[1:], target, current_combination, result)\n        find_combination(arr[1:], target - arr[0], current_combination + [arr[0]], result)\n\n    result = []\n    find_combination(arr, target, [], result)\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Explanation: 16 is a power of 2 because 2^4 = 16.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    return (n & (n - 1)) == 0\n\ndef g() -> int:\n    \"\"\"\n    Generate a random power of two.\n    \"\"\"\n    n = 8\n    return 2 ** n\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Explanation: 16 is a power of 2 because 2^4 = 16.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    return (n & (n - 1)) == 0", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random power of two.\n    \"\"\"\n    n = 8\n    return 2 ** n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    12\n\n    Explanation: The sum of the first 5 Fibonacci numbers (0, 1, 1, 2, 3) is 0 + 1 + 1 + 2 + 3 = 7.\n    \"\"\"\n    fib = [0, 1]\n\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return sum(fib[:n])\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer n.\n    \"\"\"\n    n = 6\n    return n\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n Fibonacci numbers.\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    12\n\n    Explanation: The sum of the first 5 Fibonacci numbers (0, 1, 1, 2, 3) is 0 + 1 + 1 + 2 + 3 = 7.\n    \"\"\"\n    fib = [0, 1]\n\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return sum(fib[:n])", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random positive integer n.\n    \"\"\"\n    n = 6\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, convert it to its corresponding Roman numeral representation.\n\n    Sample Input:\n    n = 1994\n\n    Sample Output:\n    'MCMXCIV'\n\n    Explanation: The Roman numeral representation of 1994 is MCMXCIV.\n    \"\"\"\n    numerals = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n    result = ''\n\n    for value, numeral in numerals.items():\n        while n >= value:\n            result += numeral\n            n -= value\n\n    return result\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer n.\n    \"\"\"\n    n = 1994\n    return n\n\nassert f(g()) == 'MCMXCIV'\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 391, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, convert it to its corresponding Roman numeral representation.\n\n    Sample Input:\n    n = 1994\n\n    Sample Output:\n    'MCMXCIV'\n\n    Explanation: The Roman numeral representation of 1994 is MCMXCIV.\n    \"\"\"\n    numerals = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n    result = ''\n\n    for value, numeral in numerals.items():\n        while n >= value:\n            result += numeral\n            n -= value\n\n    return result", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random positive integer n.\n    \"\"\"\n    n = 1994\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of different combinations of elements from the list that add up to the target value.\n    The goal is to find the total number of combinations.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 5\n\n    Output:\n    4\n\n    Explanation:\n    The different combinations that add up to 5 are:\n    [1, 1, 1, 1, 1]\n    [1, 1, 1, 2]\n    [1, 2, 2]\n    [5]\n    \"\"\"\n    def count_combinations(nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1\n\n        for num in nums:\n            for i in range(num, target + 1):\n                dp[i] += dp[i - num]\n\n        return dp[target]\n\n    return count_combinations(nums, target) == len(nums)\n    \ndef g(target=10):\n    nums = [1, 2, 3, 4, 5]\n    return count_combinations(nums, target)\n    \nassert f(g())\n", "emb": null, "idx_generation": 391, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of different combinations of elements from the list that add up to the target value.\n    The goal is to find the total number of combinations.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 5\n\n    Output:\n    4\n\n    Explanation:\n    The different combinations that add up to 5 are:\n    [1, 1, 1, 1, 1]\n    [1, 1, 1, 2]\n    [1, 2, 2]\n    [5]\n    \"\"\"\n    def count_combinations(nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1\n\n        for num in nums:\n            for i in range(num, target + 1):\n                dp[i] += dp[i - num]\n\n        return dp[target]\n\n    return count_combinations(nums, target) == len(nums)", "solution_func": "def g(target=10):\n    nums = [1, 2, 3, 4, 5]\n    return count_combinations(nums, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, check if there exists a substring of length n in s that contains only digits.\n\n    Sample Input:\n    s = \"abc123def\"\n    n = 3\n\n    Sample Output:\n    True\n    \"\"\"\n\n    for i in range(len(s) - n + 1):\n        if s[i:i+n].isdigit():\n            return True\n\n    return False\n\ndef g():\n    return \"abc123def\", 3\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, check if there exists a substring of length n in s that contains only digits.\n\n    Sample Input:\n    s = \"abc123def\"\n    n = 3\n\n    Sample Output:\n    True\n    \"\"\"\n\n    for i in range(len(s) - n + 1):\n        if s[i:i+n].isdigit():\n            return True\n\n    return False", "solution_func": "def g():\n    return \"abc123def\", 3", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring that contains only digits.\n\n    Sample Input:\n    s = \"abc123def456ghi789\"\n\n    Sample Output:\n    3\n    \"\"\"\n\n    max_length = 0\n    current_length = 0\n\n    for char in s:\n        if char.isdigit():\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n\n    return max(max_length, current_length)\n\ndef g():\n    return \"abc123def456ghi789\"\n\nassert f(g()) == 3\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 392, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring that contains only digits.\n\n    Sample Input:\n    s = \"abc123def456ghi789\"\n\n    Sample Output:\n    3\n    \"\"\"\n\n    max_length = 0\n    current_length = 0\n\n    for char in s:\n        if char.isdigit():\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n\n    return max(max_length, current_length)", "solution_func": "def g():\n    return \"abc123def456ghi789\"", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of occurrences of the substring \"abc\" in s.\n\n    Sample Input:\n    s = \"abcabcabc\"\n\n    Sample Output:\n    3\n    \"\"\"\n\n    count = 0\n    i = 0\n\n    while i < len(s) - 2:\n        if s[i:i+3] == \"abc\":\n            count += 1\n            i += 3\n        else:\n            i += 1\n\n    return count\n\ndef g():\n    return \"abcabcabc\"\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of occurrences of the substring \"abc\" in s.\n\n    Sample Input:\n    s = \"abcabcabc\"\n\n    Sample Output:\n    3\n    \"\"\"\n\n    count = 0\n    i = 0\n\n    while i < len(s) - 2:\n        if s[i:i+3] == \"abc\":\n            count += 1\n            i += 3\n        else:\n            i += 1\n\n    return count", "solution_func": "def g():\n    return \"abcabcabc\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element. If the target element is not found,\n    return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2\n\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    Output: -1\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    arr = [2, 4, 6, 8, 10]\n    target = 6\n    return arr, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element. If the target element is not found,\n    return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2\n\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    Output: -1\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    arr = [2, 4, 6, 8, 10]\n    target = 6\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of different ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n    Explanation: There are three ways to climb to the top:\n    1. 1 step + 1 step + 1 step\n    2. 1 step + 2 steps\n    3. 2 steps + 1 step\n\n    n = 4\n    Output: 5\n    Explanation: There are five ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of different ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n    Explanation: There are three ways to climb to the top:\n    1. 1 step + 1 step + 1 step\n    2. 1 step + 2 steps\n    3. 2 steps + 1 step\n\n    n = 4\n    Output: 5\n    Explanation: There are five ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 1 step + 2 steps\n    3. 1 step + 2 steps + 1 step\n    4. 2 steps + 1 step + 1 step\n    5. 2 steps + 2 steps\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    Output: True\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    Output: False\n    Explanation: The graph does not contain a cycle.\n\n    \"\"\"\n\n    def has_cycle(node: int, visited: List[bool], parent: int) -> bool:\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if has_cycle(neighbor, visited, node):\n                        return True\n                elif parent != neighbor:\n                    return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == False\n\n", "emb": null, "idx_generation": 392, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [1, 0, 1, 1],\n        [0, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    Output: True\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0\n\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    Output: False\n    Explanation: The graph does not contain a cycle.\n\n    \"\"\"\n\n    def has_cycle(node: int, visited: List[bool], parent: int) -> bool:\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if has_cycle(neighbor, visited, node):\n                        return True\n                elif parent != neighbor:\n                    return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    \n    Example:\n    nums = [1, 5, 11, 5]\n    \n    Output:\n    True\n    \n    Explanation:\n    The array can be partitioned into [1, 5, 5] and [11] where the sum of elements in both subsets is 11.\n    \"\"\"\n    total_sum = sum(nums)\n    \n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    \n    return subset_sum(nums, len(nums) - 1, target_sum)\n\ndef subset_sum(nums: List[int], n: int, target: int) -> bool:\n    if target == 0:\n        return True\n    if n < 0 or target < 0:\n        return False\n    \n    include = subset_sum(nums, n - 1, target - nums[n])\n    exclude = subset_sum(nums, n - 1, target)\n    \n    return include or exclude\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    \n    Example:\n    nums = [1, 5, 11, 5]\n    \n    Output:\n    True\n    \n    Explanation:\n    The array can be partitioned into [1, 5, 5] and [11] where the sum of elements in both subsets is 11.\n    \"\"\"\n    total_sum = sum(nums)\n    \n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    \n    return subset_sum(nums, len(nums) - 1, target_sum)\n\ndef subset_sum(nums: List[int], n: int, target: int) -> bool:\n    if target == 0:\n        return True\n    if n < 0 or target < 0:\n        return False\n    \n    include = subset_sum(nums, n - 1, target - nums[n])\n    exclude = subset_sum(nums, n - 1, target)\n    \n    return include or exclude", "solution_func": "def g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if all adjacent cells have a strictly increasing value.\n    \n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    \n    Output:\n    4\n    \n    Explanation:\n    The longest increasing path is [1, 2, 6, 9] with a length of 4.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    max_length = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            length = dfs(matrix, i, j, dp)\n            max_length = max(max_length, length)\n    \n    return max_length\n\ndef dfs(matrix: List[List[int]], i: int, j: int, dp: List[List[int]]) -> int:\n    if dp[i][j] != 0:\n        return dp[i][j]\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_length = 1\n    \n    for dx, dy in directions:\n        x = i + dx\n        y = j + dy\n        \n        if x >= 0 and x < len(matrix) and y >= 0 and y < len(matrix[0]) and matrix[x][y] > matrix[i][j]:\n            length = 1 + dfs(matrix, x, y, dp)\n            max_length = max(max_length, length)\n    \n    dp[i][j] = max_length\n    \n    return max_length\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 392, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if all adjacent cells have a strictly increasing value.\n    \n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    \n    Output:\n    4\n    \n    Explanation:\n    The longest increasing path is [1, 2, 6, 9] with a length of 4.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    max_length = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            length = dfs(matrix, i, j, dp)\n            max_length = max(max_length, length)\n    \n    return max_length\n\ndef dfs(matrix: List[List[int]], i: int, j: int, dp: List[List[int]]) -> int:\n    if dp[i][j] != 0:\n        return dp[i][j]\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_length = 1\n    \n    for dx, dy in directions:\n        x = i + dx\n        y = j + dy\n        \n        if x >= 0 and x < len(matrix) and y >= 0 and y < len(matrix[0]) and matrix[x][y] > matrix[i][j]:\n            length = 1 + dfs(matrix, x, y, dp)\n            max_length = max(max_length, length)\n    \n    dp[i][j] = max_length\n    \n    return max_length", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, determine if it is possible to form a circle of words, where the last character of each word is the same as the first character of the next word.\n    \n    Example:\n    words = [\"abc\", \"cd\", \"def\", \"fa\"]\n    \n    Output:\n    True\n    \n    Explanation:\n    The circle of words can be formed as follows: \"abc\" -> \"cd\" -> \"def\" -> \"fa\" -> \"abc\".\n    \"\"\"\n    graph = build_graph(words)\n    return has_cycle(graph, words[0], words[0], set())\n\ndef build_graph(words: List[str]) -> dict:\n    graph = {}\n    \n    for word in words:\n        start = word[0]\n        end = word[-1]\n        \n        if start not in graph:\n            graph[start] = []\n        \n        graph[start].append(end)\n    \n    return graph\n\ndef has_cycle(graph: dict, start: str, current: str, visited: set) -> bool:\n    if current in visited and current == start:\n        return True\n    \n    if current not in graph:\n        return False\n    \n    visited.add(current)\n    \n    for neighbor in graph[current]:\n        if has_cycle(graph, start, neighbor, visited):\n            return True\n    \n    visited.remove(current)\n    \n    return False\n\ndef g() -> List[str]:\n    words = [\"abc\", \"cd\", \"def\", \"fa\"]\n    return words\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 392, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, determine if it is possible to form a circle of words, where the last character of each word is the same as the first character of the next word.\n    \n    Example:\n    words = [\"abc\", \"cd\", \"def\", \"fa\"]\n    \n    Output:\n    True\n    \n    Explanation:\n    The circle of words can be formed as follows: \"abc\" -> \"cd\" -> \"def\" -> \"fa\" -> \"abc\".\n    \"\"\"\n    graph = build_graph(words)\n    return has_cycle(graph, words[0], words[0], set())\n\ndef build_graph(words: List[str]) -> dict:\n    graph = {}\n    \n    for word in words:\n        start = word[0]\n        end = word[-1]\n        \n        if start not in graph:\n            graph[start] = []\n        \n        graph[start].append(end)\n    \n    return graph\n\ndef has_cycle(graph: dict, start: str, current: str, visited: set) -> bool:\n    if current in visited and current == start:\n        return True\n    \n    if current not in graph:\n        return False\n    \n    visited.add(current)\n    \n    for neighbor in graph[current]:\n        if has_cycle(graph, start, neighbor, visited):\n            return True\n    \n    visited.remove(current)\n    \n    return False", "solution_func": "def g() -> List[str]:\n    words = [\"abc\", \"cd\", \"def\", \"fa\"]\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the closest pair of numbers in the array that add up to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [2, 7, 11, 15, 16, 20, 21], target = 23\n\n    Sample output:\n    (2, 21)\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    min_diff = float('inf')\n    closest_pair = None\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if abs(current_sum - target) < min_diff:\n            min_diff = abs(current_sum - target)\n            closest_pair = (arr[left], arr[right])\n        if current_sum == target:\n            return closest_pair\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_pair\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n\nassert f(g(), 22) == (3, 19)\n\n", "emb": null, "idx_generation": 392, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the closest pair of numbers in the array that add up to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [2, 7, 11, 15, 16, 20, 21], target = 23\n\n    Sample output:\n    (2, 21)\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    min_diff = float('inf')\n    closest_pair = None\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if abs(current_sum - target) < min_diff:\n            min_diff = abs(current_sum - target)\n            closest_pair = (arr[left], arr[right])\n        if current_sum == target:\n            return closest_pair\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_pair", "solution_func": "def g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the function should return 4.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the length of the longest increasing subsequence is 4.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the function should return 4.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the length of the longest increasing subsequence is 4.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, determine if there exists a pair of integers in the array whose sum is equal to the target value.\n    Use a stack to solve the problem.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation:\n    The pair (2, 7) sums up to 9, therefore the function should return True.\n    \"\"\"\n    stack = []\n    for num in arr:\n        if target - num in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value where there exists a pair of integers whose sum is equal to the target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 393, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, determine if there exists a pair of integers in the array whose sum is equal to the target value.\n    Use a stack to solve the problem.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation:\n    The pair (2, 7) sums up to 9, therefore the function should return True.\n    \"\"\"\n    stack = []\n    for num in arr:\n        if target - num in stack:\n            return True\n        stack.append(num)\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value where there exists a pair of integers whose sum is equal to the target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the minimum number of jumps required to reach the target value.\n    Each element in the array represents the maximum number of steps that can be jumped from that position.\n    Use a queue to solve the problem.\n\n    Example:\n    Input: nums = [2, 3, 1, 1, 4], target = 9\n    Output: 3\n\n    Explanation:\n    The minimum number of jumps required is 3, with the following jump sequence: 2 -> 3 -> 4 -> 9.\n    Therefore, the function should return 3.\n    \"\"\"\n    if target <= 0:\n        return -1\n\n    queue = [(0, 0)]\n    n = len(nums)\n\n    while queue:\n        curr_pos, jumps = queue.pop(0)\n\n        if curr_pos == target:\n            return jumps\n\n        for i in range(1, nums[curr_pos] + 1):\n            new_pos = curr_pos + i\n            if new_pos < n:\n                queue.append((new_pos, jumps + 1))\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value where the minimum number of jumps required to reach the target value is 3.\n    \"\"\"\n    return [2, 3, 1, 1, 4], 9\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 393, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the minimum number of jumps required to reach the target value.\n    Each element in the array represents the maximum number of steps that can be jumped from that position.\n    Use a queue to solve the problem.\n\n    Example:\n    Input: nums = [2, 3, 1, 1, 4], target = 9\n    Output: 3\n\n    Explanation:\n    The minimum number of jumps required is 3, with the following jump sequence: 2 -> 3 -> 4 -> 9.\n    Therefore, the function should return 3.\n    \"\"\"\n    if target <= 0:\n        return -1\n\n    queue = [(0, 0)]\n    n = len(nums)\n\n    while queue:\n        curr_pos, jumps = queue.pop(0)\n\n        if curr_pos == target:\n            return jumps\n\n        for i in range(1, nums[curr_pos] + 1):\n            new_pos = curr_pos + i\n            if new_pos < n:\n                queue.append((new_pos, jumps + 1))\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value where the minimum number of jumps required to reach the target value is 3.\n    \"\"\"\n    return [2, 3, 1, 1, 4], 9", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if it is possible to arrange the digits of n in a permutation such that the absolute difference between any two adjacent digits is greater than or equal to k.\n    \"\"\"\n    def is_valid_permutation(n: int, k: int) -> bool:\n        digits = list(str(n))\n        digits.sort()\n        for i in range(1, len(digits)):\n            if abs(int(digits[i]) - int(digits[i-1])) < k:\n                return False\n        return True\n    \n    return is_valid_permutation(n, k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two random integers n and k.\n    \"\"\"\n    import random\n    n = random.randint(1000, 9999)\n    k = random.randint(1, 5)\n    return n, k\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 393, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if it is possible to arrange the digits of n in a permutation such that the absolute difference between any two adjacent digits is greater than or equal to k.\n    \"\"\"\n    def is_valid_permutation(n: int, k: int) -> bool:\n        digits = list(str(n))\n        digits.sort()\n        for i in range(1, len(digits)):\n            if abs(int(digits[i]) - int(digits[i-1])) < k:\n                return False\n        return True\n    \n    return is_valid_permutation(n, k)", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two random integers n and k.\n    \"\"\"\n    import random\n    n = random.randint(1000, 9999)\n    k = random.randint(1, 5)\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\ndef f(strings: List[str]) -> bool:\n    \"\"\"\n    Given a list of strings, determine if there exists a string that can be formed by concatenating the strings in the list in any order.\n    \"\"\"\n    def is_valid_string(s: str, strings: List[str]) -> bool:\n        return s in strings\n    \n    def is_valid_concatenation(s: str, strings: List[str]) -> bool:\n        if s == \"\":\n            return True\n        for i in range(1, len(s)+1):\n            if s[:i] in strings and is_valid_concatenation(s[i:], strings):\n                return True\n        return False\n    \n    for string in strings:\n        if is_valid_concatenation(string, strings):\n            return True\n    return False\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of random strings.\n    \"\"\"\n    import random\n    strings = []\n    for _ in range(5):\n        string = \"\"\n        for _ in range(random.randint(1, 5)):\n            string += chr(random.randint(97, 122))\n        strings.append(string)\n    return strings\n\nassert f(g()) == True\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "import random\nfrom typing import*\ndef f(strings: List[str]) -> bool:\n    \"\"\"\n    Given a list of strings, determine if there exists a string that can be formed by concatenating the strings in the list in any order.\n    \"\"\"\n    def is_valid_string(s: str, strings: List[str]) -> bool:\n        return s in strings\n    \n    def is_valid_concatenation(s: str, strings: List[str]) -> bool:\n        if s == \"\":\n            return True\n        for i in range(1, len(s)+1):\n            if s[:i] in strings and is_valid_concatenation(s[i:], strings):\n                return True\n        return False\n    \n    for string in strings:\n        if is_valid_concatenation(string, strings):\n            return True\n    return False", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of random strings.\n    \"\"\"\n    import random\n    strings = []\n    for _ in range(5):\n        string = \"\"\n        for _ in range(random.randint(1, 5)):\n            string += chr(random.randint(97, 122))\n        strings.append(string)\n    return strings", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(s: str, n: int, k: int) -> bool:\n    \"\"\"\n    Given a string s, find the number of substrings of length n that have exactly k distinct characters.\n    \"\"\"\n    def count_substrings(s: str, n: int, k: int) -> int:\n        count = 0\n        for i in range(len(s)-n+1):\n            substring = s[i:i+n]\n            if len(set(substring)) == k:\n                count += 1\n        return count\n    \n    return count_substrings(s, n, k) >= 1\n\ndef g() -> Tuple[str, int, int]:\n    \"\"\"\n    Generate a random string s, length n, and number of distinct characters k.\n    \"\"\"\n    import random\n    s = \"\"\n    for _ in range(10):\n        s += chr(random.randint(97, 122))\n    n = random.randint(1, 3)\n    k = random.randint(1, n)\n    return s, n, k\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 393, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(s: str, n: int, k: int) -> bool:\n    \"\"\"\n    Given a string s, find the number of substrings of length n that have exactly k distinct characters.\n    \"\"\"\n    def count_substrings(s: str, n: int, k: int) -> int:\n        count = 0\n        for i in range(len(s)-n+1):\n            substring = s[i:i+n]\n            if len(set(substring)) == k:\n                count += 1\n        return count\n    \n    return count_substrings(s, n, k) >= 1", "solution_func": "def g() -> Tuple[str, int, int]:\n    \"\"\"\n    Generate a random string s, length n, and number of distinct characters k.\n    \"\"\"\n    import random\n    s = \"\"\n    for _ in range(10):\n        s += chr(random.randint(97, 122))\n    n = random.randint(1, 3)\n    k = random.randint(1, n)\n    return s, n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a subset of the given list of numbers whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target, n-1) or subset_sum(nums, target-nums[n-1], n-1)\n\n    return subset_sum(nums, target, len(nums))\n\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a subset of the given list of numbers whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target, n-1) or subset_sum(nums, target-nums[n-1], n-1)\n\n    return subset_sum(nums, target, len(nums))", "solution_func": "def g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return a new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return a new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of ways to make the target sum using the given list of numbers, where each number can be used multiple times.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\n\nassert f(*g()) == 7\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of ways to make the target sum using the given list of numbers, where each number can be used multiple times.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the range from 0 to n.\n    The list contains all the numbers from 0 to n except one.\n    Return the missing number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid:\n            # The missing number is in the left half\n            right = mid - 1\n        else:\n            # The missing number is in the right half\n            left = mid + 1\n    \n    return left\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers with one missing number.\n    \"\"\"\n    arr = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10]\n    return arr\n\nassert f(g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 393, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the range from 0 to n.\n    The list contains all the numbers from 0 to n except one.\n    Return the missing number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid:\n            # The missing number is in the left half\n            right = mid - 1\n        else:\n            # The missing number is in the right half\n            left = mid + 1\n    \n    return left", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers with one missing number.\n    \"\"\"\n    arr = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target value, find the number of unique combinations that sum up to the target.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to 4 are [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2].\n    Therefore, the function should return 4.\n\n    Note:\n    - The length of the array will not exceed 20.\n    - The range of integers in the array is [1, 100].\n    - The target value is in the range [1, 1000].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if target == 0:\n            return 1\n        if index >= len(nums) or target < 0:\n            return 0\n\n        if (index, target) in memo:\n            return memo[(index, target)]\n\n        count = helper(nums, target - nums[index], index, memo) + helper(nums, target, index + 1, memo)\n        memo[(index, target)] = count\n        return count\n\n    return helper(nums, target, 0, {})\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target value, find the number of unique combinations that sum up to the target.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to 4 are [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2].\n    Therefore, the function should return 4.\n\n    Note:\n    - The length of the array will not exceed 20.\n    - The range of integers in the array is [1, 100].\n    - The target value is in the range [1, 1000].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if target == 0:\n            return 1\n        if index >= len(nums) or target < 0:\n            return 0\n\n        if (index, target) in memo:\n            return memo[(index, target)]\n\n        count = helper(nums, target - nums[index], index, memo) + helper(nums, target, index + 1, memo)\n        memo[(index, target)] = count\n        return count\n\n    return helper(nums, target, 0, {})", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([1, 2, 3], 4)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import combinations\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target value, find all unique combinations that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    The unique combinations that sum up to 7 are [2, 2, 3] and [7].\n    Therefore, the function should return [[2, 2, 3], [7]].\n\n    Note:\n    - The length of the array will not exceed 30.\n    - The range of integers in the array is [1, 200].\n    - The target value is in the range [1, 500].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, path: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(path[:])\n            return\n        if index >= len(nums) or target < 0:\n            return\n\n        for i in range(index, len(nums)):\n            path.append(nums[i])\n            helper(nums, target - nums[i], i, path, result)\n            path.pop()\n\n    result = []\n    helper(nums, target, 0, [], result)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import combinations\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target value, find all unique combinations that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    The unique combinations that sum up to 7 are [2, 2, 3] and [7].\n    Therefore, the function should return [[2, 2, 3], [7]].\n\n    Note:\n    - The length of the array will not exceed 30.\n    - The range of integers in the array is [1, 200].\n    - The target value is in the range [1, 500].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, path: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(path[:])\n            return\n        if index >= len(nums) or target < 0:\n            return\n\n        for i in range(index, len(nums)):\n            path.append(nums[i])\n            helper(nums, target - nums[i], i, path, result)\n            path.pop()\n\n    result = []\n    helper(nums, target, 0, [], result)\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target value, find the minimum number of operations required to make all elements of the array equal to the target.\n\n    Each operation consists of adding or subtracting a value from an element.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The minimum number of operations required is 3:\n\n    1. Subtract 1 from nums[0] to make it equal to 0.\n    2. Add 1 to nums[2] to make it equal to 4.\n    3. Subtract 1 from nums[4] to make it equal to 4.\n\n    Therefore, the function should return 3.\n\n    Note:\n    - The length of the array will not exceed 1000.\n    - The range of integers in the array is [-10^9, 10^9].\n    - The target value is in the range [-10^9, 10^9].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if index >= len(nums):\n            return 0\n\n        if (index, target) in memo:\n            return memo[(index, target)]\n\n        diff = target - nums[index]\n        operations = 0\n\n        if diff > 0:\n            operations = min(helper(nums, target, index + 1, memo), 1 + helper(nums, target - diff, index + 1, memo))\n        elif diff < 0:\n            operations = min(helper(nums, target, index + 1, memo), 1 + helper(nums, target - diff, index + 1, memo))\n        else:\n            operations = helper(nums, target, index + 1, memo)\n\n        memo[(index, target)] = operations\n        return operations\n\n    return helper(nums, target, 0, {})\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 3)\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 394, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target value, find the minimum number of operations required to make all elements of the array equal to the target.\n\n    Each operation consists of adding or subtracting a value from an element.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The minimum number of operations required is 3:\n\n    1. Subtract 1 from nums[0] to make it equal to 0.\n    2. Add 1 to nums[2] to make it equal to 4.\n    3. Subtract 1 from nums[4] to make it equal to 4.\n\n    Therefore, the function should return 3.\n\n    Note:\n    - The length of the array will not exceed 1000.\n    - The range of integers in the array is [-10^9, 10^9].\n    - The target value is in the range [-10^9, 10^9].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if index >= len(nums):\n            return 0\n\n        if (index, target) in memo:\n            return memo[(index, target)]\n\n        diff = target - nums[index]\n        operations = 0\n\n        if diff > 0:\n            operations = min(helper(nums, target, index + 1, memo), 1 + helper(nums, target - diff, index + 1, memo))\n        elif diff < 0:\n            operations = min(helper(nums, target, index + 1, memo), 1 + helper(nums, target - diff, index + 1, memo))\n        else:\n            operations = helper(nums, target, index + 1, memo)\n\n        memo[(index, target)] = operations\n        return operations\n\n    return helper(nums, target, 0, {})", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 3)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that sums up to the target.\n    Return True if such a subset exists, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    f(nums, target) => True\n    Explanation: The subset [2, 3, 4] sums up to the target 9.\n\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        if current_sum + nums[index] <= target:\n            if subset_sum(nums, target, index + 1, current_sum + nums[index]):\n                return True\n        return subset_sum(nums, target, index + 1, current_sum)\n\n    return subset_sum(nums, target, 0, 0)\n\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums that sums up to the target.\n    Return True if such a subset exists, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    f(nums, target) => True\n    Explanation: The subset [2, 3, 4] sums up to the target 9.\n\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        if current_sum + nums[index] <= target:\n            if subset_sum(nums, target, index + 1, current_sum + nums[index]):\n                return True\n        return subset_sum(nums, target, index + 1, current_sum)\n\n    return subset_sum(nums, target, 0, 0)", "solution_func": "def g():\n    return [1, 2, 3, 4, 5], 9", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string s and a pattern, determine if s matches the pattern.\n    The pattern consists of lowercase letters and the character '.' which matches any single character.\n    Return True if s matches the pattern, False otherwise.\n\n    Example:\n    s = \"abb\"\n    pattern = \"a.b\"\n    f(s, pattern) => True\n    Explanation: The pattern \"a.b\" matches the string \"abb\" where '.' matches the second 'b'.\n\n    \"\"\"\n\n    def match(s: str, pattern: str, s_index: int, pattern_index: int) -> bool:\n        if s_index == len(s) and pattern_index == len(pattern):\n            return True\n        if s_index == len(s) or pattern_index == len(pattern):\n            return False\n        if pattern[pattern_index] == '.':\n            return match(s, pattern, s_index + 1, pattern_index + 1)\n        if s[s_index] == pattern[pattern_index]:\n            return match(s, pattern, s_index + 1, pattern_index + 1)\n        return False\n\n    return match(s, pattern, 0, 0)\n\n\ndef g():\n    return \"abb\", \"a.b\"\n\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string s and a pattern, determine if s matches the pattern.\n    The pattern consists of lowercase letters and the character '.' which matches any single character.\n    Return True if s matches the pattern, False otherwise.\n\n    Example:\n    s = \"abb\"\n    pattern = \"a.b\"\n    f(s, pattern) => True\n    Explanation: The pattern \"a.b\" matches the string \"abb\" where '.' matches the second 'b'.\n\n    \"\"\"\n\n    def match(s: str, pattern: str, s_index: int, pattern_index: int) -> bool:\n        if s_index == len(s) and pattern_index == len(pattern):\n            return True\n        if s_index == len(s) or pattern_index == len(pattern):\n            return False\n        if pattern[pattern_index] == '.':\n            return match(s, pattern, s_index + 1, pattern_index + 1)\n        if s[s_index] == pattern[pattern_index]:\n            return match(s, pattern, s_index + 1, pattern_index + 1)\n        return False\n\n    return match(s, pattern, 0, 0)", "solution_func": "def g():\n    return \"abb\", \"a.b\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subarray of nums with sum equal to k.\n    Return True if such a subarray exists, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    f(nums, k) => True\n    Explanation: The subarray [2, 3, 4] has a sum of 9.\n\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n\n    return False\n\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\n\nassert f(*g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 394, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subarray of nums with sum equal to k.\n    Return True if such a subarray exists, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    f(nums, k) => True\n    Explanation: The subarray [2, 3, 4] has a sum of 9.\n\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n\n    return False", "solution_func": "def g():\n    return [1, 2, 3, 4, 5], 9", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest word in the list that can be built one character at a time by other words in the list.\n    If there are multiple words with the same maximum length, return the lexicographically smallest one.\n\n    Example:\n    words = [\"w\", \"wo\", \"wor\", \"worl\", \"world\", \"word\", \"words\"]\n\n    The function should return \"world\", since it can be built by \"w\", \"wo\", \"wor\", \"worl\", and \"word\".\n\n    words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n\n    The function should return \"apple\", since it can be built by \"a\", \"ap\", \"app\", \"appl\", and \"apple\".\n    \"\"\"\n    def build_graph(words):\n        graph = collections.defaultdict(set)\n        for word in words:\n            for i in range(1, len(word)):\n                graph[word[:i]].add(word)\n        return graph\n\n    def dfs(word, graph, path, result):\n        if word not in graph:\n            return\n        for neighbor in graph[word]:\n            path.append(neighbor)\n            dfs(neighbor, graph, path, result)\n            path.pop()\n        if len(path) > len(result) or (len(path) == len(result) and path < result):\n            result[:] = path[:]\n\n    graph = build_graph(words)\n    result = []\n    for word in words:\n        dfs(word, graph, [word], result)\n\n    return result\n\ndef g():\n    words = [\"w\", \"wo\", \"wor\", \"worl\", \"world\", \"word\", \"words\"]\n    return words\n\nassert f(g()) == [\"world\"]\n\n", "emb": null, "idx_generation": 394, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest word in the list that can be built one character at a time by other words in the list.\n    If there are multiple words with the same maximum length, return the lexicographically smallest one.\n\n    Example:\n    words = [\"w\", \"wo\", \"wor\", \"worl\", \"world\", \"word\", \"words\"]\n\n    The function should return \"world\", since it can be built by \"w\", \"wo\", \"wor\", \"worl\", and \"word\".\n\n    words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n\n    The function should return \"apple\", since it can be built by \"a\", \"ap\", \"app\", \"appl\", and \"apple\".\n    \"\"\"\n    def build_graph(words):\n        graph = collections.defaultdict(set)\n        for word in words:\n            for i in range(1, len(word)):\n                graph[word[:i]].add(word)\n        return graph\n\n    def dfs(word, graph, path, result):\n        if word not in graph:\n            return\n        for neighbor in graph[word]:\n            path.append(neighbor)\n            dfs(neighbor, graph, path, result)\n            path.pop()\n        if len(path) > len(result) or (len(path) == len(result) and path < result):\n            result[:] = path[:]\n\n    graph = build_graph(words)\n    result = []\n    for word in words:\n        dfs(word, graph, [word], result)\n\n    return result", "solution_func": "def g():\n    words = [\"w\", \"wo\", \"wor\", \"worl\", \"world\", \"word\", \"words\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The function should return [[7, 4, 1],\n                              [8, 5, 2],\n                              [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 394, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The function should return [[7, 4, 1],\n                              [8, 5, 2],\n                              [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix", "solution_func": "def g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(s: str) -> List[List[str]]:\n    \"\"\"\n    Given a string s, partition it into as many parts as possible so that each part is a palindrome.\n    Return a list of all possible partitions.\n\n    Example:\n    s = \"aab\"\n\n    The function should return [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]], since \"a\", \"a\", \"b\" and \"aa\", \"b\" are valid partitions.\n\n    s = \"aaa\"\n\n    The function should return [[\"a\", \"a\", \"a\"], [\"aa\", \"a\"], [\"a\", \"aa\"], [\"aaa\"]], since \"a\", \"a\", \"a\", \"aa\", \"a\", \"a\", \"aaa\" are valid partitions.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def backtrack(s, start, partition, result):\n        if start == len(s):\n            result.append(partition[:])\n            return\n        for i in range(start, len(s)):\n            if is_palindrome(s[start:i+1]):\n                partition.append(s[start:i+1])\n                backtrack(s, i+1, partition, result)\n                partition.pop()\n\n    result = []\n    backtrack(s, 0, [], result)\n    return result\n\ndef g():\n    s = \"aab\"\n    return s\n\nassert f(g()) == [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(s: str) -> List[List[str]]:\n    \"\"\"\n    Given a string s, partition it into as many parts as possible so that each part is a palindrome.\n    Return a list of all possible partitions.\n\n    Example:\n    s = \"aab\"\n\n    The function should return [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]], since \"a\", \"a\", \"b\" and \"aa\", \"b\" are valid partitions.\n\n    s = \"aaa\"\n\n    The function should return [[\"a\", \"a\", \"a\"], [\"aa\", \"a\"], [\"a\", \"aa\"], [\"aaa\"]], since \"a\", \"a\", \"a\", \"aa\", \"a\", \"a\", \"aaa\" are valid partitions.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def backtrack(s, start, partition, result):\n        if start == len(s):\n            result.append(partition[:])\n            return\n        for i in range(start, len(s)):\n            if is_palindrome(s[start:i+1]):\n                partition.append(s[start:i+1])\n                backtrack(s, i+1, partition, result)\n                partition.pop()\n\n    result = []\n    backtrack(s, 0, [], result)\n    return result", "solution_func": "def g():\n    s = \"aab\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine if the target value is present in the list.\n    Return True if the target value is found, otherwise return False.\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: True\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return False\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 394, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine if the target value is present in the list.\n    Return True if the target value is found, otherwise return False.\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: True\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return False\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)", "solution_func": "def g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target number, return the index of the target number if it\n    exists in the list. If the target number is not in the list, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target number, return the index of the target number if it\n    exists in the list. If the target number is not in the list, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]]) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list, return a valid topological ordering of the graph\n    nodes.\n\n    Example:\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5], 5: []}\n\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n    in_degrees = {node: 0 for node in graph}\n\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degrees[neighbor] += 1\n\n    queue = [node for node in graph if in_degrees[node] == 0]\n    order = []\n\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n\n        for neighbor in graph[node]:\n            in_degrees[neighbor] -= 1\n\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order\n\ndef g():\n    \"\"\"\n    Generate a directed acyclic graph represented as an adjacency list.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5], 5: []}\n    return graph\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 395, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]]) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list, return a valid topological ordering of the graph\n    nodes.\n\n    Example:\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5], 5: []}\n\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n    in_degrees = {node: 0 for node in graph}\n\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degrees[neighbor] += 1\n\n    queue = [node for node in graph if in_degrees[node] == 0]\n    order = []\n\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n\n        for neighbor in graph[node]:\n            in_degrees[neighbor] -= 1\n\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order", "solution_func": "def g():\n    \"\"\"\n    Generate a directed acyclic graph represented as an adjacency list.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5], 5: []}\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output: 15 (1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output: 15 (1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return (n * (n + 1)) // 2", "solution_func": "def g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums that is sorted in ascending order, and a target value,\n    determine if the target is present in the list.\n\n    Example:\n    nums = [-2, 0, 3, 5, 9, 12]\n    target = 9\n\n    The target value 9 is present in the list.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> bool:\n        if low > high:\n            return False\n\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, high)\n        else:\n            return binary_search(nums, target, low, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [-2, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums that is sorted in ascending order, and a target value,\n    determine if the target is present in the list.\n\n    Example:\n    nums = [-2, 0, 3, 5, 9, 12]\n    target = 9\n\n    The target value 9 is present in the list.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> bool:\n        if low > high:\n            return False\n\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, high)\n        else:\n            return binary_search(nums, target, low, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [-2, 0, 3, 5, 9, 12]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which corresponds to the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which corresponds to the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the numbers in non-increasing order.\n\n    Example:\n    nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]\n\n    The sorted list is [9, 6, 5, 5, 4, 3, 2, 1, 1].\n\n    Therefore, the function should return [9, 6, 5, 5, 4, 3, 2, 1, 1].\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[0]\n    less_than_pivot = [num for num in nums[1:] if num >= pivot]\n    greater_than_pivot = [num for num in nums[1:] if num < pivot]\n\n    return f(less_than_pivot) + [pivot] + f(greater_than_pivot)\n\ndef g() -> List[int]:\n    nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]\n    return nums\n\nassert f(g()) == [9, 6, 5, 5, 4, 3, 2, 1, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the numbers in non-increasing order.\n\n    Example:\n    nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]\n\n    The sorted list is [9, 6, 5, 5, 4, 3, 2, 1, 1].\n\n    Therefore, the function should return [9, 6, 5, 5, 4, 3, 2, 1, 1].\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[0]\n    less_than_pivot = [num for num in nums[1:] if num >= pivot]\n    greater_than_pivot = [num for num in nums[1:] if num < pivot]\n\n    return f(less_than_pivot) + [pivot] + f(greater_than_pivot)", "solution_func": "def g() -> List[int]:\n    nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target value, determine the number of ways to form the target value\n    using the numbers in the list. You can perform addition, subtraction, multiplication,\n    and division using any of the numbers in the list. Each number can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n    Output: 4\n    Explanation: There are 4 ways to form the target value: 1+1+1+1, 1+1+2, 1+3, 2+2.\n\n    nums = [2, 3, 4], target = 10\n    Output: 8\n    Explanation: There are 8 ways to form the target value: 2+2+2+2+2, 2+2+3+3, 2+4+4, 3+3+4, 4+4+2, 4+2+2+2, 4+3+3, 4+4+2.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 395, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target value, determine the number of ways to form the target value\n    using the numbers in the list. You can perform addition, subtraction, multiplication,\n    and division using any of the numbers in the list. Each number can be used multiple times.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n    Output: 4\n    Explanation: There are 4 ways to form the target value: 1+1+1+1, 1+1+2, 1+3, 2+2.\n\n    nums = [2, 3, 4], target = 10\n    Output: 8\n    Explanation: There are 8 ways to form the target value: 2+2+2+2+2, 2+2+3+3, 2+4+4, 3+3+4, 4+4+2, 4+2+2+2, 4+3+3, 4+4+2.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g():\n    return ([1, 2, 3], 4)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of lowercase letters, return the longest substring that contains\n    all the vowels (a, e, i, o, u) in the same order as they appear in the string.\n\n    Example:\n    s = \"aeiouabcdefg\"\n    Output: \"aeiou\"\n\n    s = \"aeioubcdfg\"\n    Output: \"\"\n\n    s = \"aebcduiofg\"\n    Output: \"aebcduio\"\n    \"\"\"\n\n    vowels = \"aeiou\"\n    longest_substring = \"\"\n    current_substring = \"\"\n\n    for char in s:\n        if char in vowels:\n            current_substring += char\n\n            if current_substring == vowels:\n                return current_substring\n\n            if current_substring == vowels[:len(current_substring)]:\n                if len(current_substring) > len(longest_substring):\n                    longest_substring = current_substring\n        else:\n            current_substring = \"\"\n\n    return longest_substring\n\ndef g():\n    return \"aeiouabcdefg\"\n\nassert f(g()) == \"aeiou\"\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of lowercase letters, return the longest substring that contains\n    all the vowels (a, e, i, o, u) in the same order as they appear in the string.\n\n    Example:\n    s = \"aeiouabcdefg\"\n    Output: \"aeiou\"\n\n    s = \"aeioubcdfg\"\n    Output: \"\"\n\n    s = \"aebcduiofg\"\n    Output: \"aebcduio\"\n    \"\"\"\n\n    vowels = \"aeiou\"\n    longest_substring = \"\"\n    current_substring = \"\"\n\n    for char in s:\n        if char in vowels:\n            current_substring += char\n\n            if current_substring == vowels:\n                return current_substring\n\n            if current_substring == vowels[:len(current_substring)]:\n                if len(current_substring) > len(longest_substring):\n                    longest_substring = current_substring\n        else:\n            current_substring = \"\"\n\n    return longest_substring", "solution_func": "def g():\n    return \"aeiouabcdefg\"", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list is\n    the product of all the numbers in the original list except the one at i.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n\n    nums = [3, 2, 1]\n    Output: [2, 3, 6]\n    \"\"\"\n\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 395, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list is\n    the product of all the numbers in the original list except the one at i.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n\n    nums = [3, 2, 1]\n    Output: [2, 3, 6]\n    \"\"\"\n\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(string_list: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of strings and a target string, check if the target string can be generated by concatenating\n    the strings in the list in a specific order. Each string in the list can be used only once.\n\n    Return True if the target string can be generated, False otherwise.\n    \"\"\"\n    def backtrack(curr_string: str, remaining_list: List[str]) -> bool:\n        if curr_string == target:\n            return True\n        for i in range(len(remaining_list)):\n            if target.startswith(curr_string + remaining_list[i]):\n                if backtrack(curr_string + remaining_list[i], remaining_list[:i] + remaining_list[i+1:]):\n                    return True\n        return False\n\n    return backtrack('', string_list)\n\ndef g():\n    string_list = ['abc', 'def', 'ghi']\n    target = 'abcdefghi'\n    return string_list, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 395, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(string_list: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of strings and a target string, check if the target string can be generated by concatenating\n    the strings in the list in a specific order. Each string in the list can be used only once.\n\n    Return True if the target string can be generated, False otherwise.\n    \"\"\"\n    def backtrack(curr_string: str, remaining_list: List[str]) -> bool:\n        if curr_string == target:\n            return True\n        for i in range(len(remaining_list)):\n            if target.startswith(curr_string + remaining_list[i]):\n                if backtrack(curr_string + remaining_list[i], remaining_list[:i] + remaining_list[i+1:]):\n                    return True\n        return False\n\n    return backtrack('', string_list)", "solution_func": "def g():\n    string_list = ['abc', 'def', 'ghi']\n    target = 'abcdefghi'\n    return string_list, target", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique binary strings of length n that do not contain consecutive 1s.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 13\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique binary strings of length n that do not contain consecutive 1s.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]", "solution_func": "def g():\n    return 5", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    A path can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n\n    Return the maximum sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    # Initialize first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    \n    # Initialize first column\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    \n    # Calculate maximum sum path for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    \n    return dp[m - 1][n - 1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 396, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    A path can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, with a sum of 7.\n\n    Return the maximum sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    # Initialize first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    \n    # Initialize first column\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    \n    # Calculate maximum sum path for each cell\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    \n    return dp[m - 1][n - 1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2)\n\n    Return the nth Fibonacci number.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2)\n\n    Return the nth Fibonacci number.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]", "solution_func": "def g():\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two different numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be obtained by selecting 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two different numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be obtained by selecting 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as a list of edges, determine if the graph contains a cycle.\n\n    Example:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n    The graph contains a cycle, as there is a path that starts and ends at the same vertex.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def is_cycle(graph, curr, visited, parent):\n        visited[curr] = True\n\n        for neighbor in graph[curr]:\n            if not visited[neighbor]:\n                if is_cycle(graph, neighbor, visited, curr):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    graph = [[] for _ in range(n)]\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if is_cycle(graph, i, visited, -1):\n                return True\n\n    return False\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n    return n, edges\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as a list of edges, determine if the graph contains a cycle.\n\n    Example:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n    The graph contains a cycle, as there is a path that starts and ends at the same vertex.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def is_cycle(graph, curr, visited, parent):\n        visited[curr] = True\n\n        for neighbor in graph[curr]:\n            if not visited[neighbor]:\n                if is_cycle(graph, neighbor, visited, curr):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    graph = [[] for _ in range(n)]\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if is_cycle(graph, i, visited, -1):\n                return True\n\n    return False", "solution_func": "def g() -> Tuple[int, List[Tuple[int, int]]]:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the shortest path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The shortest path is 1 -> 3 -> 1 -> 1, with a total sum of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, cols):\n        dp[0][i] = dp[0][i-1] + grid[0][i]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 396, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, find the shortest path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The shortest path is 1 -> 3 -> 1 -> 1, with a total sum of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, cols):\n        dp[0][i] = dp[0][i-1] + grid[0][i]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the \n    sum of the numbers equals to the target. Each number in nums may only be used once in the combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation: The solution set must not contain duplicate combinations. \n    \"\"\"\n\n    def backtrack(comb: List[int], remain: int, start: int):\n        if remain == 0:\n            result.append(list(comb))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            comb.append(nums[i])\n            backtrack(comb, remain - nums[i], i + 1)\n            comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], target, 0)\n    return result\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nnums = [10, 1, 2, 7, 6, 1, 5]\ntarget = 8\nassert f(*g(nums, target)) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 396, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the \n    sum of the numbers equals to the target. Each number in nums may only be used once in the combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation: The solution set must not contain duplicate combinations. \n    \"\"\"\n\n    def backtrack(comb: List[int], remain: int, start: int):\n        if remain == 0:\n            result.append(list(comb))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            comb.append(nums[i])\n            backtrack(comb, remain - nums[i], i + 1)\n            comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], target, 0)\n    return result", "solution_func": "def g(nums: List[int], target: int):\n    return nums, target\n\nnums = [10, 1, 2, 7, 6, 1, 5]\ntarget = 8", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps to navigate from \n    the start position to the destination position. You can move up, down, left, or right from each cell, \n    but you cannot move diagonally. The start and destination positions are indicated by 'S' and 'D' respectively.\n\n    Example:\n    Input: grid = [['S', '.', '#', '#', '.', '.', '.'],\n                   ['.', '#', '.', '.', '.', '#', '.'],\n                   ['.', '#', '.', '#', '.', '#', '.'],\n                   ['.', '.', '.', '#', '.', '.', '.'],\n                   ['#', '#', '.', 'D', '#', '#', '.']]\n\n    Output: 7\n\n    Explanation: The minimum number of steps to navigate from 'S' to 'D' is 7.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def bfs(row: int, col: int) -> int:\n        queue = deque([(row, col, 0)])\n        visited = set([(row, col)])\n\n        while queue:\n            x, y, steps = queue.popleft()\n\n            if grid[x][y] == 'D':\n                return steps\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#' and (nx, ny) not in visited:\n                    queue.append((nx, ny, steps + 1))\n                    visited.add((nx, ny))\n\n        return -1\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                return bfs(i, j)\n\n    return -1\n\ndef g(grid: List[List[str]]):\n    return grid\n\ngrid = [['S', '.', '#', '#', '.', '.', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '.', '#', '.', '#', '.'],\n        ['.', '.', '.', '#', '.', '.', '.'],\n        ['#', '#', '.', 'D', '#', '#', '.']]\nassert f(g(grid)) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters representing a maze, find the minimum number of steps to navigate from \n    the start position to the destination position. You can move up, down, left, or right from each cell, \n    but you cannot move diagonally. The start and destination positions are indicated by 'S' and 'D' respectively.\n\n    Example:\n    Input: grid = [['S', '.', '#', '#', '.', '.', '.'],\n                   ['.', '#', '.', '.', '.', '#', '.'],\n                   ['.', '#', '.', '#', '.', '#', '.'],\n                   ['.', '.', '.', '#', '.', '.', '.'],\n                   ['#', '#', '.', 'D', '#', '#', '.']]\n\n    Output: 7\n\n    Explanation: The minimum number of steps to navigate from 'S' to 'D' is 7.\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def bfs(row: int, col: int) -> int:\n        queue = deque([(row, col, 0)])\n        visited = set([(row, col)])\n\n        while queue:\n            x, y, steps = queue.popleft()\n\n            if grid[x][y] == 'D':\n                return steps\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != '#' and (nx, ny) not in visited:\n                    queue.append((nx, ny, steps + 1))\n                    visited.add((nx, ny))\n\n        return -1\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                return bfs(i, j)\n\n    return -1", "solution_func": "def g(grid: List[List[str]]):\n    return grid\n\ngrid = [['S', '.', '#', '#', '.', '.', '.'],\n        ['.', '#', '.', '.', '.', '#', '.'],\n        ['.', '#', '.', '#', '.', '#', '.'],\n        ['.', '.', '.', '#', '.', '.', '.'],\n        ['#', '#', '.', 'D', '#', '#', '.']]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of trailing zeroes in n!.\n\n    Example:\n    Input: n = 10\n    Output: 2\n\n    Explanation: 10! = 3628800, which has 2 trailing zeroes.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 396, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of trailing zeroes in n!.\n\n    Example:\n    Input: n = 10\n    Output: 2\n\n    Explanation: 10! = 3628800, which has 2 trailing zeroes.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s consisting of parentheses, square brackets, and curly braces,\n    determine if the input string is balanced.\n\n    A string is considered balanced if every opening bracket has a corresponding closing bracket of the same type,\n    and the brackets are properly nested.\n\n    Example:\n    Input: s = \"({[]})\"\n    Output: True\n\n    Explanation: The input string is balanced because every opening bracket has a corresponding closing bracket\n    of the same type, and the brackets are properly nested.\n\n    Input: s = \"([)]\"\n    Output: False\n\n    Explanation: The input string is not balanced because the opening square bracket does not have a corresponding\n    closing square bracket.\n\n    Hint: Use a stack to keep track of opening brackets and check if the closing bracket matches the top of the stack.\n    \"\"\"\n\n    stack = []\n    mapping = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    }\n\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return len(stack) == 0\n\ndef g():\n    s = \"({[]})\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0], "idx_generation": 396, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s consisting of parentheses, square brackets, and curly braces,\n    determine if the input string is balanced.\n\n    A string is considered balanced if every opening bracket has a corresponding closing bracket of the same type,\n    and the brackets are properly nested.\n\n    Example:\n    Input: s = \"({[]})\"\n    Output: True\n\n    Explanation: The input string is balanced because every opening bracket has a corresponding closing bracket\n    of the same type, and the brackets are properly nested.\n\n    Input: s = \"([)]\"\n    Output: False\n\n    Explanation: The input string is not balanced because the opening square bracket does not have a corresponding\n    closing square bracket.\n\n    Hint: Use a stack to keep track of opening brackets and check if the closing bracket matches the top of the stack.\n    \"\"\"\n\n    stack = []\n    mapping = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    }\n\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return len(stack) == 0", "solution_func": "def g():\n    s = \"({[]})\"\n    return s", "map_ix": [1, 0, 0, 0, 0, 0, 1, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find a subset of nums such that the XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in nums:\n        if num ^ target in nums:\n            subset.append(num)\n    return subset\n\nnums = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(g(nums, target), target) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find a subset of nums such that the XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in nums:\n        if num ^ target in nums:\n            subset.append(num)\n    return subset\n\nnums = [1, 2, 3, 4, 5]\ntarget = 6", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Check if the string contains all characters of the target string in any order.\n    \"\"\"\n    if len(target) == 0:\n        return True\n    if len(s) == 0:\n        return False\n    if target[0] in s:\n        return f(s.replace(target[0], '', 1), target[1:])\n    else:\n        return False\n\ndef g(s: str) -> str:\n    \"\"\"\n    Extract all lowercase letters from the given string and return them.\n    \"\"\"\n    lowercase_letters = [char for char in s if char.islower()]\n    return ''.join(lowercase_letters)\n\nassert f(g('HelloWorld'), 'llo') == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Check if the string contains all characters of the target string in any order.\n    \"\"\"\n    if len(target) == 0:\n        return True\n    if len(s) == 0:\n        return False\n    if target[0] in s:\n        return f(s.replace(target[0], '', 1), target[1:])\n    else:\n        return False", "solution_func": "def g(s: str) -> str:\n    \"\"\"\n    Extract all lowercase letters from the given string and return them.\n    \"\"\"\n    lowercase_letters = [char for char in s if char.islower()]\n    return ''.join(lowercase_letters)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the same list with all duplicate numbers removed and the remaining numbers sorted in non-decreasing order.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num not in stack:\n            stack.append(num)\n    stack.sort()\n    return stack\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove all negative numbers from the given list and return the result in the same order.\n    \"\"\"\n    return [num for num in nums if num >= 0]\n\nnums = [1, -2, 3, -4, 5]\nassert f(g(nums)) == [0, 1, 3, 5]\n", "emb": null, "idx_generation": 397, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the same list with all duplicate numbers removed and the remaining numbers sorted in non-decreasing order.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num not in stack:\n            stack.append(num)\n    stack.sort()\n    return stack", "solution_func": "def g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove all negative numbers from the given list and return the result in the same order.\n    \"\"\"\n    return [num for num in nums if num >= 0]\n\nnums = [1, -2, 3, -4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list.\n    If the target is not found, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    Explanation: The target value 5 is found at index 2 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 7\n    Output: -1\n    Explanation: The target value 7 is not found in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int, int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": null, "idx_generation": 397, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list.\n    If the target is not found, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    Explanation: The target value 5 is found at index 2 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 7\n    Output: -1\n    Explanation: The target value 7 is not found in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int, int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left\n    corner to the bottom-right corner of an n x n grid.\n\n    Each step, you can either move down or to the right.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2) in a 3 x 3 grid.\n\n    Input: n = 7\n    Output: 28\n    Explanation: There are 28 unique paths from (0, 0) to (6, 6) in a 7 x 7 grid.\n    \"\"\"\n\n    # Use dynamic programming to store the number of unique paths for each cell in the grid\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize the first row and first column with 1, as there is only one way to reach each cell in the first row and first column\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n\n    # Calculate the number of unique paths for each cell by summing the number of paths from the cell above and the cell to the left\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    # Return the number of unique paths for the bottom-right cell\n    return dp[n-1][n-1]\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left\n    corner to the bottom-right corner of an n x n grid.\n\n    Each step, you can either move down or to the right.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2) in a 3 x 3 grid.\n\n    Input: n = 7\n    Output: 28\n    Explanation: There are 28 unique paths from (0, 0) to (6, 6) in a 7 x 7 grid.\n    \"\"\"\n\n    # Use dynamic programming to store the number of unique paths for each cell in the grid\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize the first row and first column with 1, as there is only one way to reach each cell in the first row and first column\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n\n    # Calculate the number of unique paths for each cell by summing the number of paths from the cell above and the cell to the left\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    # Return the number of unique paths for the bottom-right cell\n    return dp[n-1][n-1]", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"olleh dlrow\"\n    Explanation: The word \"hello\" is reversed to \"olleh\", and the word \"world\" is reversed to \"dlrow\".\n\n    Input: s = \"python programming\"\n    Output: \"nohtyp gnimmargorp\"\n    Explanation: The word \"python\" is reversed to \"nohtyp\", and the word \"programming\" is reversed to \"gnimmargorp\".\n    \"\"\"\n\n    # Split the string into words\n    words = s.split()\n\n    # Reverse each word in the list\n    reversed_words = [word[::-1] for word in words]\n\n    # Join the reversed words with whitespace to form the final string\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string\n\ndef g() -> str:\n    s = \"hello world\"\n    return s\n\nassert f(g()) == \"olleh dlrow\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"olleh dlrow\"\n    Explanation: The word \"hello\" is reversed to \"olleh\", and the word \"world\" is reversed to \"dlrow\".\n\n    Input: s = \"python programming\"\n    Output: \"nohtyp gnimmargorp\"\n    Explanation: The word \"python\" is reversed to \"nohtyp\", and the word \"programming\" is reversed to \"gnimmargorp\".\n    \"\"\"\n\n    # Split the string into words\n    words = s.split()\n\n    # Reverse each word in the list\n    reversed_words = [word[::-1] for word in words]\n\n    # Join the reversed words with whitespace to form the final string\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string", "solution_func": "def g() -> str:\n    s = \"hello world\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and an integer k, return True if there are two distinct indices i and j in the list\n    such that arr[i] ^ arr[j] = k, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if k ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    arr = [4, 2, 8, 6, 10]\n    k = 12\n    return arr, k\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and an integer k, return True if there are two distinct indices i and j in the list\n    such that arr[i] ^ arr[j] = k, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if k ^ num in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g():\n    arr = [4, 2, 8, 6, 10]\n    k = 12\n    return arr, k", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the total number of positive integers less than or equal to n that have the same number\n    of 1 bits in their binary representation as n.\n    \"\"\"\n    count = 0\n    for i in range(n + 1):\n        if bin(i).count('1') == bin(n).count('1'):\n            count += 1\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the total number of positive integers less than or equal to n that have the same number\n    of 1 bits in their binary representation as n.\n    \"\"\"\n    count = 0\n    for i in range(n + 1):\n        if bin(i).count('1') == bin(n).count('1'):\n            count += 1\n    return count", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list containing the bitwise OR of all subarrays of nums.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        temp = 0\n        for j in range(i, len(nums)):\n            temp |= nums[j]\n            result.append(temp)\n    return result\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2, 3, 3]\n", "emb": null, "idx_generation": 397, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list containing the bitwise OR of all subarrays of nums.\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        temp = 0\n        for j in range(i, len(nums)):\n            temp |= nums[j]\n            result.append(temp)\n    return result", "solution_func": "def g():\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and an integer k, find the kth missing number in the array.\n\n    Example:\n    Input: nums = [4, 7, 9, 10], k = 3\n    Output: 8\n\n    Explanation:\n    The missing numbers in the array are [5, 6, 8, 11, 12, ...].\n    The kth missing number is 8, so the output is 8.\n    \"\"\"\n\n    start = 0\n    end = len(nums) - 1\n\n    while start <= end:\n        mid = start + (end - start) // 2\n\n        missing_count = nums[mid] - nums[0] - mid\n\n        if missing_count >= k:\n            end = mid - 1\n        else:\n            start = mid + 1\n\n    return nums[start - 1] + k - (nums[start - 1] - nums[0] - (start - 1))\n\ndef g() -> Tuple[List[int], int]:\n    nums = [4, 7, 9, 10]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 8\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 397, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and an integer k, find the kth missing number in the array.\n\n    Example:\n    Input: nums = [4, 7, 9, 10], k = 3\n    Output: 8\n\n    Explanation:\n    The missing numbers in the array are [5, 6, 8, 11, 12, ...].\n    The kth missing number is 8, so the output is 8.\n    \"\"\"\n\n    start = 0\n    end = len(nums) - 1\n\n    while start <= end:\n        mid = start + (end - start) // 2\n\n        missing_count = nums[mid] - nums[0] - mid\n\n        if missing_count >= k:\n            end = mid - 1\n        else:\n            start = mid + 1\n\n    return nums[start - 1] + k - (nums[start - 1] - nums[0] - (start - 1))", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [4, 7, 9, 10]\n    k = 3\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'arr', check if there exists a subset of the array whose sum is divisible by 3.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    Output: True\n    Explanation: The subset [2, 4] has a sum of 6, which is divisible by 3.\n\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        if arr[i] % 3 == 0:\n            dp[i][i] = True\n\n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if (arr[i] + arr[j]) % 3 == 0:\n                dp[i][j] = True\n            elif (arr[i] + arr[j]) % 3 != 0:\n                for k in range(i+1, j):\n                    if dp[i][k-1] and dp[k][j]:\n                        dp[i][j] = True\n                        break\n\n    return dp[0][n-1]\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 398, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'arr', check if there exists a subset of the array whose sum is divisible by 3.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    Output: True\n    Explanation: The subset [2, 4] has a sum of 6, which is divisible by 3.\n\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        if arr[i] % 3 == 0:\n            dp[i][i] = True\n\n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if (arr[i] + arr[j]) % 3 == 0:\n                dp[i][j] = True\n            elif (arr[i] + arr[j]) % 3 != 0:\n                for k in range(i+1, j):\n                    if dp[i][k-1] and dp[k][j]:\n                        dp[i][j] = True\n                        break\n\n    return dp[0][n-1]", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers 'matrix', return the spiral order of the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = []\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers 'matrix', return the spiral order of the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = []\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 1, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array 'nums' of distinct integers and a target integer, return a list of all unique quadruplets\n    [nums[a], nums[b], nums[c], nums[d]] such that:\n    - 0 <= a, b, c, d < n (where n is the length of 'nums')\n    - a, b, c, and d are distinct\n    - nums[a] + nums[b] + nums[c] + nums[d] == target\n\n    Example:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n    Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    \"\"\"\n    def threeSum(nums, target):\n        n = len(nums)\n        result = []\n\n        for i in range(n-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left = i + 1\n            right = n - 1\n\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n\n                    left += 1\n                    right -= 1\n\n        return result\n\n    nums.sort()\n    n = len(nums)\n    result = []\n\n    for i in range(n-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n\n        three_sum_result = threeSum(nums[i+1:], target - nums[i])\n\n        for triple in three_sum_result:\n            result.append([nums[i]] + triple)\n\n    return result\n\ndef g() -> Tuple:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n    return nums, target\n\nassert f(*g()) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array 'nums' of distinct integers and a target integer, return a list of all unique quadruplets\n    [nums[a], nums[b], nums[c], nums[d]] such that:\n    - 0 <= a, b, c, d < n (where n is the length of 'nums')\n    - a, b, c, and d are distinct\n    - nums[a] + nums[b] + nums[c] + nums[d] == target\n\n    Example:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n    Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    \"\"\"\n    def threeSum(nums, target):\n        n = len(nums)\n        result = []\n\n        for i in range(n-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left = i + 1\n            right = n - 1\n\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n\n                    left += 1\n                    right -= 1\n\n        return result\n\n    nums.sort()\n    n = len(nums)\n    result = []\n\n    for i in range(n-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n\n        three_sum_result = threeSum(nums[i+1:], target - nums[i])\n\n        for triple in three_sum_result:\n            result.append([nums[i]] + triple)\n\n    return result", "solution_func": "def g() -> Tuple:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each element is the bitwise XOR of the two adjacent numbers in the original list.\n\n    Example:\n    Input: numbers = [1, 2, 3, 4, 5]\n    Output: [3, 1, 7, 1]\n\n    Explanation:\n    The XOR of 1 and 2 is 3.\n    The XOR of 2 and 3 is 1.\n    The XOR of 3 and 4 is 7.\n    The XOR of 4 and 5 is 1.\n    \"\"\"\n    xor_list = []\n    for i in range(len(numbers) - 1):\n        xor_list.append(numbers[i] ^ numbers[i + 1])\n    return xor_list\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers to be used as input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [3, 1, 7, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each element is the bitwise XOR of the two adjacent numbers in the original list.\n\n    Example:\n    Input: numbers = [1, 2, 3, 4, 5]\n    Output: [3, 1, 7, 1]\n\n    Explanation:\n    The XOR of 1 and 2 is 3.\n    The XOR of 2 and 3 is 1.\n    The XOR of 3 and 4 is 7.\n    The XOR of 4 and 5 is 1.\n    \"\"\"\n    xor_list = []\n    for i in range(len(numbers) - 1):\n        xor_list.append(numbers[i] ^ numbers[i + 1])\n    return xor_list", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers to be used as input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n\n    Example:\n    Input: s = \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    Explanation:\n    After removing all non-alphanumeric characters and ignoring case, the string becomes \"amanaplanacanalpanama\", which is a palindrome.\n    \"\"\"\n    s = \"\".join(filter(str.isalnum, s)).lower()\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n\n    Example:\n    Input: s = \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    Explanation:\n    After removing all non-alphanumeric characters and ignoring case, the string becomes \"amanaplanacanalpanama\", which is a palindrome.\n    \"\"\"\n    s = \"\".join(filter(str.isalnum, s)).lower()\n    return s == s[::-1]", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string that is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest common prefix among all the words.\n\n    Example:\n    Input: words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation:\n    The longest common prefix among the words \"flower\", \"flow\", and \"flight\" is \"fl\".\n    \"\"\"\n    if not words:\n        return \"\"\n    shortest_word = min(words, key=len)\n    for i, char in enumerate(shortest_word):\n        if any(word[i] != char for word in words):\n            return shortest_word[:i]\n    return shortest_word\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words to be used as input for the function f.\n    \"\"\"\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest common prefix among all the words.\n\n    Example:\n    Input: words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation:\n    The longest common prefix among the words \"flower\", \"flow\", and \"flight\" is \"fl\".\n    \"\"\"\n    if not words:\n        return \"\"\n    shortest_word = min(words, key=len)\n    for i, char in enumerate(shortest_word):\n        if any(word[i] != char for word in words):\n            return shortest_word[:i]\n    return shortest_word", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of words to be used as input for the function f.\n    \"\"\"\n    return [\"flower\", \"flow\", \"flight\"]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    The maximum product can be obtained by multiplying 3, 4, and 5.\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    \n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    The maximum product can be obtained by multiplying 3, 4, and 5.\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    \n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the words in the string while preserving the order of the words.\n\n    Example:\n    s = \"hello world\"\n    \n    The words in the string are \"hello\" and \"world\".\n    After reversing the words, the string becomes \"world hello\".\n    Therefore, the function should return \"world hello\".\n    \"\"\"\n    words = s.split()\n    \n    return ' '.join(words[::-1])\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"hello world\"\n    return s\n\nassert f(g()) == \"world hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the words in the string while preserving the order of the words.\n\n    Example:\n    s = \"hello world\"\n    \n    The words in the string are \"hello\" and \"world\".\n    After reversing the words, the string becomes \"world hello\".\n    Therefore, the function should return \"world hello\".\n    \"\"\"\n    words = s.split()\n    \n    return ' '.join(words[::-1])", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"hello world\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    The maximum sum of a subarray can be obtained by selecting the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 398, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    The maximum sum of a subarray can be obtained by selecting the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible substrings of s that are palindromes.\n\n    Example:\n    Input: \"abcb\"\n\n    Output: [\"a\", \"b\", \"c\", \"b\", \"bb\"]\n\n    Explanation:\n    The palindromic substrings in the string \"abcb\" are: \"a\", \"b\", \"c\", \"b\", and \"bb\".\n    \"\"\"\n\n    def is_palindrome(substring):\n        return substring == substring[::-1]\n\n    substrings = []\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if is_palindrome(substring):\n                substrings.append(substring)\n\n    return substrings\n\ndef g() -> str:\n    return \"abcb\"\n\nassert f(g()) == [\"a\", \"b\", \"c\", \"b\", \"bb\"]\n\n", "emb": null, "idx_generation": 398, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nimport math\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, return a list of all possible substrings of s that are palindromes.\n\n    Example:\n    Input: \"abcb\"\n\n    Output: [\"a\", \"b\", \"c\", \"b\", \"bb\"]\n\n    Explanation:\n    The palindromic substrings in the string \"abcb\" are: \"a\", \"b\", \"c\", \"b\", and \"bb\".\n    \"\"\"\n\n    def is_palindrome(substring):\n        return substring == substring[::-1]\n\n    substrings = []\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if is_palindrome(substring):\n                substrings.append(substring)\n\n    return substrings", "solution_func": "def g() -> str:\n    return \"abcb\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find whether there exists a subsequence of the given list of numbers whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        include = subset_sum(nums, target, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, current_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums = [1, 2, 3, 4, 5, 6], target = 9):\n    return nums\n\nassert f(g(), 9)\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find whether there exists a subsequence of the given list of numbers whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        include = subset_sum(nums, target, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, current_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)", "solution_func": "def g(nums = [1, 2, 3, 4, 5, 6], target = 9):\n    return nums", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether the given matrix is a magic square.\n    \"\"\"\n    n = len(matrix)\n    row_sum = [0] * n\n    col_sum = [0] * n\n    diag_sum = [0, 0]\n    \n    for i in range(n):\n        for j in range(n):\n            row_sum[i] += matrix[i][j]\n            col_sum[j] += matrix[i][j]\n            if i == j:\n                diag_sum[0] += matrix[i][j]\n            if i + j == n - 1:\n                diag_sum[1] += matrix[i][j]\n    \n    target_sum = row_sum[0]\n    \n    if any(sum != target_sum for sum in row_sum + col_sum + diag_sum):\n        return False\n    \n    return True\n\ndef g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g())\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether the given matrix is a magic square.\n    \"\"\"\n    n = len(matrix)\n    row_sum = [0] * n\n    col_sum = [0] * n\n    diag_sum = [0, 0]\n    \n    for i in range(n):\n        for j in range(n):\n            row_sum[i] += matrix[i][j]\n            col_sum[j] += matrix[i][j]\n            if i == j:\n                diag_sum[0] += matrix[i][j]\n            if i + j == n - 1:\n                diag_sum[1] += matrix[i][j]\n    \n    target_sum = row_sum[0]\n    \n    if any(sum != target_sum for sum in row_sum + col_sum + diag_sum):\n        return False\n    \n    return True", "solution_func": "def g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether it is possible to reach the bottom-right cell of the grid from the top-left cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i: int, j: int) -> bool:\n        if i == m - 1 and j == n - 1:\n            return True\n        if i >= m or j >= n or grid[i][j] == 1 or visited[i][j]:\n            return False\n        \n        visited[i][j] = True\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    \n    return dfs(0, 0)\n\ndef g(grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return grid\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether it is possible to reach the bottom-right cell of the grid from the top-left cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i: int, j: int) -> bool:\n        if i == m - 1 and j == n - 1:\n            return True\n        if i >= m or j >= n or grid[i][j] == 1 or visited[i][j]:\n            return False\n        \n        visited[i][j] = True\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    \n    return dfs(0, 0)", "solution_func": "def g(grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there is a subset of nums that sums up to the target value.\n    Return True if such subset exists, False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8], target = 10\n    Output: True\n\n    Explanation:\n    The subset [2, 8] has a sum of 10, which is equal to the target value.\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int, curr_sum: int, index: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        \n        include = subset_sum(nums, target, curr_sum + nums[index], index + 1)\n        exclude = subset_sum(nums, target, curr_sum, index + 1)\n        \n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8], 10\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there is a subset of nums that sums up to the target value.\n    Return True if such subset exists, False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8], target = 10\n    Output: True\n\n    Explanation:\n    The subset [2, 8] has a sum of 10, which is equal to the target value.\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int, curr_sum: int, index: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        \n        include = subset_sum(nums, target, curr_sum + nums[index], index + 1)\n        exclude = subset_sum(nums, target, curr_sum, index + 1)\n        \n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)", "solution_func": "def g() -> List[int]:\n    return [2, 4, 6, 8], 10", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is sorted in ascending order of their lengths.\n    If multiple strings have the same length, they should be sorted in alphabetical order.\n\n    Example:\n    Input: strings = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n    Output: [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n    \"\"\"\n\n    return sorted(strings, key=lambda x: (len(x), x))\n\ndef g() -> List[str]:\n    return [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n\nassert f(g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is sorted in ascending order of their lengths.\n    If multiple strings have the same length, they should be sorted in alphabetical order.\n\n    Example:\n    Input: strings = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n    Output: [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n    \"\"\"\n\n    return sorted(strings, key=lambda x: (len(x), x))", "solution_func": "def g() -> List[str]:\n    return [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 8\n\n    Explanation:\n    The maximum sum of a path from the top-left corner to the bottom-right corner is 8 (1 + 3 + 1 + 1 + 1).\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the first row with cumulative sums\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Initialize the first column with cumulative sums\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Compute the cumulative sums for the rest of the grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[-1][-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 399, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 8\n\n    Explanation:\n    The maximum sum of a path from the top-left corner to the bottom-right corner is 8 (1 + 3 + 1 + 1 + 1).\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize the first row with cumulative sums\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Initialize the first column with cumulative sums\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Compute the cumulative sums for the rest of the grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[-1][-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, return a new matrix where each element is the sum of its adjacent elements (up, down, left, and right).\n    The sum should be calculated using bitwise XOR operation.\n\n    Example:\n    Input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n\n    Output:\n    [[4, 3, 4],\n     [5, 12, 5],\n     [8, 7, 8]]\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    new_matrix = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            new_matrix[i][j] = matrix[i][j] ^ matrix[max(i - 1, 0)][j] ^ matrix[min(i + 1, m - 1)][j] ^ matrix[i][max(j - 1, 0)] ^ matrix[i][min(j + 1, n - 1)]\n    \n    return new_matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[4, 3, 4], [5, 12, 5], [8, 7, 8]]\n", "emb": null, "idx_generation": 399, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, return a new matrix where each element is the sum of its adjacent elements (up, down, left, and right).\n    The sum should be calculated using bitwise XOR operation.\n\n    Example:\n    Input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n\n    Output:\n    [[4, 3, 4],\n     [5, 12, 5],\n     [8, 7, 8]]\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    new_matrix = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            new_matrix[i][j] = matrix[i][j] ^ matrix[max(i - 1, 0)][j] ^ matrix[min(i + 1, m - 1)][j] ^ matrix[i][max(j - 1, 0)] ^ matrix[i][min(j + 1, n - 1)]\n    \n    return new_matrix", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value of any two elements in the matrix.\n\n    Example:\n    Input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n\n    Output:\n    12\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    max_xor = 0\n    \n    for i in range(m):\n        for j in range(n):\n            for x in range(m):\n                for y in range(n):\n                    xor = matrix[i][j] ^ matrix[x][y]\n                    max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 12\n", "emb": null, "idx_generation": 399, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value of any two elements in the matrix.\n\n    Example:\n    Input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n\n    Output:\n    12\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    max_xor = 0\n    \n    for i in range(m):\n        for j in range(n):\n            for x in range(m):\n                for y in range(n):\n                    xor = matrix[i][j] ^ matrix[x][y]\n                    max_xor = max(max_xor, xor)\n    \n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list such that their XOR is equal to the target value.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    [1, 3]\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target ^ num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 6\n\nassert f(*g()) == [1, 3]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 399, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list such that their XOR is equal to the target value.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    [1, 3]\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target ^ num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 6", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median of the list.\n\n    Return the median value as an integer.\n\n    Example:\n    nums = [1, 4, 7, 2, 9, 5, 3]\n\n    The median of the list is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[n // 2 - 1]) // 2\n    else:\n        return nums[n // 2]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 4, 7, 2, 9, 5, 3]\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 399, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median of the list.\n\n    Return the median value as an integer.\n\n    Example:\n    nums = [1, 4, 7, 2, 9, 5, 3]\n\n    The median of the list is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[n // 2 - 1]) // 2\n    else:\n        return nums[n // 2]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 4, 7, 2, 9, 5, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}]
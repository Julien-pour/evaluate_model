[
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the length of the longest increasing subsequence (LIS) using dynamic programming.\n    The LIS is defined as the longest subsequence in the list where the elements are in increasing order.\n    Return the length of the LIS.\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0\n    \n    lis = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if numbers[i] > numbers[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    \n    return max(lis)\n\n\ndef g():\n    numbers = [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    return numbers\n\n\nassert f(g()) == 6\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the indices of two numbers in the input list that add up to the target sum, by using a stack and dynamic programming approach.\nArgs:\n    nums: The input list of numbers.\n    target: The target sum.\nReturns:\n    The indices of the two numbers that add up to the target sum.\"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return None\n\ndef g():\n    \"\"\"\n    Returns the input for the function f.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 458,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, return True if the target value exists in the grid, and False otherwise.\n    The grid is represented as a list of lists, where each inner list represents a row in the grid.\n    \"\"\"\n    if not grid:\n        return False\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        x, y = stack.pop()\n\n        if grid[x][y] == target:\n            return True\n\n        if (x, y) not in visited:\n            visited.add((x, y))\n\n            if x + 1 < rows:\n                stack.append((x + 1, y))\n            if y + 1 < cols:\n                stack.append((x, y + 1))\n\n    return False\n\ndef g(grid: List[List[int]], target: int):\n    return grid, target\n\nassert f(*g([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5))\n",
        "idx_generation": 11,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=10) -> bool:\n    \"\"\"Check if there is a path in the grid that adds up to the target\"\"\"\n    def dfs(i, j, current_sum):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return False\n        current_sum += grid[i][j]\n        if current_sum == target:\n            return True\n        return dfs(i+1, j, current_sum) or dfs(i, j+1, current_sum)\n    \n    return dfs(0, 0, 0)\n\ndef g(target=10):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Determine if there is a valid path from the top-left corner to the bottom-right corner of the grid,\n    considering the following rules:\n    - You can only move down or right.\n    - You can only visit each cell once.\n    - You cannot visit cells with the value 'X'.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(row, col, visited):\n        if row == m-1 and col == n-1:\n            return True\n        if row >= m or col >= n or grid[row][col] == 'X' or (row, col) in visited:\n            return False\n        visited.add((row, col))\n        return dfs(row+1, col, visited) or dfs(row, col+1, visited)\n    \n    return dfs(0, 0, set())\n\ndef g(grid: List[List[str]]):\n    return grid\n\nassert f(g([['O', 'O', 'O', 'O'],\n            ['O', 'X', 'O', 'X'],\n            ['O', 'O', 'O', 'O'],\n            ['O', 'X', 'X', 'O']]))\n\nassert not f(g([['O', 'O', 'O', 'O'],\n                ['O', 'X', 'O', 'X'],\n                ['O', 'O', 'X', 'O'],\n                ['O', 'X', 'X', 'O']]))\n",
        "idx_generation": 41,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the order of characters in each word while preserving whitespace and word order.\"\"\"\n    words = s.split()\n    reversed_words = []\n    for word in words:\n        reversed_words.append(word[::-1])\n    return ' '.join(reversed_words)\ndef g(s=\"hello world\"):\n    return s\nassert f(g()) == \"olleh dlrow\"\n",
        "idx_generation": 1,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if it is possible to form string s by repeating a specific substring n or more times\"\"\"\n    m = len(s) // n\n    for i in range(1, m+1):\n        if s == s[:i] * n or s == s[:i] * (n+1):\n            return True\n    return False\ndef g(n=3):\n    return \"abc\" * n\nassert f(g())\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word='python') -> bool:\n    \"\"\"Check if the given word exists in the grid horizontally or vertically\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    for i in range(rows):\n        for j in range(cols - len(word) + 1):\n            if ''.join(grid[i][j:j+len(word)]) == word:\n                return True\n    for j in range(cols):\n        for i in range(rows - len(word) + 1):\n            if ''.join(grid[x][j] for x in range(i, i+len(word))) == word:\n                return True\n    return False\n\ndef g(word='python'):\n    grid = [['p', 'y', 't', 'h', 'o', 'n'],\n            ['a', 'b', 'c', 'd', 'e', 'f'],\n            ['g', 'h', 'i', 'j', 'k', 'l'],\n            ['m', 'n', 'o', 'p', 'q', 'r']]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 306,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a grid of numbers and a target number, determine if the target number can be formed by concatenating the numbers in the grid.\n    Return True if the target number can be formed, otherwise return False.\"\"\"\n    def search_number(row, col, index):\n        if index == len(str(target)):\n            return True\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != int(str(target)[index]):\n            return False\n        temp = grid[row][col]\n        grid[row][col] = '#'\n        found = search_number(row+1, col, index+1) or search_number(row-1, col, index+1) or search_number(row, col+1, index+1) or search_number(row, col-1, index+1)\n        grid[row][col] = temp\n        return found\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if search_number(i, j, 0):\n                return True\n    return False\n\ndef g(target=123):\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, a=3, b=23463462) -> bool:\n    \"\"\"Determine if the bitwise AND of all integers from 1 to n (inclusive) is divisible by k\"\"\"\n    bitwise_and = 2 ** 31 - 1\n    for i in range(1, n + 1):\n        bitwise_and &= i\n    return bitwise_and % k == 0\ndef g(a=3, b=23463462):\n    return (a, b)\nassert f(*g())\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a pair of numbers in the list whose XOR is equal to 0.\"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums: List[int]=[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, k=3) -> bool:\n    \"\"\"Check if the binary representation of num has exactly k consecutive 0's.\"\"\"\n    binary = bin(num)[2:]\n    return '0' * k in binary\ndef g(k=3):\n    num = 0\n    while True:\n        if f(num, k):\n            return num\n        num += 1\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(target: int, nums: List[int]) -> bool:\n    \"\"\"Given a target number and a list of integers, determine if it is possible to obtain the target by performing bitwise XOR operations on the integers in the list.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if dp[i - 1][j]:\n                dp[i][j] = True\n                if j ^ nums[i - 1] <= target:\n                    dp[i][j ^ nums[i - 1]] = True\n    return dp[n][target]\ndef g():\n    return (10, [2, 5, 8])\nassert f(*g())\n",
        "idx_generation": 183,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"Generate all possible binary strings of length n.\"\"\"\n    result = []\n    for i in range(2 ** n):\n        binary = bin(i)[2:]\n        binary = '0' * (n - len(binary)) + binary\n        result.append(binary)\n    return result\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == ['000', '001', '010', '011', '100', '101', '110', '111']\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=2) -> bool:\n    \"\"\"Determine if the binary representation of a number 'n' contains a consecutive sequence of 'k' ones.\n    Return True if such a sequence exists, otherwise return False.\n    Example:\n    n = 13, k = 2\n    The binary representation of 13 is 1101, which contains a consecutive sequence of 2 ones.\n    Therefore, the output should be True.\"\"\"\n    binary = bin(n)[2:]\n    count = 0\n    for digit in binary:\n        if digit == '1':\n            count += 1\n            if count == k:\n                return True\n        else:\n            count = 0\n    return False\n\ndef g(n=13, k=2):\n    return n\n\nassert f(g())\n",
        "idx_generation": 233,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Check if it is possible to obtain the target number by combining the given numbers using addition, subtraction, multiplication, and division.\"\"\"\n    assert all(isinstance(n, int) for n in numbers)\n    def helper(nums, curr_sum):\n        if not nums:\n            return curr_sum == target\n        num = nums[0]\n        return helper(nums[1:], curr_sum + num) or helper(nums[1:], curr_sum - num) or helper(nums[1:], curr_sum * num) or (num != 0 and curr_sum % num == 0 and helper(nums[1:], curr_sum // num))\n    return helper(numbers, 0)\ndef g():\n    return [1, 2, 3, 4]\nassert f(g())\n",
        "idx_generation": 56,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner of the grid.\n    You can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 21,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of integers, where each integer represents the cost of moving to that cell.\n    The valid movements are rightward and downward.\n    Return the minimum cost of reaching the bottom-right corner from the top-left corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    return dp[rows-1][cols-1]\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 7\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node.\n    Args:\n        graph: The graph represented as an adjacency list.\n    Returns:\n        True if a path exists from the start node to the end node, False otherwise.\n    \"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    start = 0\n    end = len(graph) - 1\n    visited = set()\n    return dfs(start, visited)\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 3], [0, 4], [1], [2]]\n\nassert f(g())\n",
        "idx_generation": 92,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a string and a grid of letters, determine if it is possible to form the string by traversing adjacent cells in the grid.\n    The string can be formed by moving up, down, left, or right in the grid, but not diagonally.\n    Each cell in the grid can only be used once.\n    Additionally, each letter in the string must be visited exactly k times.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    def dfs(i: int, j: int, idx: int) -> bool:\n        if idx == len(s):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j] >= k or grid[i][j] != s[idx]:\n            return False\n        visited[i][j] += 1\n        found = dfs(i+1, j, idx+1) or dfs(i-1, j, idx+1) or dfs(i, j+1, idx+1) or dfs(i, j-1, idx+1)\n        visited[i][j] -= 1\n        return found\n\n    visited = [[0] * len(grid[0]) for _ in range(len(grid))]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(s: str, k: int, grid: List[List[str]]):\n    return s, k, grid\n\ngrid = [['A', 'B', 'C', 'D'],\n        ['E', 'A', 'B', 'C'],\n        ['D', 'E', 'F', 'A'],\n        ['B', 'C', 'D', 'E']]\ns = \"ABCD\"\nk = 2\nassert f(*g(s, k, grid))\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in the given matrix.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    stack = [(0, 0)]\n    while stack:\n        x, y = stack.pop()\n        if x == m-1 and y == n-1:\n            return True\n        if 0 <= x+1 < m and matrix[x+1][y] == 0:\n            stack.append((x+1, y))\n        if 0 <= y+1 < n and matrix[x][y+1] == 0:\n            stack.append((x, y+1))\n    return False\n\ndef g():\n    return [[0, 0, 1], [0, 1, 0], [0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if there is a path from the top-left corner to the bottom-right corner in a grid, avoiding obstacles and visiting every cell exactly once.\"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    visited = [[False] * n for _ in range(m)]\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n        if grid[i][j] == 1 or visited[i][j]:\n            return False\n        visited[i][j] = True\n        if i + 1 < m and dfs(i + 1, j):\n            return True\n        if j + 1 < n and dfs(i, j + 1):\n            return True\n        if i - 1 >= 0 and dfs(i - 1, j):\n            return True\n        if j - 1 >= 0 and dfs(i, j - 1):\n            return True\n        visited[i][j] = False\n        return False\n    return dfs(0, 0)\ndef g(m=3, n=3, obstacles=2):\n    import random\n    grid = [[0] * n for _ in range(m)]\n    for _ in range(obstacles):\n        (i, j) = (random.randint(0, m - 1), random.randint(0, n - 1))\n        grid[i][j] = 1\n    return grid\nassert f(g())\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, determine if there is a path in the graph formed by connecting words that can be transformed by changing one letter at a time.\"\"\"\n    graph = {}\n    for word in words:\n        for i in range(len(word)):\n            pattern = word[:i] + \"_\" + word[i+1:]\n            if pattern not in graph:\n                graph[pattern] = []\n            graph[pattern].append(word)\n    \n    visited = set()\n    for word in words:\n        if word in visited:\n            continue\n        queue = [(word, 0)]\n        while queue:\n            current, steps = queue.pop(0)\n            visited.add(current)\n            for i in range(len(current)):\n                pattern = current[:i] + \"_\" + current[i+1:]\n                if pattern in graph:\n                    for neighbor in graph[pattern]:\n                        if neighbor == word:\n                            return steps <= 1\n                        if neighbor not in visited:\n                            queue.append((neighbor, steps + 1))\n    return False\n\ndef g():\n    return [\"cat\", \"bat\", \"bit\", \"big\"]\n\nassert f(g())\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Count the number of closed shapes in the grid, where 'X' represents a closed shape and '.' represents an empty space. A closed shape is a collection of 'X' characters connected horizontally or vertically.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'X':\n                dfs(grid, i, j, rows, cols)\n                count += 1\n    return count\n\ndef dfs(grid, i, j, rows, cols):\n    if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 'X':\n        return\n    grid[i][j] = '.'\n    dfs(grid, i+1, j, rows, cols)\n    dfs(grid, i-1, j, rows, cols)\n    dfs(grid, i, j+1, rows, cols)\n    dfs(grid, i, j-1, rows, cols)\n\ndef g():\n    grid = [[\"X\", \".\", \".\", \"X\"], [\".\", \"X\", \"X\", \"X\"], [\".\", \".\", \".\", \"X\"]]\n    return (grid,)\nassert f(*g()) == 2\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, check if there exists a path from the top-left corner to the bottom-right corner\n    such that the sum of the numbers along the path is a multiple of 3.\n    You can only move down or right in the grid.\n    Return True if such a path exists, False otherwise.\"\"\"\n    def dfs(i, j, curr_sum):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return curr_sum % 3 == 0\n        if i + 1 < len(grid):\n            if dfs(i + 1, j, curr_sum + grid[i + 1][j]):\n                return True\n        if j + 1 < len(grid[0]):\n            if dfs(i, j + 1, curr_sum + grid[i][j + 1]):\n                return True\n        return False\n\n    return dfs(0, 0, grid[0][0])\n\ndef g(grid=[[1,2,3],[4,5,6],[7,8,9]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, check if it forms a valid magic square. A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both diagonals are the same.\"\"\"\n    def is_magic_square(grid):\n        n = len(grid)\n        target_sum = sum(grid[0])\n        # Check rows\n        for row in grid:\n            if sum(row) != target_sum:\n                return False\n        # Check columns\n        for col in zip(*grid):\n            if sum(col) != target_sum:\n                return False\n        # Check diagonal from top-left to bottom-right\n        diagonal_sum = sum(grid[i][i] for i in range(n))\n        if diagonal_sum != target_sum:\n            return False\n        # Check diagonal from top-right to bottom-left\n        diagonal_sum = sum(grid[i][n - i - 1] for i in range(n))\n        if diagonal_sum != target_sum:\n            return False\n        return True\n    \n    return is_magic_square(grid)\n\ndef g(grid=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 245,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid representing a treasure map, find the maximum possible treasure that can be collected by starting at the top-left corner and moving to the bottom-right corner.\n    The grid is represented as a matrix, with each cell containing a non-negative integer representing the amount of treasure in that cell.\n    You can only move down or right at each step.\n    Return the maximum possible treasure that can be collected.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there is a combination of numbers in the list that adds up to the target.\n    The combination can include any number of duplicates of the same number.\n\n    Return True if a combination exists, False otherwise.\n    \"\"\"\n\n    def backtrack(index: int, curr_sum: int, path: List[int]) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n\n        for i in range(index, len(nums)):\n            path.append(nums[i])\n            if backtrack(i, curr_sum+nums[i], path):\n                return True\n            path.pop()\n\n        return False\n\n    nums.sort()\n    return backtrack(0, 0, [])\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of distinct combinations of numbers in a list that sum up to a target value.\"\"\"\n    def backtrack(remain, start, path):\n        if remain == 0:\n            return 1\n        elif remain < 0:\n            return 0\n        else:\n            count = 0\n            for i in range(start, len(nums)):\n                count += backtrack(remain - nums[i], i, path + [nums[i]])\n            return count\n\n    return backtrack(target, 0, [])\n\ndef g():\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == 2\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Check if the given word exists in the grid, where adjacent letters can be connected horizontally or vertically.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == word[0]:\n                stack.append((i, j, 0))\n    while stack:\n        (x, y, idx) = stack.pop()\n        if idx == len(word) - 1:\n            return True\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == word[idx + 1]:\n                stack.append((new_x, new_y, idx + 1))\n    return False\ndef g():\n    grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]\n    word = \"ABCCED\"\n    return grid, word\nassert f(*g())\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Count the number of combinations of 1s in the binary representation of the given number.\"\"\"\n    def count_combinations(num: int) -> int:\n        count = 0\n        while num:\n            num &= (num - 1)\n            count += 1\n        return count\n    \n    return count_combinations(n)\n\ndef g(n: int):\n    return n\n\nassert f(g(n=10)) == 2\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of 0s and 1s, find the number of islands. An island is a group of connected 1s (horizontally or vertically).\"\"\"\n    def dfs(row, col):\n        if row < 0 or col < 0 or row >= m or col >= n or matrix[row][col] != 1:\n            return\n        matrix[row][col] = -1\n        dfs(row-1, col)\n        dfs(row+1, col)\n        dfs(row, col-1)\n        dfs(row, col+1)\n\n    m = len(matrix)\n    n = len(matrix[0])\n    islands = 0\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                islands += 1\n                dfs(i, j)\n\n    return islands\n\ndef g():\n    return ([[1, 1, 0, 0, 0],\n             [1, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0],\n             [0, 0, 0, 1, 1]],)\n\nassert f(*g()) == 3\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number is present in the matrix. The matrix is a 2D list of integers, sorted in non-decreasing order from left to right and top to bottom.\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g(matrix=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return (matrix, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 147,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums=[5, 8, 2, 1, 6]):\n    return nums\n\nassert f(g()) == [1, 2, 5, 6, 8]\n",
        "idx_generation": 7,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the median of the list.\"\"\"\n    def partition(start: int, end: int) -> int:\n        pivot = nums[end]\n        i = start - 1\n        for j in range(start, end):\n            if nums[j] <= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1], nums[end] = nums[end], nums[i+1]\n        return i+1\n\n    def quickselect(start: int, end: int, k: int) -> int:\n        if start == end:\n            return nums[start]\n        pivot_index = partition(start, end)\n        if pivot_index == k:\n            return nums[pivot_index]\n        elif pivot_index < k:\n            return quickselect(pivot_index+1, end, k)\n        else:\n            return quickselect(start, pivot_index-1, k)\n\n    n = len(nums)\n    median_index = n // 2\n    if n % 2 == 0:\n        return (quickselect(0, n-1, median_index) + quickselect(0, n-1, median_index-1)) / 2\n    else:\n        return quickselect(0, n-1, median_index)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return nums\n\nnums = [1, 4, 2, 7, 5, 3, 6]\nassert f(g(nums)) == 4\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: list) -> int:\n    \"\"\"Find the maximum sum of a subarray in a given list of integers.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers nums, find the maximum possible XOR of any two different numbers in the array.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        \n        candidate = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ candidate) in prefixes:\n                max_xor = candidate\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 433,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, determine if the target value exists in the grid.\n    The grid is sorted in ascending order both row-wise and column-wise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False\n\ndef g():\n    grid = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    return grid\n\nassert f(g(), 5) == True\n",
        "idx_generation": 278,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid represented as a 2D list, determine if there exists a path from the start point to the end point.\n    Args:\n        grid: The grid represented as a 2D list where 0 represents an empty space and 1 represents a wall.\n        start: The starting point as a tuple (row, column).\n        end: The ending point as a tuple (row, column).\n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    queue = [(start[0], start[1])]\n    while queue:\n        row, col = queue.pop(0)\n        visited.add((row, col))\n        if (row, col) == end:\n            return True\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0:\n                queue.append((new_row, new_col))\n    return False\ndef g():\n    \"\"\"\n    Returns a sample grid represented as a 2D list.\n    \"\"\"\n    return [\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\nassert f(g(), (0, 0), (4, 4))\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, lst=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew']) -> bool:\n    \"\"\"Check if the given string can be formed by concatenating the elements from the list, in any order, while maintaining alphabetical order.\"\"\"\n    def backtrack(curr, prev):\n        if ''.join(curr) == s:\n            return True\n        for i in range(len(lst)):\n            if not visited[i]:\n                if lst[i] >= prev:\n                    visited[i] = True\n                    curr.append(lst[i])\n                    if backtrack(curr, lst[i]):\n                        return True\n                    curr.pop()\n                    visited[i] = False\n        return False\n\n    visited = [False] * len(lst)\n    return backtrack([], \"\")\n\ndef g(lst=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew']):\n    return ''.join(lst)\nassert f(g())\n",
        "idx_generation": 114,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target_sum=15) -> bool:\n    \"\"\"Check if there exists a row, column, or diagonal in the grid that sums up to the target_sum\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Check rows\n    for i in range(n):\n        if sum(grid[i]) == target_sum:\n            return True\n    \n    # Check columns\n    for j in range(m):\n        column_sum = 0\n        for i in range(n):\n            column_sum += grid[i][j]\n        if column_sum == target_sum:\n            return True\n    \n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += grid[i][i]\n        diagonal_sum2 += grid[i][n - 1 - i]\n    if diagonal_sum1 == target_sum or diagonal_sum2 == target_sum:\n        return True\n    \n    return False\n\ndef g(target_sum=15):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 326,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the elements of the matrix in spiral order.\n    Spiral order is defined as starting from the top left corner of the matrix, moving in a clockwise direction until all elements are visited.\"\"\"\n    result = []\n    if not matrix or not matrix[0]:\n        return result\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    direction = 0\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n    return result\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], n=5) -> bool:\n    \"\"\"Check if there exists a subgrid of size n x n in the matrix that has all bits set to 1\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows - n + 1):\n        for j in range(cols - n + 1):\n            subgrid = [row[j:j+n] for row in matrix[i:i+n]]\n            if all(all(cell == 1 for cell in row) for row in subgrid):\n                return True\n    return False\ndef g(n=5):\n    return [[1] * n] * n\nassert f(g())\n",
        "idx_generation": 102,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose XOR is equal to the target.\"\"\"\n    stack = []\n    for num in nums:\n        if target ^ num in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nassert f(g(), 10)\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose bitwise XOR is equal to the target value.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor_val = nums[left] ^ nums[right]\n        if xor_val == target:\n            return True\n        elif xor_val < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [4, 3, 6, 10, 8, 2]\n\nassert f(g(), 12)\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists a pair of elements whose bitwise XOR is equal to the target value.\"\"\"\n    def helper(arr, target, start, end):\n        if start >= end:\n            return False\n        if arr[start] ^ arr[end] == target:\n            return True\n        elif arr[start] ^ arr[end] < target:\n            return helper(arr, target, start + 1, end)\n        else:\n            return helper(arr, target, start, end - 1)\n    return helper(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[2, 4, 6, 8, 10], target=0):\n    return arr\nassert f(g(), target=14)\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the list in non-decreasing order of the number of set bits in each element.\"\"\"\n    return sorted(arr, key=lambda x: bin(x).count('1'))\ndef g(arr: List[int]):\n    return arr\nassert f(g([5, 3, 7, 1, 2])) == [1, 2, 5, 3, 7]\n",
        "idx_generation": 470,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given an array of integers and a target value, find if there are two numbers in the array that sum up to the target value.\n    Sample Input:\n    arr = [1, 4, 6, 8, 2, 9]\n    target = 10\n    Sample Output:\n    True\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 4, 6, 8, 2, 9], target=10):\n    return arr\nassert f(g())\n",
        "idx_generation": 175,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers nums, return a new list where each element is the product of all the numbers in nums except the one at the same index.\"\"\"\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n    result = [0] * n\n    for i in range(1, n):\n        prefix[i] = prefix[i-1] * nums[i-1]\n    for i in range(n-2, -1, -1):\n        suffix[i] = suffix[i+1] * nums[i+1]\n    for i in range(n):\n        result[i] = prefix[i] * suffix[i]\n    return result\ndef g(nums=[1, 2, 3, 4]):\n    return (nums,)\nassert f(*g()) == [24, 12, 8, 6]\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and a value k, find the maximum value in each subarray of length k and return the resulting list.\"\"\"\n    if k > len(nums):\n        return []\n    max_values = []\n    max_value = max(nums[:k])\n    max_values.append(max_value)\n    for i in range(k, len(nums)):\n        if nums[i - k] == max_value:\n            max_value = max(nums[i - k + 1:i + 1])\n        else:\n            max_value = max(max_value, nums[i])\n        max_values.append(max_value)\n    return max_values\n\ndef g():\n    nums = [1, 3, -1, -3, 5, 3, 6, 7]\n    k = 3\n    return (nums, k)\n\nassert f(*g()) == [3, 3, 5, 5, 6, 7]\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner in the given grid\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        x, y = stack.pop()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if x == m-1 and y == n-1:\n            return True\n        if x+1 < m and grid[x+1][y] == 0:\n            stack.append((x+1, y))\n        if y+1 < n and grid[x][y+1] == 0:\n            stack.append((x, y+1))\n    return False\n\ndef g():\n    grid = [[0, 1, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [1, 1, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Generate a spiral matrix of size n x n.\"\"\"\n    matrix = [[0] * n for _ in range(n)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    direction_index = 0\n    row, col = 0, 0\n\n    for num in range(1, n * n + 1):\n        matrix[row][col] = num\n        next_row = row + directions[direction_index][0]\n        next_col = col + directions[direction_index][1]\n        if next_row < 0 or next_row >= n or next_col < 0 or next_col >= n or matrix[next_row][next_col] != 0:\n            direction_index = (direction_index + 1) % 4\n        row += directions[direction_index][0]\n        col += directions[direction_index][1]\n\n    return matrix\n\ndef g():\n    return 4\n\nassert f(g()) == [[1, 2, 3, 4],\n                  [12, 13, 14, 5],\n                  [11, 16, 15, 6],\n                  [10, 9, 8, 7]]\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom right corner of the grid from the top left corner.\n    You can only move down or right at each step.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    \n    for i in range(1, m):\n        if grid[i][0] == 1 or not dp[i-1][0]:\n            dp[i][0] = False\n        else:\n            dp[i][0] = True\n    \n    for j in range(1, n):\n        if grid[0][j] == 1 or not dp[0][j-1]:\n            dp[0][j] = False\n        else:\n            dp[0][j] = True\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1 or (not dp[i-1][j] and not dp[i][j-1]):\n                dp[i][j] = False\n            else:\n                dp[i][j] = True\n    \n    return dp[-1][-1]\n\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 159,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given an n x n matrix, determine if it is a Toeplitz matrix. A Toeplitz matrix is one where each diagonal from\ntop-left to bottom-right has the same elements.\"\"\"\n    n = len(matrix)\n    for i in range(n-1):\n        for j in range(len(matrix[i])-1):\n            if matrix[i][j] != matrix[i+1][j+1]:\n                return False\n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    return matrix\n\nassert f(g([[1,2,3,4],[5,1,2,3],[9,5,1,2]]))\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if it is possible to construct the target integer using a combination of addition, subtraction, and multiplication operations on the numbers in nums, and using each number in nums exactly once.\"\"\"\n    nums.sort()\n    n = len(nums)\n    if n == 0:\n        return False\n    if n == 1:\n        return nums[0] == target\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] + nums[j] + nums[k] == target or nums[i] * nums[j] * nums[k] == target or nums[i] - nums[j] - nums[k] == target:\n                    return True\n    return False\ndef g(nums=[1, 2, 3, 4, 5], target=12):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(mat: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\nA magic square is a square matrix where the sum of each row, each column, and both diagonals are equal.\nThe matrix will always have an odd number of rows and columns.\"\"\"\n    n = len(mat)\n    target_sum = sum(mat[0])\n    # Check rows\n    for row in mat:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in mat:\n            col_sum += row[col]\n        if col_sum != target_sum:\n            return False\n    # Check diagonals\n    diagonal_sum = 0\n    anti_diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += mat[i][i]\n        anti_diagonal_sum += mat[i][n - i - 1]\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, check if it forms a valid crossword puzzle grid. A crossword puzzle grid is valid if it satisfies the following conditions:\n    1. Each row and column must contain at least one word (sequence of consecutive characters).\n    2. Each word must be at least 2 characters long.\n    3. No two words can intersect at a position other than the common character(s) at the intersection point.\n    4. The grid must be rectangular (same number of characters in each row and column).\"\"\"\n    def is_valid_crossword(grid):\n        n = len(grid)\n        m = len(grid[0])\n        # Check rows\n        for row in grid:\n            if len(row) < 2:\n                return False\n        # Check columns\n        for col in zip(*grid):\n            if len(col) < 2:\n                return False\n        # Check intersection points\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != '#':\n                    if (i > 0 and grid[i - 1][j] != '#') or (i < n - 1 and grid[i + 1][j] != '#') or (j > 0 and grid[i][j - 1] != '#') or (j < m - 1 and grid[i][j + 1] != '#'):\n                        continue\n                    else:\n                        return False\n        return True\n    \n    return is_valid_crossword(grid)\n\ndef g(grid=[['#', '#', '#', '#'], ['#', 'A', 'B', '#'], ['#', 'C', 'D', '#'], ['#', 'E', 'F', '#'], ['#', '#', '#', '#']]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Determine if a string follows a specific pattern on a grid.\n\n    The string must follow the pattern specified by the grid, where 'R' represents a move to the right, 'D' represents a move down, and 'X' represents a move in any direction. The string must also end at the bottom-right corner of the grid.\n    \"\"\"\n    i, j = 0, 0\n    for move in s:\n        if move == 'R':\n            j += 1\n        elif move == 'D':\n            i += 1\n        elif move == 'X':\n            i += 1\n            j += 1\n        if i >= len(pattern) or j >= len(pattern[0]):\n            return False\n        if pattern[i][j] != 1:\n            return False\n    return i == len(pattern) - 1 and j == len(pattern[0]) - 1\n\ndef g(pattern: List[List[int]]) -> str:\n    \"\"\"Generate a string that follows a specific pattern on the grid.\n\n    The generated string will follow the pattern specified by the grid, where 'R' represents a move to the right, 'D' represents a move down, and 'X' represents a move in any direction. The string will end at the bottom-right corner of the grid.\n    \"\"\"\n    m, n = len(pattern), len(pattern[0])\n    path = ''\n    i, j = 0, 0\n    while i != m - 1 or j != n - 1:\n        if i != m - 1 and pattern[i + 1][j] == 1:\n            path += 'D'\n            i += 1\n        elif j != n - 1 and pattern[i][j + 1] == 1:\n            path += 'R'\n            j += 1\n        else:\n            path += 'X'\n            i += 1\n            j += 1\n    return path\n\npattern = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\nassert f(g(pattern), pattern)\n",
        "idx_generation": 33,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a grid of integers, find the maximum sum path from the top-left corner to the bottom-right corner of the grid.\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Sample Output:\n    [[1, 4, 7, 8, 9]]\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    path = []\n    i, j = m-1, n-1\n    while i > 0 or j > 0:\n        path.append(grid[i][j])\n        if i > 0 and j > 0:\n            if dp[i-1][j] > dp[i][j-1]:\n                i -= 1\n            else:\n                j -= 1\n        elif i > 0:\n            i -= 1\n        else:\n            j -= 1\n    path.append(grid[0][0])\n    path.reverse()\n    return [path]\ndef g(grid: List[List[int]]) -> None:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return (grid,)\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert f(*g(grid)) == [[1, 4, 7, 8, 9]]\n",
        "idx_generation": 62,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Count the number of distinct elements in a list using a set.\"\"\"\n    distinct_elements = set(arr)\n    return len(distinct_elements)\n\ndef g(arr=[1, 2, 3, 3, 4, 4, 5]):\n    return arr\n\nassert f(g()) == 5\n",
        "idx_generation": 98,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python', k=2) -> bool:\n    \"\"\"Find the shortest substring of s that contains all characters of the target string using an optimization algorithm\"\"\"\n    n = len(s)\n    m = len(target)\n    if m > n:\n        return False\n    target_count = [0] * 26\n    for char in target:\n        target_count[ord(char) - ord('a')] += 1\n    window_count = [0] * 26\n    min_length = float('inf')\n    left = 0\n    count = 0\n    for right in range(n):\n        window_count[ord(s[right]) - ord('a')] += 1\n        if window_count[ord(s[right]) - ord('a')] <= target_count[ord(s[right]) - ord('a')]:\n            count += 1\n        while count == m:\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n            window_count[ord(s[left]) - ord('a')] -= 1\n            if window_count[ord(s[left]) - ord('a')] < target_count[ord(s[left]) - ord('a')]:\n                count -= 1\n            left += 1\n    return min_length == m\ndef g(target='python', k=2):\n    return 'p' + target + 'y' + target + 't' + target + 'h' + target + 'o' + target + 'n'\nassert f(g())\n",
        "idx_generation": 61,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all the numbers smaller than n that are divisible by 3 or 5.\"\"\"\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\ndef g():\n    return 15\nassert f(g()) == 45\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the binary representation of a number contains a consecutive sequence of 1s of length k.\"\"\"\n    binary = bin(n)[2:]\n    return '1' * k in binary\ndef g(k: int):\n    return int('1' * k + '0', 2)\nassert f(g(3), 3)\n",
        "idx_generation": 167,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given a list of integers 'arr', find if there exists a pair of numbers whose product is equal to 'n'.\"\"\"\n    seen = set()\n    \n    for num in arr:\n        if num == 0:\n            if n == 0:\n                return True\n            continue\n        \n        if n % num == 0 and n // num in seen:\n            return True\n        \n        seen.add(num)\n    \n    return False\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(10, g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if it is possible to construct the target integer using the numbers in nums by performing addition, subtraction, multiplication, and division operations, and using each number in nums exactly once.\"\"\"\n    stack = []\n    stack.append(0)\n\n    for num in nums:\n        new_stack = []\n        for val in stack:\n            new_stack.append(val + num)\n            new_stack.append(val - num)\n            new_stack.append(val * num)\n            if num != 0:\n                new_stack.append(val / num)\n        \n        stack = new_stack\n    \n    return target in stack\n\ndef g(nums=[1, 2, 3, 4], target=10):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum within the given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(nums)) == 6\n",
        "idx_generation": 153,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the maximum sum of a subarray in a given array.\n    The subarray must be non-empty and the elements must be contiguous.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in n:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g(n: List[int]):\n    return n\nassert f(g([-2, 1, -3, 4, -1, 2, 1, -5, 4])) == 6\n",
        "idx_generation": 303,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a sudoku solution, where each row, column, and 3x3 subgrid contains all numbers from 1 to 9 without repetition.\"\"\"\n    n = len(grid)\n    target_sum = sum(range(1, n+1))\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for col in range(n):\n        if sum(grid[row][col] for row in range(n)) != target_sum:\n            return False\n    # Check 3x3 subgrids\n    subgrid_size = int(n**0.5)\n    for i in range(0, n, subgrid_size):\n        for j in range(0, n, subgrid_size):\n            subgrid = [grid[x][y] for x in range(i, i+subgrid_size) for y in range(j, j+subgrid_size)]\n            if sum(subgrid) != target_sum:\n                return False\n    return True\n\ndef g():\n    # A valid sudoku solution\n    grid = [[5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 12,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    anti_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum != target_sum or anti_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport numpy as np\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target value, determine if there exists a submatrix with a sum equal to the target.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Create a prefix sum matrix\n    prefix_sum = np.zeros((rows + 1, cols + 1))\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + matrix[i - 1][j - 1]\n\n    # Check all submatrices for the target sum\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i + 1, rows + 1):\n                for l in range(j + 1, cols + 1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[k][j] - prefix_sum[i][l] + prefix_sum[i][j]\n                    if submatrix_sum == target:\n                        return True\n    return False\n\ndef g(matrix: List[List[int]], target: int) -> None:\n    \"\"\"\n    Generate a matrix of integers and the target sum.\n    \"\"\"\n    return (matrix, target)\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntarget = 18\n\nassert f(*g(matrix, target))\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a grid contains a row or a column where the sum of all elements is equal.\"\"\"\n    for row in grid:\n        if sum(row) == 0:\n            return True\n    for col in range(len(grid[0])):\n        total = 0\n        for row in range(len(grid)):\n            total += grid[row][col]\n        if total == 0:\n            return True\n    return False\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [-5, -7, 12]]\nassert f(g())\n",
        "idx_generation": 16,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, g=lambda x: x & (x - 1) == 0) -> bool:\n    \"\"\"Check if a given number is a power of two\"\"\"\n    return g(n)\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the maximum power of 2 that\n    is less than or equal to n.\n\n    Return the maximum power of 2.\n    \"\"\"\n    max_power = 0\n    while n >= 2:\n        n //= 2\n        max_power += 1\n    return 2 ** max_power\n\ndef g(n: int) -> int:\n    \"\"\"\n    Return the positive integer n.\n    \"\"\"\n    return n\n\nassert f(g(25)) == 16\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of integers in the given list 'nums' that add up to the 'target' value.\nSample Input:\nnums = [2, 4, 7, 11, 15]\ntarget = 9\nSample Output:\nTrue\nExplanation: The pair of integers (2, 7) adds up to the target value 9, hence the output is True.\"\"\"\n    num_set = set()\n    for num in nums:\n        if target - num in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g(nums=[2, 4, 7, 11, 15], target=9):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 56,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to arrange n queens on an n x n chessboard so that no two queens threaten each other.\n    A queen can move horizontally, vertically, or diagonally.\"\"\"\n    count = 0\n    board = [[\".\"] * n for _ in range(n)]\n\n    def is_safe(board: List[List[str]], row: int, col: int) -> bool:\n        # Check if a queen can be placed at [row, col] without threatening any other queens\n        for i in range(n):\n            if board[i][col] == \"Q\":\n                return False\n\n        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n            if board[i][j] == \"Q\":\n                return False\n\n        for i, j in zip(range(row, -1, -1), range(col, n, 1)):\n            if board[i][j] == \"Q\":\n                return False\n\n        return True\n\n    def place_queens(board: List[List[str]], row: int) -> None:\n        # Place queens on the board recursively\n        nonlocal count\n\n        if row == n:\n            count += 1\n            return\n\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row][col] = \"Q\"\n                place_queens(board, row + 1)\n                board[row][col] = \".\"\n\n    place_queens(board, 0)\n    return count\n\ndef g(n: int):\n    return n\n\nassert f(g(4)) == 2\n",
        "idx_generation": 300,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exist three elements in the given list whose sum is equal to the target value.\"\"\"\n    arr.sort()\n    for i in range(len(arr) - 2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [1, 2, -1, 3, 0, 5]\n\nassert f(g(), 6)\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there exists a square subgrid with side length k that contains only 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows - k + 1):\n        for j in range(cols - k + 1):\n            subgrid = [row[j:j+k] for row in grid[i:i+k]]\n            if all(all(cell == 1 for cell in row) for row in subgrid):\n                return True\n    return False\n\ndef g(grid: List[List[int]], k: int) -> None:\n    \"\"\"\n    Generate a grid of 0s and 1s and the side length k of the square subgrid.\n    \"\"\"\n    return (grid, k)\n\ngrid = [[0, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 1]]\nk = 2\n\nassert f(*g(grid, k))\n",
        "idx_generation": 134,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a perfect number.\"\"\"\n    def is_perfect(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                divisors.append(n // i)\n        return sum(divisors) == n\n    return is_perfect(n)\ndef g():\n    return 28\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target', find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell,\n    and return the path as a list of coordinates.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    path = [[(0, 0)] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n                path[i][j] = (i, j - 1)\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n                path[i][j] = (i - 1, j)\n            else:\n                if dp[i - 1][j] > dp[i][j - 1]:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                    path[i][j] = (i - 1, j)\n                else:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                    path[i][j] = (i, j - 1)\n\n    max_sum = dp[rows - 1][cols - 1]\n    current = (rows - 1, cols - 1)\n    path_coordinates = [current]\n\n    while current != (0, 0):\n        current = path[current[0]][current[1]]\n        path_coordinates.append(current)\n\n    return path_coordinates[::-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n            \nassert f(g()) == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]\n",
        "idx_generation": 262,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid represents a valid Sudoku solution.\"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if not set(row) == set(range(1, n+1)):\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if not set(grid[row][col] for row in range(n)) == set(range(1, n+1)):\n            return False\n    \n    # Check subgrids\n    subgrid_size = int(n ** 0.5)\n    for i in range(subgrid_size):\n        for j in range(subgrid_size):\n            subgrid = []\n            for row in range(subgrid_size):\n                subgrid.extend(grid[row + i*subgrid_size][j*subgrid_size:(j+1)*subgrid_size])\n            if not set(subgrid) == set(range(1, n+1)):\n                return False\n    \n    return True\n\ndef g():\n    import random\n    n = 9\n    grid = [[0] * n for _ in range(n)]\n    rows = [set() for _ in range(n)]\n    cols = [set() for _ in range(n)]\n    subgrids = [[set() for _ in range(n//3)] for _ in range(n//3)]\n\n    def solve(row, col):\n        if col == n:\n            col = 0\n            row += 1\n            if row == n:\n                return True\n        if grid[row][col] != 0:\n            return solve(row, col+1)\n        random_nums = random.sample(range(1, n+1), n)\n        for num in random_nums:\n            if num not in rows[row] and num not in cols[col] and num not in subgrids[row//3][col//3]:\n                rows[row].add(num)\n                cols[col].add(num)\n                subgrids[row//3][col//3].add(num)\n                grid[row][col] = num\n                if solve(row, col+1):\n                    return True\n                rows[row].remove(num)\n                cols[col].remove(num)\n                subgrids[row//3][col//3].remove(num)\n                grid[row][col] = 0\n        return False\n\n    solve(0, 0)\n    return grid\n\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if the list is a valid mountain array. A mountain array is defined as follows:\n    - The length of the array is at least 3.\n    - There exists some i with 0 < i < len(nums) - 1 such that:\n        - nums[0] < nums[1] < ... < nums[i - 1] < nums[i]\n        - nums[i] > nums[i + 1] > ... > nums[len(nums) - 1]\n    - Return True if nums is a mountain array, otherwise return False.\"\"\"\n    if len(nums) < 3:\n        return False\n    i = 0\n    while i + 1 < len(nums) and nums[i] < nums[i + 1]:\n        i += 1\n    if i == 0 or i == len(nums) - 1:\n        return False\n    while i + 1 < len(nums) and nums[i] > nums[i + 1]:\n        i += 1\n    return i == len(nums) - 1\ndef g():\n    return [1, 2, 3, 4, 5, 4, 3, 2, 1]\nassert f(g())\n",
        "idx_generation": 65,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Given the dimensions of a grid and a grid of integers, find the minimum cost to reach from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1) by moving only downwards or rightwards.\n    Additionally, each cell has a cost associated with it, which is subtracted from the total cost.\n    Return the minimum cost.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[n-1][m-1]\n\ndef g(n: int, m: int, grid: List[List[int]]):\n    return (n, m, grid)\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nn = 3\nm = 3\nassert f(*g(n, m, grid)) == 21\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Find if there exists a subarray in arr with a sum equal to the target.\"\"\"\n    stack = []\n    for num in arr:\n        if num == target:\n            return True\n        while stack and sum(stack) > target:\n            stack.pop(0)\n        if sum(stack) == target:\n            return True\n        stack.append(num)\n    return False\n    \ndef g(target=100):\n    return list(range(1, target+1))\n\nassert f(g())\n",
        "idx_generation": 2,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of positive integers, find the number of subsets whose sum is equal to the target.\"\"\"\n    def count_subsets(nums, target, i):\n        if target == 0:\n            return 1\n        if target < 0 or i >= len(nums):\n            return 0\n        include = count_subsets(nums, target - nums[i], i + 1)\n        exclude = count_subsets(nums, target, i + 1)\n        return include + exclude\n    return count_subsets(nums, target, 0) >= 1\ndef g(nums=[2, 4, 6, 8, 10]):\n    return nums\nassert f(g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, a=3, b=5) -> bool:\n    \"\"\"Check if n can be expressed as a sum of a and b, using recursion.\"\"\"\n    if n == 0:\n        return True\n    if n < 0:\n        return False\n    return f(n - a, a, b) or f(n - b, a, b)\n\ndef g(a=3, b=5):\n    return 17\n\nassert f(g())\n",
        "idx_generation": 10,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid, determine if it contains a valid path from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of 0s and 1s, where 0 represents an obstacle and 1 represents an open path.\n    The valid path can only consist of rightward and downward movements.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        x, y = stack.pop()\n        if x == rows - 1 and y == cols - 1:\n            return True\n        if x + 1 < rows and grid[x + 1][y] == 1:\n            stack.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] == 1:\n            stack.append((x, y + 1))\n    return False\n\ndef g():\n    return [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [0, 0, 0, 1]\n    ]\n\nassert f(g())\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 12\n",
        "idx_generation": 44,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid, determine if it contains a valid path from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of characters, where '0' represents an obstacle and '1' represents an open path.\n    The valid path can only consist of rightward and downward movements.\n    Additionally, there are certain cells marked with 'S' that can be used to teleport to another cell marked with 'T'.\n    If a teleportation occurs, the path can continue from the new cell in any direction.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        (x, y) = stack.pop()\n        if x == rows - 1 and y == cols - 1:\n            return True\n        if grid[x][y] == 'S':\n            for i in range(rows):\n                for j in range(cols):\n                    if grid[i][j] == 'T':\n                        stack.append((i, j))\n        if x + 1 < rows and grid[x + 1][y] != '0':\n            stack.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] != '0':\n            stack.append((x, y + 1))\n    return False\n\ndef g():\n    return [['1', '1', '0', '1'],\n            ['0', 'S', '1', '0'],\n            ['1', '1', 'T', '1'],\n            ['1', '0', '1', '1']]\n\nassert f(g())\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a given string using an optimization algorithm\"\"\"\n    words = s.split()\n    words.reverse()  # Reversing the order of the words\n    return ' '.join(words)\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g(\"Hello World\")) == \"World Hello\"\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string representing a mathematical expression, determine if the parentheses in the expression are balanced.\n    An expression is considered balanced if each opening parenthesis has a corresponding closing parenthesis and they are properly nested.\n    Sample Input:\n    expression = \"((2 + 3) * (4 - 5))\"\n    Sample Output:\n    True\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return not stack\n\ndef g(expression: str):\n    stack = []\n    for char in expression:\n        if char == '(' or char == ')':\n            stack.append(char)\n    return ''.join(stack)\n\nassert f(g('((2 + 3) * (4 - 5))'))\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if string t is a subsequence of string s\"\"\"\n    i = 0\n    for char in s:\n        if i < len(t) and char == t[i]:\n            i += 1\n    return i == len(t)\n    \ndef g() -> Tuple[str, str]:\n    return \"abcde\", \"ace\"\n    \nassert f(*g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of a given number 'n'.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\ndef g():\n    \"\"\"Returns a number whose binary representation has 5 set bits.\"\"\"\n    return 31\nassert f(g()) == 5\n",
        "idx_generation": 329,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists three numbers in the list whose bitwise XOR is equal to the target value.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            xor_val = nums[i] ^ nums[left] ^ nums[right]\n            if xor_val == target:\n                return True\n            elif xor_val < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g() -> List[int]:\n    return [3, 5, 8, 2, 10, 6]\n\nassert f(g(), 13)\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of non-negative integers and a target value, determine if it is possible to reach the target by performing bitwise XOR operations on the numbers in the list.\n    Return True if it is possible, False otherwise.\"\"\"\n    def helper(nums, target, index, xor_value):\n        if index == len(nums):\n            return xor_value == target\n        return helper(nums, target, index+1, xor_value ^ nums[index]) or helper(nums, target, index+1, xor_value)\n    \n    return helper(nums, target, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(board: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D grid of numbers and a target number, determine if it is possible to obtain the target by performing bitwise XOR operations on the numbers in the grid.\n    The grid can be traversed in any direction (up, down, left, right), but each number can only be used once.\"\"\"\n    rows = len(board)\n    cols = len(board[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row: int, col: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:\n            return False\n        visited[row][col] = True\n        if dfs(row + 1, col, curr ^ board[row][col]) or dfs(row - 1, col, curr ^ board[row][col]) or dfs(row, col + 1, curr ^ board[row][col]) or dfs(row, col - 1, curr ^ board[row][col]):\n            return True\n        visited[row][col] = False\n        return False\n    \n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g():\n    board = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 4\n    return (board, target)\n\nassert f(*g())\n",
        "idx_generation": 212,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int, a: str='1010101010') -> bool:\n    \"\"\"Determine if there exists a substring of length k in s that has an odd number of '1's when its binary representation is converted to an integer\"\"\"\n    for i in range(len(s)-k+1):\n        substring = s[i:i+k]\n        binary_int = int(substring, 2)\n        if bin(binary_int).count('1') % 2 != 0:\n            return True\n    return False\n\ndef g(a: str='1010101010'):\n    return a, len(a)//2\n\nassert f(*g())\n",
        "idx_generation": 306,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: int) -> bool:\n    \"\"\"Given a string s and a target integer, find if there exists a substring of s such that the bitwise XOR of all characters in the substring is equal to the target value.\"\"\"\n    def helper(s, target, start, end, curr_xor):\n        if start >= end:\n            return False\n        if curr_xor == target:\n            return True\n        elif curr_xor < target:\n            return helper(s, target, start + 1, end, curr_xor ^ ord(s[start]))\n        else:\n            return helper(s, target, start, end - 1, curr_xor ^ ord(s[end]))\n    return helper(s, target, 0, len(s) - 1, 0)\ndef g(s='abcdefg', target=4):\n    return s\nassert f(g(), target=5)\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of distinct ways to climb to the top of a staircase with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g(n: int) -> int:\n    return n\nn = 5\nassert f(g(n)) == 8\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is symmetric along its main diagonal.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    if rows != cols:\n        return False\n    for i in range(rows):\n        for j in range(i + 1, cols):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    return [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\n\nassert f(g())\n",
        "idx_generation": 230,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if it is possible to reach the bottom-right corner of the grid starting from the top-left corner,\n    considering the following rules:\n    - You can only move down or right.\n    - The sum of the numbers encountered along the path must be a prime number.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def dfs(row, col, path_sum):\n        if row == m-1 and col == n-1:\n            return is_prime(path_sum + grid[row][col])\n        if row >= m or col >= n:\n            return False\n        return dfs(row+1, col, path_sum + grid[row][col]) or dfs(row, col+1, path_sum + grid[row][col])\n    \n    return dfs(0, 0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]))\n\nassert not f(g([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 10]]))\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique paths to reach the bottom-right corner of a n x n grid, starting from the top-left corner.\nEach step can only move downwards or rightwards.\"\"\"\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][1] = 1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n][n]\ndef g(n: int):\n    return (n,)\nassert f(*g(3)) == 6\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(word1: str, word2: str, word3: str) -> bool:\n    \"\"\"Given three words, determine if the third word can be formed by merging the first two words while preserving \n    the relative order of characters from each word.\"\"\"\n    if len(word1) + len(word2) != len(word3):\n        return False\n    \n    dp = [[False] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, len(word1) + 1):\n        if word1[i-1] == word3[i-1]:\n            dp[i][0] = dp[i-1][0]\n    \n    for i in range(1, len(word2) + 1):\n        if word2[i-1] == word3[i-1]:\n            dp[0][i] = dp[0][i-1]\n    \n    for i in range(1, len(word1) + 1):\n        for j in range(1, len(word2) + 1):\n            if word1[i-1] == word3[i+j-1]:\n                dp[i][j] = dp[i-1][j]\n            if word2[j-1] == word3[i+j-1]:\n                dp[i][j] = dp[i][j] or dp[i][j-1]\n                \n    return dp[-1][-1]\n\ndef g():\n    word1 = \"AB\"\n    word2 = \"CD\"\n    word3 = \"ACBD\"\n    return word1, word2, word3\n\nassert f(*g())\n",
        "idx_generation": 307,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, a=3, b=23463462) -> bool:\n    \"\"\"Determine if the bitwise XOR of all integers from 1 to n (inclusive) is divisible by k\"\"\"\n    xor = 0\n    for i in range(1, n+1):\n        xor ^= i\n    return xor % k == 0\ndef g(a=3, b=23463462):\n    return a, b\nassert f(*g())\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum sum of values from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of integers, where each integer represents the value of a cell.\n    The valid path can only consist of rightward and downward movements.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j])\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 137,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the area of the largest island in a grid.\n    An island is represented by a group of connected cells with a value of 1.\n    The grid is represented as a matrix.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_area = 0\n\n    def dfs(i: int, j: int, area: int) -> int:\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return area\n        grid[i][j] = -1\n        area += 1\n        area = dfs(i-1, j, area)\n        area = dfs(i+1, j, area)\n        area = dfs(i, j-1, area)\n        area = dfs(i, j+1, area)\n        return area\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                area = dfs(i, j, 0)\n                max_area = max(max_area, area)\n\n    return max_area\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 1]])) == 4\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(maze: List[List[int]], start=(0, 0), end=(0, 0)) -> bool:\n    \"\"\"Find if there exists a path from the start position to the end position in the given maze.\"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n    queue = [(start[0], start[1])]\n    visited = set()\n    while queue:\n        x, y = queue.pop(0)\n        if (x, y) == end:\n            return True\n        if (x, y) not in visited:\n            visited.add((x, y))\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < rows and 0 <= new_y < cols and maze[new_x][new_y] == 0:\n                    queue.append((new_x, new_y))\n    return False\ndef g(start=(0, 0), end=(3, 3)):\n    maze = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return maze\nassert f(g())\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a 2D grid of '1's (land) and '0's (water), count the number of islands.\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n\n    def dfs(row: int, col: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != '1':\n            return\n        grid[row][col] = '#' # mark cell as visited\n        dfs(row + 1, col) # check bottom cell\n        dfs(row - 1, col) # check top cell\n        dfs(row, col + 1) # check right cell\n        dfs(row, col - 1) # check left cell\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    return count\n\ndef g():\n    grid = [\n        ['1', '1', '1', '1', '0'],\n        ['1', '1', '0', '1', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '0', '0', '0']\n    ]\n    return grid\n\nassert f(g()) == 1\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the number of islands in the given grid. An island is represented by 1 and is surrounded by water (0) on all sides.\"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    return count\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\nassert f(g()) == 3\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, check if it is possible to form a valid word ladder by\n    changing one letter at a time while each intermediate word must be present in the given list of words.\n    Return True if a valid word ladder can be formed, otherwise return False.\n    Example:\n    words = [\"cat\", \"cot\", \"dot\", \"dog\"]\n    Output: True (word ladder: cat -> cot -> dot -> dog)\n    \"\"\"\n    if len(words) < 2:\n        return False\n\n    word_set = set(words)\n\n    def ladder(start, end):\n        if start == end:\n            return True\n\n        visited = set()\n        queue = [start]\n\n        while queue:\n            current_word = queue.pop(0)\n            if current_word == end:\n                return True\n\n            visited.add(current_word)\n\n            for i in range(len(current_word)):\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = current_word[:i] + char + current_word[i+1:]\n                    if new_word in word_set and new_word not in visited:\n                        queue.append(new_word)\n\n        return False\n\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if ladder(words[i], words[j]):\n                return True\n\n    return False\n\ndef g():\n    return [\"cat\", \"cot\", \"dot\", \"dog\"]\n\nassert f(g())\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there exists a path from a given start node to an end node with a total sum of weights less than or equal to k.\"\"\"\n    def dfs(node, weight):\n        if node == end and weight <= k:\n            return True\n        if weight > k:\n            return False\n        for i in range(len(graph[node])):\n            if graph[node][i] != 0:\n                if dfs(i, weight + graph[node][i]):\n                    return True\n        return False\n    \n    return dfs(start, 0)\n\ndef g():\n    graph = [\n        [0, 3, 0, 0, 4],\n        [0, 0, 2, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 5],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    k = 10\n    return graph, start, end, k\n\nassert f(*g())\n",
        "idx_generation": 476,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers and a target number, determine if it is possible to obtain the target number by multiplying or dividing the numbers in the list. Each number in the list can be used exactly once.\"\"\"\n    stack = []\n    stack.append(1)\n    for num in numbers:\n        new_stack = []\n        for val in stack:\n            new_stack.append(val * num)\n            if num != 0:\n                new_stack.append(val / num)\n        stack = new_stack\n    return target in stack\n\ndef g(numbers=[1, 2, 3, 4], target=24):\n    return (numbers, target)\n\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given a list of integers and a target value, find all unique combinations where the candidate numbers sum to the target.\"\"\"\n    def backtrack(combination, target, start):\n        if target == 0:\n            result.append(combination[:])\n            return\n        for i in range(start, len(nums)):\n            if target - nums[i] < 0:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            combination.append(nums[i])\n            backtrack(combination, target - nums[i], i+1)\n            combination.pop()\n    nums.sort()\n    result = []\n    backtrack([], target, 0)\n    return result\ndef g() -> Tuple[List[int], int]:\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Check if a string matches a given pattern, where each character in the pattern represents a unique substring in the string.\"\"\"\n    n = len(s)\n    m = len(pattern)\n    memo = {}\n    \n    def isMatch(i, j):\n        if i == n and j == m:\n            return True\n        if i == n or j == m:\n            return False\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        if pattern[j] not in memo.values():\n            for k in range(i + 1, n + 1):\n                memo[(i, j)] = isMatch(k, j + 1)\n                if memo[(i, j)]:\n                    return True\n        \n        return False\n    \n    return isMatch(0, 0)\n\ndef g(s='appleappleapple', pattern='abc'):\n    return s, pattern\n\nassert f(*g())\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of unique combinations of numbers that can be formed by\n    taking the bitwise OR of all possible pairs of numbers.\n    \"\"\"\n    unique_combinations = set()\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            bitwise_or = nums[i] | nums[j]\n            unique_combinations.add(bitwise_or)\n    return len(unique_combinations)\n\ndef g(nums: List[int] = [2, 4, 6, 8]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 206,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the given strings s and t are anagrams of each other.\"\"\"\n    def count_characters(string):\n        \"\"\"Count the number of occurrences of each character in a string.\"\"\"\n        count = {}\n        for char in string:\n            if char in count:\n                count[char] += 1\n            else:\n                count[char] = 1\n        return count\n\n    count_s = count_characters(s)\n    count_t = count_characters(t)\n\n    return count_s == count_t\n\ndef g():\n    \"\"\"Generate two anagram strings.\"\"\"\n    import random\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    s = ''.join(random.sample(alphabet, len(alphabet)))\n    t = ''.join(random.sample(alphabet, len(alphabet)))\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 219,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\n\ndef f(lst: list) -> bool:\n    \"\"\"Check if a list of integers is sorted in ascending order.\"\"\"\n    return lst == sorted(lst)\n\ndef g():\n    lst = [random.randint(0, 100) for _ in range(10)]\n    return sorted(lst)\n\nassert f(g())\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two numbers in the array such that their sum is equal to the target.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 4, 7, 11, 15], 9\n\nassert f(*g()) == True\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order using the merge sort algorithm.\n    \"\"\"\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        return merge(left, right)\n\n    return merge_sort(nums)\n\ndef g():\n    return ([5, 3, 8, 2, 1, 9, 4, 7, 6],)\n\nassert f(*g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 46,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(points: List[List[float]], k=3) -> bool:\n    \"\"\"Given a list of points in 2D space, find the k closest points to the origin (0, 0).\nSolution should return a list of the k closest points.\nThe distance between two points (x1, y1) and (x2, y2) is calculated using the Euclidean distance formula: sqrt((x2 - x1)^2 + (y2 - y1)^2)\"\"\"\n    distances = [(math.sqrt(point[0]**2 + point[1]**2), point) for point in points]\n    distances.sort()\n    closest_points = [point for distance, point in distances[:k]]\n    return closest_points\n\ndef g(k=3):\n    return [[1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9], [10, 10]]\n\nassert f(g()) == [[1, 1], [2, 2], [3, 3]]\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum cost to reach from the top-left corner to the bottom-right corner.\nYou can only move down or right. Each cell represents the cost to move to that location.\nFind the minimum cost path.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(n: int, grid: List[List[int]]):\n    return n, grid\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(*g(3, grid)) == 7\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list such that the sum of elements in the subarray is divisible by 5.\"\"\"\n    prefix_sum = 0\n    seen_remainders = set()\n    for num in nums:\n        prefix_sum += num\n        remainder = prefix_sum % 5\n        if remainder in seen_remainders or remainder == 0:\n            return True\n        seen_remainders.add(remainder)\n    return False\n\ndef g():\n    nums = [3, 2, 4, 1, 6, 9, 2, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Check if the given expression has balanced parentheses.\"\"\"\n    def is_balanced(expr):\n        stack = []\n        for char in expr:\n            if char in '({[':\n                stack.append(char)\n            elif char in ')}]':\n                if not stack:\n                    return False\n                if char == ')' and stack[-1] != '(':\n                    return False\n                if char == '}' and stack[-1] != '{':\n                    return False\n                if char == ']' and stack[-1] != '[':\n                    return False\n                stack.pop()\n        return not stack\n    return is_balanced(expression)\ndef g():\n    return \"((3 + 5) * (7 - 2))\"\nassert f(g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a value k, find the maximum sum of any contiguous subarray of size k.\n    Implement the solution using a sliding window approach.\n    \"\"\"\n    n = len(arr)\n    if k > n:\n        return []\n\n    start = 0\n    end = k - 1\n    current_sum = sum(arr[start:end+1])\n    max_sum = current_sum\n\n    while end < n - 1:\n        current_sum = current_sum - arr[start] + arr[end+1]\n        max_sum = max(max_sum, current_sum)\n        start += 1\n        end += 1\n\n    return max_sum\n\ndef g():\n    arr = [2, 3, 5, 1, 6, 8, 9]\n    k = 3\n    return arr, k\n\nassert f(*g()) == 23\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[str], word: str) -> bool:\n    \"\"\"Given a grid of characters and a word, determine if the word can be formed in the grid.\n    Return True if the word can be formed, otherwise return False.\"\"\"\n    def search_word(row, col, index):\n        if index == len(word):\n            return True\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != word[index]:\n            return False\n        temp = grid[row][col]\n        grid[row][col] = '#'\n        found = search_word(row+1, col, index+1) or search_word(row-1, col, index+1) or search_word(row, col+1, index+1) or search_word(row, col-1, index+1)\n        grid[row][col] = temp\n        return found\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if search_word(i, j, 0):\n                return True\n    return False\n\ndef g(word='PYTHON'):\n    grid = [['P', 'Y', 'T', 'H', 'O', 'N'],\n            ['U', 'P', 'U', 'Z', 'Z', 'L'],\n            ['E', 'G', 'R', 'I', 'D', 'S'],\n            ['S', 'E', 'A', 'R', 'C', 'H'],\n            ['S', 'T', 'R', 'I', 'N', 'G']]\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the maximum element in each row.\"\"\"\n    max_elements = []\n    for row in matrix:\n        max_elements.append(max(row))\n    return max_elements\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [3, 6, 9]\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(li: List[int]) -> bool:\n    \"\"\"Find a list of integers in ascending order that contains at least one pair of numbers where the XOR of the two numbers is greater than or equal to 10.\"\"\"\n    return any(li[i] ^ li[i + 1] >= 10 for i in range(len(li) - 1))\ndef g():\n    return list(range(10))\nassert f(g())\n",
        "idx_generation": 29,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given an array of integers arr, determine if there are three distinct indices i, j, k such that arr[i] & arr[j] & arr[k] == 0.\n    Returns True if such indices exist, False otherwise.\"\"\"\n    # Sort the array in ascending order\n    arr.sort()\n    # Use dynamic programming to find if there are three distinct indices whose bitwise AND is zero\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            dp[i][j] = dp[j][i] = (arr[i] & arr[j] == 0)\n            for k in range(j+1, n):\n                if dp[i][j] and dp[j][k] and dp[i][k]:\n                    return True\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return len(arr), arr\n\nassert f(*g()) == False\n",
        "idx_generation": 266,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest increasing subarray.\"\"\"\n    max_length = 1\n    curr_length = 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            curr_length += 1\n            max_length = max(max_length, curr_length)\n        else:\n            curr_length = 1\n    \n    return max_length\n    \ndef g(nums: List[int]):\n    return nums\n\n# Example usage\nnums = [1, 2, 3, 2, 5, 6, 7, 8, 9]\nassert f(g(nums)) == 6\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in nums that sum up to target.\"\"\"\n    sorted_nums = sorted(nums)\n    left = 0\n    right = len(sorted_nums) - 1\n    while left < right:\n        current_sum = sorted_nums[left] + sorted_nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\n# Example usage\nnums = [4, 2, 7, 1, 5]\ntarget = 9\nassert f(*g(nums, target))\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D matrix where each row is sorted in ascending order and each column is sorted in ascending order,\n    determine if a target value exists in the matrix.\n    Return True if the target value is found, otherwise return False.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = rows - 1\n    col = 0\n    while row >= 0 and col < cols:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            row -= 1\n    return False\n\ndef g():\n    return [[1, 4, 7, 11, 15],\n            [2, 5, 8, 12, 19],\n            [3, 6, 9, 16, 22],\n            [10, 13, 14, 17, 24],\n            [18, 21, 23, 26, 30]]\n\nassert f(g(), 5)\n",
        "idx_generation": 367,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid, determine if it is possible to reach the bottom right corner from the top left corner.\n    The maze is represented as a grid of 0s and 1s, where 0s represent open paths and 1s represent walls.\n    You can only move in the four cardinal directions (up, down, left, right) and cannot move through walls.\n    Return True if it is possible to reach the bottom right corner, False otherwise.\n    \"\"\"\n    m, n = len(maze), len(maze[0])\n    visited = set()\n    queue = [(0, 0)]\n    \n    while queue:\n        x, y = queue.pop(0)\n        if (x, y) == (m-1, n-1):\n            return True\n        visited.add((x, y))\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == 0 and (nx, ny) not in visited:\n                queue.append((nx, ny))\n                visited.add((nx, ny))\n    \n    return False\n\n\ndef g():\n    maze = [\n        [0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 1, 1, 0, 0],\n        [1, 1, 1, 1, 0]\n    ]\n    return maze\n\n\nassert f(g())\n",
        "idx_generation": 71,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(points: List[List[int]], k=3, target=10) -> bool:\n    \"\"\"Given a list of 2D points, find the k points that form a convex hull with the maximum area. Return True if the\narea of the convex hull is greater than or equal to the target area, otherwise return False.\nSample Input:\npoints = [[0, 0], [0, 5], [5, 0], [5, 5], [2, 2], [4, 4]]\nk = 3\ntarget = 10\nSample Output:\nTrue\"\"\"\n    # Implement Jarvis Algorithm to find the k points forming the convex hull\n    def jarvis(points, k):\n        n = len(points)\n        if n < k:\n            return []\n        hull = []\n        leftmost = min(points, key=lambda x: x[0])\n        hull.append(leftmost)\n        current_point = leftmost\n        while True:\n            next_point = points[0]\n            for i in range(1, n):\n                if points[i] == current_point:\n                    continue\n                orientation = get_orientation(current_point, next_point, points[i])\n                if orientation == 2 or (orientation == 0 and distance(current_point, points[i]) > distance(current_point, next_point)):\n                    next_point = points[i]\n            current_point = next_point\n            if current_point == leftmost:\n                break\n            hull.append(current_point)\n        return hull\n    \n    # Get orientation of 3 points (0 = collinear, 1 = clockwise, 2 = counterclockwise)\n    def get_orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n    \n    # Get distance between 2 points\n    def distance(p1, p2):\n        return (p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2\n    \n    # Calculate area of a polygon\n    def polygon_area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1] - points[j][0] * points[i][1]\n        return abs(area) / 2\n    \n    hull = jarvis(points, k)\n    return polygon_area(hull) >= target\n\ndef g(points=[[0, 0], [0, 5], [5, 0], [5, 5], [2, 2], [4, 4]], k=3, target=10):\n    return points\n\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a square matrix.\"\"\"\n    num_rows = len(matrix)\n    num_columns = len(matrix[0])\n    for row in matrix:\n        if len(row) != num_columns:\n            return False\n    return num_rows == num_columns\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Check if the reverse of s is a substring of the binary representation of n\"\"\"\n    return s[::-1] in bin(n)[2:]\ndef g(n=4):\n    return \"10\" if n == 5 else \"11\" if n == 6 else \"0\"\nassert f(g())\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Determine if the two given strings 's1' and 's2' are isomorphic.\nTwo strings are isomorphic if the characters in 's1' can be replaced to get 's2'.\nAll occurrences of a character must be replaced with another character while preserving the order of characters.\nNo two characters may map to the same character but a character may map to itself.\nSample Input:\ns1 = 'egg'\ns2 = 'add'\nSample Output:\nTrue\nExplanation: The characters 'e' in 's1' can be replaced with 'a' and 'g' can be replaced with 'd',\nwhich results in the string 'add' which is the same as 's2', hence the output is True.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    mapping = {}\n    used_chars = set()\n    \n    for i in range(len(s1)):\n        char1 = s1[i]\n        char2 = s2[i]\n        \n        if char1 in mapping:\n            if mapping[char1] != char2:\n                return False\n        else:\n            if char2 in used_chars:\n                return False\n            mapping[char1] = char2\n            used_chars.add(char2)\n    \n    return True\n\ndef g(s1='egg', s2='add'):\n    return (s1, s2)\n\nassert f(*g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix, rotate the matrix 90 degrees clockwise in-place.\"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n-i-1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n-j-1][i]\n            matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n            matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n            matrix[j][n-i-1] = temp\n    return matrix\ndef g():\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]],)\nassert f(*g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return a list containing all the elements of the matrix in spiral order.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    result = []\n    top = 0\n    bottom = m - 1\n    left = 0\n    right = n - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    return result\ndef g(matrix: List[List[int]]):\n    return (matrix,)\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(*g(matrix)) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 213,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"Determine if a set of points in a 2D plane form a rectangle\"\"\"\n    if len(points) != 4:\n        return False\n    x_values = [point[0] for point in points]\n    y_values = [point[1] for point in points]\n    return len(set(x_values)) == 2 and len(set(y_values)) == 2\ndef g():\n    return [(0, 0), (0, 1), (1, 0), (1, 1)]\nassert f(g())\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome using a stack and a queue.\"\"\"\n    stack = []\n    queue = []\n    for char in s:\n        if char.isalpha():\n            char = char.lower()\n            stack.append(char)\n            queue.append(char)\n    while stack and queue:\n        if stack.pop() != queue.pop(0):\n            return False\n    return True\ndef g(s='A man, a plan, a canal: Panama'):\n    return s\nassert f(g())\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the two numbers that appear the most frequently.\"\"\"\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    max_frequency = max(frequency.values())\n    most_frequent_nums = [num for num, freq in frequency.items() if freq == max_frequency]\n    return most_frequent_nums\n\ndef g():\n    return [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\nassert f(g()) == [4]\n",
        "idx_generation": 371,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if 'n' can be represented as a sum of exactly 'k' distinct powers of 2.\n    Sample Input:\n    n = 13\n    k = 3\n    Sample Output:\n    True\n    Explanation: The number 13 can be represented as 2^0 + 2^2 + 2^3, which sums up to 13.\n    There are exactly 3 distinct powers of 2 used in this representation, hence the output is True.\"\"\"\n    powers = []\n    for i in range(31, -1, -1):\n        if n >= 2**i:\n            n -= 2**i\n            powers.append(i)\n    return len(powers) == k and len(set(powers)) == k\ndef g(n=13, k=3):\n    return n, k\nassert f(*g())\n",
        "idx_generation": 48,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value of any two elements.\n    Return the maximum XOR value.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        xor_set = set()\n        for num in nums:\n            xor_set.add(num & mask)\n        \n        possible_max_xor = max_xor | (1 << i)\n        for xor in xor_set:\n            if (xor ^ possible_max_xor) in xor_set:\n                max_xor = possible_max_xor\n                break\n    \n    return max_xor\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return the list of integers.\n    \"\"\"\n    return nums\n\nassert f(g([3, 10, 5, 25, 2, 8])) == 28\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, x: int) -> bool:\n    \"\"\"Check if the binary representation of x has an even number of 1s.\"\"\"\n    binary = bin(x)[2:]\n    return binary.count('1') % 2 == 0\ndef g(x: int):\n    return bin(x)[2:]\nassert f(g(10), 10)\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers nums, a target integer, and a number k, find if there exists a subarray of length k in nums that sums up to the target.\nArgs:\n    nums: The list of integers.\n    target: The target sum.\n    k: The length of the subarray.\nReturns:\n    True if a subarray exists, False otherwise.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n+1)\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i-1]\n    for i in range(k, n+1):\n        if prefix_sum[i] - prefix_sum[i-k] == target:\n            return True\n    return False\ndef g():\n    return ([1, 2, 3, 4, 5], 9, 3)\nassert f(*g())\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers, determine if there exists a subarray with a sum that is a perfect square.\n    Return True if such subarray exists, otherwise return False.\"\"\"\n    def is_perfect_square(num):\n        return int(num ** 0.5) ** 2 == num\n    \n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if is_perfect_square(prefix_sum) or prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Return the array of integers.\n    \"\"\"\n    return arr\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, check if it is a magic square. A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    # Check rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n    # Check columns\n    for j in range(n):\n        column_sum = sum(matrix[i][j] for i in range(n))\n        if column_sum != target_sum:\n            return False\n    # Check main diagonal\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != target_sum:\n        return False\n    # Check secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != target_sum:\n        return False\n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    return matrix\n\nassert f(g([[2, 7, 6], [9, 5, 1], [4, 3, 8]]))\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list such that the sum of its elements is a perfect square.\"\"\"\n    def is_perfect_square(n: int) -> bool:\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n\n    def helper(start: int, end: int) -> bool:\n        if start == end:\n            return False\n        if is_perfect_square(prefix_sum[end] - prefix_sum[start]):\n            return True\n        return helper(start, end - 1) or helper(start + 1, end)\n\n    return helper(0, len(nums))\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of all even numbers in a list.\"\"\"\n    return sum(num for num in nums if num % 2 == 0)\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\nassert f(g()) == 30\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=10) -> bool:\n    \"\"\"Given a string, determine if it can be formed by concatenating n copies of a substring.\nThe substring must be a non-empty string.\"\"\"\n    if len(s) % n != 0:\n        return False\n\n    substring = s[:len(s) // n]\n    return substring * n == s\n\ndef g(n=10):\n    return 'abcd' * n\n\nassert f(g())\n",
        "idx_generation": 0,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer, determine if there exists a combination of numbers in 'nums' that add up to the target.\n    Each number in 'nums' can be used multiple times.\"\"\"\n    def helper(nums, target, index):\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        return helper(nums, target - nums[index], index) or helper(nums, target, index + 1)\n    \n    return helper(nums, target, 0)\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g())\n",
        "idx_generation": 313,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a path in the given matrix that starts from the top-left corner and ends at the bottom-right corner, visiting every cell exactly once.\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def is_valid_cell(row: int, col: int) -> bool:\n        return 0 <= row < rows and 0 <= col < cols and not visited[row][col]\n    \n    def helper(row: int, col: int) -> bool:\n        if row == rows - 1 and col == cols - 1:\n            return True\n        \n        visited[row][col] = True\n        \n        if is_valid_cell(row + 1, col) and matrix[row + 1][col] != 0 and helper(row + 1, col):\n            return True\n        if is_valid_cell(row, col + 1) and matrix[row][col + 1] != 0 and helper(row, col + 1):\n            return True\n        if is_valid_cell(row - 1, col) and matrix[row - 1][col] != 0 and helper(row - 1, col):\n            return True\n        if is_valid_cell(row, col - 1) and matrix[row][col - 1] != 0 and helper(row, col - 1):\n            return True\n        \n        visited[row][col] = False\n        return False\n    \n    return helper(0, 0)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n\nassert f(g())\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, check if it is a magic square, i.e., the sums of each row, column, and diagonal are equal.\"\"\"\n    def is_magic_square(matrix):\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n        # Check rows\n        for row in matrix:\n            if sum(row) != target_sum:\n                return False\n        # Check columns\n        for col in range(n):\n            if sum(matrix[row][col] for row in range(n)) != target_sum:\n                return False\n        # Check diagonals\n        if sum(matrix[i][i] for i in range(n)) != target_sum or sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n            return False\n        return True\n    return len(matrix) > 0 and is_magic_square(matrix)\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\nassert f(g())\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a grid of integers, find a path from the top-left corner to the bottom-right corner that\n    maximizes the product of the numbers along the path. Return True if the maximum product is greater\n    than or equal to the target, otherwise return False.\n    Sample Input:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    target = 100\n    Sample Output:\n    True\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('-inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] * grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] * grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) * grid[i][j]\n    return dp[rows - 1][cols - 1] >= target\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=100):\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum that can be obtained by moving from the top-left cell to the bottom-right cell, only moving down or right.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[-1][-1]\n\ndef g(matrix: List[List[int]] = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return matrix\n\nassert f(g()) == 12\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there is a subarray that sums up to the target value.\n    The solution should return True if such subarray exists, and False otherwise.\"\"\"\n    def helper(arr, target, curr_sum, start):\n        if curr_sum == target:\n            return True\n        if start == len(arr):\n            return False\n        \n        if curr_sum + arr[start] <= target:\n            if helper(arr, target, curr_sum + arr[start], start + 1):\n                return True\n        \n        return helper(arr, target, curr_sum, start + 1)\n    \n    return helper(arr, target, 0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g()) == True\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=5, target=20) -> bool:\n    \"\"\"Check if there exists a subarray of size k whose sum is equal to the target.\"\"\"\n    queue = []\n    curr_sum = 0\n    for num in arr:\n        if len(queue) == k:\n            curr_sum -= queue.pop(0)\n        queue.append(num)\n        curr_sum += num\n        if curr_sum == target:\n            return True\n    return False\n\ndef g(k=5, target=20):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nassert f(g())\n",
        "idx_generation": 12,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string s, find the length of the longest substring without repeating characters using a dynamic programming approach.\nArgs:\n    s: The input string.\nReturns:\n    The length of the longest substring without repeating characters.\"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for i, char in enumerate(s):\n        if char in seen and start <= seen[char]:\n            start = seen[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        seen[char] = i\n\n    return max_length\n\n\ndef g():\n    \"\"\"\n    Returns the input for the function f.\n    \"\"\"\n    return \"abcabcbb\"\n\n\nassert f(g()) == 3\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\ndef g(n=6):\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, determine if there is a valid path from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of characters, where 'S' represents the starting point, 'E' represents the ending point,\n    '#' represents an obstacle, and '.' represents an open path.\n    The valid path can only consist of rightward and downward movements, and cannot cross any obstacles.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        (x, y) = stack.pop()\n        if grid[x][y] == 'E':\n            return True\n        if x + 1 < rows and grid[x + 1][y] != '#':\n            stack.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] != '#':\n            stack.append((x, y + 1))\n    return False\n\ndef g():\n    return [['S', '.', '#', '.'],\n            ['#', '.', '#', '.'],\n            ['#', '.', '.', 'E']]\n\nassert f(g())\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Find the sum of all numbers in the grid\"\"\"\n    total = 0\n    for row in grid:\n        for num in row:\n            total += num\n    return total\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\nassert f(g()) == 45\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a 2D grid of characters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are those horizontally or vertically neighboring.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(row: int, col: int, word: str, index: int) -> bool:\n        if index == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        temp = grid[row][col]\n        grid[row][col] = '#' # mark cell as visited\n        for direction in directions:\n            newRow = row + direction[0]\n            newCol = col + direction[1]\n            if dfs(newRow, newCol, word, index + 1):\n                return True\n        grid[row][col] = temp # unmark cell if word does not exist\n        return False\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, word, 0):\n                return True\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if it is possible to transform s into t using the following operations:\n    - Swap the first and last characters of s\n    - Reverse the order of the characters in s\n    - Append the character 'a' to the end of s\"\"\"\n    queue = deque([s])\n    visited = set([s])\n    while queue:\n        curr = queue.popleft()\n        if curr == t:\n            return True\n        if curr[::-1] not in visited:\n            queue.append(curr[::-1])\n            visited.add(curr[::-1])\n        if curr[-1] + curr[1:-1] + curr[0] not in visited:\n            queue.append(curr[-1] + curr[1:-1] + curr[0])\n            visited.add(curr[-1] + curr[1:-1] + curr[0])\n        if curr + 'a' not in visited:\n            queue.append(curr + 'a')\n            visited.add(curr + 'a')\n    return False\n\ndef g(s='abcde', t='edcba'):\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a number is a palindrome.\n    \"\"\"\n    num = str(n)\n    return num == num[::-1]\n\ndef g(n=12321):\n    return n\n\nassert f(g())\n",
        "idx_generation": 96,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the count of total set bits in all numbers from 1 to n.\"\"\"\n    count = 0\n    for i in range(1, n+1):\n        count += bin(i).count('1')\n    return count\ndef g(n=10):\n    return n\nassert f(g()) == 17\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if the bitwise AND of n and m is a power of 2\"\"\"\n    return n & m != 0 and (n & (n-1)) == 0 and (m & (m-1)) == 0\n\ndef g() -> tuple:\n    \"\"\"Find two distinct positive integers n and m such that the bitwise AND of n and m is a power of 2\"\"\"\n    n = 2\n    m = 3\n    while not f(n, m):\n        m += 1\n        if m > n:\n            n += 1\n            m = 1\n    return n, m\n\nassert f(*g())\n",
        "idx_generation": 94,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target value, determine if it is possible to obtain the target value by performing bitwise XOR operations between k elements in nums. Each element in the list can be used at most once.\"\"\"\n    def backtrack(nums, k, target, bitmask, idx):\n        if k == 0:\n            return target == 0\n        if bitmask == (1 << len(nums)) - 1:\n            return False\n        for i in range(len(nums)):\n            if bitmask & 1 << i == 0:\n                if backtrack(nums, k - 1, target ^ nums[i], bitmask | 1 << i, idx + 1):\n                    return True\n        return False\n    return backtrack(nums, k, target, 0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    k = 3\n    target = 12\n    return (nums, k, target)\n\nassert f(*g())\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g():\n    return (585,)\nassert f(*g())\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Check if a string contains a valid mathematical expression with n pairs of parentheses.\"\"\"\n    stack = []\n    for ch in s:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if len(stack) == 0 or stack.pop() != '(':\n                return False\n    return len(stack) == 0 and n == s.count('(')\n    \ndef g(n=4):\n    return '(' * n + ')' * n\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Calculate the perimeter of a polygon formed by a sequence of points in a 2D plane.\n    \"\"\"\n    n = len(points)\n    perimeter = 0\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        distance = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n        perimeter += distance\n    return perimeter\n\ndef g():\n    import random\n    points = [[random.randint(0, 10), random.randint(0, 10)] for _ in range(4)]\n    return points\n\nassert f(g()) > 0\n",
        "idx_generation": 319,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Determine the maximum sum that can be obtained by starting at the top-left cell (0,0) of the grid and moving to the bottom-right cell (n-1, m-1),\n    only moving down or right at each step. Each cell of the grid contains a non-negative integer.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Initialize the DP table\n    dp = [[0] * m for _ in range(n)]\n    \n    # Fill in the DP table\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[n-1][m-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a grid with random non-negative integer values for testing.\"\"\"\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given number is a palindrome after converting it to base n.\"\"\"\n    num = int(s)\n    converted_num = \"\"\n    while num > 0:\n        converted_num += str(num % n)\n        num //= n\n    return converted_num == converted_num[::-1]\n\ndef g(n: int) -> str:\n    \"\"\"Find the smallest palindrome number in base n.\"\"\"\n    num = 1\n    while True:\n        num_str = str(num)\n        if num_str == num_str[::-1] and f(num_str, n):\n            return num_str\n        num += 1\n\nassert f(g(2), 2)\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Determine the number of bits required to represent the given positive integer.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += 1\n        n = n >> 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 48\n\nassert f(g()) == 6\n",
        "idx_generation": 150,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=3) -> bool:\n    \"\"\"Given an adjacency matrix representation of a graph, determine if there is a path from start to end.\"\"\"\n    def dfs(graph, visited, curr, end):\n        if curr == end:\n            return True\n        visited[curr] = True\n        for neighbor in range(len(graph[curr])):\n            if graph[curr][neighbor] == 1 and visited[neighbor] == False:\n                if dfs(graph, visited, neighbor, end):\n                    return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, visited, start, end)\n\ndef g(start=0, end=3):\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 51,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number is present in the grid.\"\"\"\n    def search(grid, target):\n        rows = len(grid)\n        cols = len(grid[0])\n        stack = []\n        visited = [[False] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == target:\n                    return True\n                if not visited[i][j]:\n                    stack.append((i, j))\n                    visited[i][j] = True\n                    while stack:\n                        x, y = stack.pop()\n                        if grid[x][y] == target:\n                            return True\n                        if x > 0 and not visited[x-1][y]:\n                            stack.append((x-1, y))\n                            visited[x-1][y] = True\n                        if x < rows-1 and not visited[x+1][y]:\n                            stack.append((x+1, y))\n                            visited[x+1][y] = True\n                        if y > 0 and not visited[x][y-1]:\n                            stack.append((x, y-1))\n                            visited[x][y-1] = True\n                        if y < cols-1 and not visited[x][y+1]:\n                            stack.append((x, y+1))\n                            visited[x][y+1] = True\n        return False\n    return search(grid, target)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Find the length of the longest word that can be formed by concatenating characters in the grid.\"\"\"\n    max_len = 0\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            visited = set()\n            max_word_len = dfs(grid, i, j, visited, '')\n            max_len = max(max_len, max_word_len)\n    return max_len\n\ndef dfs(grid, row, col, visited, word):\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or (row, col) in visited:\n        return len(word)\n    visited.add((row, col))\n    word += grid[row][col]\n    max_word_len = 0\n    max_word_len = max(max_word_len, dfs(grid, row-1, col, visited, word))\n    max_word_len = max(max_word_len, dfs(grid, row+1, col, visited, word))\n    max_word_len = max(max_word_len, dfs(grid, row, col-1, visited, word))\n    max_word_len = max(max_word_len, dfs(grid, row, col+1, visited, word))\n    visited.remove((row, col))\n    return max_word_len\n\ndef g(grid=[['a', 'b', 'c', 'd'],\n            ['e', 'f', 'g', 'h'],\n            ['i', 'j', 'k', 'l'],\n            ['m', 'n', 'o', 'p']]):\n    return grid\n\nassert f(g()) == 16\n",
        "idx_generation": 106,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Check if it is possible to reach the end position from the start position in the given grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    queue = [start]\n    while queue:\n        (x, y) = queue.pop(0)\n        if x == end[0] and y == end[1]:\n            return True\n        if x < 0 or y < 0 or x >= rows or y >= cols or (grid[x][y] == 1) or visited[x][y]:\n            continue\n        visited[x][y] = True\n        queue.append((x - 1, y))\n        queue.append((x + 1, y))\n        queue.append((x, y - 1))\n        queue.append((x, y + 1))\n    return False\ndef g():\n    grid = [[0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0]]\n    start = (0, 0)\n    end = (4, 4)\n    return [grid, start, end]\nassert f(*g())\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=5) -> bool:\n    \"\"\"Find the number of combinations of numbers from the given list that add up to the target number\"\"\"\n    count = 0\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        total, index = stack.pop()\n        if total == target:\n            count += 1\n        if index < len(nums):\n            stack.append((total + nums[index], index + 1))\n            stack.append((total, index + 1))\n    return count\n\ndef g(target=5):\n    return [1, 2, 3, 4]\n\nassert f(g()) == 3\n",
        "idx_generation": 263,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, determine the number of unique combinations that add up to the target.\"\"\"\n    def backtrack(nums, target, start, current, result):\n        if target == 0:\n            result.append(list(current))\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(nums, target-nums[i], i, current, result)\n            current.pop()\n    \n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return len(result)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\n\nnums = [2, 3, 6, 7]\ntarget = 7\n\nassert f(g(nums, target), target) == 2\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target', return a list of all the unique combinations of numbers from 'nums' that add up to the target.\n    Each number in 'nums' can be used multiple times in the combinations.\"\"\"\n    def backtrack(combination, remaining):\n        if remaining == 0:\n            results.append(combination)\n            return\n        for num in nums:\n            if num > remaining:\n                break\n            if not combination or num >= combination[-1]:\n                backtrack(combination + [num], remaining - num)\n\n    nums.sort()\n    results = []\n    backtrack([], target)\n    return results\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nimport math\nfrom typing import *\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the binary representation of n has k consecutive 1s.\nReturn True if it has k consecutive 1s, False otherwise.\"\"\"\n    binary = bin(n)[2:]\n    consecutive_ones = 0\n    for digit in binary:\n        if digit == '1':\n            consecutive_ones += 1\n            if consecutive_ones == k:\n                return True\n        else:\n            consecutive_ones = 0\n    return False\ndef g():\n    n = random.randint(1, 1000)\n    k = random.randint(1, 5)\n    return n, k\nassert f(*g())\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to the target value.\"\"\"\n    if target == 0:\n        return True\n    if not nums or target < 0:\n        return False\n    return f(nums[1:], target-nums[0]) or f(nums[1:], target)\ndef g(nums=[2, 4, 6, 8], target=14):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 10,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=3) -> bool:\n    \"\"\"Find a subset of numbers from the given list that sums up to the target, using at most target number of elements\"\"\"\n    stack = [(0, 0, [])]\n    while stack:\n        current_sum, current_count, current_subset = stack.pop()\n        if current_sum == target and current_count <= target:\n            return True\n        if current_count < target:\n            for num in nums:\n                if current_sum + num <= target:\n                    stack.append((current_sum + num, current_count + 1, current_subset + [num]))\n    return False\n\ndef g(target=3):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 103,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels in a given string.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    return sum(1 for char in s.lower() if char in vowels)\n\ndef g(s=\"Hello, World!\"):\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given list using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 7) == 6\n",
        "idx_generation": 173,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of elements in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 10)\n",
        "idx_generation": 34,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string s is a valid parentheses sequence.\"\"\"\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef g(s: str):\n    return s\n\nassert f(g('()()()'))",
        "idx_generation": 54,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"Given a list of points in 2D space, determine if they form a square.\n    Return True if the points form a square, otherwise return False.\"\"\"\n    def distance(point1, point2):\n        return (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2\n\n    if len(points) != 4:\n        return False\n    distances = []\n    for i in range(len(points)-1):\n        for j in range(i+1, len(points)):\n            distances.append(distance(points[i], points[j]))\n    distances.sort()\n    if distances[0] == distances[1] == distances[2] == distances[3] != 0 and distances[4] == distances[5]:\n        return True\n    return False\n\ndef g():\n    points = [(0, 0), (0, 1), (1, 1), (1, 0)]\n    return points\n\nassert f(g())",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the values of the matrix in spiral order.\n    Args:\n        matrix: The matrix of integers represented as a list of lists.\n    Returns:\n        The values of the matrix in spiral order as a list.\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    result = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g(matrix: List[List[int]]):\n    \"\"\"\n    Returns the input matrix.\n    \"\"\"\n    return matrix\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(matrix)) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 and s2 are anagrams.\"\"\"\n    count = [0] * 26\n    for char in s1:\n        count[ord(char) - ord('a')] += 1\n    for char in s2:\n        count[ord(char) - ord('a')] -= 1\n    return all(count[i] == 0 for i in range(26))\n\ndef g():\n    return (\"listen\", \"silent\")\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be formed by rearranging the characters of another string t.\"\"\"\n    def helper(s, t):\n        if s == '':\n            return True\n        for i, char in enumerate(t):\n            if char == s[0]:\n                if helper(s[1:], t[:i] + t[i+1:]):\n                    return True\n        return False\n    return helper(s, s[::-1])\ndef g():\n    return 'tacocat'\nassert f(g())\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find a number that is a perfect square and has the same sum of its digits\"\"\"\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(num))\n    for i in range(1, n+1):\n        if i**2 == digit_sum(i):\n            return True\n    return False\ndef g():\n    return 14\nassert f(g())\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], n=1) -> bool:\n    \"\"\"Check if there exists a pair of integers in arr whose XOR is equal to n.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] ^ arr[j] == n:\n                return True\n    return False\ndef g(n=1):\n    return [n, n + 1, n + 2, n + 3]\nassert f(g())\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists a pair of elements whose bitwise XOR is equal to the target value.\"\"\"\n    def helper(arr, target, start, end):\n        if start >= end:\n            return False\n        if arr[start] ^ arr[end] == target:\n            return True\n        elif arr[start] ^ arr[end] < target:\n            return helper(arr, target, start + 1, end)\n        else:\n            return helper(arr, target, start, end - 1)\n    return helper(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[2, 4, 6, 8, 10], target=0):\n    return arr\n\nassert f(g(), target=14)\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum path from the top-left corner to the bottom-right corner of the grid,\n    moving only down or right, and summing the numbers encountered along the path.\"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Determine if there is a subarray in the given list such that the sum of its elements is equal to zero.\"\"\"\n    prefix_sum = 0\n    prefix_sum_set = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sum_set:\n            return True\n        prefix_sum_set.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n    \nassert f(g())\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a valid topological sorting of a directed acyclic graph (DAG).\"\"\"\n    n = len(nums)\n    indegree = [0] * n\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] > nums[j]:\n                indegree[nums[j]] += 1\n\n    for i in range(n):\n        if indegree[nums[i]] != 0:\n            return False\n        for j in range(i+1, n):\n            if nums[i] > nums[j]:\n                indegree[nums[j]] -= 1\n\n    return True\n\ndef g():\n    return [3, 2, 1, 4, 0, 5]\n\nassert f(g())\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"Given an adjacency matrix 'graph' representing a directed graph, find the topological ordering of the graph.\"\"\"\n    from collections import deque\n    n = len(graph)\n    in_degree = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 1:\n                in_degree[j] += 1\n    queue = deque()\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for i in range(n):\n            if graph[node][i] == 1:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    queue.append(i)\n    return result\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 1, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return graph\nassert f(g()) == [0, 1, 2, 3, 4]\n",
        "idx_generation": 370,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"Determine if a 9x9 Sudoku board is valid.\"\"\"\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num or board[3*(row//3)+i//3][3*(col//3)+i%3] == num:\n                return False\n        return True\n\n    def solve_sudoku(board):\n        for row in range(9):\n            for col in range(9):\n                if board[row][col] == \".\":\n                    for num in \"123456789\":\n                        if is_valid(board, row, col, num):\n                            board[row][col] = num\n                            if solve_sudoku(board):\n                                return True\n                            board[row][col] = \".\"\n                    return False\n        return True\n\n    return solve_sudoku(board)\n\ndef g(board=[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n             [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n             [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n             [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n             [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n             [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n             [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n             [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n             [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]):\n    return board\n\nassert f(g())",
        "idx_generation": 9,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of size M x N, determine if it is possible to reach the bottom-right cell from the top-left cell.\n    You can only move down or right in the matrix.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    \n    for i in range(1, m):\n        if matrix[i][0] == 1:\n            dp[i][0] = dp[i-1][0]\n            \n    for j in range(1, n):\n        if matrix[0][j] == 1:\n            dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 1:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid forms a valid Sudoku solution.\"\"\"\n    def is_valid_row(row):\n        return len(set(row)) == 9 and all(1 <= num <= 9 for num in row)\n\n    def is_valid_col(col):\n        return len(set(col)) == 9 and all(1 <= num <= 9 for num in col)\n\n    def is_valid_box(box):\n        return len(set(box)) == 9 and all(1 <= num <= 9 for num in box)\n\n    for i in range(9):\n        row = grid[i]\n        col = [grid[j][i] for j in range(9)]\n        if not (is_valid_row(row) and is_valid_col(col)):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid_box(box):\n                return False\n\n    return True\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 144,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left corner to the bottom-right corner in the given grid\"\"\"\n    m, n = len(nums), len(nums[0])\n    queue = [(0, 0, 0)]\n    visited = set()\n    while queue:\n        x, y, dist = queue.pop(0)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if x == m - 1 and y == n - 1:\n            return dist\n        if x + 1 < m:\n            queue.append((x + 1, y, dist + 1))\n        if y + 1 < n:\n            queue.append((x, y + 1, dist + 1))\n    return -1\ndef g(nums: List[List[int]]) -> List[List[int]]:\n    return nums\nnums = [[0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]\nassert f(g(nums)) == 8\n",
        "idx_generation": 273,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Transpose the given matrix\"\"\"\n    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a matrix\"\"\"\n    return matrix\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix)) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target number k, determine if there exists a subarray with a sum equal to k.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], k=9):\n    return nums\n\nassert f(g(), k=7)\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"Return the elements of a grid in spiral order, starting from the top-left corner and moving clockwise.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n    result = []\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(grid[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            result.append(grid[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(grid[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(grid[i][left])\n            left += 1\n    return result\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return (grid,)\nassert f(*g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 429,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all unique combinations of numbers in the list that sum up to the target.\n    Each number in a combination may only be used once.\n    \"\"\"\n\n    def backtrack(combination, start, target):\n        if target == 0:\n            combinations.append(combination[:])\n        elif target > 0:\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                combination.append(nums[i])\n                backtrack(combination, i+1, target-nums[i])\n                combination.pop()\n\n    nums.sort()\n    combinations = []\n    backtrack([], 0, target)\n    return combinations\n\ndef g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 46,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the sum of all elements in the grid that are divisible by 3.\n    Return the sum.\"\"\"\n    m, n = len(grid), len(grid[0])\n    total = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] % 3 == 0:\n                total += grid[i][j]\n    return total\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 18\n",
        "idx_generation": 142,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Determine if a string can be split into k equal parts.\"\"\"\n    if len(s) % k != 0:\n        return False\n    sub_len = len(s) // k\n    for i in range(0, len(s), sub_len):\n        if s[i:i+sub_len] != s[0:sub_len]:\n            return False\n    return True\n\ndef g():\n    s = \"abcabcabcabc\"\n    k = 4\n    return (s, k)\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 230,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within a given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\narr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(arr)) == 6\n",
        "idx_generation": 356,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the length of the smallest subarray with a sum greater than or equal to the target.\n\n    Return 0 if no such subarray exists.\"\"\"\n    left = 0\n    min_length = float('inf')\n    current_sum = 0\n\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n\n    return min_length if min_length != float('inf') else 0\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\n\nnums = [2, 3, 1, 2, 4, 3]\ntarget = 7\nassert f(g(nums, target), target) == 2\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, check if it is a valid binary number.\"\"\"\n    for char in s:\n        if char != '0' and char != '1':\n            return False\n    return True\n\ndef g():\n    return '101010'\n\nassert f(g())\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, return True if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=12):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 2,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Check if the parentheses in the given expression are balanced\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    expression = \"((2 + 3) * 5) + (4 * (6 - 2))\"\n    return expression\n\nassert f(g())\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: list, target=10) -> bool:\n    \"\"\"Check if the target value is present in the matrix\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == target:\n                return True\n    return False\n\ndef g(target=10):\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    matrix[1][1] = target\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 130,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Determine if the parentheses in the expression are balanced.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"((3 + 4) - 2) * (5 - 2)\"\n\nassert f(g())\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(n: int) -> int:\n    \"\"\"Given an integer 'n', return the nth Fibonacci number.\nThe Fibonacci sequence starts with 0 and 1, and each subsequent number in the sequence is the sum of the two preceding ones.\nExample:\nInput:\n5\nOutput:\n5\nNote: The input integer will always be greater than or equal to 0.\n\"\"\"\n    if n <= 1:\n        return n\n    prev1, prev2 = 0, 1\n    for _ in range(2, n + 1):\n        curr = prev1 + prev2\n        prev1, prev2 = prev2, curr\n    return prev2\ndef g() -> int:\n    \"\"\"Generate an integer 'n' that has a valid solution.\n    Return the generated integer.\n    \"\"\"\n    n = 7\n    return n\nassert f(g()) == 13\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\ndef g():\n    return (6,)\nassert f(g()[0]) == 8\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D grid of integers and a target value, determine if the target value exists in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        x, y = stack.pop()\n        if x < 0 or x >= rows or y < 0 or y >= cols or (x, y) in visited:\n            continue\n        if grid[x][y] == target:\n            return True\n        visited.add((x, y))\n        stack.append((x+1, y))\n        stack.append((x-1, y))\n        stack.append((x, y+1))\n        stack.append((x, y-1))\n    return False\n\ndef g():\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5)\n\nassert f(*g())\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented by a 2D grid, determine if the maze is solvable.\n    The maze is represented by a list of lists, where 0 represents a wall and 1\n    represents a path. The entrance and exit of the maze are represented by the\n    top-left and bottom-right corners respectively.\"\"\"\n    def helper(row: int, col: int) -> bool:\n        if row < 0 or row >= len(maze) or col < 0 or col >= len(maze[0]) or maze[row][col] != 1:\n            return False\n        \n        if row == len(maze) - 1 and col == len(maze[0]) - 1:\n            return True\n        \n        maze[row][col] = -1\n        \n        return helper(row+1, col) or helper(row-1, col) or helper(row, col+1) or helper(row, col-1)\n    \n    return helper(0, 0)\ndef g():\n    maze = [[1, 0, 0, 0],\n            [1, 1, 0, 1],\n            [0, 1, 0, 0],\n            [1, 1, 1, 1]]\n    return maze\nassert f(g())\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]], start: Tuple[int, int], target: int) -> bool:\n    \"\"\"Given a 2D grid of integers, a starting position, and a target value, determine if it is possible to reach the target value from the starting position by moving only right or down.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [start]\n    visited = set()\n    while stack:\n        x, y = stack.pop()\n        if x < 0 or x >= rows or y < 0 or y >= cols or (x, y) in visited:\n            continue\n        if grid[x][y] == target:\n            return True\n        visited.add((x, y))\n        stack.append((x + 1, y))\n        stack.append((x, y + 1))\n    return False\ndef g():\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), 9)\nassert f(*g())\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_str = \"\"\n    while stack:\n        reversed_str += stack.pop()\n    return s == reversed_str\ndef g(s=\"racecar\"):\n    return (s,)\nassert f(*g())\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a palindrome.\n\"\"\"\n    def is_palindrome(n):\n        if len(str(n)) <= 1:\n            return True\n        if str(n)[0] != str(n)[-1]:\n            return False\n        return is_palindrome(str(n)[1:-1])\n    return is_palindrome(n)\ndef g(n=12321):\n    return n\nassert f(g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, g=lambda x: bin(x).count('1')) -> bool:\n    \"\"\"Find the number of set bits in a given number\"\"\"\n    return g(n) == 3\ndef g():\n    return 14\nassert f(g())\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of the given list such that the XOR of all elements in the subset is zero.\"\"\"\n    def helper(nums, index, xor_sum):\n        if xor_sum == 0:\n            return True\n        if index == len(nums):\n            return False\n        return helper(nums, index + 1, xor_sum ^ nums[index]) or helper(nums, index + 1, xor_sum)\n    \n    return helper(nums, 0, 0)\n\ndef g(nums: List[int]):\n    return nums\n\n# Example usage:\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums))\n",
        "idx_generation": 143,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subset of the given list of integers such that the bitwise XOR of all the\n    elements in the subset is equal to the target value.\"\"\"\n    n = len(nums)\n    for i in range(2 ** n):\n        subset = [nums[j] for j in range(n) if (i & (1 << j))]\n        bitwise_xor = 0\n        for num in subset:\n            bitwise_xor ^= num\n        if bitwise_xor == target:\n            return True\n    return False\ndef g(nums: List[int]=[2, 4, 6, 8], target: int=10):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int, k: int) -> bool:\n    \"\"\"Check if the binary representation of n has exactly k consecutive 1s.\"\"\"\n    binary = bin(n)[2:]\n    return '1' * k in binary\ndef g(n: int, k: int):\n    return bin(n)[2:]\nassert f(g(13, 2), 13, 2)\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to move from the top-left corner to the bottom-right corner of the grid.\n    You can only move down or right at each step, and each cell represents the cost to move to that cell.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[-1][-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 227,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import *\ndef f(points: List[List[int]]) -> float:\n    \"\"\"Calculate the area of a polygon formed by a sequence of points in a 2D plane.\"\"\"\n    n = len(points)\n    area = 0\n    for i in range(n):\n        (x1, y1) = points[i]\n        (x2, y2) = points[(i + 1) % n]\n        area += (x1 * y2) - (x2 * y1)\n    return abs(area) / 2\ndef g():\n    import random\n    points = [[random.randint(0, 10), random.randint(0, 10)] for _ in range(3)]\n    return points\nassert f(g()) > 0\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], k=5, target=15) -> bool:\n    \"\"\"Given a grid of integers, find a subgrid of size kxk that has the maximum sum of elements. Return True if the\nsum is greater than or equal to the target sum, otherwise return False.\nSample Input:\ngrid = [[1, 2, 3, 4, 5],\n        [6, 7, 8, 9, 10],\n        [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]]\nk = 3\ntarget = 15\nSample Output:\nTrue\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = float('-inf')\n    for i in range(rows - k + 1):\n        for j in range(cols - k + 1):\n            current_sum = sum(sum(grid[i + x][j:j + k]) for x in range(k))\n            max_sum = max(max_sum, current_sum)\n    return max_sum >= target\n\ndef g(grid=[[1, 2, 3, 4, 5],\n            [6, 7, 8, 9, 10],\n            [11, 12, 13, 14, 15],\n            [16, 17, 18, 19, 20],\n            [21, 22, 23, 24, 25]], k=3, target=15):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of unique permutations of the integers from 1 to n (inclusive) such that the bitwise\n    AND of all the elements in each permutation is divisible by k.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if i % k == 0:\n            count += 1\n    return count\ndef g(n: int=5, k: int=2):\n    return (n, k)\nassert f(*g()) == 2\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, return the values of the matrix in spiral order.\n\"\"\"\n    if not matrix:\n        return []\n    m, n = len(matrix), len(matrix[0])\n    res = []\n    seen = [[False] * n for _ in range(m)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    direction = 0\n    row, col = 0, 0\n    for _ in range(m * n):\n        res.append(matrix[row][col])\n        seen[row][col] = True\n        next_row, next_col = row + directions[direction][0], col + directions[direction][1]\n        if 0 <= next_row < m and 0 <= next_col < n and not seen[next_row][next_col]:\n            row, col = next_row, next_col\n        else:\n            direction = (direction + 1) % 4\n            row, col = row + directions[direction][0], col + directions[direction][1]\n    return res\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\"\"\"\n    def unique_paths(n, row, col, memo):\n        if row == n - 1 and col == n - 1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        if memo[row][col] != -1:\n            return memo[row][col]\n        memo[row][col] = unique_paths(n, row + 1, col, memo) + unique_paths(n, row, col + 1, memo)\n        return memo[row][col]\n    \n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths(n, 0, 0, memo)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 320,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Check if it is possible to navigate from the start position to the end position in the given maze.\"\"\"\n    n = len(maze)\n    if n == 0:\n        return False\n    m = len(maze[0])\n    if m == 0:\n        return False\n    visited = [[False] * m for _ in range(n)]\n    stack = [start]\n    while stack:\n        x, y = stack.pop()\n        if x == end[0] and y == end[1]:\n            return True\n        if x < 0 or y < 0 or x >= n or y >= m or maze[x][y] == 1 or visited[x][y]:\n            continue\n        visited[x][y] = True\n        stack.append((x-1, y))\n        stack.append((x+1, y))\n        stack.append((x, y-1))\n        stack.append((x, y+1))\n    return False\n\ndef g():\n    maze = [[0, 0, 0, 0, 0],\n            [1, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0]]\n    start = (0, 0)\n    end = (4, 4)\n    return [maze, start, end]\n\nassert f(*g())\n",
        "idx_generation": 326,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of unique paths from the top-left to the bottom-right corner of a n x n grid, where you can only move down or right.\"\"\"\n    def count_paths(i, j):\n        if i == 0 or j == 0:\n            return 1\n        else:\n            return count_paths(i-1, j) + count_paths(i, j-1)\n    return count_paths(n-1, n-1)\ndef g():\n    return 4\nassert f(g()) == 20\n",
        "idx_generation": 110,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the first non-repeating number in the given list.\n    \"\"\"\n    count = {}\n    queue = []\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n        if count[num] == 1:\n            queue.append(num)\n        elif count[num] == 2:\n            queue.remove(num)\n    return queue[0]\n\ndef g():\n    return [1, 3, 2, 2, 1, 4, 4]\n\nassert f(g()) == 3\n",
        "idx_generation": 300,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, determine the number of unique combinations that add up to the target.\nEach number in the list can only be used once in a combination.\"\"\"\n    def backtrack(nums, target, start, current, result):\n        if target == 0:\n            result.append(list(current))\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(nums[:i] + nums[i+1:], target - nums[i], i, current, result)\n            current.pop()\n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return len(result)\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\nnums = [1, 2, 3, 4]\ntarget = 5\nassert f(g(nums, target), target) == 2\n",
        "idx_generation": 317,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if t is an anagram of s.\"\"\"\n    def helper(s, t):\n        if s == '' and t == '':\n            return True\n        if len(s) != len(t):\n            return False\n        for i in range(len(s)):\n            if s[i] in t:\n                return helper(s[:i] + s[i+1:], t.replace(s[i], '', 1))\n        return False\n    return helper(s, t)\n\ndef g():\n    return ('listen', 'silent')\n\nassert f(*g()) == True\n",
        "idx_generation": 58,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if the binary representation of n contains exactly k bits set to 1\"\"\"\n    binary = bin(n)[2:]\n    count = binary.count('1')\n    return count == k\ndef g(n: int, k: int):\n    return (n, k)\nassert f(*g(10, 2))\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to arrange n distinct objects in a row, where some objects have to be placed together.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g(n: int) -> int:\n    \"\"\"Return the number of distinct objects to be arranged.\"\"\"\n    return n\nassert f(g(5)) == 8\n",
        "idx_generation": 225,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in ascending order.\n    \n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Output:\n    [0, 1]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n            \n    return []\n    \ndef g(nums: List[int], target: int):\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return (nums, target)\n    \nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(*g(nums, target)) == [0, 1]\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if a target value is present in a sorted list using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g(arr=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20], target=12):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 36,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray in the given list with a sum equal to k.\"\"\"\n    stack = []\n    curr_sum = 0\n    for num in nums:\n        stack.append(num)\n        curr_sum += num\n        while curr_sum > k:\n            curr_sum -= stack.pop(0)\n        if curr_sum == k:\n            return True\n    return False\n\ndef g():\n    return [1, 4, 2, -2, 5, -3, 3]\n\nassert f(g(), 4) == True\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if a target number exists in a 2D grid, where each row and column is sorted in ascending order.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    for i in range(rows):\n        if grid[i][0] <= target <= grid[i][cols-1]:\n            left, right = 0, cols-1\n            while left <= right:\n                mid = (left + right) // 2\n                if grid[i][mid] == target:\n                    return True\n                elif grid[i][mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n    return False\ndef g():\n    return ([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 11)\nassert f(*g())\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a pair of numbers in the list that sum up to the target value.\n    Return True if such pair exists, and False otherwise.\"\"\"\n    stack = []\n    for num in nums:\n        if target - num in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Check if the given string can be constructed by concatenating words from the list.\"\"\"\n    def can_construct(s, words, start, end, memo={}):\n        if start == end:\n            return True\n        if start in memo:\n            return memo[start]\n        for i in range(start, end):\n            prefix = s[start:i+1]\n            if prefix in words and can_construct(s, words, i+1, end, memo):\n                memo[start] = True\n                return True\n        memo[start] = False\n        return False\n    \n    return can_construct(s, words, 0, len(s))\n\ndef g():\n    s = 'leetcode'\n    words = ['leet', 'code']\n    return (s, words)\n\nassert f(*g())\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the length of the shortest\n    subarray that sums up to the target. If no such subarray exists, return -1.\n    \"\"\"\n    min_length = float('inf')\n    current_sum = 0\n    start = 0\n    \n    for end in range(len(nums)):\n        current_sum += nums[end]\n        \n        while current_sum >= target:\n            min_length = min(min_length, end - start + 1)\n            current_sum -= nums[start]\n            start += 1\n    \n    return min_length if min_length != float('inf') else -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 3, 1, 2, 4, 3], 7)\n\nassert f(*g()) == 2\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find a pair of numbers in the given list whose bitwise AND is equal to the target.\"\"\"\n    nums.sort()\n    (left, right) = (0, len(nums) - 1)\n    while left < right:\n        bitwise_and = nums[left] & nums[right]\n        if bitwise_and == target:\n            return True\n        elif bitwise_and < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [5, 3, 9, 10, 7, 2]\n\nassert f(g(), 2)\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given an array of integers arr, determine if there are three distinct indices i, j, k such that arr[i] & arr[j] & arr[k] == 0.\n    Returns True if such indices exist, False otherwise.\"\"\"\n    arr.sort()\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[i][j] = dp[j][i] = arr[i] & arr[j] == 0\n            for k in range(j + 1, n):\n                if dp[i][j] and dp[j][k] and dp[i][k]:\n                    return True\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return (len(arr), arr)\n\nassert f(*g()) == False\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a subsequence of three numbers in the given list that form an arithmetic sequence.\"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if nums[i + 1] - nums[i] == nums[i + 2] - nums[i + 1]:\n            return True\n    return False\n\ndef g():\n    return [1, 3, 5, 2, 6, 9, 8]\n\nassert f(g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a prime palindrome. A prime palindrome is a number that is prime and also a palindrome, meaning it reads the same forwards and backwards.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    return is_prime(n) and is_palindrome(n)\n\ndef g(n: int):\n    while True:\n        if str(n) == str(n)[::-1]:\n            for i in range(2, int(n ** 0.5) + 1):\n                if n % i == 0:\n                    break\n            else:\n                return n\n        n += 1\n\nassert f(g(101))\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subarray with a sum equal to zero, False otherwise.\"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in sum_set:\n            return True\n        sum_set.add(prefix_sum)\n    return False\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [4, 2, -3, 1, 6]\nassert f(g(nums)) == True\n",
        "idx_generation": 420,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D matrix 'arr' and a target integer, determine if the target exists in the matrix.\n    The matrix is guaranteed to be sorted in ascending order both row-wise and column-wise.\"\"\"\n    rows = len(arr)\n    cols = len(arr[0])\n    i = rows - 1\n    j = 0\n    while i >= 0 and j < cols:\n        if arr[i][j] == target:\n            return True\n        elif arr[i][j] < target:\n            j += 1\n        else:\n            i -= 1\n    return False\ndef g(arr=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target sum, determine if there exists a subset of the list that adds up to the target sum.\"\"\"\n    def subset_sum(arr, target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(arr):\n            return False\n        include = subset_sum(arr, target - arr[index], index + 1)\n        exclude = subset_sum(arr, target, index + 1)\n        return include or exclude\n\n    return subset_sum(arr, target, 0)\n\ndef g(target=10):\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target exists in the matrix using depth-first search (DFS).\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    stack = deque([(0, 0)])\n\n    while stack:\n        row, col = stack.pop()\n        if matrix[row][col] == target:\n            return True\n\n        # Add adjacent cells to the stack\n        if row + 1 < rows:\n            stack.append((row + 1, col))\n        if col + 1 < cols:\n            stack.append((row, col + 1))\n    \n    return False\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g(), 5)\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(mat: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate the given 2D square matrix by 90 degrees clockwise.\"\"\"\n    n = len(mat)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = mat[i][j]\n            mat[i][j] = mat[n - j - 1][i]\n            mat[n - j - 1][i] = mat[n - i - 1][n - j - 1]\n            mat[n - i - 1][n - j - 1] = mat[j][n - i - 1]\n            mat[j][n - i - 1] = temp\n    return mat\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 470,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix, return the transpose of the matrix.\"\"\"\n    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n\ndef g():\n    \"\"\"Generate a matrix.\"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n",
        "idx_generation": 149,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Check if a given arithmetic expression is balanced, meaning that all opening and closing parentheses are properly matched.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(expression: str) -> str:\n    return expression\n\nassert f(g(\"(2 + 3) * 4\"))\n",
        "idx_generation": 96,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if a given number n can be expressed as the sum of m consecutive positive integers.\"\"\"\n    def is_sum_of_consecutive_integers(num, count):\n        start = (num - count + 1) // count\n        end = (num + count) // count\n        return num == (start + end) * count // 2\n        \n    return is_sum_of_consecutive_integers(n, m)\n    \ndef g(m: int) -> int:\n    \"\"\"Find the smallest number that can be expressed as the sum of m consecutive positive integers.\"\"\"\n    num = 1\n    while True:\n        if f(num, m):\n            return num\n        num += 1\n        \nassert f(g(m=4), m=4)\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Determine if the parentheses in the given expression are balanced.\n    Return True if the parentheses are balanced, False otherwise.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(expression: str):\n    \"\"\"Generate an expression with parentheses.\"\"\"\n    return (expression,)\n\nexpression = \"((3 + 5) * 2) + (4 - 2)\"\nassert f(*g(expression)) == True\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, k=3) -> bool:\n    \"\"\"Find a number that has exactly k set bits in its binary representation\"\"\"\n    return bin(num).count('1') == k\ndef g(k=3):\n    num = 1\n    while bin(num).count('1') != k:\n        num += 1\n    return num\nassert f(g())\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\"\"\"\n    n = len(nums)\n    left = [1] * n\n    right = [1] * n\n    result = [0] * n\n    \n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n        \n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n        \n    for i in range(n):\n        result[i] = left[i] * right[i]\n        \n    return result\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(s: str, target: int) -> bool:\n    \"\"\"Check if it is possible to form the target number using the given string and mathematical operations.\"\"\"\n    nums = [int(char) for char in s if char.isdigit()]\n    ops = [char for char in s if char in ['+', '-', '*', '/']]\n    result = nums[0]\n    for i in range(1, len(nums)):\n        if ops[i-1] == '+':\n            result += nums[i]\n        elif ops[i-1] == '-':\n            result -= nums[i]\n        elif ops[i-1] == '*':\n            result *= nums[i]\n        elif ops[i-1] == '/':\n            if nums[i] == 0:\n                return False\n            result /= nums[i]\n    return result == target\n\ndef g():\n    return \"8*2-1\", 15\n\nassert f(*g())\n",
        "idx_generation": 336,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string s, find the length of the longest palindromic subsequence in s.\"\"\"\n    def helper(s, start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if s[start] == s[end]:\n            return helper(s, start + 1, end - 1) + 2\n        else:\n            return max(helper(s, start + 1, end), helper(s, start, end - 1))\n    return helper(s, 0, len(s) - 1)\ndef g():\n    return 'babad'\nassert f(g()) == 3\n",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return 'level'\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum product of a subarray in a given list of integers.\"\"\"\n    max_prod = float('-inf')\n    curr_prod = 1\n    for num in arr:\n        curr_prod = max(num, curr_prod * num)\n        max_prod = max(max_prod, curr_prod)\n    return max_prod\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\nassert f(g([2, 3, -2, 4])) == 6\n",
        "idx_generation": 42,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target value k, find the length of the shortest subarray\n    with a sum greater than or equal to k. If no such subarray exists, return 0.\"\"\"\n    min_length = float('inf')\n    left = 0\n    curr_sum = 0\n    \n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        while curr_sum >= k:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n\ndef g(nums=[2, 3, 1, 2, 4, 3], k=7):\n    return (nums, k)\n\nassert f(*g()) == 2\n",
        "idx_generation": 132,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], target='python') -> bool:\n    \"\"\"Check if the word target is present in the grid horizontally, vertically or diagonally.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if check_horizontal(grid, i, j, target):\n                return True\n            if check_vertical(grid, i, j, target):\n                return True\n            if check_diagonal(grid, i, j, target):\n                return True\n    return False\n\ndef check_horizontal(grid, row, col, target):\n    for i in range(len(target)):\n        if col + i >= len(grid[0]) or grid[row][col+i] != target[i]:\n            return False\n    return True\n\ndef check_vertical(grid, row, col, target):\n    for i in range(len(target)):\n        if row + i >= len(grid) or grid[row+i][col] != target[i]:\n            return False\n    return True\n\ndef check_diagonal(grid, row, col, target):\n    for i in range(len(target)):\n        if row + i >= len(grid) or col + i >= len(grid[0]) or grid[row+i][col+i] != target[i]:\n            return False\n    return True\n\ndef g(grid=[['p', 'y', 't', 'h', 'o', 'n'], ['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p', 'q', 'r'], ['s', 't', 'u', 'v', 'w', 'x'], ['y', 'z', 'a', 'v', 'a', 'l']]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers nums and an integer target, find two numbers in\n    the list such that they add up to target. Return the indices of the two numbers\n    as a list. You may assume that each input would have exactly one solution, and\n    you may not use the same element twice.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 54,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> bool:\n    \"\"\"Check if the parentheses in the given string are balanced.\"\"\"\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"((()))\"\n\nassert f(g())\n",
        "idx_generation": 28,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a non-negative integer n, compute the Fibonacci number at position n using dynamic programming.\"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0] * (n+1)\n        fib[0] = 0\n        fib[1] = 1\n        for i in range(2, n+1):\n            fib[i] = fib[i-1] + fib[i-2]\n        return fib[n]\ndef g():\n    return 6\nassert f(g()) == 8\n",
        "idx_generation": 143,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number exists in the given matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    stack = [(0, 0)]\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == target:\n            return True\n        if 0 <= x + 1 < rows:\n            stack.append((x + 1, y))\n        if 0 <= y + 1 < cols:\n            stack.append((x, y + 1))\n    return False\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return matrix, target\nassert f(*g())\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\nYou can only move down or right.\nReturn the minimum sum.\n\nExample:\ngrid = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\n\nThe minimum sum of a path from the top-left corner to the bottom-right corner is 7.\n\nSample Input:\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nSample Output:\n21\n\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n])) == 7\n",
        "idx_generation": 65,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(n: int, obstacles: List[List[int]]) -> bool:\n    \"\"\"Given the dimensions of a grid and a list of obstacle coordinates, determine the number of unique paths from the top-left corner to the bottom-right corner.\nThe grid is represented by a 2D list where 0 represents an empty cell and 1 represents an obstacle. You can only move rightwards or downwards on the grid.\"\"\"\n    rows = n\n    cols = n\n    grid = [[0] * cols for _ in range(rows)]\n    for obstacle in obstacles:\n        row, col = obstacle\n        grid[row][col] = 1\n    queue = [(0, 0)]\n    paths = [[0] * cols for _ in range(rows)]\n    paths[0][0] = 1\n    while queue:\n        (x, y) = queue.pop(0)\n        if x + 1 < rows and grid[x + 1][y] != 1:\n            queue.append((x + 1, y))\n            paths[x + 1][y] += paths[x][y]\n        if y + 1 < cols and grid[x][y + 1] != 1:\n            queue.append((x, y + 1))\n            paths[x][y + 1] += paths[x][y]\n    return paths[rows - 1][cols - 1]\ndef g(n=3, obstacles=[[1, 1]]):\n    return (n, obstacles)\nassert f(*g()) == 2\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(expression: str) -> bool:\n    \"\"\"Check if the given expression is a palindrome when read forward and backward\"\"\"\n    stack = []\n    for char in expression:\n        stack.append(char)\n    reverse_expression = \"\"\n    while stack:\n        reverse_expression += stack.pop()\n    return expression == reverse_expression\ndef g():\n    return \"madam\"\nassert f(g())\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if the given string t is a rotation of the string s.\"\"\"\n    return len(s) == len(t) and t in s+s\ndef g() -> Tuple[str, str]:\n    \"\"\"Generate two strings where one is a rotation of the other.\"\"\"\n    import random\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    s = ''.join(random.choices(alphabet, k=random.randint(1, 10)))\n    t = s[-1] + s[:-1]\n    return s, t\nassert f(*g())\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, nums=[10, 5, 3], target=15) -> bool:\n    \"\"\"Find if there exists a combination of numbers in nums that sum up to the target using bit manipulation.\"\"\"\n    def helper(nums, target, bitmask):\n        if target == 0:\n            return True\n        if target < 0 or bitmask == 0:\n            return False\n        for i, num in enumerate(nums):\n            if bitmask & (1 << i):\n                if helper(nums, target - num, bitmask ^ (1 << i)):\n                    return True\n        return False\n    bitmask = (1 << len(nums)) - 1\n    return helper(nums, target, bitmask)\ndef g(nums=[10, 5, 3], target=15):\n    return target\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of 1's in the binary representation of n.\"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n % 2 + f(n // 2)\n\ndef g():\n    return 27\n\nassert f(g()) == 4\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers, find the length of the longest subarray whose bitwise XOR of all elements is equal to the target value.\"\"\"\n    def backtrack(nums, target, curr_xor, start, curr_length, max_length):\n        if curr_xor == target:\n            max_length = max(max_length, curr_length)\n        if start == len(nums):\n            return max_length\n        max_length = backtrack(nums, target, curr_xor, start + 1, curr_length, max_length)\n        curr_xor ^= nums[start]\n        curr_length += 1\n        max_length = backtrack(nums, target, curr_xor, start + 1, curr_length, max_length)\n        return max_length\n    \n    return backtrack(nums, target, 0, 0, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return (nums, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if n is a palindrome in binary representation.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    binary = bin(n)[2:]\n    return is_palindrome(binary)\ndef g(n=9):\n    return n\nassert f(g())\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of unique ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g(n: int):\n    return n\n\nn = 5\nassert f(g(n)) == 8\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nimport math\ndef f(points: List[List[int]]) -> float:\n    \"\"\"Given a list of 2D points, find the minimum distance between any two points.\"\"\"\n    min_distance = math.inf\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            distance = math.sqrt((points[j][0] - points[i][0]) ** 2 + (points[j][1] - points[i][1]) ** 2)\n            min_distance = min(min_distance, distance)\n    return min_distance\ndef g():\n    \"\"\"Returns a list of 2D points.\"\"\"\n    return [[0, 0], [3, 4], [7, 6], [9, 8]]\nassert f(g()) == 2.8284271247461903\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from the top-left corner to the bottom-right corner of a grid.\n    You can only move down or right. The grid is represented as a matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])\n    return dp[rows-1][cols-1]\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, compute the number of set bits (bits with value 1) in its binary representation.\n    Return the count of set bits.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\ndef g(n: int) -> int:\n    \"\"\"\n    Return the positive integer n.\n    \"\"\"\n    return n\nassert f(g(23)) == 4\n",
        "idx_generation": 352,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a graph is connected using Breadth-First Search (BFS).\"\"\"\n    n = len(graph)\n    visited = [False] * n\n    queue = []\n    queue.append(0)\n    visited[0] = True\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if not visited[v]:\n                queue.append(v)\n                visited[v] = True\n    return all(visited)\ndef g(graph=[[1, 2], [0, 2], [0, 1, 3], [2]]):\n    return graph\nassert f(g())\n",
        "idx_generation": 95,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=4, path_length=3) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node\n    with a length equal to the given path_length.\n\n    Args:\n        graph: The graph represented as an adjacency list.\n        start: The starting node.\n        end: The ending node.\n        path_length: The required length of the path.\n\n    Returns:\n        True if a path exists with the given length, False otherwise.\n    \"\"\"\n    visited = set()\n    queue = [(start, 0)]\n    while queue:\n        node, length = queue.pop(0)\n        visited.add(node)\n        if node == end and length == path_length:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, length + 1))\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 4], [3]]\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid represented by a 2D list of integers, determine if there exists a path from the start point to the end point.\n    A path can only be formed by moving in four directions: up, down, left, and right. 0 represents an empty cell, and 1 represents an obstacle.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    queue = [(start[0], start[1])]\n    \n    while queue:\n        row, col = queue.pop(0)\n        \n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 1 or visited[row][col]:\n            continue\n        \n        visited[row][col] = True\n        \n        if (row, col) == end:\n            return True\n        \n        queue.append((row + 1, col))\n        queue.append((row - 1, col))\n        queue.append((row, col + 1))\n        queue.append((row, col - 1))\n    \n    return False\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0]], (0, 0), (4, 4)\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"Given an integer n and a grid of integers, determine if it is possible to reach from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1) by moving only downwards or rightwards.\n    Additionally, the sum of the numbers along the path must be maximized.\n    Return True if it is possible, False otherwise.\"\"\"\n    def dfs(i: int, j: int, total: int) -> bool:\n        if i == n-1 and j == n-1:\n            return True\n        if i >= n or j >= n:\n            return False\n        total += grid[i][j]\n        return dfs(i + 1, j, total) or dfs(i, j + 1, total)\n    \n    return dfs(0, 0, 0)\n\ndef g(n: int, grid: List[List[int]]):\n    return (n, grid)\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nn = 3\nassert f(*g(n, grid))\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(tree: Dict[str, List[str]], string: str) -> bool:\n    \"\"\"Check if the given string can be formed by traversing the tree from the root node to a leaf node.\"\"\"\n    def traverse(node: str, remaining: str) -> bool:\n        if not remaining:\n            return True\n        if node not in tree:\n            return False\n        for child in tree[node]:\n            if remaining.startswith(child):\n                if traverse(child, remaining[len(child):]):\n                    return True\n        return False\n    return traverse('root', string)\n\ndef g() -> Tuple[Dict[str, List[str]], str]:\n    tree = {\n        'root': ['a', 'b'],\n        'a': ['pp', 'le'],\n        'b': ['an', 'd'],\n        'pp': ['l', 'y'],\n        'an': ['o', 't'],\n        'l': ['e'],\n        'y': [],\n        'o': [],\n        't': [],\n        'le': [],\n        'd': [],\n    }\n    string = 'apple'\n    return tree, string\n\nassert f(*g())\n",
        "idx_generation": 73,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n\n    def is_empty(self):\n        return len(self.items) == 0\n\ndef f(n: int) -> int:\n    \"\"\"Generate the first n numbers in the Fibonacci sequence.\"\"\"\n    queue = Queue()\n    queue.enqueue(0)\n    queue.enqueue(1)\n    fib_sequence = []\n\n    while len(fib_sequence) < n:\n        current = queue.dequeue()\n        fib_sequence.append(current)\n        next_fib = current + queue.items[0]\n        queue.enqueue(next_fib)\n\n    return fib_sequence\n\ndef g():\n    return 7\n\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8]\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, determine the longest substring without repeating characters.\"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    longest_substring = \"\"\n    for end, char in enumerate(s):\n        if char in seen and start <= seen[char]:\n            start = seen[char] + 1\n        else:\n            if end - start + 1 > max_length:\n                max_length = end - start + 1\n                longest_substring = s[start:end+1]\n        seen[char] = end\n    return longest_substring\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == \"abc\"\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the number of unique combinations that add up to the target.\n    Args:\n        nums: A list of integers.\n        target: The target value.\n    Returns:\n        The number of unique combinations that add up to the target.\n    \"\"\"\n    nums.sort()\n    combinations = set()\n    \n    def backtrack(remain, current_combination, start):\n        if remain == 0:\n            combinations.add(tuple(current_combination))\n            return\n        elif remain < 0:\n            return\n        else:\n            for i in range(start, len(nums)):\n                current_combination.append(nums[i])\n                backtrack(remain - nums[i], current_combination, i)\n                current_combination.pop()\n    \n    backtrack(target, [], 0)\n    return len(combinations)\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers and a target value.\n    \"\"\"\n    return [2, 3, 6, 7], 7\n    \nassert f(*g()) == 2\n",
        "idx_generation": 270,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\ndef g(target=5):\n    return [1, 3, 5, 6, 8]\nassert f(g(), target=5) == 2\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: list) -> list:\n    \"\"\"Sort a list of integers using bubble sort.\"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef g(arr=[9, 5, 2, 7, 1, 3, 6, 8, 4, 10]):\n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n",
        "idx_generation": 36,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int, target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target sum, determine if there exists a subarray of length k\n    whose sum is equal to the target sum.\n    \"\"\"\n    stack = []\n    current_sum = 0\n    \n    for i in range(len(arr)):\n        stack.append(arr[i])\n        current_sum += arr[i]\n        \n        if len(stack) > k:\n            current_sum -= stack.pop(0)\n        \n        if current_sum == target and len(stack) == k:\n            return True\n    \n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], k=3, target=15):\n    return arr, k, target\n\nassert f(*g())\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, check if it forms a valid word search puzzle grid. A word search puzzle grid is valid if it satisfies the following conditions:\n1. Each row and column must contain at least one word (sequence of consecutive characters).\n2. Each word must be at least 3 characters long.\n3. Words can be formed horizontally, vertically, or diagonally (both forward and backward).\n4. The grid must be rectangular (same number of characters in each row and column).\n5. Words cannot overlap or share the same characters.\n6. All characters in a word must be contiguous (adjacent) in the grid.\"\"\"\n    def is_valid_word_search(grid):\n        n = len(grid)\n        m = len(grid[0])\n        for row in grid:\n            if len(row) < 3:\n                return False\n        for col in zip(*grid):\n            if len(col) < 3:\n                return False\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != '#':\n                    if i > 0 and grid[i - 1][j] != '#' or (i < n - 1 and grid[i + 1][j] != '#') or (j > 0 and grid[i][j - 1] != '#') or (j < m - 1 and grid[i][j + 1] != '#'):\n                        continue\n                    else:\n                        return False\n        return True\n    return is_valid_word_search(grid)\ndef g(grid=[['#', '#', '#', '#'], ['#', 'A', 'B', '#'], ['#', 'C', 'D', '#'], ['#', 'E', 'F', '#'], ['#', '#', '#', '#']]):\n    return grid\nassert f(g())\n",
        "idx_generation": 307,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Given a string s and a list of words, determine if s can be constructed by concatenating words from the list, without any characters left unused.\"\"\"\n    stack = []\n    while s:\n        found = False\n        for word in words:\n            if s.startswith(word):\n                stack.append(word)\n                s = s[len(word):]\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef g():\n    return ('leetcode', ['leet', 'code'])\n\nassert f(*g())\n",
        "idx_generation": 136,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Check if the target string can be formed by concatenating words in the given list.\n    \"\"\"\n    target_len = len(target)\n    word_lens = [len(word) for word in words]\n    dp = [False] * (target_len + 1)\n    dp[0] = True\n\n    for i in range(1, target_len + 1):\n        for word_len in word_lens:\n            if i >= word_len and dp[i - word_len] and target[i - word_len:i] in words:\n                dp[i] = True\n                break\n\n    return dp[-1]\n\ndef g(words: List[str], target: str):\n    return words\n\nwords = [\"apple\", \"banana\", \"orange\"]\ntarget = \"applebanana\"\n\nassert f(g(words, target), target)\n",
        "idx_generation": 182,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given array that sums up to the target value.\"\"\"\n    num_set = set()\n    for num in arr:\n        complement = target - num\n        if complement in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value between two numbers in the given list.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(30, -1, -1):\n        mask = mask | (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        \n        candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n    \n    return max_xor\n\ndef g(nums=[3, 10, 5, 25, 2, 8]):\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose sum is a perfect square.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) ** 0.5 == int((nums[i] + nums[j]) ** 0.5):\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g())\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int, target_sum: int, numbers: List[int]) -> int:\n    \"\"\"Find the minimum number of elements from the list that sums up to the target_sum.\"\"\"\n    def min_subset_sum(numbers, target_sum):\n        dp = [float('inf') for _ in range(target_sum + 1)]\n        dp[0] = 0\n        for i in range(1, target_sum + 1):\n            for num in numbers:\n                if num <= i:\n                    dp[i] = min(dp[i], dp[i - num] + 1)\n        return dp[target_sum]\n\n    return min_subset_sum(numbers, target_sum)\n\ndef g(n=5, target_sum=10):\n    numbers = [random.randint(1, 10) for _ in range(n)]\n    return (n, target_sum, numbers)\n\nassert f(*g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Given a sorted list of integers, find if there are two numbers that sum up to the target.\nReturn True if such pair exists, otherwise return False.\nSample Input:\nnums = [-2, 0, 2, 5, 8]\ntarget = 3\nSample Output:\nTrue\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[-2, 0, 2, 5, 8], target=3):\n    return sorted(nums)\nassert f(g())\n",
        "idx_generation": 226,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner.\n    You can only move down, right or diagonally.\n    Example:\n    Input:\n    matrix = [\n        [1, 0, 1],\n        [1, 1, 0],\n        [0, 1, 1]\n    ]\n    Output:\n    True\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] and matrix[i][0] == 1\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] and matrix[0][j] == 1\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 1:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i-1][j-1]\n    return dp[m-1][n-1]\ndef g():\n    return [[1, 0, 1], [1, 1, 0], [0, 1, 1]]\nassert f(g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the path from the top-left corner to the bottom-right corner with the maximum sum.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Rotate the given matrix 90 degrees clockwise.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated = [[0] * n for _ in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            rotated[j][n - i - 1] = matrix[i][j]\n\n    return rotated\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nmatrix = [[1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9]]\n\nexpected_result = [[7, 4, 1],\n                   [8, 5, 2],\n                   [9, 6, 3]]\n\nassert f(g(matrix)) == expected_result\n",
        "idx_generation": 182,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers and a target value, determine if there is a combination of numbers in the array that adds up to the target.\"\"\"\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        curr_sum, index = stack.pop()\n        if curr_sum == target:\n            return True\n        if index < len(arr):\n            stack.append((curr_sum + arr[index], index + 1))\n            stack.append((curr_sum, index + 1))\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix in which the sum of each row, each column, and both diagonals are the same.\n    Return True if the matrix is a magic square, False otherwise.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in matrix:\n            column_sum += row[col]\n        if column_sum != target_sum:\n            return False\n    # Check diagonal 1\n    diagonal_sum_1 = 0\n    for i in range(n):\n        diagonal_sum_1 += matrix[i][i]\n    if diagonal_sum_1 != target_sum:\n        return False\n    # Check diagonal 2\n    diagonal_sum_2 = 0\n    for i in range(n):\n        diagonal_sum_2 += matrix[i][n - i - 1]\n    if diagonal_sum_2 != target_sum:\n        return False\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=10) -> bool:\n    \"\"\"Check if a string is a palindrome after removing n characters.\"\"\"\n    stack = []\n    for char in s:\n        if len(stack) > 0 and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    \n    return len(stack) <= n\n\ndef g(n=10):\n    return 'radar'[:n] + 'madam'\n\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the binary representation of a number contains exactly k set bits.\"\"\"\n    binary = bin(n)[2:]\n    return binary.count('1') == k\ndef g(k: int):\n    return (2**k) - 1\nassert f(g(3), 3)\n",
        "idx_generation": 346,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a prime number.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return is_prime(n)\ndef g():\n    return 17\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n    \"\"\"\n    n = len(arr)\n    left_products = [1] * n\n    right_products = [1] * n\n    output = [1] * n\n    \n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * arr[i - 1]\n    \n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * arr[i + 1]\n    \n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n    \n    return output\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    num_set = set()\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g(nums=[4, 2, 7, 1, 3], target=10):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers nums and an integer k, return a new list where each element is the sum of the previous k elements in nums. For the first k elements, the sum will be the sum of all preceding elements.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * n\n    prefix_sum[0] = nums[0]\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i]\n    result = [0] * n\n    for i in range(n):\n        start = max(0, i - k + 1)\n        result[i] = prefix_sum[i] - prefix_sum[start - 1] if start > 0 else prefix_sum[i]\n    return result\ndef g(nums: List[int], k: int):\n    return (nums, k)\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nk = 3\nassert f(*g(nums, k)) == [1, 3, 6, 9, 12, 15, 18, 21, 24]\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of numbers, return the sum of all numbers in the grid when read in a zigzag pattern starting from the top-left corner.\n    The zigzag pattern should move from left to right, then right to left, and so on for each row.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    total_sum = 0\n    for i in range(rows):\n        if i % 2 == 0:\n            for j in range(cols):\n                total_sum += grid[i][j]\n        else:\n            for j in range(cols-1, -1, -1):\n                total_sum += grid[i][j]\n    \n    return total_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the list that sum up to the target and return their indices.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Reverse the given list using a stack.\"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    reversed_list = []\n    while stack:\n        reversed_list.append(stack.pop())\n    return reversed_list\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers and a target number, determine if it is possible to obtain the target number by adding or subtracting the numbers in the list. Each number in the list can be used exactly once.\"\"\"\n    stack = []\n    stack.append(0)\n    for num in numbers:\n        new_stack = []\n        for val in stack:\n            new_stack.append(val + num)\n            new_stack.append(val - num)\n        stack = new_stack\n    return target in stack\n\ndef g(numbers=[1, 2, 3, 4], target=10):\n    return (numbers, target)\n\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there exists a row or column that contains only 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows):\n        if all(num == 1 for num in grid[i]):\n            return True\n    \n    for j in range(cols):\n        if all(grid[i][j] == 1 for i in range(rows)):\n            return True\n    \n    return False\n\ndef g():\n    return [[0, 1, 0], [1, 1, 1], [0, 0, 1]]\n\nassert f(g())\n",
        "idx_generation": 4,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target number exists in the grid, where adjacent numbers can be connected horizontally or vertically.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                stack.append((i, j))\n    while stack:\n        (x, y) = stack.pop()\n        if grid[x][y] == target:\n            return True\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == target:\n                stack.append((new_x, new_y))\n    return False\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 5\n    return (grid, target)\n\nassert f(*g())\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of distinct paths from the top-left corner to the bottom-right corner of a grid (n x n).\nYou can only move down or right.\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"Given the dimensions of a grid and a list of integers representing the heights of each cell, determine if it is possible to reach the bottom-right corner from the top-left corner.\nThe grid is represented by a 2D list. You can only move rightwards or downwards on the grid. When moving to a cell, you must always choose a path that leads to a higher or equal height.\"\"\"\n    rows = n\n    cols = m\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        (x, y) = stack.pop()\n        if (x, y) == (rows - 1, cols - 1):\n            return True\n        visited.add((x, y))\n        curr_height = grid[x][y]\n        if x + 1 < rows and grid[x + 1][y] >= curr_height and (x + 1, y) not in visited:\n            stack.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] >= curr_height and (x, y + 1) not in visited:\n            stack.append((x, y + 1))\n    return False\ndef g(n=3, m=3, grid=[[1, 2, 3], [2, 3, 4], [3, 4, 5]]):\n    return (n, m, grid)\nassert f(*g()) == True\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses sequence. A valid parentheses sequence is defined as\n    having equal number of opening and closing parentheses, and the opening parentheses must come before the closing parentheses.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0 or stack[-1] != '(':\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g() -> str:\n    return '(())()()'\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"Check if the given string can be formed by concatenating any subset of the words in the list, in any order.\"\"\"\n    def backtrack(subset, index):\n        if ''.join(subset) == s:\n            return True\n        if index == len(strings):\n            return False\n        return backtrack(subset + [strings[index]], index + 1) or backtrack(subset, index + 1)\n    return backtrack([], 0)\ndef g(strings=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return ''.join(strings)\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n    Return True if it is a power of two, False otherwise.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n-1)) == 0\ndef g(n=16):\n    \"\"\"\n    Generate a positive integer n that is a power of two.\n    \"\"\"\n    return n\nassert f(g())\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int], target: int) -> bool:\n    \"\"\"Given two lists of integers nums1 and nums2, determine if it is possible to obtain the target number by performing bitwise AND between elements in nums1 and nums2. Each element in the lists can be used exactly once.\"\"\"\n    def backtrack(nums1, nums2, target, bitmask, idx):\n        if bitmask == (1 << len(nums1)) - 1:\n            return False\n        for i in range(len(nums1)):\n            if bitmask & (1 << i) == 0:\n                if (nums1[i] & nums2[idx]) == target:\n                    return True\n                if backtrack(nums1, nums2, target, bitmask | (1 << i), idx + 1):\n                    return True\n        return False\n    \n    return backtrack(nums1, nums2, target, 0, 0)\n\ndef g():\n    nums1 = [2, 3, 5]\n    nums2 = [7, 8, 9]\n    target = 1\n    return (nums1, nums2, target)\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a subset of the given list such that the bitwise XOR of all elements in the subset is equal to a target value.\"\"\"\n    def subset_xor(nums: List[int], target: int, index: int, current_xor: int) -> bool:\n        if current_xor == target:\n            return True\n        if index >= len(nums):\n            return False\n        return subset_xor(nums, target, index + 1, current_xor ^ nums[index]) or subset_xor(nums, target, index + 1, current_xor)\n    return subset_xor(nums, 0, 0, 0)\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5]\nassert f(g())\n",
        "idx_generation": 313,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a palindrome in binary representation.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g():\n    return 9\n\nassert f(g())\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, determine if it is a magic square. A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both diagonals are the same.\"\"\"\n    n = len(matrix)\n\n    # Calculate the sum of the first row\n    target_sum = sum(matrix[0])\n\n    # Check row sums\n    for i in range(1, n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Check column sums\n    for j in range(n):\n        if sum(matrix[i][j] for i in range(n)) != target_sum:\n            return False\n\n    # Check diagonal sums\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a magic square matrix.\"\"\"\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of moves required to reach the target cell from the starting cell in a grid.\n    You can only move rightwards or downwards and each cell contains a positive integer representing the cost of moving to that cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j])\n\n    return dp[m - 1][n - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 149,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of trailing zeros in its binary representation.\n    Return the count of trailing zeros.\"\"\"\n    count = 0\n    while n > 0 and n & 1 == 0:\n        count += 1\n        n >>= 1\n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Return the positive integer n.\n    \"\"\"\n    return n\n\nassert f(g(24)) == 3\n",
        "idx_generation": 363,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, value: int):\n        self.value = value\n        self.children = []\n\ndef f(nodes: List[Node]) -> bool:\n    \"\"\"Check if a given tree is a binary tree.\"\"\"\n    def is_binary(node: Node) -> bool:\n        if len(node.children) > 2:\n            return False\n        for child in node.children:\n            if not is_binary(child):\n                return False\n        return True\n\n    return is_binary(nodes[0]) if nodes else False\n\ndef g():\n    root = Node(1)\n    root.children = [Node(2), Node(3)]\n    root.children[0].children = [Node(4), Node(5)]\n    root.children[1].children = [Node(6)]\n    return [root]\n\nassert f(g()) == True\n",
        "idx_generation": 162,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=4) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node\n    using Depth First Search (DFS).\n\n    Args:\n        graph: The graph represented as an adjacency list.\n        start: The starting node.\n        end: The ending node.\n\n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 4], [3]]\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, return the number of islands in the grid.\n    A grid is said to have an island if there are adjacent 1s forming a connected landmass.\n    Two 1s are considered adjacent if they are horizontally or vertically neighboring.\n    Sample Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Sample Output:\n    3\"\"\"\n    def dfs(grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = 0\n        dfs(grid, row+1, col)\n        dfs(grid, row-1, col)\n        dfs(grid, row, col+1)\n        dfs(grid, row, col-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(grid, i, j)\n                \n    return count\n\ndef g():\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    \nassert f(g()) == 3\n",
        "idx_generation": 121,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, determine if there is a path that spells out the word \"PYTHON\".\n    You can move in any direction (up, down, left, right), but you can only visit each cell once.\n    Sample Input:\n    grid = [\n        ['P', 'Y', 'T', 'H'],\n        ['O', 'X', 'N', 'O'],\n        ['T', 'O', 'H', 'P'],\n        ['Y', 'O', 'N', 'X']\n    ]\n    Sample Output:\n    True\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    word = \"PYTHON\"\n    visited = set()\n\n    def dfs(row: int, col: int, idx: int) -> bool:\n        if idx == len(word):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return False\n        if grid[row][col] != word[idx] or (row, col) in visited:\n            return False\n        visited.add((row, col))\n        if dfs(row + 1, col, idx + 1) or dfs(row - 1, col, idx + 1) or dfs(row, col + 1, idx + 1) or dfs(row, col - 1, idx + 1):\n            return True\n        visited.remove((row, col))\n        return False\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(grid: List[List[str]]) -> List[List[str]]:\n    return grid\n\n# Example usage\ngrid = [\n    ['P', 'Y', 'T', 'H'],\n    ['O', 'X', 'N', 'O'],\n    ['T', 'O', 'H', 'P'],\n    ['Y', 'O', 'N', 'X']\n]\nassert f(g(grid))\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Find the longest word in a list of words that can be constructed by other words in the list.\n\n    Args:\n    - words: A list of strings.\n\n    Returns:\n    - A list of the longest words that can be constructed by other words in the list.\n    \"\"\"\n    word_set = set(words)\n    longest_words = []\n    for word in words:\n        word_set.remove(word)\n        if can_construct(word, word_set):\n            longest_words.append(word)\n        word_set.add(word)\n\n    return longest_words\n\ndef can_construct(word, word_set):\n    if not word:\n        return True\n\n    for i in range(1, len(word) + 1):\n        prefix = word[:i]\n        if prefix in word_set and can_construct(word[i:], word_set):\n            return True\n\n    return False\n\ndef g(words=[\"cat\", \"cats\", \"catsdogcats\", \"dog\", \"dogcatsdog\", \"hippopotamuses\", \"rat\", \"ratcatdogcat\"]):\n    return words\n\nassert f(g()) == [\"catsdogcats\", \"dogcatsdog\", \"ratcatdogcat\"]\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of unique combinations of k integers from the range 1 to n.\"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num-1)\n    \n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g(n=6, k=3):\n    return (n, k)\n\nassert f(*g()) == 20\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if a given number is divisible by all numbers from 1 to k (inclusive).\"\"\"\n    for i in range(1, k+1):\n        if n % i != 0:\n            return False\n    return True\n\ndef g(k: int) -> int:\n    \"\"\"Find the smallest positive number that is divisible by all numbers from 1 to k (inclusive).\"\"\"\n    num = 1\n    while True:\n        if f(num, k):\n            return num\n        num += 1\n\nassert f(g(k=10), k=10)\n",
        "idx_generation": 287,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, determine if there are two numbers in the list that sum up to the target.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        if arr[low] + arr[high] == target:\n            return True\n        elif arr[low] + arr[high] < target:\n            low += 1\n        else:\n            high -= 1\n    return False\ndef g(target=10):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 343,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-increasing order using the insertion sort algorithm.\"\"\"\n    for i in range(1, len(nums)):\n        key = nums[i]\n        j = i - 1\n        while j >= 0 and nums[j] < key:\n            nums[j + 1] = nums[j]\n            j -= 1\n        nums[j + 1] = key\n    return nums\n\ndef g(nums=[5, 8, 2, 1, 6]):\n    return nums\n\nassert f(g()) == [8, 6, 5, 2, 1]\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to the target number.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers from the list that add up to the target number.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return [arr[left], arr[right]]\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\narr = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(arr, target), target)\n",
        "idx_generation": 162,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Find if the target number is present in the grid. The grid is a 2D list of integers where each row and column is sorted in non-decreasing order.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g(grid=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return (grid, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a valid parenthesis sequence.\"\"\"\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return len(stack) == 0\ndef g():\n    return \"()()()\"\nassert f(g())\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if the target word can be formed by concatenating two or more words from the list.\n    The words can be used in any order and can be repeated.\"\"\"\n    def helper(word):\n        if word == target:\n            return True\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in words and helper(suffix):\n                return True\n        return False\n    return helper(target)\n\ndef g():\n    words = [\"hello\", \"world\", \"python\", \"programming\"]\n    target = \"helloworld\"\n    return (words, target)\n\nassert f(*g())\n",
        "idx_generation": 192,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there exists a pair of numbers in the list whose XOR is equal to the target number.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\ndef g(nums=[3, 5, 2, 8, 6, 9], target=10):\n    return nums\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    sum_diagonal1 = sum(matrix[i][i] for i in range(n))\n    sum_diagonal2 = sum(matrix[i][n-i-1] for i in range(n))\n    if sum_diagonal1 != sum_diagonal2:\n        return False\n    for i in range(n):\n        if sum(matrix[i]) != sum_diagonal1:\n            return False\n        if sum(matrix[j][i] for j in range(n)) != sum_diagonal1:\n            return False\n    return True\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 136,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=13, k=3) -> bool:\n    \"\"\"Check if there exists k elements in nums that add up to target\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - k + 1):\n        if dfs(nums, target, i, k):\n            return True\n    return False\n\ndef dfs(nums, target, start, k):\n    if k == 0:\n        return target == 0\n    n = len(nums)\n    for i in range(start, n - k + 1):\n        if i > start and nums[i] == nums[i - 1]:\n            continue\n        if nums[i] > target:\n            break\n        if dfs(nums, target - nums[i], i + 1, k - 1):\n            return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in the sorted list of numbers using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g(nums: List[int], target: int) -> List[int]:\n    sorted_nums = sorted(nums)\n    return (sorted_nums, target)\nnums = [4, 2, 7, 1, 5]\ntarget = 7\nassert f(*g(nums, target)) == 4\n",
        "idx_generation": 273,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(coordinates: List[Tuple[int, int]], target_distance=5) -> bool:\n    \"\"\"Determine if there exists a pair of coordinates that are exactly target_distance apart\"\"\"\n    for i in range(len(coordinates)):\n        for j in range(i+1, len(coordinates)):\n            x1, y1 = coordinates[i]\n            x2, y2 = coordinates[j]\n            distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n            if distance == target_distance:\n                return True\n    return False\n\ndef g():\n    return [(0, 0), (3, 4), (6, 8), (9, 12), (15, 20)]\n\nassert f(g())\n",
        "idx_generation": 223,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the length of the longest increasing path. A path is considered increasing if each number\n    in the path is greater than the previous number. The path can move horizontally or vertically, but not diagonally.\"\"\"\n    def dfs(i, j, grid, memo):\n        if memo[i][j] != 0:\n            return memo[i][j]\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_path = 1\n        \n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n            if ni >= 0 and ni < len(grid) and nj >= 0 and nj < len(grid[0]) and grid[ni][nj] > grid[i][j]:\n                max_path = max(max_path, 1 + dfs(ni, nj, grid, memo))\n        \n        memo[i][j] = max_path\n        return max_path\n    \n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    memo = [[0] * n for _ in range(m)]\n    \n    max_path = 0\n    \n    for i in range(m):\n        for j in range(n):\n            max_path = max(max_path, dfs(i, j, grid, memo))\n    \n    return max_path\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\ngrid = [\n    [9, 9, 4],\n    [6, 6, 8],\n    [2, 1, 1]\n]\n\nassert f(g(grid)) == 4\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum size of a square subgrid that contains only 1s.\n    Return the area of the largest square subgrid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_side = 0\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    return max_side * max_side\n\ndef g():\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than n that are divisible by either 3 or 5.\"\"\"\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result\n\ndef g():\n    return 100\n\nassert f(g()) == 2318\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a magic square. A magic square is a square grid of numbers where the sum of each row,\n    each column, and both diagonals is the same.\n    Sample Input:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    Sample Output:\n    True\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonal 1\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n    \n    # Check diagonal 2\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n - i - 1]\n    if diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    return [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\nassert f(g())\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all duplicates removed while maintaining the original order of the elements.\"\"\"\n    seen = set()\n    unique_nums = []\n    for num in nums:\n        if num not in seen:\n            unique_nums.append(num)\n            seen.add(num)\n    return unique_nums\n\ndef g(nums=[1, 2, 2, 3, 4, 4, 5, 5]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if n is a power of 2.\"\"\"\n    return n & (n - 1) == 0 and n != 0\ndef g(n: int):\n    return n\nassert f(g(16), 16)\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given an array of integers, determine if it can be divided into two subsets with equal sum.\n    Return True if it is possible, otherwise False.\"\"\"\n    def can_partition(nums, curr_sum, index, target_sum, memo):\n        if curr_sum == target_sum:\n            return True\n        if index == len(nums) or curr_sum > target_sum:\n            return False\n        if (curr_sum, index) in memo:\n            return memo[(curr_sum, index)]\n        \n        if can_partition(nums, curr_sum + nums[index], index + 1, target_sum, memo) or can_partition(nums, curr_sum, index + 1, target_sum, memo):\n            memo[(curr_sum, index)] = True\n            return True\n        \n        memo[(curr_sum, index)] = False\n        return False\n    \n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    memo = {}\n    return can_partition(nums, 0, 0, target_sum, memo)\n\ndef g():\n    return [1, 5, 11, 5]\nassert f(g())\n",
        "idx_generation": 41,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    return ' '.join(s.split()[::-1])\n\ndef g():\n    return \"Hello World!\"\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner. You can only\n    move down or right. The grid is represented as a list of lists of integers.\n    \n    Example:\n    [[1, 3, 1],\n     [1, 5, 1],\n     [4, 2, 1]]\n     \n    In this example, the shortest path is 1 -> 3 -> 1 -> 1 -> 1 with a total sum of 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    # Check if all rows have the same sum\n    row_sum = sum(matrix[0])\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n    \n    # Check if all columns have the same sum\n    col_sum = sum(matrix[i][0] for i in range(len(matrix)))\n    for j in range(len(matrix[0])):\n        if sum(matrix[i][j] for i in range(len(matrix))) != col_sum:\n            return False\n    \n    # Check if the two diagonals have the same sum\n    diagonal1_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    diagonal2_sum = sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix)))\n    if diagonal1_sum != row_sum or diagonal2_sum != row_sum:\n        return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a square matrix, determine if it is a magic square. A magic square is one where the sum of every row, column, and diagonal is the same.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    # Check rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the input matrix.\"\"\"\n    return matrix\n\nassert f(g([[2, 7, 6], [9, 5, 1], [4, 3, 8]]))\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(brackets: str) -> bool:\n    \"\"\"Given a string containing brackets (parentheses, square brackets, and curly brackets), determine if the brackets are balanced.\nAn expression is considered balanced if each opening bracket has a corresponding closing bracket and they are properly nested.\nSample Input:\nbrackets = \"{[()()]}\"\nSample Output:\nTrue\"\"\"\n    stack = []\n    opening_brackets = \"([{\"\n    closing_brackets = \")]}\"\n    for char in brackets:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or not is_matching(stack[-1], char):\n                return False\n            stack.pop()\n    return not stack\n\ndef is_matching(opening_bracket: str, closing_bracket: str) -> bool:\n    if opening_bracket == \"(\" and closing_bracket == \")\":\n        return True\n    elif opening_bracket == \"[\" and closing_bracket == \"]\":\n        return True\n    elif opening_bracket == \"{\" and closing_bracket == \"}\":\n        return True\n    else:\n        return False\n\ndef g(brackets: str) -> str:\n    stack = []\n    opening_brackets = \"([{\"\n    closing_brackets = \")]}\"\n    for char in brackets:\n        if char in opening_brackets or char in closing_brackets:\n            stack.append(char)\n    return ''.join(stack)\nassert f(g(\"{[()()]}\"))\n",
        "idx_generation": 38,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers nums, return a new list where each element is the sum of the previous two elements in nums. Assume the first two elements are always 0 and 1.\"\"\"\n    n = len(nums)\n    result = [0] * n\n    result[0] = nums[0]\n    result[1] = nums[1]\n    for i in range(2, n):\n        result[i] = nums[i-1] + nums[i-2]\n    return result\ndef g(nums=[0, 1, 1, 2, 3, 5, 8]):\n    return (nums,)\nassert f(*g()) == [0, 1, 1, 2, 3, 5, 8]\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, grid: List[List[int]]) -> bool:\n    \"\"\"Determine if a string follows a specific path on a grid.\n\n    The string must follow the path specified by the grid, where 0 represents a move to the right and 1 represents a move down. The string must also end at the bottom-right corner of the grid.\n    \"\"\"\n    i, j = 0, 0\n    for move in s:\n        if move == '0':\n            j += 1\n        elif move == '1':\n            i += 1\n        if i >= len(grid) or j >= len(grid[0]):\n            return False\n        if grid[i][j] != 1:\n            return False\n    return i == len(grid) - 1 and j == len(grid[0]) - 1\n\ndef g(grid: List[List[int]]) -> str:\n    \"\"\"Generate a string that follows a specific path on the grid.\n\n    The generated string will follow the path specified by the grid, where 0 represents a move to the right and 1 represents a move down. The string will end at the bottom-right corner of the grid.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    path = ''\n    i, j = 0, 0\n    while i != m - 1 or j != n - 1:\n        if i != m - 1 and grid[i + 1][j] == 1:\n            path += '1'\n            i += 1\n        else:\n            path += '0'\n            j += 1\n    return path\n\ngrid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\nassert f(g(grid), grid)\n",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a 2D grid of integers, rotate the grid by 90 degrees clockwise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    rotated_grid = [[0] * rows for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_grid[j][rows - 1 - i] = grid[i][j]\n    \n    return rotated_grid\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[List[int]]) -> int:\n    \"\"\"Given a grid represented by a 2D list, find the maximum sum of numbers\n    in a path from the top-left corner to the bottom-right corner. You can only\n    move down or right.\"\"\"\n    rows = len(arr)\n    cols = len(arr[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = arr[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + arr[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + arr[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + arr[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 3, 2], [2, 1, 4], [5, 6, 1]]\n    return grid\n\nassert f(g()) == 15\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a grid of characters and a word, determine if the word can be formed by traversing the grid horizontally or\n    vertically, one character at a time, without reusing any characters. The word can start at any position in the grid\n    and can move in any direction (horizontal or vertical).\n\n    Example:\n    grid = [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n    word = 'ABC'\n    In this example, the grid has characters arranged in a 3x3 matrix. The word 'ABC' can be formed by starting at\n    position (0, 0) and moving right to (0, 1), and then down to (1, 1). The function should return True.\n\n    Note: The word can be formed by moving horizontally or vertically, but not diagonally.\n\n    :param grid: A grid of characters represented as a 2D list\n    :param word: The word to check if it can be formed in the grid\n    :return: True if the word can be formed, False otherwise\n    \"\"\"\n    def dfs(row, col, visited, word_idx):\n        if word_idx == len(word):\n            return True\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or (row, col) in visited or grid[row][col] != word[word_idx]:\n            return False\n\n        visited.add((row, col))\n\n        if dfs(row + 1, col, visited, word_idx + 1) or dfs(row - 1, col, visited, word_idx + 1) or dfs(row, col + 1, visited, word_idx + 1) or dfs(row, col - 1, visited, word_idx + 1):\n            return True\n\n        visited.remove((row, col))\n\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, set(), 0):\n                return True\n\n    return False\n\ndef g():\n    return ([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], 'ABC')\n\nassert f(*g())\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(string: str) -> str:\n    \"\"\"Reverse the given string using a stack\"\"\"\n    stack = list(string)\n    reverse_string = ''\n    while stack:\n        reverse_string += stack.pop()\n    return reverse_string\ndef g():\n    return 'hello'\nassert f(g()) == 'olleh'\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing at most one character from it.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    if is_palindrome(s):\n        return True\n    \n    n = len(s)\n    for i in range(n):\n        temp = s[:i] + s[i+1:]\n        if is_palindrome(temp):\n            return True\n    return False\n\ndef g(s: str) -> str:\n    \"\"\"\n    Generate a string s that is a palindrome after removing at most one character from it.\n    \"\"\"\n    return s[:len(s)//2] + s[len(s)//2+1:]\n\ns = \"racecar\"\nassert f(g(s))\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subsequence of the list where the sum of all elements\n    is divisible by 3, otherwise return False.\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: True\n    Explanation: The subsequence [2, 3, 4] has a sum of 9 which is divisible by 3.\n    \"\"\"\n    n = len(nums)\n\n    # Generate all possible subsequences\n    subsets = []\n    for i in range(1, 2**n):\n        subset = [nums[j] for j in range(n) if (i & (1 << j))]\n        subsets.append(subset)\n\n    # Check if any subsequence has a sum divisible by 3\n    for subset in subsets:\n        if sum(subset) % 3 == 0:\n            return True\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 26,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two integers n and m, find the maximum value of n ^ m, where ^ represents the bitwise XOR operation.\"\"\"\n    max_value = 0\n    for i in range(n, m+1):\n        for j in range(n, m+1):\n            max_value = max(max_value, i ^ j)\n    return max_value\ndef g(n: int, m: int):\n    return (n, m)\nassert f(*g(n=5, m=10)) == 15\n",
        "idx_generation": 202,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list\n    such that the bitwise XOR of all the elements in the subset is equal to the target number.\"\"\"\n    def helper(nums, target, curr_xor, index):\n        if curr_xor == target:\n            return True\n        if index >= len(nums):\n            return False\n        return helper(nums, target, curr_xor, index + 1) or helper(nums, target, curr_xor ^ nums[index], index + 1)\n    \n    return helper(nums, target, 0, 0)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums, target\n\nnums = [2, 4, 6, 8]\ntarget = 10\nassert f(*g(nums, target))\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int, k: int) -> bool:\n    \"\"\"Check if the binary representation of n contains at least k consecutive 1s.\"\"\"\n    binary = bin(n)[2:]\n    return '1' * k in binary\ndef g(n: int, k: int):\n    return '1' * k\nassert f(g(15, 3), 15, 3)\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb to the top of a staircase of n steps.\n- n is a positive integer\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\ndef g(n=5):\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer 'n', return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g():\n    return 7\n\nassert f(g()) == 13\n",
        "idx_generation": 430,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\ndef g(grid: List[List[int]]):\n    return grid\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid)) == 7\n",
        "idx_generation": 202,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, a=5, b=10) -> bool:\n    \"\"\"Check if a given number is a power of 2 and within a specific range.\"\"\"\n    def is_power_of_two(num):\n        return num != 0 and (num & (num - 1)) == 0\n    def is_within_range(num):\n        return a <= num <= b\n    return is_power_of_two(n) and is_within_range(n)\n\ndef g(a=5, b=10):\n    num = 8\n    return num\n\nassert f(g())\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a cycle in a directed graph represented by adjacency list.\"\"\"\n    stack = []\n    visited = set()\n    for start in range(len(nums)):\n        if start not in visited:\n            stack.append(start)\n            while stack:\n                node = stack.pop()\n                if node in visited:\n                    return True\n                visited.add(node)\n                for neighbor in nums[node]:\n                    stack.append(neighbor)\n    return False\n\ndef g():\n    return [[1, 2], [2], [0, 3], []]\n\nassert f(g())\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, check if there is a path from the start node to the end node.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return True\n\n        if node not in visited:\n            visited.add(node)\n\n            if node in graph:\n                stack.extend(graph[node])\n\n    return False\n\ndef g(graph: Dict[str, List[str]], start: str, end: str):\n    return graph, start, end\n\nassert f(*g({\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"E\"], \"D\": [\"F\"], \"E\": [\"G\"], \"F\": [\"E\"], \"G\": []}, \"A\", \"G\"))\n",
        "idx_generation": 11,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \ndef f(root: TreeNode) -> bool:\n    \"\"\"Check if a binary tree is symmetric.\"\"\"\n    def is_symmetric(left: TreeNode, right: TreeNode) -> bool:\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        return is_symmetric(left.left, right.right) and is_symmetric(left.right, right.left)\n    \n    if not root:\n        return True\n    return is_symmetric(root.left, root.right)\n\ndef g() -> TreeNode:\n    \"\"\"Generate a symmetric binary tree.\"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n    return root\n\nassert f(g())\n",
        "idx_generation": 17,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of size m x n containing 0's and 1's, find the number of distinct islands.\n    An island is considered to be the same if and only if one island can be translated (and not rotated or reflected) to equal the other.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    def dfs(row, col, direction):\n        if row < 0 or row >= m or col < 0 or col >= n or grid[row][col] <= 0:\n            return \"\"\n        \n        grid[row][col] *= -1\n        island = direction + dfs(row + 1, col, \"D\") + dfs(row - 1, col, \"U\") + dfs(row, col + 1, \"R\") + dfs(row, col - 1, \"L\")\n        return island\n    \n    islands = set()\n    \n    for row in range(m):\n        for col in range(n):\n            if grid[row][col] == 1:\n                island = dfs(row, col, \"S\")\n                islands.add(island)\n    \n    return len(islands)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n\nassert f(g()) == 1\n",
        "idx_generation": 140,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of lowercase letters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n    \"\"\"\n    if not grid:\n        return False\n    \n    rows, cols = len(grid), len(grid[0])\n    word_length = len(word)\n\n    def dfs(row: int, col: int, index: int) -> bool:\n        if index == word_length:\n            return True\n        \n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != word[index]:\n            return False\n        \n        temp = grid[row][col]\n        grid[row][col] = '#'\n\n        found = dfs(row - 1, col, index + 1) \\\n                or dfs(row + 1, col, index + 1) \\\n                or dfs(row, col - 1, index + 1) \\\n                or dfs(row, col + 1, index + 1)\n\n        grid[row][col] = temp\n        return found\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == word[0]:\n                if dfs(i, j, 0):\n                    return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Returns the 2D grid and the word 'ABCCED':\n        [\n            ['A', 'B', 'C', 'E'],\n            ['S', 'F', 'C', 'S'],\n            ['A', 'D', 'E', 'E']\n        ]\n    \"\"\"\n    return [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\nword = 'ABCCED'\nassert f(g()) is True\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, s: str) -> bool:\n    \"\"\"Given a string s consisting of lowercase English letters, determine if it is possible to create k distinct palindromes of length n using the characters of s.\n    Return True if it is possible, otherwise False.\"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    def backtrack(curr_palindromes, remaining_chars):\n        if len(curr_palindromes) == k:\n            return True\n        \n        for i in range(len(remaining_chars)):\n            curr_char = remaining_chars[i]\n            new_remaining_chars = remaining_chars[:i] + remaining_chars[i+1:]\n            for j in range(len(curr_palindromes)):\n                curr_palindrome = curr_palindromes[j]\n                if is_palindrome(curr_palindrome + curr_char):\n                    curr_palindromes[j] += curr_char\n                    if backtrack(curr_palindromes, new_remaining_chars):\n                        return True\n                    curr_palindromes[j] = curr_palindrome\n            if len(curr_palindromes) < k and is_palindrome(curr_char):\n                curr_palindromes.append(curr_char)\n                if backtrack(curr_palindromes, new_remaining_chars):\n                    return True\n                curr_palindromes.pop()\n        \n        return False\n    \n    return backtrack([], s)\n\ndef g(n=2, k=3, s=\"aabbb\"):\n    return n, k, s\n\nassert f(*g())\n",
        "idx_generation": 390,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import comb\n\ndef f(n: int) -> int:\n    \"\"\"Calculate the sum of the binomial coefficients for all k from 0 to n\"\"\"\n    return sum(comb(n, k) for k in range(n+1))\n\ndef g():\n    return 5\n\nassert f(g()) == 32\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if it is possible to partition the list into two subsets such that the sum of elements in each subset is equal to the target.\"\"\"\n    def can_partition(nums, target, curr_sum, start, visited):\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if not visited[i]:\n                visited[i] = True\n                if can_partition(nums, target, curr_sum + nums[i], i + 1, visited):\n                    return True\n                visited[i] = False\n        return False\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target = total_sum // 2\n    visited = [False] * len(nums)\n    return can_partition(nums, target, 0, 0, visited)\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\nnums = [1, 5, 11, 5]\ntarget = 11\nassert f(g(nums, target), target) == True\n",
        "idx_generation": 339,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a contiguous subarray in the given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the maximum difference between any two elements in the list.\"\"\"\n    max_diff = 0\n    stack = [nums[0]]\n    for num in nums[1:]:\n        while stack and num > stack[-1]:\n            max_diff = max(max_diff, num - stack[-1])\n            stack.pop()\n        stack.append(num)\n    return max_diff\n\ndef g(nums=[5, 2, 7, 1, 4]):\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string has balanced parentheses.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g(s=\"((()))\"):\n    return (s,)\nassert f(*g())\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate the given matrix 90 degrees clockwise.\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            result[j][n - 1 - i] = matrix[i][j]\n    return result\n\ndef g():\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]],)\n\nassert f(*g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target value.\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target ^ num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums: List[int] = [3, 4, 5, 6, 7, 8], target: int = 11):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that sums up to the target.\"\"\"\n    n = len(nums)\n    \n    def subsetSum(idx: int, currSum: int) -> bool:\n        if currSum == target:\n            return True\n        if idx >= n or currSum > target:\n            return False\n        return subsetSum(idx + 1, currSum + nums[idx]) or subsetSum(idx + 1, currSum)\n    \n    return subsetSum(0, 0)\n\ndef g():\n    nums = [1, 5, 11, 6]\n    target = 17\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if the given list is a power of 2.\"\"\"\n    nums.sort()\n    return nums[-1] & (nums[-1] - 1) == 0\ndef g():\n    return [1, 2, 4, 8, 16]\nassert f(g()) == True\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three numbers in the given list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g()) == 210\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"Find the area of a polygon given its vertices coordinates.\"\"\"\n    n = len(points)\n    area = 0\n\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i+1) % n]\n        area += (x1 * y2) - (x2 * y1)\n\n    return abs(area) / 2\n\ndef g(points: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return a list of points representing the vertices of a polygon.\"\"\"\n    return points\n\nassert f(g([[0, 0], [0, 4], [4, 4], [4, 0]])) == 16.0\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]], k: int) -> bool:\n    \"\"\"Check if it is possible to form a convex polygon using k points from the given set of points. Return True if possible, False otherwise.\"\"\"\n    if k < 3 or k > len(points):\n        return False\n    \n    # Sort points based on x-coordinate\n    sorted_points = sorted(points, key=lambda x: x[0])\n    \n    # Check if the first k points form a convex polygon\n    return check_convex(sorted_points[:k])\n\ndef check_convex(points: List[List[int]]) -> bool:\n    n = len(points)\n    if n < 3:\n        return False\n    \n    # Calculate cross product of adjacent edges\n    cross_product = []\n    for i in range(n-2):\n        x1, y1 = points[i]\n        x2, y2 = points[i+1]\n        x3, y3 = points[i+2]\n        cross_product.append((x2-x1)*(y3-y2) - (x3-x2)*(y2-y1))\n    \n    # Check if all cross products have the same sign\n    return all(cross_product[i] * cross_product[i+1] >= 0 for i in range(len(cross_product)-1))\n\ndef g(points: List[List[int]], k: int):\n    return points\n\npoints = [[0, 0], [1, 0], [1, 1], [0, 1], [0.5, 0.5]]\nk = 4\nassert f(g(points, k), k)\n",
        "idx_generation": 273,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if a given list of integers can be rearranged to form a binary search tree.\"\"\"\n    def is_bst(nums: List[int], low: int, high: int) -> bool:\n        if low >= high:\n            return True\n        root = nums[low]\n        i = low + 1\n        while i <= high and nums[i] < root:\n            i += 1\n        j = i\n        while j <= high and nums[j] > root:\n            j += 1\n        if j <= high:\n            return False\n        left = is_bst(nums, low + 1, i - 1)\n        right = is_bst(nums, i, high)\n        return left and right\n    \n    nums.sort()\n    return is_bst(nums, 0, len(nums) - 1)\n\ndef g():\n    return [4, 2, 7, 1, 3]\n\nassert f(g())\n",
        "idx_generation": 233,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a grid of 0s and 1s, convert all 0s that are surrounded by 1s into 1s.\"\"\"\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    queue = []\n    \n    def bfs(i, j):\n        queue.append((i, j))\n        visited.add((i, j))\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n                    visited.add((nx, ny))\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                if grid[i][j] == 0 and (i, j) not in visited:\n                    bfs(i, j)\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0 and (i, j) not in visited:\n                grid[i][j] = 1\n    \n    return grid\ndef g():\n    return [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 1, 1], [1, 1, 1, 1]]\nassert f(g()) == [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, check if it is possible to form a word by following a specific path in the grid.\n    You can only move to adjacent cells (up, down, left, or right) and each cell can only be visited once.\n    Return True if a word can be formed, False otherwise.\"\"\"\n    def dfs(i, j, word, visited):\n        if len(word) == 0:\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or (i, j) in visited:\n            return False\n        if grid[i][j] != word[0]:\n            return False\n        visited.add((i, j))\n        if dfs(i - 1, j, word[1:], visited) or dfs(i + 1, j, word[1:], visited) or dfs(i, j - 1, word[1:], visited) or dfs(i, j + 1, word[1:], visited):\n            return True\n        visited.remove((i, j))\n        return False\n\n    words = [\"PYTHON\", \"PROGRAMMING\", \"PUZZLE\"]\n    for word in words:\n        visited = set()\n        if dfs(0, 0, word, visited):\n            return True\n    return False\n\ndef g(grid=[['P', 'Y', 'T', 'H', 'O', 'N'],\n           ['R', 'X', 'X', 'X', 'X', 'I'],\n           ['O', 'X', 'G', 'R', 'A', 'M'],\n           ['G', 'X', 'X', 'X', 'X', 'M'],\n           ['R', 'X', 'X', 'X', 'X', 'I'],\n           ['A', 'P', 'U', 'Z', 'Z', 'L'],\n           ['M', 'X', 'X', 'X', 'X', 'E']]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 375,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target_sum=42) -> bool:\n    \"\"\"Find a combination of numbers from a list that adds up to the target sum.\"\"\"\n    def backtrack(nums, target_sum, current_sum, index):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(nums):\n            return False\n        if backtrack(nums, target_sum, current_sum + nums[index], index + 1):\n            return True\n        if backtrack(nums, target_sum, current_sum, index + 1):\n            return True\n        return False\n    \n    return backtrack(nums, target_sum, 0, 0)\n\ndef g(target_sum=42):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nassert f(g())\n",
        "idx_generation": 139,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a 2D grid of integers, determine if the grid is a magic square. A magic square is a square grid where the sums of each row, each column, and each diagonal are all equal.\"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for j in range(n):\n        if sum(grid[i][j] for i in range(n)) != target_sum:\n            return False\n    # Check diagonals\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n    return True\ndef g(grid=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return grid\nassert f(g()) == True\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers and an integer k, determine if there exists a subarray with length k that has\n    all unique elements.\"\"\"\n    subarrays = [arr[i:i+k] for i in range(len(arr)-k+1)]\n    return any(len(set(subarray)) == k for subarray in subarrays)\n\ndef g(k=3):\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 18,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of numbers in the given list whose XOR is equal to the target.\n    The subset can contain any number of elements.\"\"\"\n    n = len(nums)\n    total = 1 << n\n\n    for i in range(total):\n        xor = 0\n        for j in range(n):\n            if i & (1 << j):\n                xor ^= nums[j]\n        if xor == target:\n            return True\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of trailing zeros in n!\"\"\"\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 6\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer 'n', determine if it is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, determine whether there exists a subarray with a sum equal to 0.\n    Return True if such subarray exists, False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in sum_set:\n            return True\n        sum_set.add(prefix_sum)\n    return False\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\nassert f(g([4, -6, 2, 1, -4, 5, -5, 2])) == True\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers in the list that add up to the target.\nReturn the indices of the two numbers as a list.\"\"\"\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n    return []\ndef g():\n    return ([2, 7, 11, 15], 9)\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, find the maximum sum that can be obtained by moving from the top-left cell to the bottom-right cell.\n    You can only move down or right. Return True if the maximum sum is greater than 0, otherwise return False.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1] > 0\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g())\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to climb n stairs by taking either 1 or 2 steps at a time.\"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return f(n-1) + f(n-2)\ndef g():\n    return 5\nassert f(g()) == 8\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, check if it is a valid parentheses string. A valid parentheses string is either empty (\"\"), \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g():\n    return '(()())'\nassert f(g())\n",
        "idx_generation": 54,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid, find the maximum sum of numbers that can be obtained by traversing from top-left to bottom-right following certain rules.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 166,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]], k: int) -> bool:\n    \"\"\"\n    Given a list of 2D points, determine if there exists a circle with a radius k that contains all the points inside it.\n    \"\"\"\n    center_x = sum(point[0] for point in points) / len(points)\n    center_y = sum(point[1] for point in points) / len(points)\n    \n    for point in points:\n        distance = ((point[0] - center_x) ** 2 + (point[1] - center_y) ** 2) ** 0.5\n        if distance > k:\n            return False\n            \n    return True\n\ndef g(points: List[List[int]], k: int) -> None:\n    \"\"\"\n    Generate a list of 2D points and the radius k for the circle.\n    \"\"\"\n    return points, k\n\npoints = [[1, 1], [2, 2], [3, 3], [4, 4]]\nk = 5\nassert f(*g(points, k))\n",
        "idx_generation": 60,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of moves required to reach the destination cell (denoted by 9) from the start cell (denoted by 1) in a grid.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = [(0, 0, 0)]\n    visited = set()\n    while queue:\n        x, y, moves = queue.pop(0)\n        if grid[x][y] == 9:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != 0:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return -1\n\ndef g():\n    return [[1, 1, 1, 0], [0, 1, 1, 0], [0, 1, 0, 1], [1, 1, 9, 1]]\n    \nassert f(g()) == 5\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], k=2, target=5) -> bool:\n    \"\"\"Given a grid of integers, find a path of length k that maximizes the sum of elements. The path can only move\ndownwards or to the right. Return True if the sum is greater than or equal to the target sum, otherwise return False.\nSample Input:\ngrid = [[1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]]\nk = 2\ntarget = 5\nSample Output:\nTrue\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = float('-inf')\n    def dfs(i, j, path):\n        nonlocal max_sum\n        path.append(grid[i][j])\n        if len(path) == k:\n            max_sum = max(max_sum, sum(path))\n            return\n        if i + 1 < rows:\n            dfs(i + 1, j, path)\n        if j + 1 < cols:\n            dfs(i, j + 1, path)\n        path.pop()\n    dfs(0, 0, [])\n    return max_sum >= target\n\ndef g(grid=[[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]], k=2, target=5):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid represented as a 2D list, determine if there exists a path from the top-left corner to the bottom-right corner.\nArgs:\n    grid: The grid represented as a 2D list where 0 represents an empty space and 1 represents an obstacle.\nReturns:\n    True if a path exists, False otherwise.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    return dfs(grid, 0, 0, rows, cols)\n\ndef dfs(grid, row, col, rows, cols):\n    if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] == 1:\n        return False\n    if row == rows-1 and col == cols-1:\n        return True\n    grid[row][col] = 1\n    return dfs(grid, row+1, col, rows, cols) or dfs(grid, row, col+1, rows, cols)\n\ndef g():\n    \"\"\"\n    Returns a sample grid represented as a 2D list.\n    \"\"\"\n    return [[0, 0, 0, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0]]\nassert f(g())\n",
        "idx_generation": 325,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string.\"\"\"\n    words = s.split()\n    reverse_words = deque(words)\n    reverse_words.reverse()\n    return ' '.join(reverse_words)\n\ndef g():\n    return ('Hello World',)\n\nassert f(g()[0]) == 'World Hello'\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is a substring of s. Returns True if t is a substring of s, False otherwise.\n    \"\"\"\n    if len(t) > len(s):\n        return False\n    elif t == '':\n        return True\n    elif s == '':\n        return False\n    elif s[0] == t[0] and f(s[1:], t[1:]):\n        return True\n    else:\n        return f(s[1:], t)\n\ndef g():\n    s = 'programming'\n    t = 'gram'\n    return (s, t)\n\nassert f(*g()) == True\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Check if the bitwise AND of two numbers n and m is equal to k\"\"\"\n    return (n & m) == k\ndef g(n=10, m=7, k=2):\n    return n & m\nassert f(g(), m=7, k=2)\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique bit strings of length n that do not contain consecutive 1's.\"\"\"\n    def countStrings(n, prev):\n        if n == 0:\n            return 1\n        if prev == 1:\n            return countStrings(n - 1, 0)\n        return countStrings(n - 1, 0) + countStrings(n - 1, 1)\n    return countStrings(n, 0)\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 216,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, return the shortest distance from the top-left corner to the bottom-right corner,\n    by moving rightwards or downwards. Each cell represents the cost of moving to that cell.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    distances = [[float('inf')] * cols for _ in range(rows)]\n    distances[0][0] = grid[0][0]\n    queue = deque([(0, 0)])\n    \n    while queue:\n        i, j = queue.popleft()\n        \n        for dx, dy in [(0, 1), (1, 0)]:\n            new_i = i + dx\n            new_j = j + dy\n            if 0 <= new_i < rows and 0 <= new_j < cols:\n                new_distance = distances[i][j] + grid[new_i][new_j]\n                if new_distance < distances[new_i][new_j]:\n                    distances[new_i][new_j] = new_distance\n                    queue.append((new_i, new_j))\n    \n    return distances[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    return dp[rows - 1][cols - 1]\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix)) == 29\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of 2.\"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an undirected graph represented by an adjacency matrix and two vertices: start and end.\n    Determine if there is a path from start to end in the graph.\n    Return True if a path exists, False otherwise.\"\"\"\n    stack = [start]\n    visited = [False] * len(graph)\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            neighbors = [i for i, value in enumerate(graph[node]) if value == 1]\n            stack.extend(neighbors)\n    return False\n\ndef g():\n    return [[0, 1, 0, 0, 1],\n            [1, 0, 1, 1, 0],\n            [0, 1, 0, 1, 0],\n            [0, 1, 1, 0, 0],\n            [1, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4) == True\n",
        "idx_generation": 175,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix and a target number, determine if the target number exists in the matrix.\n    Args:\n        matrix: The matrix represented as a 2D list of integers.\n        target: The target number to search for.\n    Returns:\n        True if the target number exists, False otherwise.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows = len(matrix)\n    cols = len(matrix[0])\n    visited = set()\n    queue = [(0, 0)]\n    while queue:\n        row, col = queue.pop(0)\n        visited.add((row, col))\n        if matrix[row][col] == target:\n            return True\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col))\n    return False\ndef g():\n    \"\"\"\n    Returns a sample matrix represented as a 2D list.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\nassert f(g(), 5)\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, end=4, path_length=3) -> bool:\n    \"\"\"Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node\nwith a length equal to the given path_length.\nArgs:\n    graph: The graph represented as an adjacency list.\n    start: The starting node.\n    end: The ending node.\n    path_length: The required length of the path.\nReturns:\n    True if a path exists with the given length, False otherwise.\"\"\"\n    def dfs(node, length):\n        if length == path_length and node == end:\n            return True\n        if length < path_length:\n            for neighbor in graph[node]:\n                if dfs(neighbor, length + 1):\n                    return True\n        return False\n\n    return dfs(start, 0)\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 4], [3]]\n\nassert f(g())\n",
        "idx_generation": 23,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid representing a maze, determine if there is a path from the top-left corner to the bottom-right corner.\n    A path can only move right or down.\n    Return True if there is a path, otherwise False.\"\"\"\n    def is_valid(x, y):\n        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1:\n            return True\n        return False\n    \n    def bfs():\n        queue = deque([(0, 0)])\n        visited = set()\n        while queue:\n            x, y = queue.popleft()\n            if (x, y) == (len(grid)-1, len(grid[0])-1):\n                return True\n            if (x, y) not in visited:\n                visited.add((x, y))\n                if is_valid(x+1, y):\n                    queue.append((x+1, y))\n                if is_valid(x, y+1):\n                    queue.append((x, y+1))\n        return False\n    \n    return bfs()\n\ndef g():\n    return [[1, 1, 1],\n            [1, 0, 1],\n            [1, 1, 1]]\nassert f(g())\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Example:\n    Input:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 0],\n        [0, 1, 1]\n    ]\n    Output:\n    True\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] and grid[i][0] == 1\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] and grid[0][j] == 1\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    return dp[m-1][n-1]\ndef g():\n    return [[1, 0, 0], [1, 1, 0], [0, 1, 1]]\nassert f(g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a grid of letters and a word, determine if the word can be formed by traversing adjacent cells in the grid.\nThe word can be formed by moving up, down, left, or right in the grid, but not diagonally.\nEach cell in the grid can only be used once.\nReturn True if the word can be formed, False otherwise.\"\"\"\n    def dfs(i: int, j: int, idx: int) -> bool:\n        if idx == len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or (j >= len(grid[0])) or (visited[i][j]) or (grid[i][j] != word[idx]):\n            return False\n        visited[i][j] = True\n        found = dfs(i + 1, j, idx + 1) or dfs(i - 1, j, idx + 1) or dfs(i, j + 1, idx + 1) or dfs(i, j - 1, idx + 1)\n        visited[i][j] = False\n        return found\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\ndef g(grid: List[List[str]], word: str):\n    return (grid, word)\n\ngrid = [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['M', 'N', 'O', 'P']]\nword = 'ABCD'\nassert f(*g(grid, word))\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a subset of elements in the list that sum up to the target value.\"\"\"\n    def helper(arr, target, index, current_sum):\n        if current_sum == target:\n            return True\n        if index >= len(arr):\n            return False\n        if current_sum + arr[index] <= target:\n            if helper(arr, target, index + 1, current_sum + arr[index]):\n                return True\n        return helper(arr, target, index + 1, current_sum)\n\n    return helper(arr, target, 0, 0)\n\ndef g(arr=[2, 4, 6, 8, 10]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"Given a string and an integer k, determine if it is possible to rearrange the characters of the string\n    such that no two adjacent characters are the same and the string has exactly k distinct characters.\"\"\"\n    distinct_chars = len(set(string))\n    return distinct_chars == k\n\ndef g(string: str, k: int):\n    def backtrack(curr_string, distinct_chars):\n        if len(curr_string) == len(string) and distinct_chars == k:\n            return curr_string\n        for char in string:\n            if char != curr_string[-1]:\n                new_string = curr_string + char\n                if new_string.count(char) <= k:\n                    new_distinct_chars = distinct_chars + (1 if new_string.count(char) == 1 else 0)\n                    result = backtrack(new_string, new_distinct_chars)\n                    if result:\n                        return result\n        return None\n    \n    return backtrack(string[0], 1)\n\nassert f(g(\"abacabadabacaba\", 4), 4)\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of unique combinations of three elements\n    from the list that form a Pythagorean triplet (a^2 + b^2 = c^2).\n    \"\"\"\n    def is_pythagorean_triplet(a: int, b: int, c: int) -> bool:\n        return a * a + b * b == c * c\n    \n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_pythagorean_triplet(nums[i], nums[j], nums[k]):\n                    count += 1\n    return count\n\ndef g(nums=[3, 4, 5, 6, 7, 8, 9]):\n    return (nums,)\n\nassert f(*g()) == 1\n",
        "idx_generation": 261,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers and two positive integers n and k, determine if it is possible to select k integers from the list such that the product of any two selected integers is divisible by n.\n    Return True if such a selection is possible, otherwise return False.\"\"\"\n    \n    def is_divisible_by_n(a: int, b: int, n: int) -> bool:\n        return (a * b) % n == 0\n    \n    def select_k(nums: List[int], k: int, n: int) -> bool:\n        if k == 0:\n            return True\n        if not nums:\n            return False\n        \n        # Select first number from the list\n        num = nums[0]\n        remaining_nums = nums[1:]\n        \n        # Check if num can be paired with any other selected number to have a product divisible by n\n        for i in range(len(remaining_nums)):\n            if is_divisible_by_n(num, remaining_nums[i], n):\n                # Recurse with the remaining numbers and k-1\n                if select_k(remaining_nums[:i] + remaining_nums[i+1:], k-1, n):\n                    return True\n        \n        # Recurse without selecting the current number\n        if select_k(remaining_nums, k, n):\n            return True\n        \n        return False\n    \n    return select_k(nums, k, n)\n\ndef g(n: int, k: int, nums: List[int]) -> Tuple[int, int, List[int]]:\n    \"\"\"\n    Return the values of n, k, and nums.\n    \"\"\"\n    return n, k, nums\n\nassert f(*g(3, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the list of integers in ascending order using bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([5, 3, 8, 2, 1])) == [1, 2, 3, 5, 8]\n",
        "idx_generation": 406,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given list of integers in ascending order using the bubble sort algorithm.\n\"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g():\n    arr = [9, 4, 7, 2, 1, 5, 3, 8, 6]\n    return arr\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 57,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all the duplicate elements removed. \n    Use a stack to keep track of the previously encountered elements for optimization.\"\"\"\n    stack = []\n    for num in nums:\n        if num not in stack:\n            stack.append(num)\n    return stack\n\ndef g(nums=[1, 2, 2, 3, 4, 4, 5]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a sorted 2D matrix of integers and a target integer, find if the target exists in the matrix.\n    \n    Args:\n        matrix: The sorted 2D matrix.\n        target: The target integer.\n        \n    Returns:\n        True if the target exists, False otherwise.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    \n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g():\n    return ([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5)\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in a list using linear search.\nArgs:\n- arr: A list of integers.\n- target: The number to be found in the list.\nReturns:\n- The index of the target number in the list, or -1 if it is not found.\"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\ndef g(arr=[1, 3, 5, 7, 9, 11, 13], target=7):\n    return (arr, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray whose sum is less than or equal to the target number.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = 1\n    curr_sum = arr[left]\n    while right <= len(arr):\n        if curr_sum <= target:\n            return True\n        elif curr_sum < target and right < len(arr):\n            curr_sum += arr[right]\n            right += 1\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return False\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Find a subarray whose sum is less than or equal to the target number.\n    Return the subarray and its sum as a tuple.\n    \"\"\"\n    left = 0\n    right = 1\n    curr_sum = arr[left]\n    while right <= len(arr):\n        if curr_sum <= target:\n            return arr[left:right], curr_sum\n        elif curr_sum < target and right < len(arr):\n            curr_sum += arr[right]\n            right += 1\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return [], 0\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(arr, target)[0], target)\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int], g=lambda x: x & x - 1 == 0) -> bool:\n    \"\"\"Check if a given number is a power of two and if it exists in a sorted array\"\"\"\n    if not g(n):\n        return False\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == n:\n            return True\n        elif arr[mid] < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    n = 8\n    arr = [1, 2, 4, 8, 16, 32, 64, 128]\n    return (n, arr)\n\nassert f(*g())\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers whose sum is equal to the target value.\"\"\"\n    nums.sort()\n    (left, right) = (0, len(nums) - 1)\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [2, 4, 6, 8, 10, 12]\nassert f(g(), 16)\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in the given list whose sum is equal to the target value.\"\"\"\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n    def helper(start: int, end: int, target: int) -> bool:\n        if start == end:\n            return False\n        if prefix_sum[end] - prefix_sum[start] == target:\n            return True\n        return helper(start, end - 1, target) or helper(start + 1, end, target)\n    return helper(0, len(nums), target)\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6], 10)\nassert f(*g())\n",
        "idx_generation": 334,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a binary search tree (BST).\"\"\"\n    def is_bst(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n    \n    return is_bst(arr, float('-inf'), float('inf'))\n\ndef g():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    # Create a binary search tree\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    root.right.left = TreeNode(5)\n    root.right.right = TreeNode(7)\n\n    return root\n\nassert f(g())\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum along a path from the top-left corner to the bottom-right corner.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 12\n",
        "idx_generation": 259,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, check if it is a valid tree representation.\n    A valid tree representation follows these rules:\n    1. The matrix must be square (n x n).\n    2. The diagonal of the matrix should be all zeros (no self-loops).\n    3. The matrix should be symmetric (if there is an edge from A to B, there should be an edge from B to A).\n    4. The matrix should be connected (there should be a path between any two nodes).\n\n    Return True if the matrix is a valid tree representation, otherwise return False.\n    \"\"\"\n    n = len(matrix)\n    if n == 0 or len(matrix[0]) != n:\n        return False\n\n    # Check if the diagonal is all zeros\n    for i in range(n):\n        if matrix[i][i] != 0:\n            return False\n\n    # Check if the matrix is symmetric\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n\n    # Check if the matrix is connected\n    visited = [False] * n\n    stack = [0]\n    visited[0] = True\n\n    while stack:\n        node = stack.pop()\n        for i in range(n):\n            if matrix[node][i] != 0 and not visited[i]:\n                stack.append(i)\n                visited[i] = True\n\n    if False in visited:\n        return False\n\n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a valid tree representation matrix.\n\n    The generated matrix should satisfy the following conditions:\n    1. The matrix must be square (n x n).\n    2. The diagonal of the matrix should be all zeros (no self-loops).\n    3. The matrix should be symmetric (if there is an edge from A to B, there should be an edge from B to A).\n    4. The matrix should be connected (there should be a path between any two nodes).\n\n    Return the generated matrix.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return matrix\n\n    # Generate a random spanning tree\n    visited = [False] * n\n    stack = [0]\n    visited[0] = True\n\n    while stack:\n        node = stack.pop()\n        for i in range(n):\n            if not visited[i] and matrix[node][i] == 0:\n                matrix[node][i] = 1\n                matrix[i][node] = 1\n                stack.append(i)\n                visited[i] = True\n\n    return matrix\n\nmatrix = [[0, 1, 0, 0],\n          [1, 0, 1, 1],\n          [0, 1, 0, 1],\n          [0, 1, 1, 0]]\nassert f(g(matrix))\n",
        "idx_generation": 365,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Return the spiral traversal of the given matrix.\"\"\"\n    rows = len(matrix)\n    columns = len(matrix[0])\n    \n    result = []\n    \n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = columns - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse the top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        # Traverse the right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        # Traverse the bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        # Traverse the left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g(matrix: List[List[int]]):\n    return (matrix,)\n\nassert f(*g([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n])) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers from a given list that sum up to the target value.\"\"\"\n    complements = {}\n    for num in nums:\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], nums.index(num)]\n        complements[num] = nums.index(num)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums, target\n\nassert f(*g([2, 7, 11, 15], 9)) == [0, 1]\n",
        "idx_generation": 42,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string expression representing a mathematical expression, return True if the parentheses in the expression are balanced, False otherwise.\nThe expression only contains parentheses, and the parentheses must be correctly nested.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g(expression=\"((3+2)*(4-1))\"):\n    return expression\nassert f(g()) == True\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import *\ndef f(points: List[List[int]]) -> int:\n    \"\"\"Calculate the number of rectangles that can be formed by a set of points in a 2D plane.\"\"\"\n    count = 0\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            for k in range(j+1, len(points)):\n                for l in range(k+1, len(points)):\n                    if is_rectangle(points[i], points[j], points[k], points[l]):\n                        count += 1\n    return count\n\ndef is_rectangle(p1, p2, p3, p4):\n    x_values = [p1[0], p2[0], p3[0], p4[0]]\n    y_values = [p1[1], p2[1], p3[1], p4[1]]\n    return len(set(x_values)) == 2 and len(set(y_values)) == 2\n\ndef g():\n    points = [[random.randint(0, 10), random.randint(0, 10)] for _ in range(4)]\n    return points\nassert f(g()) >= 0\n",
        "idx_generation": 489,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string 's', determine if it is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of trailing zeros in n! (factorial of n).\n    The trailing zeros are the zeros at the end of the factorial representation.\"\"\"\n    def trailing_zeros(n):\n        count = 0\n        while n > 0:\n            n //= 5\n            count += n\n        return count\n    return trailing_zeros(n)\n\ndef g():\n    n = 20\n    return (n,)\n\nassert f(*g()) == 4\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list that sums up to a prime number.\"\"\"\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n\n    def helper(start: int, end: int) -> bool:\n        if start == end:\n            return False\n        if is_prime(prefix_sum[end] - prefix_sum[start]):\n            return True\n        return helper(start, end - 1) or helper(start + 1, end)\n\n    return helper(0, len(nums))\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 74,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that it is a perfect square and the sum of its digits is also a perfect square.\"\"\"\n    def is_perfect_square(num: int) -> bool:\n        return int(num ** 0.5) ** 2 == num\n    \n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n    \n    return is_perfect_square(n) and is_perfect_square(sum_of_digits(n))\n\ndef g():\n    num = 1\n    while True:\n        if f(num):\n            return num\n        num += 1\n\nassert f(g())\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the number of paths to reach the bottom-right corner of a matrix starting from the top-left corner.\n    You can only move down or right at each step.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return a matrix with random values.\"\"\"\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 6\n",
        "idx_generation": 301,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subarray with a sum equal to zero, and False otherwise.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == 0 or prefix_sum in prefix_sums:\n            return True\n        \n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g():\n    return [2, -3, 4, -1, 6, -2, 1]\n\nassert f(g())\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers and an integer k, determine if there exists k consecutive integers in the list that are in strictly increasing order.\"\"\"\n    heap = []\n    for num in arr:\n        if len(heap) >= k:\n            heapq.heappop(heap)\n        heapq.heappush(heap, num)\n        if len(heap) == k and heap[0] == num - k + 1:\n            return True\n    return False\n\ndef g(arr=[1, 2, 4, 5, 6, 8]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\"\"\"\n    def is_palindrome(s: str, start: int, end: int) -> bool:\n        if start >= end:\n            return True\n        if s[start] != s[end]:\n            return False\n        return is_palindrome(s, start + 1, end - 1)\n    \n    return is_palindrome(s, 0, len(s) - 1)\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 5,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to obtain the target number by rearranging the given numbers and applying a series of stack operations.\"\"\"\n    def helper(index, current_sum, stack):\n        if index == len(numbers):\n            return current_sum == target\n        \n        if helper(index + 1, current_sum + numbers[index], stack):\n            return True\n        if helper(index + 1, current_sum - numbers[index], stack):\n            return True\n        \n        stack.append(numbers[index])\n        if helper(index + 1, current_sum, stack):\n            return True\n        stack.pop()\n        \n        return False\n    \n    return helper(0, 0, [])\n    \ndef g():\n    return ([1, 2, 3, 4], 10)\n    \nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of k consecutive numbers in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_sum = float('-inf')\n    \n    for i in range(rows):\n        for j in range(cols - k + 1):\n            current_sum = sum(grid[i][j:j+k])\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(grid: List[List[int]], k: int) -> None:\n    \"\"\"\n    Generate a grid of integers and the value of k for the maximum sum.\n    \"\"\"\n    return grid, k\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nk = 2\nassert f(*g(grid, k)) == 17\n",
        "idx_generation": 60,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid of characters representing a maze, find the minimum number of steps required to reach the goal ('G') from the start ('S').\n    You can move in four directions: up, down, left, and right. Walls are represented by '#', open paths are represented by '.', and the start and goal positions are represented by 'S' and 'G' respectively.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    start = None\n    goal = None\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    queue = deque([(start[0], start[1], 0)])  # (i, j, steps)\n    visited[start[0]][start[1]] = True\n\n    while queue:\n        curr_i, curr_j, steps = queue.popleft()\n\n        if (curr_i, curr_j) == goal:\n            return steps\n\n        for direction in directions:\n            next_i = curr_i + direction[0]\n            next_j = curr_j + direction[1]\n            if next_i >= 0 and next_i < rows and next_j >= 0 and next_j < cols and not visited[next_i][next_j] and grid[next_i][next_j] != '#':\n                queue.append((next_i, next_j, steps + 1))\n                visited[next_i][next_j] = True\n\n    return -1\n\ndef g():\n    return [['S', '.', '#', '#', '#', '#'],\n            ['#', '.', '#', '#', '#', '#'],\n            ['#', '.', '#', '#', '#', '#'],\n            ['#', '.', '#', '#', '.', '#'],\n            ['#', '.', '.', '.', '.', '#'],\n            ['#', '#', '#', '#', 'G', '#']]\n\nassert f(g()) == 9\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the largest square containing only 1s and return its area.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_area = 0\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_area = max(max_area, dp[i][j] ** 2)\n    \n    return max_area\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]])) == 4\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum sum path from the top left corner to the bottom right corner of a grid, moving only down and right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\ndef g():\n    \"\"\"\n    Returns a sample grid.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 7\n",
        "idx_generation": 401,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Check if the given string can be formed by concatenating the words in the given list in any order\"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    while stack:\n        word = ''\n        for i in range(len(stack)):\n            word += stack[i]\n            if word in words:\n                stack = stack[i+1:]\n                break\n        else:\n            return False\n    return True\n\ndef g(words: List[str]) -> str:\n    return ''.join(words)\n\nassert f(g(['apple', 'banana', 'orange']), 'applebananaorange')\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, return the longest substring without repeating characters\"\"\"\n    max_len = 0\n    start = 0\n    max_start = 0\n    char_dict = {}\n    for i in range(len(s)):\n        if s[i] in char_dict and char_dict[s[i]] >= start:\n            start = char_dict[s[i]] + 1\n        char_dict[s[i]] = i\n        if i - start + 1 > max_len:\n            max_len = i - start + 1\n            max_start = start\n    return s[max_start:max_start+max_len]\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == \"abc\"\n",
        "idx_generation": 380,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of 2.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subset of arr that XORs to k.\"\"\"\n    n = len(arr)\n    for i in range(1, (1 << n)):\n        subset = [arr[j] for j in range(n) if (i & (1 << j))]\n        xor = subset[0]\n        for num in subset[1:]:\n            xor ^= num\n        if xor == k:\n            return True\n    return False\n\ndef g():\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g())\n",
        "idx_generation": 218,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Count the number of different ways to climb a staircase with n steps. You can take either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\ndef g():\n    return 6\n    \nassert f(g()) == 13\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid. You can only move down or right.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g(n: int, m: int):\n    return (n, m)\n\nassert f(*g(3, 4)) == 10\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if a given string is a valid IP address in the format X.X.X.X, where X is an integer from 0 to 255.\n    The string should contain exactly 4 integers separated by periods.\n    \"\"\"\n    nums = s.split('.')\n    if len(nums) != 4:\n        return False\n    for num in nums:\n        if not num.isdigit() or int(num) < 0 or int(num) > 255:\n            return False\n    return True\n\ndef g():\n    return \"192.168.0.1\"\n\nassert f(g())\n",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a number n and a list of edges, determine if it is possible to construct a connected graph with n nodes\n    such that each node has exactly two edges connected to it.\n    Return True if it is possible, False otherwise.\"\"\"\n    if len(edges) != n:\n        return False\n    \n    graph = [[] for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    for node in graph:\n        if len(node) != 2:\n            return False\n    \n    return True\n\ndef g(n: int, edges: List[List[int]]):\n    return (n, edges)\n\nn = 4\nedges = [[0, 1], [1, 2], [2, 3], [3, 0]]\nassert f(*g(n, edges))\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"Given a binary tree, return the postorder traversal of its nodes' values.\n    Args:\n        root: The root of the binary tree.\n    Returns:\n        The postorder traversal as a list of integers.\n    \"\"\"\n    if not root:\n        return []\n    stack = [(root, False)]\n    result = []\n    while stack:\n        node, visited = stack.pop()\n        if visited:\n            result.append(node.val)\n        else:\n            stack.append((node, True))\n            if node.right:\n                stack.append((node.right, False))\n            if node.left:\n                stack.append((node.left, False))\n    return result\ndef g():\n    \"\"\"\n    Returns a sample binary tree.\n    \"\"\"\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.right.left = TreeNode(3)\n    return root\nassert f(g()) == [3, 2, 1]\n",
        "idx_generation": 18,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(graph: Dict[str, List[str]], start_node: str, end_node: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary, determine if there is a path from a start node to an end node.\n    The solution should return True if a path exists, and False otherwise.\"\"\"\n    visited = set()\n    stack = [start_node]\n    \n    while stack:\n        node = stack.pop()\n        if node == end_node:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n            \n    return False\n\ndef g():\n    # Generate a random graph\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start_node = 'A'\n    end_node = 'F'\n    return graph, start_node, end_node\n\n# Example usage\ngraph, start_node, end_node = g()\nassert f(*g())\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if there exists a path from the top-left corner to the bottom-right corner of the grid, only moving down or right.\n    Args:\n        grid: A 2D grid represented as a list of lists.\n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return True\n        if i >= rows or j >= cols:\n            return False\n        if grid[i][j] == 1:\n            return False\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g():\n    \"\"\"\n    Returns a sample grid.\n    \"\"\"\n    return [[0, 0, 0],\n            [0, 1, 0],\n            [0, 0, 0]]\n    \nassert f(g())\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Check if a given list of words can be arranged in a circular chain,\n    where the last letter of each word is the same as the first letter of the next word\"\"\"\n    n = len(words)\n    if n == 0:\n        return False\n\n    # Create a dictionary to store the first and last letters of each word\n    letters = {}\n    for word in words:\n        first, last = word[0], word[-1]\n        if first == last:\n            return False\n        if first not in letters:\n            letters[first] = []\n        letters[first].append(last)\n\n    # Perform a depth-first search to find a circular chain\n    def dfs(current, count):\n        if count == n:\n            return True\n        if current not in letters:\n            return False\n\n        next_letters = letters[current]\n        for next_letter in next_letters:\n            letters[current].remove(next_letter)\n            if dfs(next_letter, count + 1):\n                return True\n            letters[current].append(next_letter)\n\n        return False\n\n    return dfs(words[0][0], 1)\n\n\ndef g() -> List[str]:\n    return ['hello', 'orange', 'elephant', 'tiger']\n\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to climb a staircase with n steps, where you can either take 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 34,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if the given string s can be rearranged to form k distinct palindromic substrings.\"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                count += 1\n    return count >= k\n\ndef g():\n    return ('racecar', 2)\n\nassert f(*g())\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique permutations of the digits of a given number\"\"\"\n    num_str = str(n)\n    num_digits = len(num_str)\n    freq = [0] * 10\n    for digit in num_str:\n        freq[int(digit)] += 1\n    factorial = [1] * (num_digits + 1)\n    for i in range(1, num_digits + 1):\n        factorial[i] = factorial[i - 1] * i\n    total_permutations = factorial[num_digits]\n    for count in freq:\n        total_permutations //= factorial[count]\n    return total_permutations\n\ndef g():\n    return 123\n\nassert f(g()) == 6\n",
        "idx_generation": 386,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"Given a list of integers, find all unique permutations of the integers.\nReturn a list of lists containing the unique permutations.\"\"\"\n    def backtrack(path, visited):\n        if len(path) == len(nums):\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            if visited[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                continue\n            visited[i] = True\n            backtrack(path + [nums[i]], visited)\n            visited[i] = False\n    nums.sort()\n    result = []\n    backtrack([], [False] * len(nums))\n    return result\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return the list of integers.\n    \"\"\"\n    return nums\nassert f(g([1, 1, 2])) == [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 4, 2, 7, 5, 9]\n\nassert f(g(), 11) == True\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there are two numbers in the array that sum up to the target value\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\n# Example usage:\narr = [2, 4, 6, 8, 10]\ntarget = 12\nassert f(*g(arr, target))\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there exists a pair of numbers in the list\n    whose sum is equal to the target number and the absolute difference between the two numbers is less than or equal\n    to k. Otherwise, return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            if abs(arr[left] - arr[right]) <= k:\n                return True\n            else:\n                left += 1\n                right -= 1\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[1, 3, 5, 7, 9], target=12, k=2):\n    return (arr, target, k)\nassert f(*g())\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(nums: List[int], k=2) -> bool:\n    \"\"\"Check if there exists a subsequence of length k in the given list of numbers that forms an arithmetic progression.\"\"\"\n    for i in range(len(nums) - k + 1):\n        subsequence = nums[i:i+k]\n        difference = subsequence[1] - subsequence[0]\n        arithmetic_progression = True\n        for j in range(1, len(subsequence)):\n            if subsequence[j] - subsequence[j-1] != difference:\n                arithmetic_progression = False\n                break\n        if arithmetic_progression:\n            return True\n    return False\n\ndef g(k=2):\n    \"\"\"Generate a list of numbers such that there exists a subsequence of length k that forms an arithmetic progression.\"\"\"\n    import random\n    nums = []\n    for i in range(k):\n        nums.append(random.randint(1, 10))\n    difference = random.randint(1, 10)\n    for i in range(k, k + 5):\n        nums.append(nums[i-1] + difference)\n    return nums\n\nassert f(g())\n",
        "idx_generation": 219,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if s and t are anagrams\"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for i in range(len(s)):\n        count_s[ord(s[i]) - ord('a')] += 1\n        count_t[ord(t[i]) - ord('a')] += 1\n    return count_s == count_t\ndef g():\n    s = \"anagram\"\n    t = \"nagaram\"\n    return s, t\nassert f(*g())\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]], word: str) -> bool:\n    \"\"\"Check if the given word can be formed by following a path in the given graph.\"\"\"\n    rows = len(graph)\n    cols = len(graph[0])\n    visited = [[False] * cols for _ in range(rows)]\n    stack = []\n    for i in range(rows):\n        for j in range(cols):\n            if graph[i][j] == word[0]:\n                stack.append((i, j, 0))\n                visited[i][j] = True\n    while stack:\n        x, y, index = stack.pop()\n        if index == len(word) - 1:\n            return True\n        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n        for nx, ny in neighbors:\n            if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and graph[nx][ny] == word[index+1]:\n                stack.append((nx, ny, index+1))\n                visited[nx][ny] = True\n    return False\n\ndef g():\n    graph = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]\n    word = 'ABCCED'\n    return (graph, word)\n\nassert f(*g())\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers arr and a target integer, determine if there exist two integers in the array\n    such that their XOR is equal to the target value. Returns True if such pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_xor = arr[left] ^ arr[right]\n        if curr_xor == target:\n            return True\n        elif curr_xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 13\n    return (arr, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 364,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix represented as a 2D list of integers, determine if it is a magic square.\nA magic square is a square matrix in which the sum of each row, each column, and both diagonals is the same.\nArgs:\n    matrix: The matrix represented as a 2D list of integers.\nReturns:\n    True if the matrix is a magic square, False otherwise.\"\"\"\n    def is_magic_square(matrix):\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n        for i in range(1, n):\n            if sum(matrix[i]) != target_sum:\n                return False\n        for j in range(n):\n            if sum(row[j] for row in matrix) != target_sum:\n                return False\n        if sum(matrix[i][i] for i in range(n)) != target_sum or sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n            return False\n        return True\n    \n    return is_magic_square(matrix)\n\ndef g():\n    \"\"\"\n    Returns a sample 3x3 magic square represented as a 2D list.\n    \"\"\"\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 205,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of the list whose sum is equal to 0.\"\"\"\n    prefix_sum = set()\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if curr_sum == 0 or curr_sum in prefix_sum:\n            return True\n        prefix_sum.add(curr_sum)\n    return False\n\ndef g():\n    return [2, 4, -2, -4, 6, -6]\n\nassert f(g())\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the nums list that sum up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([2, 4, 6, 8, 10], 12)\n\nassert f(*g())\n",
        "idx_generation": 351,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left corner to the bottom-right corner in the given grid. The grid consists of 0s and 1s, where 0 represents an obstacle and 1 represents an open path.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers `arr`, return True if there exists a subarray with an equal number of even and odd elements, otherwise return False.\"\"\"\n    n = len(arr)\n    count = 0\n    prefix_counts = {0: -1}\n    for i in range(n):\n        if arr[i] % 2 == 0:\n            count += 1\n        else:\n            count -= 1\n        if count in prefix_counts:\n            if i - prefix_counts[count] > 1:\n                return True\n        else:\n            prefix_counts[count] = i\n    return False\n\ndef g(arr=[2, 1, 3, 4, 6]):\n    return (arr,)\n\nassert f(*g())\n",
        "idx_generation": 442,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate it 90 degrees clockwise.\n    \n    Sample input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n    Sample output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine whether there are three integers in the list whose\nsum equals the target. Return True if such triplets exist, otherwise return False.\"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    \"\"\"Return the list of three integers whose sum equals the target value, if such triplets exist, otherwise return an empty list.\"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[i], nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n    \nassert f(g([1, 2, 3, 4, 5, 6, 7], 10), 10)\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=24) -> bool:\n    \"\"\"Given a list of four integers, determine if it is possible to combine them using the four basic arithmetic operations (+, -, *, /) to get a final result of 24.\"\"\"\n    def helper(nums: List[float]) -> bool:\n        if len(nums) == 1:\n            return abs(nums[0] - target) < 0.0001\n\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j:\n                    new_nums = []\n                    for k in range(len(nums)):\n                        if k != i and k != j:\n                            new_nums.append(nums[k])\n\n                    a = nums[i]\n                    b = nums[j]\n\n                    if helper(new_nums + [a + b]):\n                        return True\n                    if helper(new_nums + [a - b]):\n                        return True\n                    if helper(new_nums + [a * b]):\n                        return True\n                    if b != 0 and helper(new_nums + [a / b]):\n                        return True\n\n        return False\n\n    return helper(numbers)\n\ndef g():\n    return [4, 6, 2, 3]\n\nassert f(g())\n",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n    Solve this problem without using division.\"\"\"\n    n = len(arr)\n    left = [1] * n\n    right = [1] * n\n    result = [0] * n\n    \n    for i in range(1, n):\n        left[i] = left[i - 1] * arr[i - 1]\n        \n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] * arr[i + 1]\n        \n    for i in range(n):\n        result[i] = left[i] * right[i]\n        \n    return result\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given an array of integers, find if there exists a subarray whose sum is equal to the target value using a sliding window approach.\nArgs:\n    arr: The input array of integers.\n    target: The target sum.\nReturns:\n    True if a subarray with the target sum exists, False otherwise.\"\"\"\n    left, right = 0, 0\n    curr_sum = arr[0]\n    while right < len(arr) - 1:\n        if curr_sum == target:\n            return True\n        if curr_sum < target:\n            right += 1\n            curr_sum += arr[right]\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return False\ndef g():\n    \"\"\"\n    Returns a sample array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\nassert f(g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if the given matrix is a magic square, where the sum of each row, each column, and each diagonal is the same.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n    # Check diagonals\n    diag_sum = 0\n    anti_diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][i]\n        anti_diag_sum += matrix[i][n-i-1]\n    if diag_sum != target_sum or anti_diag_sum != target_sum:\n        return False\n    return True\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[2, 7, 6], [9, 5, 1], [4, 3, 8]]))\n",
        "idx_generation": 115,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there is a subset of nums that sums up to the target\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\ndef g(nums=[1, 5, 11, 5]):\n    return (nums,)\nassert f(*g(), target=22)\n",
        "idx_generation": 118,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all multiples of 3 or 5 below a given number n.\nReturn the sum.\"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\ndef g(n=100):\n    return n\nassert f(g()) == 2318\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subsequence with a sum equal to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6], 11)\n\nassert f(*g())\n",
        "idx_generation": 302,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers arr and a target value k, find the maximum length of a subarray that sums up to k.\"\"\"\n    max_length = 0\n    sum_indices = {0: -1}\n    prefix_sum = 0\n    for i, num in enumerate(arr):\n        prefix_sum += num\n        if prefix_sum - k in sum_indices:\n            max_length = max(max_length, i - sum_indices[prefix_sum - k])\n        if prefix_sum not in sum_indices:\n            sum_indices[prefix_sum] = i\n    return max_length\n\ndef g(k: int):\n    return [1, -1, 5, -2, 3], k\n\nassert f(*g(3)) == 4\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Given three positive integers n, m, and k, determine if it is possible to arrange n elements in a stack such that every mth element is at the top of the stack.\"\"\"\n    if k == 1:\n        return True\n    if k > n:\n        return False\n    if m == 1:\n        return n % k == 0\n    return n % m == 0\n\ndef g(n=10, m=2, k=3):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if it is possible to combine the numbers using addition,\n    subtraction, multiplication, and division operations to reach the target number.\n    Each number in the list can only be used once.\n    Return True if a combination exists, and False otherwise.\n    \"\"\"\n    def helper(numbers, target, curr_sum, index):\n        if curr_sum == target:\n            return True\n        if index >= len(numbers):\n            return False\n        \n        num = numbers[index]\n        return (\n            helper(numbers, target, curr_sum + num, index + 1) or\n            helper(numbers, target, curr_sum - num, index + 1) or\n            helper(numbers, target, curr_sum * num, index + 1) or\n            (curr_sum % num == 0 and helper(numbers, target, curr_sum / num, index + 1))\n        )\n    \n    return helper(numbers, target, 0, 0)\n\n\ndef g():\n    numbers = [2, 5, 10, 20]\n    target = 30\n    return [numbers, target]\n\n\nassert f(*g())\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string s is a valid arithmetic expression with balanced parentheses.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\ndef g():\n    return '(()(()))()'\nassert f(g())\n",
        "idx_generation": 253,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate a grid clockwise by 90 degrees.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    rotated_grid = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            rotated_grid[j][rows-i-1] = grid[i][j]\n    return rotated_grid\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 72,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a 2D grid of 0s and 1s, determine if it forms a valid path from the top-left corner to the bottom-right corner.\n    You can only move horizontally or vertically and can only travel through cells containing a 1.\n    Return True if a valid path exists, False otherwise.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n\n    while stack:\n        row, col = stack.pop()\n        if row == rows-1 and col == cols-1:\n            return True\n\n        if (row, col) in visited or grid[row][col] == 0:\n            continue\n\n        visited.add((row, col))\n\n        if row+1 < rows:\n            stack.append((row+1, col))\n        if col+1 < cols:\n            stack.append((row, col+1))\n\n    return False\n\ndef g(grid: List[List[int]]):\n    return grid\n\ngrid = [[1, 1, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 1, 1],\n        [0, 0, 0, 1]]\n\nassert f(g(grid))\n",
        "idx_generation": 396,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the minimum number of steps required to move from the top-left corner to the bottom-right corner, considering only moving down or right.\"\"\"\n    def helper(row, col):\n        if row >= len(grid) or col >= len(grid[0]):\n            return float('inf')\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return 0\n        return 1 + min(helper(row+1, col), helper(row, col+1))\n    \n    return helper(0, 0)\n\ndef g():\n    grid = [\n        [1, 0, 1, 1, 1],\n        [0, 1, 1, 0, 1],\n        [1, 1, 1, 1, 0],\n        [1, 1, 1, 1, 0],\n        [1, 1, 0, 0, 1]\n    ]\n    return grid\n\nassert f(g()) == 8\n",
        "idx_generation": 166,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    Each step, you can only move right or down.\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Check if a string s is a palindrome, considering only alphanumeric characters and ignoring cases.\"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    stack = deque()\n    for ch in s:\n        stack.append(ch)\n    while len(stack) > 1:\n        if stack.pop() != stack.popleft():\n            return False\n    return True\ndef g(s: str=\"A man, a plan, a canal: Panama\"):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target=\"world\") -> bool:\n    \"\"\"Check if the target string is a substring of the input string.\"\"\"\n    if len(target) > len(s):\n        return False\n\n    if s[:len(target)] == target:\n        return True\n\n    return f(s[1:], target)\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer, determine if it is a power of two.\"\"\"\n    return n & (n - 1) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset whose bitwise XOR is equal to zero.\n    Return True if such a subset exists, False otherwise.\"\"\"\n    def helper(i: int, xor: int) -> bool:\n        if i == len(arr):\n            return xor == 0\n        return helper(i + 1, xor ^ arr[i]) or helper(i + 1, xor)\n    \n    return helper(0, 0)\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 282,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum that can be obtained by adding a subarray of the list, with the constraint that no two numbers in the subarray are adjacent.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n    return dp[-1]\ndef g(nums=[2, 7, 9, 3, 1]):\n    return nums\nassert f(g()) == 12\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum path from the top-left corner to the bottom-right corner.\nYou can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 311,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring='abc', count=2) -> bool:\n    \"\"\"Given a string, find whether it contains a specific substring a certain number of times\"\"\"\n    return s.count(substring) == count\n\ndef g(substring='abc', count=2):\n    return substring * count + 'def'\n\nassert f(g())\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0, target=5) -> bool:\n    \"\"\"Given a graph represented as an adjacency list and two nodes start and target,\n    determine if there exists a path from start to target in the graph.\n\n    Each node in the graph is represented by an index in the adjacency list,\n    and each element in the adjacency list represents the neighbors of that node.\n\n    Example:\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2, 4], [3, 5], [4]]\n    start = 0\n    target = 5\n\n    The function should return True since there is a path from node 0 to node 5:\n    0 -> 3 -> 4 -> 5\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n\n    return False\n\ndef g(start=0, target=5):\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2, 4], [3, 5], [4]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0, end=4) -> bool:\n    \"\"\"Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node.\nArgs:\n    graph: The graph represented as an adjacency list.\n    start: The starting node.\n    end: The ending node.\nReturns:\n    True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 4], [3]]\n\nassert f(g())\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed acyclic graph (DAG), return True if there exists a path\n    from the first node to the last node, otherwise return False.\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    Output: True\n    Explanation: There exists a path from node 0 to node 3: 0 -> 1 -> 3.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n\n    def dfs(node):\n        visited[node] = True\n        if node == n - 1:\n            return True\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    return dfs(0)\n\ndef g():\n    return [[0, 1, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 26,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if there is a path from the top-left corner to the bottom-right corner in a grid, avoiding obstacles.\"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i, j):\n        if i == m-1 and j == n-1:\n            return True\n        if grid[i][j] == 1:\n            return False\n        grid[i][j] = 1\n        if i+1 < m and dfs(i+1, j):\n            return True\n        if j+1 < n and dfs(i, j+1):\n            return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g(m=5, n=5, obstacles=4):\n    import random\n    grid = [[0] * n for _ in range(m)]\n    for _ in range(obstacles):\n        i, j = random.randint(0, m-1), random.randint(0, n-1)\n        grid[i][j] = 1\n    return grid\n\nassert f(g())\n",
        "idx_generation": 57,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid, target=\"ABC\"):\n    \"\"\"Check if the target string can be formed by traversing the grid\"\"\"\n    def helper(i, j, target, grid):\n        if len(target) == 0:\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != target[0]:\n            return False\n        grid[i][j] = \"#\"\n        found = helper(i+1, j, target[1:], grid) or helper(i-1, j, target[1:], grid) or helper(i, j+1, target[1:], grid) or helper(i, j-1, target[1:], grid)\n        grid[i][j] = target[0]\n        return found\n    \n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if helper(i, j, target, grid):\n                return True\n    return False\n\ndef g():\n    return ([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']],)\n\nassert f(g()[0])\n",
        "idx_generation": 298,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Given a list of positive integers and a target sum, determine if there exists a combination of numbers that add up to the target sum.\"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target-nums[n-1], n-1) or subset_sum(nums, target, n-1)\n    return subset_sum(nums, target, len(nums))\ndef g(target=0):\n    return [1, 2, 3, 4, 5]\nassert f(g(), target=9)\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if it is possible to obtain the target number by multiplying or dividing the numbers in the list.\n    Each number in the list can be used exactly once.\"\"\"\n    queue = [(1, 0)]\n    for num in arr:\n        new_queue = []\n        for val, count in queue:\n            new_queue.append((val * num, count + 1))\n            new_queue.append((val / num, count + 1))\n        queue = new_queue\n    return any(val == target and count == len(arr) for val, count in queue)\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4], 24))\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\n\ndef f(n: int, r: int) -> int:\n    \"\"\"Calculate the number of combinations of n items taken r at a time\"\"\"\n    return factorial(n) // (factorial(r) * factorial(n - r))\n\ndef g(n=5, r=3):\n    return n, r\n\nassert f(*g()) == 10\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, k: int, result: int) -> bool:\n    \"\"\"Given two integers n and k, the goal is to find an integer 'result' such that\n    the number of combinations (n choose i) where i ranges from 0 to n, is equal to 'result'.\n    The combinations are calculated using the formula C(n, i) = n! / (i! * (n-i)!).\n    Return True if 'result' is correct, and False otherwise.\"\"\"\n    \n    def calculate_combinations(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        else:\n            return calculate_combinations(n-1, k-1) + calculate_combinations(n-1, k)\n        \n    return calculate_combinations(n, k) == result\n\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, the goal is to find an integer 'result' such that\n    the number of combinations (n choose i) where i ranges from 0 to n, is equal to 'result'.\n    The combinations are calculated using the formula C(n, i) = n! / (i! * (n-i)!).\n    Return the value of 'result'.\"\"\"\n\n    def calculate_factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * calculate_factorial(n-1)\n        \n    numerator = calculate_factorial(n)\n    denominator = calculate_factorial(k) * calculate_factorial(n-k)\n    result = numerator // denominator\n    return result\n\n\nassert f(5, 2, g(5, 2))\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the minimum number of elements from the given list that sum up to the target.\"\"\"\n    nums.sort(reverse=True)\n    queue = [(0, 0)]\n    while queue:\n        curr_sum, count = queue.pop(0)\n        if curr_sum == target:\n            return count\n        if curr_sum > target:\n            continue\n        for num in nums:\n            queue.append((curr_sum + num, count + 1))\n    return -1\n\ndef g():\n    return [2, 3, 5, 8]\n\nassert f(g(), 10) == 2\n",
        "idx_generation": 80,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of elements in the list that sum up to the target value.\"\"\"\n    def helper(arr, target, start, end):\n        if start >= end:\n            return False\n        if arr[start] + arr[end] == target:\n            return True\n        elif arr[start] + arr[end] < target:\n            return helper(arr, target, start + 1, end)\n        else:\n            return helper(arr, target, start, end - 1)\n\n    arr.sort()\n    return helper(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[2, 4, 6, 8, 10]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of elements in the list that sum up to the target value.\n    Return True if the sum of any two elements equals to target, False otherwise.\"\"\"\n    arr.sort()\n    start = 0\n    end = len(arr) - 1\n    while start < end:\n        current_sum = arr[start] + arr[end]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g(arr=[2, 4, 6, 8, 10]):\n    \"\"\"Return the input list as it is\"\"\"\n    return arr\n\nassert f(g())\n",
        "idx_generation": 253,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if it is possible to split the string into k non-empty substrings, where each substring is a palindrome\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    def backtrack(s: str, k: int, start: int, curr: List[str]) -> bool:\n        if start == len(s):\n            return k == 0\n        for end in range(start, len(s)):\n            if is_palindrome(s[start:end + 1]):\n                curr.append(s[start:end + 1])\n                if backtrack(s, k - 1, end + 1, curr):\n                    return True\n                curr.pop()\n        return False\n    return backtrack(s, k, 0, [])\ndef g():\n    return \"aabbc\", 3\nassert f(*g())\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose XOR is equal to the target.\n    The list is sorted in ascending order.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nassert f(g(), 10)\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray with a sum equal to 0.\nReturn True if such a subarray exists, False otherwise.\"\"\"\n    prefix_sum = set()\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if current_sum == 0 or current_sum in prefix_sum:\n            return True\n        prefix_sum.add(current_sum)\n    return False\ndef g(arr: List[int]):\n    return (arr,)\nassert f(*g([4, 2, -3, 1, 6]))\n",
        "idx_generation": 215,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray of length k with a sum greater than or equal to a target value.\n    Return True if such a subarray exists, False otherwise.\"\"\"\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i in range(k, len(prefix_sum)):\n        if prefix_sum[i] - prefix_sum[i - k] >= k:\n            return True\n    \n    return False\n\ndef g(arr: List[int], k: int):\n    return (arr, k)\n\nassert f(*g([1, 2, 3, 4, 5], 3))\n",
        "idx_generation": 370,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in non-decreasing order and a target number, \n    determine if the target number exists in the list using binary search.\n    Return True if the target number exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Return the input list and the target number.\n    \"\"\"\n    return arr, target\n\narr = [1, 3, 5, 7, 9, 11, 13, 15]\ntarget = 9\nassert f(g(arr, target)[0], g(arr, target)[1])\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initialize the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n    \n    # Initialize the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n    \n    # Fill in the rest of the grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    \n    return grid[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 279,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a magic square, where the sum of each row, column, and diagonal is the same.\"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n    for i in range(n):\n        if sum(grid[i]) != target_sum:\n            return False\n        if sum(grid[j][i] for j in range(n)) != target_sum:\n            return False\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(grid[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    return True\n\ndef g():\n    grid = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], node: int) -> int:\n    \"\"\"Given an undirected graph represented as an adjacency list and a node, find the number of neighbors that have an odd degree.\n\"\"\"\n\n    odd_degree_neighbors = 0\n\n    for neighbor in graph[node]:\n        if len(graph[neighbor]) % 2 != 0:\n            odd_degree_neighbors += 1\n\n    return odd_degree_neighbors\n\ndef g(graph: List[List[int]], node: int):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list and a node.\n    \"\"\"\n\n    return (graph, node)\n\ngraph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\nnode = 0\n\nassert f(*g(graph, node)) == 2\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the input list is a permutation of consecutive integers\"\"\"\n    n = len(arr)\n    return sorted(arr) == list(range(1, n + 1))\n\ndef g():\n    arr = [5, 3, 1, 4, 2]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Find a subset of the given array that sums up to the target value\"\"\"\n    def subset_sum(arr, n, target):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, n-1, target)\n        return subset_sum(arr, n-1, target) or subset_sum(arr, n-1, target-arr[n-1])\n    \n    return subset_sum(arr, len(arr), target)\n\ndef g(target=100):\n    arr = [10, 20, 30, 40, 50]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 12,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray whose sum is equal to the target number.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = 1\n    curr_sum = arr[left]\n    while right <= len(arr):\n        if curr_sum == target:\n            return True\n        elif curr_sum < target and right < len(arr):\n            curr_sum += arr[right]\n            right += 1\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return False\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Find a subarray whose sum is equal to the target number.\n    Return the subarray and its sum as a tuple.\n    \"\"\"\n    left = 0\n    right = 1\n    curr_sum = arr[left]\n    while right <= len(arr):\n        if curr_sum == target:\n            return arr[left:right], curr_sum\n        elif curr_sum < target and right < len(arr):\n            curr_sum += arr[right]\n            right += 1\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return [], 0\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(arr, target)[0], target)\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in a list that add up to the target.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 122,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of the first n even numbers.\"\"\"\n    return n * (n + 1)\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 110\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of trailing zeros in n factorial.\"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\ndef g(n=10):\n    return n\nassert f(g()) == 2\n",
        "idx_generation": 159,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subarray of consecutive elements in the list that adds up to the target.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subarray of consecutive elements in the list that adds up to the target number.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return nums[i:j]\n\n    return []\n\nnums = [1, 2, 3, 4, 5, 6]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=100) -> bool:\n    \"\"\"Find a subset of array elements that sums up to a given target value\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][target]\n\ndef g(target=100):\n    return [10, 20, 30, 40, 50]\n\nassert f(g())\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of numbers, find the maximum sum of a subarray within the list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g()) == 6\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid, determine if it contains a valid path from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of characters, where '0' represents an obstacle and '1' represents an open path.\n    The valid path can only consist of rightward and downward movements.\n    Additionally, there are certain cells marked with 'S' that can be used to skip the next cell in the path.\n    If a skip occurs, the path can continue from the cell after the skipped cell.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        (x, y) = stack.pop()\n        if x == rows - 1 and y == cols - 1:\n            return True\n        if grid[x][y] == 'S':\n            stack.append((x + 1, y + 1))\n        if x + 1 < rows and grid[x + 1][y] != '0':\n            stack.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] != '0':\n            stack.append((x, y + 1))\n    return False\n\ndef g():\n    return [['1', '1', '0', '1'],\n            ['0', 'S', '1', '0'],\n            ['1', '1', '1', '1'],\n            ['1', '0', '1', '1']]\n\nassert f(g())\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of the given list of integers that adds up to the target value.\"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target-nums[n-1], n-1) or subset_sum(nums, target, n-1)\n\n    return subset_sum(nums, target, len(nums))\n\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of positive integers and a target value, find the number of distinct subsets that sum up to the target.\"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] += dp[i - num]\n    return dp[target]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 7) == 3\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=8) -> bool:\n    \"\"\"Check if it's possible to obtain the target string by repeatedly concatenating a substring of the given string.\"\"\"\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0 and s[:i] * (n // i) == s:\n            return len(s) == target_length\n    return False\n\ndef g(target_length=8):\n    return 'abcd' * (target_length // 4)\n\nassert f(g())\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid of integers representing a maze, a starting position, and an ending position, determine if it is possible to reach the ending position from the starting position by moving only up, down, left, or right. You can only move to cells that contain 1s.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [start]\n    visited = set()\n    while stack:\n        (x, y) = stack.pop()\n        if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == 0 or (x, y) in visited:\n            continue\n        if (x, y) == end:\n            return True\n        visited.add((x, y))\n        stack.append((x + 1, y))\n        stack.append((x - 1, y))\n        stack.append((x, y + 1))\n        stack.append((x, y - 1))\n    return False\n\ndef g():\n    grid = [[1, 1, 1, 1],\n            [1, 0, 0, 1],\n            [1, 1, 0, 1],\n            [0, 1, 1, 1]]\n    start = (0, 0)\n    end = (3, 3)\n    return (grid, start, end)\n\nassert f(*g()) == True\n",
        "idx_generation": 453,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a 2D grid of integers and an integer k, find the sum of values in the k-th subrectangle starting from the top-left corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def calculate_sum(top: int, left: int, bottom: int, right: int) -> int:\n        total = 0\n\n        for i in range(top, bottom+1):\n            for j in range(left, right+1):\n                total += grid[i][j]\n\n        return total\n\n    return calculate_sum(0, 0, k-1, k-1)\n\ndef g():\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    k = 2\n    return grid, k\n\nassert f(*g()) == 12\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    You can only move down or right at any point in time.\"\"\"\n    def unique_paths_helper(x: int, y: int, memo: dict) -> int:\n        if (x, y) in memo:\n            return memo[(x, y)]\n        if x == 0 or y == 0:\n            memo[(x, y)] = 1\n            return 1\n        memo[(x, y)] = unique_paths_helper(x - 1, y, memo) + unique_paths_helper(x, y - 1, memo)\n        return memo[(x, y)]\n    \n    return unique_paths_helper(n - 1, n - 1, {})\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Determine if s is a subsequence of t.\"\"\"\n    stack = []\n    for char in t:\n        if stack and stack[-1] == s[0]:\n            s = s[1:]\n            if not s:\n                return True\n        if char == s[0]:\n            s = s[1:]\n            if not s:\n                return True\n        stack.append(char)\n    return False\ndef g():\n    return ('abc', 'ahbgdc')\nassert f(*g())\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be formed by concatenating multiple copies of a substring of s.\"\"\"\n    def helper(s, substring):\n        if s == '':\n            return True\n        if s.startswith(substring):\n            return helper(s[len(substring):], substring)\n        return False\n    for i in range(1, len(s)//2 + 1):\n        substring = s[:i]\n        if helper(s, substring):\n            return True\n    return False\ndef g():\n    return 'abababab'\nassert f(g())\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the bitwise AND of all the elements in the original list.\"\"\"\n    result = []\n    for i in range(len(nums)):\n        bitwise_and = nums[0]\n        for j in range(1, len(nums)):\n            bitwise_and &= nums[j]\n        result.append(bitwise_and)\n        nums.append(nums.pop(0))\n    return result\n\ndef g(nums=[5, 8, 2, 1, 6]):\n    return nums\n\nassert f(g()) == [0, 0, 0, 0, 0]\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset of the list\n    such that the XOR of all elements in the subset is equal to the target value.\"\"\"\n    def subset_xor(nums: List[int], target: int, n: int, xor: int) -> bool:\n        if xor == target:\n            return True\n        if n == 0:\n            return False\n        return subset_xor(nums, target, n - 1, xor ^ nums[n - 1]) or subset_xor(nums, target, n - 1, xor)\n    return subset_xor(nums, target, len(nums), 0)\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 1)\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, determine the number of distinct ways to climb to the top of a staircase.\nYou can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int):\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 395,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(board: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of values obtained by traversing through a grid from the top-left to the bottom-right.\n    You can only move down or right.\n    \"\"\"\n\n    m = len(board)\n    n = len(board[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = board[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + board[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + board[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + board[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random grid with values in the range [0, 10].\n    \"\"\"\n\n    import random\n\n    m = random.randint(3, 6)\n    n = random.randint(3, 6)\n\n    grid = [[random.randint(0, 10) for _ in range(n)] for _ in range(m)]\n    return grid\n\nassert f(g()) > 0\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a perfect square.\"\"\"\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n    return is_square(n) and is_square(int(str(n)[::-1]))\ndef g():\n    return 121\nassert f(g())\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner.\nYou can only move down or right in the grid.\nReturn True if it is possible, False otherwise.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    def dfs(i: int, j: int) -> bool:\n        if i == rows - 1 and j == cols - 1:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == 1 or visited[i][j]:\n            return False\n        visited[i][j] = True\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    return dfs(0, 0)\ndef g(grid: List[List[int]]):\n    return grid\ngrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nassert f(g(grid))\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary, and two nodes 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\nArgs:\n    graph: The graph represented as a dictionary, where the keys are nodes and the values are lists of nodes that are adjacent to the key node.\n    start: The starting node in the graph.\n    end: The ending node in the graph.\nReturns:\n    True if there is a path from 'start' to 'end', False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as a dictionary.\n    \"\"\"\n    return {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n\nassert f(g(), 'A', 'F')\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner from the top-left corner by only moving through the cells with 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return True\n        \n        visited[i][j] = True\n        \n        if i + 1 < rows and grid[i + 1][j] == 1 and not visited[i + 1][j]:\n            if dfs(i + 1, j):\n                return True\n        \n        if j + 1 < cols and grid[i][j + 1] == 1 and not visited[i][j + 1]:\n            if dfs(i, j + 1):\n                return True\n        \n        return False\n    \n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]) -> None:\n    \"\"\"\n    Generate a grid of 0s and 1s for the path finding problem.\n    \"\"\"\n    return grid\n\ngrid = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nassert f(g(grid))\n",
        "idx_generation": 60,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell from the top-left cell in a grid.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] and grid[i][0] == 0\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] and grid[0][j] == 0\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    return dp[m - 1][n - 1]\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nassert f(g())\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner, only moving down or right.\n    Additionally, the path must include at least one 0 cell.\n    Return True if such a path exists, otherwise False.\"\"\"\n    def dfs(row, col):\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return True\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return False\n        if matrix[row][col] == 1 or visited[row][col]:\n            return False\n        \n        visited[row][col] = True\n        \n        return dfs(row + 1, col) or dfs(row, col + 1)\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    visited = [[False] * num_cols for _ in range(num_rows)]\n    \n    return dfs(0, 0)\n\ndef g():\n    matrix = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 299,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Given an integer n, generate a list of all possible permutations of the numbers 1 to n.\nExample:\nn = 3\nOutput:\n[\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n]    \nYou need to implement the function f() and provide a matching implementation for g() which returns the input value for n.\n\"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], res)\n    res = []\n    nums = list(range(1, n + 1))\n    backtrack(nums, [], res)\n    return res\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(s: str) -> List[str]:\n    \"\"\"Given a string s, return a list containing all possible permutations of the characters in the string.\"\"\"\n    def backtrack(chars, path, res):\n        if not chars:\n            res.append(path)\n            return\n        for i in range(len(chars)):\n            backtrack(chars[:i] + chars[i+1:], path + chars[i], res)\n    res = []\n    backtrack(s, \"\", res)\n    return res\ndef g(s=\"abc\"):\n    return s\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the number of subarrays that sum up to the target.\"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        complement = prefix_sum - target\n\n        if complement in prefix_sums:\n            count += prefix_sums[complement]\n\n        if prefix_sum in prefix_sums:\n            prefix_sums[prefix_sum] += 1\n        else:\n            prefix_sums[prefix_sum] = 1\n\n    return count\n\ndef g():\n    return ([1, 1, 1], 2)\n\nassert f(*g()) == 2\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list of integers, such that the sum of its elements is equal to 0.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    nums = [1, 3, -2, 4, -6, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 482,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if a target number can be obtained by stacking elements in a specific order.\n    The elements in the input array can be stacked on top of each other in any order, and the sum of each stack should be equal to the target number.\n    \"\"\"\n    stack = []\n    for num in arr:\n        if num == target:\n            stack.append(num)\n        else:\n            for i in range(len(stack)):\n                stack[i] += num\n            stack.append(num)\n        if target in stack:\n            return True\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Generate a sequence of elements that can be stacked to obtain the target number.\n    The generated sequence of elements can be stacked on top of each other in any order, and the sum of each stack should be equal to the target number.\n    \"\"\"\n    sequence = []\n    stack = []\n    for num in arr:\n        if num == target:\n            stack.append(num)\n            sequence.append(num)\n        else:\n            for i in range(len(stack)):\n                stack[i] += num\n            stack.append(num)\n            sequence.append(num)\n        if target in stack:\n            return sequence\n    return []\n\narr = [1, 2, 3, 4]\ntarget = 7\nassert f(g(arr, target), target)\n",
        "idx_generation": 84,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], x: int) -> int:\n    \"\"\"Given a sorted array of integers, find the index of the first occurrence of a target element x. If x is not found, return -1.\"\"\"\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            if mid == 0 or arr[mid - 1] != x:\n                return mid\n            else:\n                high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9], 4\n\nassert f(*g()) == 3\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of two distinct elements in the given list of integers.\"\"\"\n    max_product = float('-inf')\n    stack = []\n    for num in nums:\n        while stack:\n            max_product = max(max_product, num * stack[-1])\n            if num <= stack[-1]:\n                break\n            stack.pop()\n        stack.append(num)\n    return max_product\ndef g(nums=[5, 2, 6, 1, 3]):\n    return nums\nassert f(g()) == 30\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value of any two integers in a given list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\nassert f(g()) == 28\n",
        "idx_generation": 444,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a valid sudoku solution.\n    A valid sudoku solution must have each row, each column, and each of the nine 3x3 sub-grids containing all the digits from 1 to 9 without repetition.\"\"\"\n    \n    # Check rows\n    for row in grid:\n        if sorted(row) != list(range(1, 10)):\n            return False\n    \n    # Check columns\n    for col in range(9):\n        column = [grid[row][col] for row in range(9)]\n        if sorted(column) != list(range(1, 10)):\n            return False\n    \n    # Check sub-grids\n    for i in range(3):\n        for j in range(3):\n            sub_grid = [grid[row][col] for row in range(i*3, i*3+3) for col in range(j*3, j*3+3)]\n            if sorted(sub_grid) != list(range(1, 10)):\n                return False\n    \n    return True\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9],\n    ]\n\nassert f(g())\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to reach the target number by performing mathematical operations on the given list of numbers.\n    The mathematical operations allowed are addition, subtraction, multiplication, and division.\"\"\"\n    def dfs(nums, target, curr, index):\n        if index == len(nums):\n            return curr == target\n        if dfs(nums, target, curr + nums[index], index + 1):\n            return True\n        if dfs(nums, target, curr - nums[index], index + 1):\n            return True\n        if dfs(nums, target, curr * nums[index], index + 1):\n            return True\n        if nums[index] != 0 and curr % nums[index] == 0 and dfs(nums, target, curr / nums[index], index + 1):\n            return True\n        return False\n    return dfs(nums, target, 0, 0)\ndef g(nums=[1, 2, 3, 4], target=10):\n    return [nums, target]\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, check if there are two numbers in the list that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g(), 12)\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of moves required to reach the bottom-right corner from the top-left corner of the given graph, where each cell represents the cost to move to that cell. Return -1 if it is not possible to reach the destination.\"\"\"\n    n = len(graph)\n    m = len(graph[0])\n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = graph[0][0]\n    \n    for i in range(n):\n        for j in range(m):\n            if i + 1 < n:\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + graph[i + 1][j])\n            if j + 1 < m:\n                dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + graph[i][j + 1])\n    \n    return dp[n - 1][m - 1] if dp[n - 1][m - 1] != float('inf') else -1\n\ndef g(graph: List[List[int]]) -> List[List[int]]:\n    return graph\n\ngraph = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(graph)) == 7\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node in visited:\n            continue\n        visited.add(node)\n        stack.extend(graph.get(node, []))\n    return False\ndef g():\n    graph = {\n        1: [2, 3, 4],\n        2: [5],\n        3: [6],\n        4: [],\n        5: [],\n        6: [7],\n        7: []\n    }\n    start = 1\n    end = 7\n    return [graph, start, end]\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target number k, determine if it is possible to find a subarray whose sum is divisible by k.\"\"\"\n    prefix_sum = 0\n    mod_dict = {0: -1}\n    for i, num in enumerate(arr):\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in mod_dict:\n            if i - mod_dict[prefix_sum] > 1:\n                return True\n        else:\n            mod_dict[prefix_sum] = i\n    return False\n\ndef g(k: int):\n    arr = [1, 2, 3, 4, 5]\n    return (arr, k)\n\nassert f(*g(3))\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the input list is a sorted and rotated version of another list\"\"\"\n    n = len(arr)\n    sorted_arr = sorted(arr)\n    for i in range(n):\n        if arr[i:] + arr[:i] == sorted_arr:\n            return True\n    return False\n\ndef g():\n    arr = [4, 5, 6, 7, 1, 2, 3]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an unsorted integer array, find the smallest missing positive integer.\n    - Assume that the input array does not contain duplicates and that the missing positive integer is guaranteed to be less than or equal to the length of the array.\"\"\"\n    def first_missing_positive(nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1\n    return first_missing_positive(nums)\ndef g(nums: List[int]):\n    return sorted(nums)\nassert f(g([3,4,-1,1])) == 2\n",
        "idx_generation": 33,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subarray whose sum is greater than or equal to the target number.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = 1\n    curr_sum = arr[left]\n    while right <= len(arr):\n        if curr_sum >= target:\n            return True\n        elif curr_sum < target and right < len(arr):\n            curr_sum += arr[right]\n            right += 1\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return False\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Find a subarray whose sum is greater than or equal to the target number.\n    Return the subarray and its sum as a tuple.\n    \"\"\"\n    left = 0\n    right = 1\n    curr_sum = arr[left]\n    while right <= len(arr):\n        if curr_sum >= target:\n            return arr[left:right], curr_sum\n        elif curr_sum < target and right < len(arr):\n            curr_sum += arr[right]\n            right += 1\n        else:\n            curr_sum -= arr[left]\n            left += 1\n    return [], 0\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(arr, target)[0], target)\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if a string has a substring of length n that can be rearranged to form a palindrome.\"\"\"\n    for i in range(len(s) - n + 1):\n        substring = s[i:i+n]\n        if substring == substring[::-1]:\n            return True\n    \n    return False\n\ndef g(n=3):\n    return 'racecar'[:n] + 'abcd'[:n]\n\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers, find the two numbers that add up to the target value and return their indices.\"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = n * (n**2 + 1) // 2\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[i][col] for i in range(n)) != target_sum:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum or sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n: int) -> int:\n    \"\"\"Find the nth prime number.\"\"\"\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if f(num):\n            primes.append(num)\n        num += 1\n    return primes[-1]\n\nn = 10\nassert f(g(n))\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers, find the indices of two numbers such that they add up to a specific target.\n    Return the indices as a list [index1, index2].\"\"\"\n    num_dict = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers can be partitioned into two subsets with equal sum.\"\"\"\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in arr:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g())\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray. Return the maximum sum.\n    Sample input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Sample output:\n    6\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\"\"\"\n    if not nums:\n        return 0\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the input list of integers.\"\"\"\n    return nums\n\nassert f(g([-2, 1, -3, 4, -1, 2, 1, -5, 4])) == 6\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, return True if the target word can be formed by concatenating two words from the list. Use a queue to implement a breadth-first search.\"\"\"\n    queue = [target]\n    while queue:\n        current_word = queue.pop(0)\n        if current_word in words:\n            return True\n        for word in words:\n            if current_word.startswith(word):\n                queue.append(current_word[len(word):])\n    return False\n\ndef g(words=[\"apple\", \"pen\", \"pineapple\"], target=\"pineapplepenapple\"):\n    return (words, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in the given list of integers.\"\"\"\n    def longest_increasing_subsequence(nums):\n        n = len(nums)\n        lis = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j] and lis[i] < lis[j] + 1:\n                    lis[i] = lis[j] + 1\n        return max(lis)\n\n    return longest_increasing_subsequence(nums)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a subset of numbers from the given list that add up to the target number\"\"\"\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        total, index = stack.pop()\n        if total == target:\n            return True\n        if index < len(nums):\n            stack.append((total + nums[index], index + 1))\n            stack.append((total, index + 1))\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a subgrid such that the subgrid forms a square.\n    Return the maximum sum.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)+1):\n                subgrid_sum = 0\n                for x in range(i, i+k):\n                    for y in range(j, j+k):\n                        subgrid_sum += grid[x][y]\n                max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum\n\ndef g(grid: List[List[int]]):\n    return (grid,)\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(*g(grid)) == 45\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D grid of integers and a target value, check if the target value exists in the grid.\"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0:\n        return False\n    \n    stack = []\n    stack.append((0, 0))\n    \n    while stack:\n        row, col = stack.pop()\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            if row + 1 < rows:\n                stack.append((row + 1, col))\n            if col + 1 < cols:\n                stack.append((row, col + 1))\n    \n    return False\n\ndef g(grid: List[List[int]]=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target: int=9):\n    return (grid, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner.\n    You can only move down, right, or up.\n    Example:\n    Input:\n    grid = [\n        [1, 0, 1],\n        [1, 1, 0],\n        [0, 1, 1]\n    ]\n    Output:\n    True\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] and grid[i][0] == 1\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] and grid[0][j] == 1\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i-1][j+1]\n    return dp[m-1][n-1]\ndef g():\n    return [[1, 0, 1], [1, 1, 0], [0, 1, 1]]\nassert f(g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> int:\n    \"\"\"Find the length of the longest palindromic subsequence in the given string.\"\"\"\n    def backtrack(i, j):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n\n        if s[i] == s[j]:\n            return 2 + backtrack(i + 1, j - 1)\n        else:\n            return max(backtrack(i + 1, j), backtrack(i, j - 1))\n\n    return backtrack(0, len(s) - 1)\n\ndef g(s: str) -> str:\n    \"\"\"Generate a random string.\"\"\"\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    return ''.join(random.choice(letters) for _ in range(len(s)))\n\nassert f(g('')) == 0\n",
        "idx_generation": 45,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"Given two integers, return the bitwise AND of all the numbers between them (inclusive).\"\"\"\n    while num2 > num1:\n        num2 = num2 & (num2 - 1)\n    \n    return num2\n\ndef g(num1=5, num2=8):\n    return num1, num2\n\nassert f(*g()) == 0\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset whose bitwise OR equals the target value.\n    The bitwise OR of a set of integers is the result of applying the bitwise OR operation to all the elements in the set.\n    Return True if such a subset exists, otherwise return False.\"\"\"\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if nums[index] > target:\n            return subset_sum(nums, target, index + 1)\n        return subset_sum(nums, target - nums[index], index + 1) or subset_sum(nums, target, index + 1)\n    \n    return subset_sum(nums, target, 0)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 15) == True\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a non-empty subarray.\n    \n    Sample Input:\n    nums = [2, 3, -2, 4]\n    \n    Sample Output:\n    6\n    \n    Explanation: The maximum product is obtained by multiplying the subarray [2, 3].\n    \"\"\"\n    max_product = float('-inf')\n    curr_max = curr_min = 1\n    \n    for num in nums:\n        if num < 0:\n            curr_max, curr_min = curr_min, curr_max\n        curr_max = max(curr_max * num, num)\n        curr_min = min(curr_min * num, num)\n        max_product = max(max_product, curr_max)\n    \n    return max_product\n    \ndef g() -> List[int]:\n    return [2, 3, -2, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\nYou can only move down or right. Each cell represents the cost to move to that location.\nFind the maximum sum path.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(grid: List[List[int]]):\n    return grid\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid)) == 12\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom math import factorial\ndef f(n: int) -> bool:\n    \"\"\"Determine if n is a strong number.\"\"\"\n    def is_strong(n):\n        digit_factorial_sum = sum(factorial(int(digit)) for digit in str(n))\n        return digit_factorial_sum == n\n\n    return is_strong(n)\n\ndef g():\n    return 145\n\nassert f(g())\n",
        "idx_generation": 245,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid of letters, determine the length of the longest word that can be formed by concatenating letters in adjacent cells.\nThe word can be formed by moving up, down, left, or right in the grid, but not diagonally.\nEach cell in the grid can only be used once.\nReturn the length of the longest word that can be formed.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    max_length = 0\n    def dfs(i: int, j: int, word: str) -> None:\n        nonlocal max_length\n        max_length = max(max_length, len(word))\n        for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n            if 0 <= x < rows and 0 <= y < cols and grid[x][y] != '#' and (x, y) not in visited:\n                visited.add((x, y))\n                dfs(x, y, word + grid[x][y])\n                visited.remove((x, y))\n    visited = set()\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] != '#':\n                visited.add((i, j))\n                dfs(i, j, grid[i][j])\n                visited.remove((i, j))\n    return max_length\ndef g(grid: List[List[str]]):\n    return grid\ngrid = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]\nassert f(g(grid)) == 9\n",
        "idx_generation": 203,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if not visited[node]:\n            visited[node] = True\n\n            if node == end:\n                return True\n\n            for neighbor in graph[node]:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 36,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of size n x n, find the minimum sum of a path from the top-left corner to the bottom-right corner of the grid.\nYou can only move down or right, but you can only visit each cell once.\"\"\"\n    dp = [[float('inf')] * n for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n        dp[0][i] = dp[0][i - 1] + grid[0][i]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[n - 1][n - 1]\ndef g(n: int, grid: List[List[int]]):\n    return grid\nassert f(3, g(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 71,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid, determine if it contains a valid path from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of characters, where '0' represents an obstacle and '1' represents an open path.\n    The valid path can only consist of rightward and downward movements.\n    Additionally, there are certain cells marked with 'S' that can be used to swap positions with another cell marked with 'T'.\n    If a swap occurs, the path can continue from the new cell in any direction.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        (x, y) = stack.pop()\n        if x == rows - 1 and y == cols - 1:\n            return True\n        if grid[x][y] == 'S':\n            for i in range(rows):\n                for j in range(cols):\n                    if grid[i][j] == 'T':\n                        grid[x][y], grid[i][j] = grid[i][j], grid[x][y]\n                        stack.append((i, j))\n        if x + 1 < rows and grid[x + 1][y] != '0':\n            stack.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] != '0':\n            stack.append((x, y + 1))\n    return False\n\ndef g():\n    return [['1', '1', '0', '1'],\n            ['0', 'S', '1', '0'],\n            ['1', '1', 'T', '1'],\n            ['1', '0', '1', '1']]\n\nassert f(g())\n",
        "idx_generation": 76,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, check if it forms a valid maze. A valid maze satisfies the following conditions:\n1. There is exactly one start ('S') and one goal ('G') in the maze.\n2. The maze is rectangular and has at least 2 rows and 2 columns.\n3. The maze can be traversed from the start to the goal by moving only up, down, left, or right.\n4. The maze may contain walls ('#') that cannot be crossed.\n5. The maze must be connected, meaning that there is a path from the start to the goal.\"\"\"\n    def is_valid_maze(grid):\n        n = len(grid)\n        m = len(grid[0])\n        start_count = 0\n        goal_count = 0\n        for row in grid:\n            if len(row) < 2:\n                return False\n            start_count += row.count('S')\n            goal_count += row.count('G')\n        if start_count != 1 or goal_count != 1:\n            return False\n        visited = [[False] * m for _ in range(n)]\n        def dfs(i, j):\n            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == '#' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i - 1, j)\n            dfs(i + 1, j)\n            dfs(i, j - 1)\n            dfs(i, j + 1)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'S':\n                    dfs(i, j)\n                    break\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'G' and not visited[i][j]:\n                    return False\n        return True\n    return is_valid_maze(grid)\ndef g(grid=[['#', '#', '#', '#', '#', '#', '#'], ['#', 'S', '#', '#', '#', '#', '#'], ['#', '.', '.', '.', '.', '.', '#'], ['#', '.', '#', '#', '#', '.', '#'], ['#', '.', '#', 'G', '#', '.', '#'], ['#', '.', '.', '.', '#', '.', '#'], ['#', '#', '#', '#', '#', '#', '#']]):\n    return grid\nassert f(g())\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of distinct integers and a target sum, find all unique combinations in the array that add up to the target sum.\n    Each number in the array may only be used once in each combination.\n    Return a list of lists containing all the unique combinations.\"\"\"\n    def backtrack(start, curr_sum, path):\n        if curr_sum == target:\n            result.append(path[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, curr_sum + nums[i], path)\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, 0, [])\n    return result\n\ndef g():\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]",
        "idx_generation": 88,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(arr: List[int], target_sum=10) -> bool:\n    \"\"\"Given a list of integers, find a subset of elements that sums up to a target value.\"\"\"\n    n = len(arr)\n    for r in range(1, n+1):\n        for subset in itertools.combinations(arr, r):\n            if sum(subset) == target_sum:\n                return True\n    return False\n\ndef g(target_sum=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g(nums=[5, 2, 7, 1, 4]):\n    return nums\n\nassert f(g()) == [1, 2, 4, 5, 7]\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there exists a pair of numbers in the list\n    whose sum is equal to the target number and the absolute difference between the two numbers is less than or equal\n    to k. Otherwise, return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            if abs(arr[left] - arr[right]) <= k:\n                return True\n            else:\n                left += 1\n                right -= 1\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[2, 4, 6, 8, 10], target=14, k=3):\n    return (arr, target, k)\n\nassert f(*g())\n",
        "idx_generation": 27,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target integer, find the minimum difference between the target and any element in the list.\n    Sample Input:\n    nums = [1, 5, 9, 13, 17]\n    target = 10\n    Sample Output:\n    1\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    min_diff = math.inf\n    while left <= right:\n        mid = (left + right) // 2\n        current_diff = abs(target - nums[mid])\n        min_diff = min(min_diff, current_diff)\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return min_diff\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 5, 9, 13, 17], 10))\n",
        "idx_generation": 338,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there is a number in the list whose binary representation has a '0' at the same position as the most significant bit (MSB) of another number in the list.\"\"\"\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if i != j:\n                if (nums[i] >> (nums[j].bit_length() - 1)) & 1 == 0:\n                    return True\n    return False\n\ndef g():\n    return ([5, 6, 7, 8, 9],)\n\nassert f(*g())\n",
        "idx_generation": 468,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three numbers from a given list of integers.\n    Return the maximum product.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g(nums=[-10, -3, 1, 2, 3, 4]):\n    return nums\n\nassert f(g()) == 120\n",
        "idx_generation": 235,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the number of possible paths from the top-left corner to the bottom-right corner in the given grid. You can only move down or right.\"\"\"\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1 or grid[m-1][n-1] == 1:\n        return 0\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(1, m):\n        dp[i][0] = 1 if grid[i][0] == 0 and dp[i-1][0] == 1 else 0\n    for j in range(1, n):\n        dp[0][j] = 1 if grid[0][j] == 0 and dp[0][j-1] == 1 else 0\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] if grid[i][j] == 0 else 0\n    return dp[m-1][n-1]\ndef g():\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nassert f(g()) == 2\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Traverse a matrix in a spiral order and return the elements in a list.\"\"\"\n    result = []\n    if not matrix:\n        return result\n    row_begin, row_end = 0, len(matrix) - 1\n    col_begin, col_end = 0, len(matrix[0]) - 1\n\n    while row_begin <= row_end and col_begin <= col_end:\n        # Traverse right\n        for i in range(col_begin, col_end + 1):\n            result.append(matrix[row_begin][i])\n        row_begin += 1\n\n        # Traverse down\n        for i in range(row_begin, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n\n        if row_begin <= row_end:\n            # Traverse left\n            for i in range(col_end, col_begin - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n\n        if col_begin <= col_end:\n            # Traverse up\n            for i in range(row_end, row_begin - 1, -1):\n                result.append(matrix[i][col_begin])\n            col_begin += 1\n\n    return result\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a permutation of the first n natural numbers\"\"\"\n    n = len(arr)\n    if set(arr) != set(range(1, n+1)):\n        return False\n    return True\n\ndef g(n: int) -> List[int]:\n    \"\"\"Generate a permutation of the first n natural numbers\"\"\"\n    return list(range(1, n+1))\n\nassert f(g(5))\n",
        "idx_generation": 106,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subarray in the list whose sum is equal to the target.\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == target:\n            return True\n        if prefix_sum - target in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g()) == True\n",
        "idx_generation": 46,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[str], target='abc') -> bool:\n    \"\"\"Given a list of strings and a target string, determine if there exists a subsequence of the list that forms the target string.\"\"\"\n    def is_subsequence(s, t):\n        i = j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                j += 1\n            i += 1\n        return j == len(t)\n\n    return any(is_subsequence(string, target) for string in arr)\n\ndef g(target='abc'):\n    arr = ['ab', 'ac', 'bc', 'abc', 'def']\n    return arr\n\nassert f(g())\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Given a list of integers and a value k, find the maximum sum of any subarray of length k.\"\"\"\n    if k > len(nums):\n        return 0\n    max_sum = sum(nums[:k])\n    current_sum = max_sum\n    for i in range(k, len(nums)):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    nums = [5, 7, 3, 9, 2, 1, 6]\n    k = 3\n    return (nums, k)\n\nassert f(*g()) == 19\n",
        "idx_generation": 137,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find two distinct numbers that add up to the target and return their indices.\"\"\"\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n    return []\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(*g(nums, target)) == [0, 1]\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers n and k, determine if n is a power of k.\n    Return True if n is a power of k, otherwise return False.\n    Sample Input:\n    n = 16, k = 2\n    Sample Output:\n    True\"\"\"\n    if n == 1:\n        return True\n    elif n % k == 0:\n        return f(n//k, k)\n    else:\n        return False\ndef g(n: int = 16, k: int = 2):\n    return n, k\nassert f(g()[0], g()[1])\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum\ndef g() -> List[int]:\n    return [-2, -3, 4, -1, -2, 1, 5, -3]\nassert f(g()) == 7\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target_sum: int) -> bool:\n    \"\"\"Given a list of positive integers and a target sum, determine if there exists a subset of the list\n    that adds up to the target sum. Return True if such a subset exists, False otherwise.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target_sum]\n\n\ndef g(arr: List[int], target_sum: int):\n    return (arr, target_sum)\n\n\nassert f(*g([2, 4, 6, 8], 10))\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, return the maximum subarray sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return (nums,)\nassert f(*g()) == 6\n",
        "idx_generation": 196,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list whose sum is equal to the target value.\n    - arr is the list of integers\n    - target is the target sum\"\"\"\n    stack = []\n    stack.append((0, 0))  # (index, current_sum)\n    while stack:\n        (index, current_sum) = stack.pop()\n        if current_sum == target:\n            return True\n        if index < len(arr):\n            stack.append((index + 1, current_sum + arr[index]))  # include the current element in the sum\n            stack.append((index + 1, current_sum))  # exclude the current element from the sum\n    return False\n\ndef g(arr=[2, 4, 6, 8], target=10):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10, k=3) -> bool:\n    \"\"\"Find if there exists a combination of k numbers in nums that sum up to the target.\"\"\"\n    def helper(nums, target, k):\n        if target == 0 and k == 0:\n            return True\n        if target < 0 or k == 0 or not nums:\n            return False\n        include = helper(nums[1:], target - nums[0], k - 1)\n        exclude = helper(nums[1:], target, k)\n        return include or exclude\n    \n    return helper(nums, target, k)\n\ndef g(target=10, k=3):\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Find all unique combinations of numbers in the list that add up to the target value.\"\"\"\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            res.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            if curr_sum + nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(i, path, curr_sum + nums[i])\n            path.pop()\n\n    res = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return res\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Return the list of numbers and the target value.\"\"\"\n    return nums, target\n\nassert f(*g([2, 3, 6, 7], 7)) == [[2, 2, 3], [7]]\n",
        "idx_generation": 325,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Check if the target number appears in the grid diagonally from top-left to bottom-right.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    for i in range(min(n, m)):\n        if grid[i][i] == target:\n            return True\n    return False\n\ndef g(grid: List[List[int]], target: int):\n    return grid\n\ngrid = [[1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]]\ntarget = 5\n\nassert f(g(grid, target), target)\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down, right, or diagonally.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = grid[i - 1][j - 1] + max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    \n    return dp[m][n]\n\ndef g(grid: List[List[int]]):\n    return grid\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(grid)) == 29\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, determine if it is possible to make s\n    palindrome by removing exactly k characters from it. Return True if it is possible,\n    otherwise return False.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    def helper(s: str, k: int) -> bool:\n        if len(s) <= 1:\n            return True\n        \n        if s[0] == s[-1]:\n            return helper(s[1:-1], k)\n        \n        if k == 0:\n            return False\n        \n        return helper(s[1:], k-1) or helper(s[:-1], k-1)\n    \n    return helper(s, k) or is_palindrome(s) and k % 2 == 0\ndef g():\n    s = \"racecar\"\n    k = 2\n    return s, k\nassert f(*g())\n",
        "idx_generation": 54,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the k-th bit of n is set to 1.\"\"\"\n    return (n >> k) & 1 == 1\ndef g(n: int, k: int):\n    return n | (1 << k)\nassert f(g(10, 3), 3)\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Determine if there exists a subset of nums such that the bitwise XOR of all the numbers in the subset is equal to k.\"\"\"\n    def count_subsets(nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(1, 1 << len(nums)):\n            subset_xor = 0\n            for j in range(len(nums)):\n                if i & (1 << j):\n                    subset_xor ^= nums[j]\n            if subset_xor == k:\n                count += 1\n        return count\n    return count_subsets(nums, k) > 0\ndef g(nums: List[int], k: int):\n    return nums\nassert f(g(nums=[1, 2, 3, 4, 5], k=6), k=6)\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Check if there exists k unique prime numbers that sum up to n.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    def backtrack(curr_sum, count, start):\n        if curr_sum == n and count == k:\n            return True\n        if curr_sum > n or count > k:\n            return False\n        for i in range(start, n+1):\n            if is_prime(i):\n                if backtrack(curr_sum + i, count + 1, i + 1):\n                    return True\n        return False\n    return backtrack(0, 0, 2)\ndef g():\n    n = 20\n    return n\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=2) -> bool:\n    \"\"\"Check if n is a perfect power of k\"\"\"\n    if n == 1:\n        return True\n    if n % k != 0:\n        return False\n    return f(n // k, k)\ndef g(k=2):\n    n = 1\n    while True:\n        if f(n, k):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. You can only move down or right.\nSample Input:\ngrid = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\nSample Output:\n7\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\nassert f(g()) > 0\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if the given string s can be divided into k non-empty substrings, where each substring is a palindrome.\"\"\"\n    if len(s) % k != 0:\n        return False\n    substring_length = len(s) // k\n    for i in range(0, len(s), substring_length):\n        substring = s[i:i+substring_length]\n        if substring != substring[::-1]:\n            return False\n    return True\ndef g():\n    return ('aabbaabb', 4)\nassert f(*g())\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int, max_distance: int) -> bool:\n    \"\"\"Given a graph represented as a dictionary and two nodes start and end, check if there is a path from start to end in the graph with a total distance not exceeding max_distance using a breadth-first search.\"\"\"\n    visited = set()\n    queue = [(start, 0)]\n    while queue:\n        node, distance = queue.pop(0)\n        if node == end and distance <= max_distance:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, distance + 1))\n    return False\n\ndef g():\n    return ({1: [2, 3], 2: [4, 5], 3: [6], 4: [7], 5: [7], 6: [7], 7: []}, 1, 7, 5)\n\nassert f(*g())\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there is a path from the start node to the end node.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        current_node = stack.pop()\n        if current_node == end:\n            return True\n        if not visited[current_node]:\n            visited[current_node] = True\n            for neighbor in range(len(graph[current_node])):\n                if graph[current_node][neighbor] == 1:\n                    stack.append(neighbor)\n    return False\n\ndef g():\n    return [[0, 1, 1, 0],\n            [1, 0, 0, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0]]\n\nassert f(g(), 0, 3)\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of 0s and 1s, count the number of islands. An island is defined as a group of connected 1s (horizontally or vertically).\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or matrix[i][j] == 0 or visited[i][j]:\n            return\n        visited[i][j] = True\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 1 and not visited[i][j]:\n                dfs(i, j)\n                count += 1\n\n    return count\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 1],\n            [0, 0, 0, 1, 1],\n            [0, 0, 0, 0, 0],\n            [1, 0, 1, 1, 1]]\n\nassert f(g()) == 4\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to navigate from the top-left corner to the bottom-right corner,\n    moving only downwards or to the right, and visiting only cells with a value of 1.\n    Sample Input:\n    grid = [\n        [1, 0, 0],\n        [1, 1, 0],\n        [1, 1, 1]\n    ]\n    Sample Output:\n    True\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        row, col = stack.pop()\n        if row == rows-1 and col == cols-1:\n            return True\n        if row+1 < rows and grid[row+1][col] == 1:\n            stack.append((row+1, col))\n        if col+1 < cols and grid[row][col+1] == 1:\n            stack.append((row, col+1))\n    return False\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 0, 0], [1, 1, 0], [1, 1, 1]]))\n",
        "idx_generation": 83,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner in a grid. You can only move down or right, and can only visit each cell once.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    def dfs(i: int, j: int, path_sum: int) -> int:\n        if i == rows - 1 and j == cols - 1:\n            return path_sum + matrix[i][j]\n        if i + 1 < rows and j + 1 < cols:\n            return max(dfs(i + 1, j, path_sum + matrix[i][j]), dfs(i, j + 1, path_sum + matrix[i][j]))\n        elif i + 1 < rows:\n            return dfs(i + 1, j, path_sum + matrix[i][j])\n        elif j + 1 < cols:\n            return dfs(i, j + 1, path_sum + matrix[i][j])\n        else:\n            return path_sum + matrix[i][j]\n    \n    return dfs(0, 0, 0)\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix)) == 29\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to express n as the sum of positive integers.\"\"\"\n    def count_ways(n, m):\n        if n == 0:\n            return 1\n        elif n < 0 or m <= 0:\n            return 0\n        else:\n            return count_ways(n, m-1) + count_ways(n-m, m)\n    return count_ways(n, n)\ndef g():\n    return 6\nassert f(g()) == 11\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, return the number of ways to choose k items from a set of n items.\n    The order of the items does not matter.\"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g(n: int, k: int):\n    return (n, k)\n\nassert f(*g(5, 2)) == 10\n",
        "idx_generation": 495,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists a pair of elements that sum up to a given target value.\n\n    Args:\n    - arr: A list of integers, sorted in ascending order\n\n    Returns:\n    - True if there exists a pair of elements that sum up to the target value, False otherwise\n    \"\"\"\n    target = 10\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 123,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Find the longest increasing subsequence in the given array.\"\"\"\n    n = len(arr)\n    lengths = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lengths[i] < lengths[j] + 1:\n                lengths[i] = lengths[j] + 1\n    max_length = max(lengths)\n    subsequence = []\n    for i in range(n - 1, -1, -1):\n        if lengths[i] == max_length:\n            subsequence.append(arr[i])\n            max_length -= 1\n    return subsequence[::-1]\n\ndef g():\n    return [3, 1, 5, 2, 4, 9, 7, 6, 8]\n\nassert f(g()) == [1, 2, 4, 6, 8]\n",
        "idx_generation": 34,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two distinct indices i and j in the array such that arr[i] + arr[j] equals the target value.\"\"\"\n    n = len(arr)\n    left, right = 0, n - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 344,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum XOR value between any two elements in the array.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        prefix_set = set()\n        mask |= (1 << i)\n        for num in arr:\n            prefix_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if (temp ^ prefix) in prefix_set:\n                max_xor = temp\n                break\n    return max_xor\ndef g(arr=[3, 10, 5, 25, 2, 8]):\n    return arr\nassert f(g()) == 28\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if the given list of integers is sorted in non-decreasing order and contains a perfect square\"\"\"\n    sorted_nums = sorted(nums)\n    for i in range(len(sorted_nums) - 1):\n        if sorted_nums[i] > sorted_nums[i + 1]:\n            return False\n    for num in sorted_nums:\n        if int(num ** 0.5) ** 2 == num:\n            return True\n    return False\n\ndef g():\n    return [5, 2, 1, 3, 4, 9, 6, 7, 8]\n\nassert f(g())\n",
        "idx_generation": 241,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix 'graph', determine if it represents a valid directed acyclic graph (DAG).\nReturn True if it is a DAG, False otherwise.\"\"\"\n    n = len(graph)\n    in_degree = [0] * n\n    \n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 1:\n                in_degree[j] += 1\n    \n    queue = []\n    \n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    count = 0\n    \n    while queue:\n        node = queue.pop(0)\n        count += 1\n        \n        for i in range(n):\n            if graph[node][i] == 1:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    queue.append(i)\n    \n    return count == n\n\ndef g():\n    graph = [\n        [0, 1, 1, 1],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return (graph,)\n\nassert f(*g()) == True\n",
        "idx_generation": 337,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num_courses: int, prerequisites: List[List[int]]) -> bool:\n    \"\"\"\n    Given the total number of courses and a list of prerequisite pairs,\n    determine if it is possible to finish all courses.\n    Return True if it is possible, otherwise return False.\n\n    Example:\n    num_courses = 4, prerequisites = [[1,0],[2,1],[3,2]]\n    Output: True\n\n    Explanation: To finish all courses, you must take all courses in the correct order:\n    0 -> 1 -> 2 -> 3\n    \"\"\"\n    graph = [[] for _ in range(num_courses)]\n    in_degree = [0] * num_courses\n\n    for course, prerequisite in prerequisites:\n        graph[prerequisite].append(course)\n        in_degree[course] += 1\n\n    queue = []\n    for course in range(num_courses):\n        if in_degree[course] == 0:\n            queue.append(course)\n\n    visited = 0\n    while queue:\n        curr_course = queue.pop(0)\n        visited += 1\n\n        for neighbor in graph[curr_course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return visited == num_courses\n\n\ndef g() -> Tuple[int, List[List[int]]]:\n    return 4, [[1,0],[2,1],[3,2]]\n\n\nassert f(*g())\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid is symmetric along its main diagonal.\"\"\"\n    n = len(grid)\n    for i in range(n):\n        for j in range(i+1, n):\n            if grid[i][j] != grid[j][i]:\n                return False\n    return True\ndef g(grid=[[1, 2, 3], [2, 4, 5], [3, 5, 6]]):\n    \"\"\"Generate a grid such that it is symmetric along its main diagonal.\"\"\"\n    return grid\nassert f(g())\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find the indices of two numbers in the given list that sum up to the target.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all the multiples of 3 or 5 below n.\"\"\"\n    def helper(n):\n        if n <= 0:\n            return 0\n        if n % 3 == 0 or n % 5 == 0:\n            return n + helper(n - 1)\n        else:\n            return helper(n - 1)\n    return helper(n - 1)\n\ndef g():\n    return 100\n\nassert f(g()) == 2318\n",
        "idx_generation": 55,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be split into two non-empty substrings such that both substrings have the same number of '0's and '1's.\"\"\"\n    def helper(s, i, count0, count1):\n        if i == len(s):\n            return count0 == count1 and count0 != 0\n        if count0 == count1 and count0 != 0:\n            return True\n        if s[i] == '0':\n            return helper(s, i + 1, count0 + 1, count1)\n        elif s[i] == '1':\n            return helper(s, i + 1, count0, count1 + 1)\n        else:\n            return helper(s, i + 1, count0, count1) or helper(s, i + 1, count0 + 1, count1)\n    return helper(s, 0, 0, 0)\ndef g():\n    return '101010'\nassert f(g())\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a palindrome.\"\"\"\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n    return digits == digits[::-1]\n\ndef g(n: int) -> int:\n    \"\"\"Find the next palindrome number greater than n.\"\"\"\n    n += 1\n    while not f(n):\n        n += 1\n    return n\n\nn = 12321\nassert f(g(n))\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 17\n    return n\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list such that the sum of its elements is a Fibonacci number.\"\"\"\n    def is_fibonacci(n: int) -> bool:\n        if n <= 1:\n            return True\n        a, b = 0, 1\n        while b < n:\n            a, b = b, a + b\n        return b == n\n    \n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            if is_fibonacci(prefix_sum[j] - prefix_sum[i]):\n                return True\n    \n    return False\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the sum of all numbers that are divisible by 3 or 5.\"\"\"\n    total = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            total += num\n\n    return total\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that sums up to the target.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\ndef g():\n    return [2, 4, 6, 8, 10], 18\n\nassert f(*g()) == True\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find a subarray that sums up to the target, and return its start and end indices.\"\"\"\n    prefix_sum = {0: -1}\n    curr_sum = 0\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum - target in prefix_sum:\n            return [prefix_sum[curr_sum - target] + 1, i]\n        prefix_sum[curr_sum] = i\n    return []\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 15\nassert f(*g(nums, target)) == [0, 4]\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a valid path from the top-left corner to the bottom-right corner in the given grid\"\"\"\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        x, y = stack.pop()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if x == m-1 and y == n-1:\n            return True\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0:\n                stack.append((nx, ny))\n    return False\n\ndef g():\n    grid = [[0, 1, 0, 0, 0],\n            [0, 0, 0, 1, 0],\n            [1, 1, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, nums=[1, 2, 3, 4, 5], target=10) -> bool:\n    \"\"\"Find if there exists a combination of numbers in nums that sum up to the target using dynamic programming.\"\"\"\n    def helper(nums, target):\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for num in nums:\n            for i in range(target, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n        return dp[target]\n    return helper(nums, target)\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    return nums\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the nth Fibonacci number.\n\n    Args:\n        n: The positive integer.\n\n    Returns:\n        The nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    \n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g():\n    \"\"\"\n    Returns a sample positive integer.\n    \"\"\"\n    return 7\n\nassert f(g()) == 13\n",
        "idx_generation": 333,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of all elements in the given grid.\"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    return total_sum\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 45\n",
        "idx_generation": 208,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid of characters, check if it contains a valid word formed by connecting adjacent characters.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    word = ''\n    visited = [[False] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        nonlocal word\n\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:\n            return\n\n        visited[row][col] = True\n        word += grid[row][col]\n\n        if word == \"STACK\":\n            return True\n\n        if dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1):\n            return True\n\n        visited[row][col] = False\n        word = word[:-1]\n\n        return False\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j):\n                return True\n\n    return False\n\ndef g() -> List[List[str]]:\n    return [['S', 'T', 'A', 'C', 'K'],\n            ['A', 'B', 'C', 'D', 'E'],\n            ['K', 'L', 'M', 'N', 'O'],\n            ['P', 'Q', 'R', 'S', 'T'],\n            ['U', 'V', 'W', 'X', 'Y']]\n            \nassert f(g())\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\nassert f(g())\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find if there exists a pair of numbers in the given list that XOR to the target value.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g())\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of numbers in the given list whose XOR is equal to the target.\n    The subset should contain exactly three elements.\"\"\"\n    n = len(nums)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                xor = nums[i] ^ nums[j] ^ nums[k]\n                if xor == target:\n                    return True\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 7)\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the n-th Fibonacci number using dynamic programming.\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n    Return the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\n\ndef g():\n    n = 10\n    return n\n\n\nassert f(g()) == 55\n",
        "idx_generation": 8,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the integers that add up to the target.\n    - nums: List of integers\n    - target: Target number\n    \"\"\"\n    def helper(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i == len(nums):\n            return False\n        return helper(i + 1, curr_sum + nums[i]) or helper(i + 1, curr_sum)\n\n    return helper(0, 0)\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 9)\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the sum of the digits in n is divisible by 3.\"\"\"\n    digit_sum = sum(int(d) for d in str(n))\n    return digit_sum % 3 == 0\ndef g(n: int):\n    return n\nassert f(g(12345), 12345)\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str, max_distance: int) -> bool:\n    \"\"\"Given a graph represented as a dictionary and two nodes start and end, check if there is a path from start to end in the graph with a total distance not exceeding max_distance using an optimized depth-first search.\"\"\"\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, distance = stack.pop()\n        if node == end and distance <= max_distance:\n            return True\n        visited.add(node)\n        if distance < max_distance:\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append((neighbor, distance + 1))\n    return False\n\ndef g():\n    return ({'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['E'], 'E': []}, 'A', 'E', 3)\n\nassert f(*g())\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there is a path from start\n    to end using a depth-first search algorithm.\n    Sample input:\n    {1: [2, 3], 2: [4], 3: [4], 4: []}, 1, 4\n    Sample output:\n    True\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return {1: [2, 3], 2: [4], 3: [4], 4: []}, 1, 4\n\nassert f(*g())\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges, determine if the graph contains a cycle.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    \n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    visited = [False] * n\n    stack = [False] * n\n    \n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    return (n, edges)\n\nassert f(*g())\n",
        "idx_generation": 89,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there exists a path from the start node to the end node.\n    Return True if a path exists, otherwise return False.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, visited, start, end)\n\ndef dfs(graph: List[List[int]], visited: List[bool], curr: int, end: int) -> bool:\n    visited[curr] = True\n    if curr == end:\n        return True\n    for i in range(len(graph[curr])):\n        if graph[curr][i] == 1 and not visited[i]:\n            if dfs(graph, visited, i, end):\n                return True\n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 1, 0, 0],\n            [1, 0, 0, 1, 0],\n            [1, 0, 0, 0, 1],\n            [0, 1, 0, 0, 1],\n            [0, 0, 1, 1, 0]]\n\nstart = 0\nend = 4\nassert f(g(), start, end)\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from top-left to bottom-right in the grid.\"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1:\n            return False\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return True\n        grid[i][j] = 1\n        return dfs(i+1, j) or dfs(i, j+1) or dfs(i-1, j) or dfs(i, j-1)\n    \n    return dfs(0, 0)\ndef g():\n    return ([[0, 0, 0], [0, 1, 0], [0, 0, 0]],)\nassert f(*g())\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two positive integers n and k, calculate the number of possible k-length sequences\n    such that each element is a non-negative integer less than or equal to n, and the sum of the\n    sequence is equal to n.\"\"\"\n    def calculate_sequences(n, k, curr_sum, count):\n        if curr_sum == n and count == k:\n            return 1\n        if curr_sum > n or count > k:\n            return 0\n        res = 0\n        for i in range(n+1):\n            res += calculate_sequences(n, k, curr_sum + i, count + 1)\n        return res\n    \n    return calculate_sequences(n, k, 0, 0)\n\ndef g(n=5, k=3):\n    return (n, k)\n\nassert f(*g()) == 21\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"Determine if the sum of any k numbers in the array is equal to the target number.\"\"\"\n    arr.sort()\n    n = len(arr)\n    stack = []\n    for i in range(n):\n        stack.append(arr[i])\n        if len(stack) == k:\n            if sum(stack) == target:\n                return True\n            stack.pop(0)\n    return False\n\ndef g(arr: List[int], target: int, k: int) -> List[int]:\n    \"\"\"Generate a sequence of k elements from the array that sums up to the target number.\"\"\"\n    arr.sort()\n    n = len(arr)\n    stack = []\n    for i in range(n):\n        stack.append(arr[i])\n        if len(stack) == k:\n            if sum(stack) == target:\n                return stack\n            stack.pop(0)\n    return []\n\narr = [1, 4, 2, 3, 5]\ntarget = 9\nk = 3\nassert f(g(arr, target, k), target, k)\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, determine if the target value exists in the grid.\n    The grid is sorted in non-decreasing order from left to right and top to bottom.\n    Return True if the target value exists in the grid, otherwise return False.\n    \"\"\"\n    def helper(grid, target, row, col):\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\n            return False\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            return helper(grid, target, row + 1, col)\n        else:\n            return helper(grid, target, row, col - 1)\n    \n    if len(grid) == 0:\n        return False\n    return helper(grid, target, 0, len(grid[0]) - 1)\n\ndef g(grid=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 38,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given array in ascending order using the merge sort algorithm.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = f(arr[:mid])\n    right = f(arr[mid:])\n    return merge(left, right)\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    merged = []\n    i = 0\n    j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged\ndef g(arr: List[int]):\n    return arr\nassert f(g([4, 2, 7, 1, 5, 3])) == [1, 2, 3, 4, 5, 7]\n",
        "idx_generation": 382,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists a pair of elements whose bitwise XOR is equal to the target value.\n    Returns True if such a pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        xor_val = arr[left] ^ arr[right]\n        if xor_val == target:\n            return True\n        elif xor_val < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[2, 4, 6, 8, 10], target=0):\n    return arr\n\nassert f(g(), target=14)\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the sum of the first n positive integers.\"\"\"\n    return n * (n + 1) // 2\n\ndef g():\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 246,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str, k: int, grid: List[List[str]]) -> bool:\n    \"\"\"Given a string and a grid of letters, determine if it is possible to form the string by traversing adjacent cells in the grid.\nThe string can be formed by moving up, down, left, or right in the grid, but not diagonally.\nEach cell in the grid can only be used once.\nAdditionally, each letter in the string must be visited exactly k times.\nReturn True if it is possible, False otherwise.\"\"\"\n\n    def dfs(i: int, j: int, idx: int) -> bool:\n        if idx == len(s):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or (j >= len(grid[0])) or (visited[i][j] >= k) or (grid[i][j] != s[idx]):\n            return False\n        visited[i][j] += 1\n        found = dfs(i + 1, j, idx + 1) or dfs(i - 1, j, idx + 1) or dfs(i, j + 1, idx + 1) or dfs(i, j - 1, idx + 1)\n        visited[i][j] -= 1\n        return found\n\n    visited = [[0] * len(grid[0]) for _ in range(len(grid))]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(s: str, k: int, grid: List[List[str]]):\n    return (s, k, grid)\n\ngrid = [['A', 'B', 'C', 'D'], ['E', 'A', 'B', 'C'], ['D', 'E', 'F', 'A'], ['B', 'C', 'D', 'E']]\ns = 'ABC'\nk = 1\nassert f(*g(s, k, grid))\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a permutation of the first n natural numbers.\"\"\"\n    n = len(nums)\n    target_sum = n * (n + 1) // 2\n    return sum(nums) == target_sum and len(set(nums)) == n\n\ndef g() -> List[int]:\n    return [3, 1, 2, 4]\n\nassert f(g())\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Determine if there exists a subarray in the given list whose sum is divisible by k.\"\"\"\n    prefix_sum = 0\n    mods = {0}\n    for num in nums:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in mods:\n            return True\n        mods.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, 7, 2, 6, 10, 8, 3]\n\nassert f(g(), 5)\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> bool:\n    \"\"\"Find whether it is possible to rearrange the characters of the input string to form a palindrome.\"\"\"\n    perms = permutations(s)\n    for perm in perms:\n        if perm == perm[::-1]:\n            return True\n    return False\ndef g(s=\"racecar\"):\n    return s\nassert f(g())\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s, determine if it can be divided into k equal parts.\"\"\"\n    if len(s) % k != 0:\n        return False\n    part_length = len(s) // k\n    for i in range(0, len(s), part_length):\n        if s[i:i + part_length] != s[:part_length]:\n            return False\n    return True\n\ndef g(s=\"abcabcabcabc\", k=4):\n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than or equal to n that are divisible by either 3 or 5\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n    return total\n\ndef g():\n    return 100\n\nassert f(g()) == 2418\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is an arithmetic sequence.\"\"\"\n    if len(nums) <= 2:\n        return True\n\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n\n    return True\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g())\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers `arr`, return True if there exists a subarray with a sum equal to 0, otherwise return False.\"\"\"\n    n = len(arr)\n    prefix_sum = 0\n    prefix_sums = set()\n    for i in range(n):\n        prefix_sum += arr[i]\n        if prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g(arr=[-1, 2, -3, 1, 6]):\n    return (arr,)\n\nassert f(*g())\n",
        "idx_generation": 442,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Check if the given string matches the given pattern, where the pattern can contain both letters and wildcard characters '?' (matches any single character) and '*' (matches any sequence of characters).\"\"\"\n    def helper(s_index, pattern_index):\n        if s_index == len(s) and pattern_index == len(pattern):\n            return True\n        if s_index == len(s) or pattern_index == len(pattern):\n            return False\n        \n        if pattern[pattern_index] == '?':\n            return helper(s_index + 1, pattern_index + 1)\n        elif pattern[pattern_index] == '*':\n            return helper(s_index + 1, pattern_index) or helper(s_index, pattern_index + 1)\n        elif s[s_index] == pattern[pattern_index]:\n            return helper(s_index + 1, pattern_index + 1)\n        \n        return False\n    \n    return helper(0, 0)\n    \ndef g():\n    return ('hello', 'h?llo')\n    \nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(exp: str) -> bool:\n    \"\"\"Given a string representing a mathematical expression, determine if the parentheses in the expression are balanced.\n    The expression can contain the following characters: '(', ')', '+', '-', '*', '/'.\"\"\"\n    stack = []\n    \n    for char in exp:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0 or stack[-1] != '(':\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g(exp: str):\n    return exp\n\nassert f(g(\"(2+3)*(4-5)\"))\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    You can only move down or right in the grid. Each cell represents the cost to pass through that cell.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 25,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if it is possible to reach the bottom-right corner of a grid starting from the top-left corner.\n    You can only move down or right. The grid is represented as a matrix.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[False] * cols for _ in range(rows)]\n    \n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return True\n        if memo[i][j]:\n            return False\n        memo[i][j] = True\n        if i + 1 < rows and grid[i + 1][j] != 1:\n            if dfs(i + 1, j):\n                return True\n        if j + 1 < cols and grid[i][j + 1] != 1:\n            if dfs(i, j + 1):\n                return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[0, 0, 0], [0, 1, 0], [0, 0, 0]])) == True\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if the given grid forms a perfect square.\n    A perfect square grid has the same number of rows and columns, and all sides are equal in length.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0 or rows != cols:\n        return False\n    side_length = rows\n    for i in range(rows):\n        if len(grid[i]) != cols:\n            return False\n    return all(len(row) == cols for row in grid) and all(len(row) == side_length for row in grid)\n\ndef g(n: int) -> List[List[int]]:\n    \"\"\"Generate a grid that forms a perfect square.\n    The generated grid will have n rows and n columns, forming a perfect square.\n    \"\"\"\n    return [[1] * n] * n\n\nassert f(g(n=4))\n",
        "idx_generation": 210,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner \n    starting from the top-left corner. You can only move right or down.\n    Sample Input:\n    grid = [\n        [1, 1, 1],\n        [1, 0, 1],\n        [0, 1, 1]\n    ]\n    Sample Output:\n    True\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True\n\n    for i in range(1, rows):\n        if grid[i][0] == 1 and dp[i-1][0]:\n            dp[i][0] = True\n\n    for j in range(1, cols):\n        if grid[0][j] == 1 and dp[0][j-1]:\n            dp[0][j] = True\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 1 and (dp[i-1][j] or dp[i][j-1]):\n                dp[i][j] = True\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return [[1, 1, 1], [1, 0, 1], [0, 1, 1]]\n\nassert f(g([[1, 1, 1], [1, 0, 1], [0, 1, 1]]))\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python', k=2) -> bool:\n    \"\"\"Find the longest substring of s that contains all characters of the target string using dynamic programming\"\"\"\n    n, m = len(s), len(target)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    max_len = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == target[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_len = max(max_len, dp[i][j])\n    return max_len == m\ndef g(target='python', k=2):\n    return target * k\nassert f(g())\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value between any two numbers in the list.\n    XOR is a bitwise operation where 0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, and 1 ^ 1 = 0.\n    \"\"\"\n    def max_xor(arr):\n        max_xor = float('-inf')\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                xor = arr[i] ^ arr[j]\n                if xor > max_xor:\n                    max_xor = xor\n        return max_xor\n    \n    return max_xor(arr)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return (arr,)\n\nassert f(*g()) == 7\n",
        "idx_generation": 58,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the minimum number of elements from the list\n    whose bitwise XOR results in the target number.\"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] = min(dp[i], dp[i - num] + 1)\n    \n    return dp[target]\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    return nums, target\n\nnums = [2, 4, 6, 8]\ntarget = 10\nassert f(*g(nums, target)) == 2\n",
        "idx_generation": 433,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell of the matrix from the top-left cell by moving only down or right, and the sum of the chosen path is a prime number.\"\"\"\n    assert all(len(row) == len(matrix[0]) for row in matrix)\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    def helper(i, j, curr_sum):\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return is_prime(curr_sum + matrix[i][j])\n        if i < len(matrix) - 1 and helper(i + 1, j, curr_sum + matrix[i][j]):\n            return True\n        if j < len(matrix[0]) - 1 and helper(i, j + 1, curr_sum + matrix[i][j]):\n            return True\n        return False\n    return helper(0, 0, 0)\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g())\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of different ways to climb to the top of a staircase with n steps. You can climb either 1 or 2 steps at a time.\nReturn the number of distinct ways.\"\"\"\n    def count_ways(n):\n        if n <= 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n    return count_ways(n)\ndef g():\n    return 5\nassert f(g()) == 8\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the target string is a rotation of the given string.\"\"\"\n    if len(s) != len(target):\n        return False\n    concatenated = s + s\n    return target in concatenated\ndef g():\n    s = \"programming\"\n    target = \"grammingpro\"\n    return (s, target)\nassert f(g()[0], g()[1])\n",
        "idx_generation": 383,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers and a target integer, find two numbers in the array that sum up to the target.\n    Return the indices of the two numbers.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15, 8, 3]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == [0, 4]\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], start=0, target=4) -> bool:\n    \"\"\"Check if there is a path from a start node to a target node in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == target:\n            return True\n\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n\n    return False\n\ndef g():\n    return [[1, 2],\n            [2, 3],\n            [3],\n            [4],\n            []]\n\nassert f(g())\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> bool:\n    \"\"\"Check if a binary tree is a binary search tree.\"\"\"\n    def helper(node, lower, upper):\n        if not node:\n            return True\n        if node.val <= lower or node.val >= upper:\n            return False\n        return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n    \n    return helper(root, float('-inf'), float('inf'))\n\ndef g():\n    root = Node(4)\n    root.left = Node(2)\n    root.right = Node(6)\n    root.left.left = Node(1)\n    root.left.right = Node(3)\n    root.right.left = Node(5)\n    root.right.right = Node(7)\n    return root\n\nassert f(g())\n",
        "idx_generation": 94,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], src: int, dst: int) -> bool:\n    \"\"\"Check if there exists a path from 'src' to 'dst' in the given graph.\"\"\"\n    def dfs(graph, src, dst, visited):\n        visited[src] = True\n        if src == dst:\n            return True\n        for neighbor in graph[src]:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, dst, visited):\n                    return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, src, dst, visited)\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [0, 3],\n        3: [3]\n    }\n    src = 2\n    dst = 3\n    return graph, src, dst\n\nassert f(*g())\n",
        "idx_generation": 97,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, s: str) -> bool:\n    \"\"\"Given a grid of size n x m filled with characters 'X' and 'O', determine if it is possible to reach from the top-left corner to the bottom-right corner by only moving right or down. However, the path must not contain any 'X' characters.\nSample Input:\nn = 3, m = 4, s = \"OOOOOXOOOXOO\"\nSample Output:\nTrue\"\"\"\n    grid = [[s[i * m + j] for j in range(m)] for i in range(n)]\n    \n    def dfs(i, j):\n        if i == n-1 and j == m-1:\n            return True\n        if i < n-1 and grid[i+1][j] != 'X' and dfs(i+1, j):\n            return True\n        if j < m-1 and grid[i][j+1] != 'X' and dfs(i, j+1):\n            return True\n        return False\n    \n    return grid[0][0] != 'X' and dfs(0, 0)\n    \ndef g(n: int, m: int, s: str):\n    possible_paths = []\n    def backtrack(i, j, path):\n        if i == n-1 and j == m-1:\n            possible_paths.append(path)\n            return\n        if i < n-1 and s[(i+1)*m + j] != 'X':\n            backtrack(i+1, j, path + 'D')\n        if j < m-1 and s[i*m + j+1] != 'X':\n            backtrack(i, j+1, path + 'R')\n    backtrack(0, 0, '')\n    return possible_paths[0]\n\nassert f(3, 4, \"OOOOOXOOOXOO\") == True\nassert g(3, 4, \"OOOOOXOOOXOO\") in ['DDRRR', 'DRDRR', 'DRRDR', 'RRDDR', 'RRDRD']\n\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(t: str, s='cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa', target=43) -> bool:\n    \"\"\"Given a string consisting of lowercase letters, find the number of distinct subsequences that can be formed\n    by rearranging the characters of the string.\n    Sample Input:\n    `\"abc\"`\n    Sample Output:\n    `6`\"\"\"\n    def count_subsequences(s):\n        n = len(s)\n        dp = [0] * (n+1)\n        dp[0] = 1\n        last_occurrence = {}\n        for i in range(1, n+1):\n            dp[i] = 2 * dp[i-1]\n            if s[i-1] in last_occurrence:\n                dp[i] -= dp[last_occurrence[s[i-1]] - 1]\n            last_occurrence[s[i-1]] = i\n        return dp[n]\n    return count_subsequences(t) >= target\ndef g(s='cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa', target=43):\n    return s[:1] + ''.join([b for (a, b) in zip(s, s[1:]) if b != a])\nassert f(g())\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Determine if the array can be sorted using a stack and a queue.\"\"\"\n    stack = []\n    queue = []\n    n = len(arr)\n    for i in range(n):\n        if len(stack) == 0 or arr[i] >= stack[-1]:\n            stack.append(arr[i])\n        elif len(queue) == 0 or arr[i] <= queue[0]:\n            queue.insert(0, arr[i])\n        else:\n            return False\n    return True\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Generate a sequence of elements that can be used to sort the array using a stack and a queue.\"\"\"\n    stack = []\n    queue = []\n    n = len(arr)\n    for i in range(n):\n        if len(stack) == 0 or arr[i] >= stack[-1]:\n            stack.append(arr[i])\n        elif len(queue) == 0 or arr[i] <= queue[0]:\n            queue.insert(0, arr[i])\n        else:\n            return []\n    return stack + queue[::-1]\n\narr = [1, 4, 2, 3, 5]\nassert f(g(arr))\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted array of integers and a target value, use binary search to find the index of the target value in the array.\n        If the target value is not present, return -1.\n\"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    target = 16\n    return (arr, target)\n\nassert f(*g()) == 7\n",
        "idx_generation": 57,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the Quick Sort algorithm.\"\"\"\n    def partition(arr, low, high):\n        i = low - 1\n        pivot = arr[high]\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i = i + 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n    def quick_sort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n            quick_sort(arr, low, pi - 1)\n            quick_sort(arr, pi + 1, high)\n    n = len(nums)\n    quick_sort(nums, 0, n - 1)\n    return nums\ndef g():\n    return [64, 34, 25, 12, 22, 11, 90]\nassert f(g()) == [11, 12, 22, 25, 34, 64, 90]\n",
        "idx_generation": 409,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that XOR to the target.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 13\nassert f(*g())\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers in the list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 720\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the length of the longest increasing path.\nA path is considered increasing if all the adjacent cells have a greater value.\"\"\"\n    if not matrix:\n        return 0\n    rows = len(matrix)\n    cols = len(matrix[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    def dfs(row, col):\n        if memo[row][col]:\n            return memo[row][col]\n        max_length = 1\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] > matrix[row][col]:\n                max_length = max(max_length, dfs(new_row, new_col) + 1)\n        memo[row][col] = max_length\n        return max_length\n    longest_path = 0\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n    return longest_path\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return (matrix,)\nassert f(*g()) == 4\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and an integer k, return the k most frequent elements in the list.\"\"\"\n    frequency_map = {}\n    for num in nums:\n        frequency_map[num] = frequency_map.get(num, 0) + 1\n    sorted_nums = sorted(frequency_map.items(), key=lambda x: x[1], reverse=True)\n    return [num for num, _ in sorted_nums[:k]]\n\ndef g():\n    return ([1, 2, 3, 4, 5, 1, 2, 3, 4, 1, 2, 1, 1], 3)\n\nassert f(*g()) == [1, 2, 3]\n",
        "idx_generation": 188,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"Given an integer n, generate all valid parentheses combinations with n pairs of parentheses.\n\"\"\"\n    def backtrack(s, left, right, res):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right, res)\n        if right < left:\n            backtrack(s + ')', left, right + 1, res)\n    res = []\n    backtrack('', 0, 0, res)\n    return res\ndef g():\n    n = 3\n    return n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 92,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given an array of integers, determine if there exists a subsequence of length k with consecutive elements.\"\"\"\n    subsequences = list(itertools.combinations(arr, k))\n    for subseq in subsequences:\n        subseq = sorted(subseq)\n        if all(subseq[i + 1] - subseq[i] == 1 for i in range(len(subseq) - 1)):\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 3)\n",
        "idx_generation": 1,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number n is a palindrome.\"\"\"\n    def reverse(num):\n        rev = 0\n        while num > 0:\n            rev = (rev * 10) + (num % 10)\n            num = num // 10\n        return rev\n    return n == reverse(n)\ndef g(n=12321):\n    return n\nassert f(g())\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find two distinct numbers in the list that sum up to the target. Return their indices in ascending order.\"\"\"\n    nums_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in nums_dict:\n            return [nums_dict[target - num], i]\n        nums_dict[num] = i\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 188,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if a given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = n * (n**2 + 1) // 2\n\n    # Check rows and columns sum\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if row_sum != target_sum or col_sum != target_sum:\n            return False\n\n    # Check diagonal sum\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=5) -> bool:\n    \"\"\"Given a list of integers, find a subarray that sums up to the target value.\nReturn True if such a subarray exists, False otherwise.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the sum of all multiples of 3 or 5 below n.\nReturns the sum.\"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\ndef g():\n    return 100\nassert f(g()) == 2318\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target value k, return True if there exists a subarray with a sum equal to k, and False otherwise.\"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in sum_set:\n            return True\n        sum_set.add(prefix_sum)\n    return False\ndef g(nums=[1, -1, 5, -2, 3], k=3):\n    return (nums, k)\nassert f(*g()) == True\n",
        "idx_generation": 246,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the string represents a valid arithmetic expression with balanced parentheses.\"\"\"\n    stack = []\n    for ch in s:\n        if ch == '(':\n            stack.append(ch)\n        elif ch == ')':\n            if len(stack) == 0 or stack[-1] != '(':\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return '((3+4)*5)'\n\nassert f(g())\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the length of the longest increasing path in the grid.\n    You can only move up, down, left, or right in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    max_length = 0\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(grid, dp, i, j))\n    return max_length\n\ndef dfs(grid: List[List[int]], dp: List[List[int]], i: int, j: int) -> int:\n    if dp[i][j] != 0:\n        return dp[i][j]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_length = 1\n    for dx, dy in directions:\n        x, y = i + dx, j + dy\n        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] > grid[i][j]:\n            max_length = max(max_length, 1 + dfs(grid, dp, x, y))\n    dp[i][j] = max_length\n    return max_length\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[9, 9, 4], [6, 6, 8], [2, 1, 1]])) == 4\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the minimum number of jumps required to reach the last index, starting from the first index.\n    Each element in 'nums' represents the maximum number of steps that can be jumped from that position.\"\"\"\n    if len(nums) <= 1:\n        return 0\n    max_reach = nums[0]\n    steps = nums[0]\n    jumps = 1\n    for i in range(1, len(nums)):\n        if i == len(nums) - 1:\n            return jumps\n        max_reach = max(max_reach, i + nums[i])\n        steps -= 1\n        if steps == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            steps = max_reach - i\n\ndef g():\n    nums = [2, 3, 1, 1, 4]\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if the given grid is symmetric.\n    A symmetric grid is one that remains unchanged when rotated 180 degrees.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0 or rows != cols:\n        return False\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] != grid[rows - i - 1][cols - j - 1]:\n                return False\n    return True\n\ndef g(n: int) -> List[List[int]]:\n    \"\"\"Generate a symmetric grid.\n    The generated grid will be an n x n grid that is symmetric.\n    \"\"\"\n    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n\nassert f(g(n=3))\n",
        "idx_generation": 210,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of positive integers, return the maximum sum of a path from the top-left corner to the bottom-right corner.\nThe valid movements are rightward and downward.\nReturn the maximum sum of a path from the top-left corner to the bottom-right corner.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing at most one character.\"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g(\"racecar\"))\n",
        "idx_generation": 69,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of set bits in a given integer\"\"\"\n    return g(n) == bin(n).count('1')\n\ndef g(n: int) -> int:\n    \"\"\"Calculate the number of set bits in a given integer\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\nassert f(g(n=15))\n",
        "idx_generation": 64,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subarray (contiguous subsequence) whose bitwise XOR is equal to the target value.\"\"\"\n    prefix_xor = [0]\n    for num in nums:\n        prefix_xor.append(prefix_xor[-1] ^ num)\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarray_xor = prefix_xor[i] ^ prefix_xor[j]\n            if subarray_xor == target:\n                return True\n    return False\n\ndef g() -> List[int]:\n    return [4, 3, 1, 6, 10, 8, 2]\n\nassert f(g(), 7)\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum sum path from the top-left corner to the bottom-right corner of the grid,\n    moving only down or right, and summing the numbers encountered along the path.\"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 21\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb to the top of a staircase with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g():\n    n = 4\n    return (n,)\nassert f(*g()) == 5\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3, n=10) -> bool:\n    \"\"\"Find the sum of the first n terms of the arithmetic sequence starting from 2 with a common difference of 3, and check if it is equal to the string s.\"\"\"\n    return sum(range(2, 2 + k * n, k)) == int(s)\ndef g(k=3, n=10):\n    return str(sum(range(2, 2 + k * n, k)))\nassert f(g())\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, check if there is a valid chain that can be formed by\n    concatenating all the words together, where the last character of a word matches\n    the first character of the next word. Return True if a valid chain can be formed,\n    otherwise return False.\n    Example:\n    words = [\"apple\", \"elephant\", \"tiger\", \"rabbit\"]\n    Output: True (chain: apple -> elephant -> tiger -> rabbit)\n    \"\"\"\n    if len(words) == 0:\n        return False\n\n    graph = {}\n    in_degrees = {}\n\n    for word in words:\n        start_char = word[0]\n        end_char = word[-1]\n\n        if start_char not in graph:\n            graph[start_char] = []\n        if end_char not in graph:\n            graph[end_char] = []\n\n        if start_char not in in_degrees:\n            in_degrees[start_char] = 0\n        if end_char not in in_degrees:\n            in_degrees[end_char] = 0\n\n        in_degrees[end_char] += 1\n        graph[start_char].append(end_char)\n\n    start_nodes = []\n    for node in graph:\n        if in_degrees[node] == 0:\n            start_nodes.append(node)\n\n    if len(start_nodes) != 1:\n        return False\n\n    visited = set()\n    stack = [start_nodes[0]]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return len(visited) == len(graph)\n\ndef g():\n    return [\"apple\", \"elephant\", \"tiger\", \"rabbit\"]\n\nassert f(g())\n",
        "idx_generation": 269,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Given a grid of characters representing a maze, find the minimum number of steps required to reach the goal.\n    The maze is represented by a 2D grid, where 'S' represents the start position, 'G' represents the goal position, '#' represents walls, and '.' represents empty spaces.\n    You can move up, down, left, or right from a given position, but you cannot move through walls.\n    Return the minimum number of steps to reach the goal, or -1 if it is not possible to reach the goal.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    start = None\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n    \n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        curr_pos, steps = queue.pop(0)\n        x, y = curr_pos\n        \n        if grid[x][y] == 'G':\n            return steps\n        \n        if curr_pos in visited:\n            continue\n        \n        visited.add(curr_pos)\n        \n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] != '#':\n                queue.append(((new_x, new_y), steps + 1))\n    \n    return -1\n\ndef g(grid: List[List[str]]) -> List[List[str]]:\n    return grid\n\ngrid = [['S', '.', '.', '#', '#'], ['.', '#', '.', '.', '#'], ['.', '.', '#', '.', '.'], ['.', '#', '.', 'G', '.']]\nassert f(g(grid)) == 6\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a graph contains a cycle using Depth-First Search (DFS).\"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = []\n    stack.append(0)\n    visited[0] = True\n    while stack:\n        u = stack.pop()\n        for v in graph[u]:\n            if not visited[v]:\n                stack.append(v)\n                visited[v] = True\n            elif visited[v] and v != u:\n                return True\n    return False\ndef g(graph=[[1, 2], [0, 2], [0, 1, 3], [2]]):\n    return graph\nassert f(g())\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph with exactly k edges\"\"\"\n    queue = [(start, 0)]\n    while queue:\n        node, edges = queue.pop(0)\n        if node == end and edges == k:\n            return True\n        if edges < k:\n            for neighbor in graph[node]:\n                queue.append((neighbor, edges + 1))\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    k = 3\n    return (graph, start, end, k)\n\nassert f(*g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"Generate all possible combinations of 'k' elements from the range 1 to 'n'.\"\"\"\n    combinations = []\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            combinations.append(curr_comb[:])\n        else:\n            for i in range(start, n + 1):\n                curr_comb.append(i)\n                backtrack(i + 1, curr_comb)\n                curr_comb.pop()\n    backtrack(1, [])\n    return combinations\ndef g(n=4, k=2):\n    return (n, k)\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 147,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the list such that their sum is equal to the target number.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 4, 7, 3, 9, 2], target=10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 0,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of numbers in ascending order using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        while stack and stack[-1] > num:\n            nums.append(stack.pop())\n        stack.append(num)\n    return stack\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    return [5, 3, 9, 2, 7]\n\nassert f(g()) == [2, 3, 5, 7, 9]\n",
        "idx_generation": 150,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not present in the list, return -1. The list is not guaranteed to be unique.\n    \"\"\"\n    def binary_search(arr, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, right)\n        else:\n            return binary_search(arr, target, left, mid - 1)\n    \n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 7\n    return (arr, target)\n\nassert f(*g()) == 6\n",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using quicksort algorithm.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    pivot = nums[0]\n    less = [x for x in nums[1:] if x <= pivot]\n    greater = [x for x in nums[1:] if x > pivot]\n    return f(less) + [pivot] + f(greater)\n\ndef g(nums: List[int]) -> List[int]:\n    return f(nums)\n\nassert f(g([5, 2, 8, 1, 9, 3, 7, 4, 6])) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 415,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if a number is a power of two\"\"\"\n    return num & (num - 1) == 0\ndef g():\n    \"\"\"\n    Returns a number\n    \"\"\"\n    return 64\nassert f(g())\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"Given two integers n and m, generate a grid of size n x m where each cell contains the product of its row and column indices.\"\"\"\n    grid = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            grid[i][j] = i * j\n    return grid\n\ndef g() -> List[int]:\n    \"\"\"Generate two integers.\"\"\"\n    return 3, 4\n\nassert f(*g()) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix consisting of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner, \n    where each cell in the path has a value of 1. You can only move down or to the right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D dp table to store the intermediate results\n    dp = [[False] * cols for _ in range(rows)]\n\n    # Base case: First cell is reachable\n    dp[0][0] = True\n\n    # Fill the dp table\n    for i in range(rows):\n        for j in range(cols):\n            # If the current cell is reachable\n            if dp[i][j]:\n                # Check if we can move down\n                if i + 1 < rows and matrix[i + 1][j] == 1:\n                    dp[i + 1][j] = True\n                # Check if we can move right\n                if j + 1 < cols and matrix[i][j + 1] == 1:\n                    dp[i][j + 1] = True\n\n    # Return the value of the bottom-right cell\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    matrix = [\n        [1, 0, 0, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [0, 0, 1, 1]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 393,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Count the number of inversions in the given list of integers.\"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    return [6, 5, 4, 3, 2, 1]\n\nassert f(g()) == 15\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, a: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of 'a' with sum equal to 'k'.\"\"\"\n    def subset_sum(a, n, k):\n        if k == 0:\n            return True\n        if n == 0 and k != 0:\n            return False\n        if a[n-1] > k:\n            return subset_sum(a, n-1, k)\n        return subset_sum(a, n-1, k) or subset_sum(a, n-1, k-a[n-1])\n\n    return subset_sum(a, n, k)\n\ndef g(n=4, k=9, a=[2, 4, 6, 7]):\n    return n, k, a\n\nassert f(*g())\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, determine if there exists a word that is an anagram of another word in the list.\n    An anagram is a word formed by rearranging the letters of another word.\n    Sample Input:\n    words = [\"listen\", \"silent\", \"hello\", \"holle\"]\n    Sample Output:\n    True\"\"\"\n    unique_words = set()\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in unique_words:\n            return True\n        unique_words.add(sorted_word)\n    return False\n\ndef g(words: List[str]):\n    return words + ['silent']\n\nassert f(g(['listen', 'hello', 'holle']))\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the smallest positive integer whose digits, when multiplied, result in n.\"\"\"\n    digits = [int(digit) for digit in str(n)]\n    product = 1\n    for digit in digits:\n        product *= digit\n    return product == n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 88,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value. Return their indices.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\ndef g():\n    return [2, 7, 11, 15, 1, 8], 9\nassert f(g()[0], g()[1]) == [0, 1]\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all even numbers less than or equal to n\"\"\"\n    return sum(i for i in range(n+1) if i % 2 == 0)\n\ndef g():\n    return 10\n\nassert f(g()) == 30\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a non-empty subarray.\n    Args:\n        nums: A list of integers\n    Returns:\n        The maximum sum of a non-empty subarray\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = nums[0]\n    curr_sum = nums[0]\n    \n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g():\n    \"\"\"\n    Returns a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers and a target value, find the indices of two numbers in the array that sum up to the target value. Return the indices as a list.\"\"\"\n    num_map = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    return (arr, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str, brackets='()') -> bool:\n    \"\"\"Check if the brackets in the expression are balanced\"\"\"\n    stack = []\n    for char in expression:\n        if char in brackets:\n            if char == brackets[0]:\n                stack.append(char)\n            else:\n                if len(stack) == 0:\n                    return False\n                stack.pop()\n    return len(stack) == 0\n\ndef g(brackets='()'):\n    return '(()())'\n\nassert f(g())\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=2) -> bool:\n    \"\"\"Check if the number n can be expressed as a sum of k prime numbers.\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def check_sum(num, k):\n        if k == 1:\n            return is_prime(num)\n        for i in range(2, num):\n            if is_prime(i) and check_sum(num - i, k - 1):\n                return True\n        return False\n    \n    return check_sum(n, k)\n    \ndef g(n=10):\n    return n\nassert f(g())\n",
        "idx_generation": 46,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to obtain the target number by rearranging the given numbers and applying a series of stack operations.\"\"\"\n    def helper(index, current_sum, stack):\n        if index == len(numbers):\n            return current_sum == target\n        if helper(index + 1, current_sum + numbers[index], stack):\n            return True\n        if helper(index + 1, current_sum - numbers[index], stack):\n            return True\n        stack.append(numbers[index])\n        if helper(index + 1, current_sum, stack):\n            return True\n        stack.pop()\n        return False\n    return helper(0, 0, [])\n\ndef g():\n    return ([1, 2, 3, 4], 10)\n\nassert f(*g())\n",
        "idx_generation": 458,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the maximum sum of any 2x2 subgrid.\"\"\"\n    max_sum = float('-inf')\n    for i in range(len(grid)-1):\n        for j in range(len(grid[0])-1):\n            subgrid_sum = grid[i][j] + grid[i][j+1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, subgrid_sum)\n    return max_sum\n\ndef g():\n    return [[1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12],\n            [13, 14, 15, 16]]\n\nassert f(g()) == 54\n",
        "idx_generation": 224,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Given a 2D grid of characters and a word, determine if the word can be formed by traversing adjacent cells \n    horizontally or vertically. Each cell in the grid can only be used once.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row, col, idx):\n        if idx == len(word):\n            return True\n        \n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or grid[row][col] != word[idx]:\n            return False\n        \n        visited[row][col] = True\n        found = dfs(row+1, col, idx+1) or dfs(row-1, col, idx+1) or dfs(row, col+1, idx+1) or dfs(row, col-1, idx+1)\n        visited[row][col] = False\n        \n        return found\n    \n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n            \n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n    Return True if s can be segmented, False otherwise.\n    \"\"\"\n    def can_segment(s, words, memo):\n        if s == \"\":\n            return True\n        if s in memo:\n            return memo[s]\n        for word in words:\n            if s.startswith(word) and can_segment(s[len(word):], words, memo):\n                memo[s] = True\n                return True\n        memo[s] = False\n        return False\n    \n    return can_segment(s, words, {})\n\ndef g():\n    s = \"applepenapple\"\n    words = [\"apple\", \"pen\"]\n    return s, words\n\nassert f(*g())\n",
        "idx_generation": 75,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a string contains a palindrome of length n using bit manipulation.\"\"\"\n    return any(bin(i).count('1') % 2 == 1 for i in range(1, n+1)) and s == s[::-1]\ndef g(n: int) -> str:\n    \"\"\"Generate a string with a palindrome of length n.\"\"\"\n    return 'a' * (n // 2) + 'b' + 'a' * (n // 2)\nassert f(g(n=5), n=5)\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum bitwise XOR value between any two numbers in the list.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    return max_xor\n\ndef g(nums: List[int]) -> Tuple:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return (nums,)\n\nnums = [3, 10, 5, 25, 2, 8]\nassert f(*g(nums)) == 28\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, a=1, b=2) -> bool:\n    \"\"\"Determine if a number is a perfect power of another number\"\"\"\n    for i in range(k, int(n**(1/k)) + 1):\n        if i**k == n:\n            return True\n    return False\n\ndef g(k=3):\n    \"\"\"Generate a number that is a perfect power of another number\"\"\"\n    return k**k\n\nassert f(g(), 3)\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n steps, taking either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, convert it to a new string where each character is replaced by its ordinal value in the ASCII table.\n    The ordinal value is represented in binary format.\n    Return the new string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        ordinal_value = ord(char)\n        binary_value = bin(ordinal_value)[2:]\n        result += binary_value\n    return result\ndef g(s=\"hello\"):\n    return s\nassert f(g()) == \"11010001100101110110011011001101111\"\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary, determine if there exists a path from the start node to the end node.\n    Return True if a path exists, otherwise return False.\"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\nassert f(g(), start='A', end='F') == True\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return ({\"A\": [\"B\", \"C\"], \"B\": [\"C\"], \"C\": [\"D\"], \"D\": []}, \"A\", \"D\")\n\nassert f(*g())\n",
        "idx_generation": 107,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(word: str, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a word and a grid of letters, determine if the word can be formed by traversing adjacent cells in the grid.\n    The word can be formed by moving up, down, left, or right in the grid, but not diagonally.\n    Each cell in the grid can only be used once.\n    Return True if the word can be formed, False otherwise.\n    \"\"\"\n    def dfs(i: int, j: int, k: int) -> bool:\n        if k == len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[k]:\n            return False\n        temp, grid[i][j] = grid[i][j], '#'\n        found = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n        grid[i][j] = temp\n        return found\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(word: str, grid: List[List[str]]):\n    return word, grid\n\ngrid = [['A', 'B', 'C', 'D'],\n        ['E', 'F', 'G', 'H'],\n        ['I', 'J', 'K', 'L'],\n        ['M', 'N', 'O', 'P']]\nword = \"ABCD\"\nassert f(*g(word, grid))\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(tree: List[List[int]], node: int, target: int) -> bool:\n    \"\"\"Check if there is a path from the given node to a leaf node in the tree that sums up to the target value\"\"\"\n    stack = [(node, 0)]\n    while stack:\n        curr_node, curr_sum = stack.pop()\n        if not tree[curr_node]:  # Leaf node\n            if curr_sum == target:\n                return True\n        for child in tree[curr_node]:\n            stack.append((child, curr_sum + child))\n    return False\n\ndef g():\n    tree = [[1, 2], [3, 4], [], [5], [], []]\n    node = 0\n    target = 9\n    return (tree, node, target)\n\nassert f(*g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the number of distinct combinations that add up to the target.\nArgs:\n    nums: The list of integers.\n    target: The target number.\nReturns:\n    The number of distinct combinations that add up to the target.\"\"\"\n    def dfs(nums, target, index, path, result):\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target - nums[i], i, path + [nums[i]], result)\n    \n    result = []\n    dfs(nums, target, 0, [], result)\n    return len(result)\n\ndef g():\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == 2\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, return the index of the target number in the list. If the target number is not found, return -1.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list of numbers in ascending order using the Bubble Sort algorithm.\"\"\"\n    swapped = True\n    while swapped:\n        swapped = False\n        for i in range(n - 1):\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                swapped = True\n    return nums\n\ndef g():\n    return (5, [4, 2, 1, 3, 5])\n\nassert f(*g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 152,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there are three integers in the list that sum up to the target value.\n    Return True if such triplets exist, otherwise return False.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [1, 4, 2, 8, 5, 3]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find two numbers in the array that add up to the target value.\"\"\"\n    n = len(arr)\n    arr.sort()\n    left, right = 0, n - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(n=10, target=10):\n    import random\n    arr = random.sample(range(1, n + 1), n)\n    return arr\n\nassert f(g())\n",
        "idx_generation": 425,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers and a target number n, find if there exists a pair of distinct numbers in the list whose sum is equal to n.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == n:\n            return True\n        elif nums[left] + nums[right] < n:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], n: int = 10):\n    return nums\n\nassert f(n=10, nums=g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 282,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented by a 2D grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner.\n    You can move in four directions: up, down, left, and right. A path exists if there are only 1s and you can reach the bottom-right corner.\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n\n    def backtrack(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or maze[row][col] != 1:\n            return False\n        if row == rows - 1 and col == cols - 1:\n            return True\n        maze[row][col] = 0\n        return (\n            backtrack(row - 1, col) or\n            backtrack(row + 1, col) or\n            backtrack(row, col - 1) or\n            backtrack(row, col + 1)\n        )\n\n    return backtrack(0, 0)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 0, 0, 1, 1],\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 0, 1],\n        [0, 0, 1, 1, 1]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 401,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers and a target integer, find two numbers from the array that add up to the target.\nReturn the indices of the two numbers as a list. Assume that each input has exactly one solution and the same element cannot be used twice.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 218,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of the given array that adds up to the target value.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g(arr=[1, 3, 5, 7, 9], target=12):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, return True if there exists a substring of length 4 in s that contains at least 2 vowels and\n    2 consonants, and False otherwise.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    return any((sum(c in vowels for c in s[i:i+4]) >= 2 and 2 <= (4 - sum(c in vowels for c in s[i:i+4])) <= 3 for i in range(len(s) - 3)))\ndef g():\n    return 'programming'\nassert f(g())\n",
        "idx_generation": 28,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\"\"\"\n    def is_alphanumeric(char):\n        return char.isalpha() or char.isdigit()\n    \n    def helper(string, start, end):\n        if start >= end:\n            return True\n        if not is_alphanumeric(string[start]):\n            return helper(string, start + 1, end)\n        if not is_alphanumeric(string[end]):\n            return helper(string, start, end - 1)\n        if string[start].lower() != string[end].lower():\n            return False\n        return helper(string, start + 1, end - 1)\n    \n    return helper(string, 0, len(string) - 1)\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 134,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"Given a list of integers and a target number, find the two numbers in the list that add up to the target. Return their indices.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return (num_dict[complement], i)\n        num_dict[num] = i\n    return (-1, -1)\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == (0, 1)\n",
        "idx_generation": 244,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"Given a list of integers and a target integer k, find the number of subarrays whose sum is divisible by k.\n    Sample input:\n    [4, 5, 0, -2, -3, 1], 5\n    Sample output:\n    7\"\"\"\n    prefix_sum = 0\n    count = 0\n    remainder = {0: 1}\n    for num in arr:\n        prefix_sum += num\n        mod = prefix_sum % k\n        if mod in remainder:\n            count += remainder[mod]\n        remainder[mod] = remainder.get(mod, 0) + 1\n    return count\n\ndef g():\n    return ([4, 5, 0, -2, -3, 1], 5)\n\nassert f(*g()) == 7\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subsequence of the list whose sum is equal to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g():\n    return ([1, 5, 11, 5], 16)\n\nassert f(*g())\n",
        "idx_generation": 309,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, find the maximum subarray sum. Return the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return (arr,)\n\nassert f(*g()) == 6\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a valid path from the top-left corner to the bottom-right corner in a given grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        x, y = stack.pop()\n        if x == rows-1 and y == cols-1:\n            return True\n        if grid[x][y] == 1:\n            continue\n        grid[x][y] = 1\n        if x+1 < rows:\n            stack.append((x+1, y))\n        if y+1 < cols:\n            stack.append((x, y+1))\n    return False\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [1, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, target=24) -> bool:\n    \"\"\"Given a list of four integers, determine if it is possible to combine them using the basic arithmetic operations (+, -, *, /) to obtain the target number.\"\"\"\n    def backtrack(nums: List[int], target: int) -> bool:\n        if len(nums) == 1:\n            return abs(nums[0] - target) < 1e-6\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                a, b = nums[i], nums[j]\n                new_nums = nums[:i] + nums[i+1:j] + nums[j+1:]\n                if backtrack(new_nums + [a + b], target) or backtrack(new_nums + [a - b], target) or backtrack(new_nums + [b - a], target) or backtrack(new_nums + [a * b], target) or (b != 0 and backtrack(new_nums + [a / b], target)) or (a != 0 and backtrack(new_nums + [b / a], target)):\n                    return True\n        return False\n    return backtrack(num, target)\n\ndef g(num=[1, 2, 3, 4], target=24):\n    return num\n\nassert f(g())\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome after removing exactly one character. A valid palindrome is a string that\n    reads the same forward and backward.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return s[left+1:right+1] == s[left+1:right+1][::-1] or s[left:right] == s[left:right][::-1]\n        left += 1\n        right -= 1\n    return True\n\ndef g() -> str:\n    return 'racecar'\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner in a grid.\"\"\"\n    def max_path_sum(grid, row, col, memo):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return grid[row][col]\n        if row >= len(grid) or col >= len(grid[0]):\n            return float('-inf')\n        if memo[row][col] != float('-inf'):\n            return memo[row][col]\n        down = max_path_sum(grid, row + 1, col, memo)\n        right = max_path_sum(grid, row, col + 1, memo)\n        memo[row][col] = grid[row][col] + max(down, right)\n        return memo[row][col]\n    \n    memo = [[float('-inf')] * len(grid[0]) for _ in range(len(grid))]\n    return max_path_sum(grid, 0, 0, memo)\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    def is_palindrome(s, start, end):\n        if start >= end:\n            return True\n        if s[start] != s[end]:\n            return False\n        return is_palindrome(s, start + 1, end - 1)\n    \n    return is_palindrome(s, 0, len(s) - 1)\n\ndef g(s=\"racecar\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 82,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number is a palindrome in binary representation.\n    Return True if the number is a binary palindrome, False otherwise.\n    \"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g():\n    \"\"\"\n    Generate a palindrome in binary representation.\n    Return the palindrome as an integer.\n    \"\"\"\n    import random\n\n    num = random.randint(0, int(\"1\" * 32, 2))\n    binary = bin(num)[2:]\n    while binary != binary[::-1]:\n        num = random.randint(0, int(\"1\" * 32, 2))\n        binary = bin(num)[2:]\n    return num\n\nassert f(g())\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target value, determine if it is possible to obtain the target value by performing bitwise XOR operations between any subset of nums.\"\"\"\n    def backtrack(nums, target, idx, curr_xor):\n        if curr_xor == target:\n            return True\n        if idx == len(nums):\n            return False\n        if backtrack(nums, target, idx + 1, curr_xor ^ nums[idx]):\n            return True\n        return backtrack(nums, target, idx + 1, curr_xor)\n    return backtrack(nums, target, 0, 0)\n\ndef g():\n    nums = [3, 5, 9, 12, 15]\n    target = 6\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 485,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given list that sums up to a number which is a perfect square.\"\"\"\n    def is_perfect_square(n: int) -> bool:\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n\n    def helper(start: int, end: int) -> bool:\n        if start == end:\n            return False\n        if is_perfect_square(prefix_sum[end] - prefix_sum[start]):\n            return True\n        return helper(start, end - 1) or helper(start + 1, end)\n\n    return helper(0, len(nums))\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g())\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int = 100) -> bool:\n    \"\"\"Check if the sum of the first n natural numbers is equal to the integer value represented by the string s.\"\"\"\n    return sum(range(n + 1)) == int(s)\ndef g(n: int = 100):\n    return str(sum(range(n + 1)))\nassert f(g())\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], path: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and a path as a string, check if the path visits all the nodes\n    in the graph exactly once and returns to the starting node. Each character in the path represents a node index\n    (0-based).\n\n    Example:\n    graph = [[0, 1, 1],\n             [1, 0, 1],\n             [1, 1, 0]]\n    path = '012'\n    In this example, the graph has 3 nodes and the adjacency matrix represents the connections between the nodes.\n    The path '012' means the path starts at node 0, goes to node 1, then to node 2, and finally returns to node 0.\n    The function should return True.\n\n    Note: The path should visit all nodes exactly once and return to the starting node, but the order of visiting\n    the nodes can be different.\n\n    :param graph: A graph represented as an adjacency matrix (2D list)\n    :param path: A string representing the path to check\n    :return: True if the path visits all nodes exactly once and returns to the starting node, False otherwise\n    \"\"\"\n    visited = set()\n    current_node = int(path[0])\n    visited.add(current_node)\n\n    for node in path[1:]:\n        node = int(node)\n        if graph[current_node][node] == 0 or node in visited:\n            return False\n        visited.add(node)\n        current_node = node\n\n    return graph[current_node][int(path[0])] == 1\n\ndef g():\n    return ([[0, 1, 1], [1, 0, 1], [1, 1, 0]], '012')\n    \nassert f(*g())\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        stack.extend(graph[node] - visited)\n    return False\n\ndef g():\n    graph = {\n        'A': {'B', 'C'},\n        'B': {'D', 'E'},\n        'C': {'F'},\n        'D': {'G'},\n        'E': {'F'},\n        'F': {'G'},\n        'G': set()\n    }\n    return graph, 'A', 'G'\n\nassert f(*g())\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a cyclic path from start to end in the given graph\"\"\"\n    stack = [(start, [start])]\n    while stack:\n        node, path = stack.pop()\n        if node == end and len(path) > 1:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                stack.append((neighbor, path + [neighbor]))\n    return False\n\ndef g():\n    graph = [[1, 2], [2], [3, 4], [4], [1]]\n    start = 0\n    end = 4\n    return (graph, start, end)\n\nassert f(*g())\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, determine if there is a path in the graph formed by connecting words that differ by only one character.\"\"\"\n    graph = {}\n    for word in words:\n        for i in range(len(word)):\n            pattern = word[:i] + \"_\" + word[i+1:]\n            if pattern not in graph:\n                graph[pattern] = []\n            graph[pattern].append(word)\n    \n    visited = set()\n    for word in words:\n        if word in visited:\n            continue\n        stack = [word]\n        while stack:\n            current = stack.pop()\n            visited.add(current)\n            for i in range(len(current)):\n                pattern = current[:i] + \"_\" + current[i+1:]\n                if pattern in graph:\n                    for neighbor in graph[pattern]:\n                        if neighbor == word:\n                            return True\n                        if neighbor not in visited:\n                            stack.append(neighbor)\n    return False\n\ndef g():\n    return [\"cat\", \"bat\", \"hat\", \"hat\"]\n\nassert f(g())\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(target: int, nums: List[int]) -> List[List[int]]:\n    \"\"\"Find all unique combinations of numbers in the given list that sum up to the target.\"\"\"\n    def backtrack(remain, current_combination, start):\n        if remain == 0:\n            combinations.append(list(current_combination))\n            return\n        elif remain < 0:\n            return\n        for i in range(start, len(nums)):\n            current_combination.append(nums[i])\n            backtrack(remain - nums[i], current_combination, i)\n            current_combination.pop()\n\n    combinations = []\n    backtrack(target, [], 0)\n    return combinations\n\ndef g(target: int, nums: List[int]):\n    return target, nums\n\ntarget = 7\nnums = [2, 3, 6, 7]\nassert f(*g(target, nums)) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k=2) -> bool:\n    \"\"\"Find if there exists a subarray in arr with k consecutive elements in ascending order.\"\"\"\n    for i in range(len(arr)-k+1):\n        if arr[i:i+k] == sorted(arr[i:i+k]):\n            return True\n    return False\n    \ndef g(k=2):\n    return list(range(1, k+1)) + list(range(5, 0, -1))\n\nassert f(g())\n",
        "idx_generation": 2,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if the target value is present using binary search.\nReturn True if it is present, False otherwise.\"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n    return binary_search(nums, target, 0, len(nums) - 1)\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 157,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target integer, find the index of the target in the list using binary search.\n    If the target is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 66,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum from the given list of numbers.\n    Solution should return the maximum sum.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in numbers:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 9\n",
        "idx_generation": 428,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n    return (arr, target)\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Given a grid consisting of characters 'X' and 'O', return True if the grid is surrounded by 'X', and False otherwise.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if (i == 0 or i == rows - 1 or j == 0 or j == cols - 1) and grid[i][j] == 'O':\n                if not dfs(grid, i, j):\n                    return False\n    return True\n\ndef dfs(grid: List[List[str]], i: int, j: int) -> bool:\n    rows = len(grid)\n    cols = len(grid[0])\n    if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 'O':\n        return True\n    grid[i][j] = 'X'\n    return dfs(grid, i - 1, j) and dfs(grid, i + 1, j) and dfs(grid, i, j - 1) and dfs(grid, i, j + 1)\n\ndef g(grid: List[List[str]]=[['X', 'X', 'X', 'X'],\n                              ['X', 'O', 'O', 'X'],\n                              ['X', 'X', 'O', 'X'],\n                              ['X', 'O', 'X', 'X']]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 404,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int]):\n    return (nums,)\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(*g(nums)) == 6\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given sorted list of integers using binary search.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, strings=['hello', 'world', 'python', 'programming', 'puzzle']) -> bool:\n    \"\"\"Find the number of strings in a list that can be formed by rearranging the characters in a given string.\"\"\"\n    sorted_string = ''.join(sorted(s))\n    return sum([''.join(sorted(word)) == sorted_string for word in strings])\ndef g(strings=['hello', 'world', 'python', 'programming', 'puzzle']):\n    return ''.join(sorted(strings, key=len))[:5]\nassert f(g())\n",
        "idx_generation": 31,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalpha())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g())\n",
        "idx_generation": 175,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find all indices of the target value in the list.\"\"\"\n    return [i for i, num in enumerate(arr) if num == target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Return a list of integers and a target value.\"\"\"\n    return [1, 2, 3, 4, 2, 5, 2], 2\n\nassert f(*g()) == [1, 4, 6]\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Calculate the sum of all prime numbers in a list.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    return sum([num for num in nums if is_prime(num)])\n\ndef g():\n    return [1, 3, 5, 7, 10, 11, 13]\n\nassert f(g()) == 39\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target_sum=100) -> bool:\n    \"\"\"Find a subset of numbers that sums up to the target_sum\"\"\"\n    n = len(numbers)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j < numbers[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - numbers[i - 1]]\n    return dp[n][target_sum]\ndef g(numbers=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], target_sum=100):\n    return numbers\nassert f(g())\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray within the list.\"\"\"\n    current_sum = max_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [1, -2, 3, 4, -1, 2, 5, -3]\nassert f(g(nums)) == 13\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the target cell from the source cell in a given grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = [(0, 0)]\n    while queue:\n        x, y = queue.pop(0)\n        if grid[x][y] == 2:\n            return True\n        if grid[x][y] == 1:\n            continue\n        grid[x][y] = 1\n        if x+1 < rows:\n            queue.append((x+1, y))\n        if y+1 < cols:\n            queue.append((x, y+1))\n    return False\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [1, 0, 2, 0]]\n\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Determine if 'n' can be represented as a sum of exactly 'm' distinct Fibonacci numbers.\n    Sample Input:\n    n = 15\n    m = 3\n    Sample Output:\n    True\n    Explanation: The number 15 can be represented as 2 + 5 + 8, which are distinct Fibonacci numbers.\n    There are exactly 3 distinct Fibonacci numbers used in this representation, hence the output is True.\"\"\"\n    fib = [0, 1]\n    while fib[-1] < n:\n        fib.append(fib[-1] + fib[-2])\n    fib.pop(0)\n    fib_set = set(fib)\n    sum_fib = set()\n    def dfs(n, fib, fib_set, sum_fib, m):\n        if n == 0 and m == 0:\n            return True\n        if n < 0 or m <= 0:\n            return False\n        for i in range(len(fib)):\n            if n - fib[i] >= 0 and fib[i] not in sum_fib:\n                sum_fib.add(fib[i])\n                if dfs(n - fib[i], fib, fib_set, sum_fib, m - 1):\n                    return True\n                sum_fib.remove(fib[i])\n        return False\n    return dfs(n, fib, fib_set, sum_fib, m)\ndef g(n=15, m=3):\n    return n, m\nassert f(*g())\n",
        "idx_generation": 48,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Rotate the given grid 90 degrees clockwise\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    result = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            result[j][rows - i - 1] = grid[i][j]\n    return result\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the size of the largest square containing only 1s.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    max_size = 0\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            elif grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n            max_size = max(max_size, dp[i][j])\n    return max_size * max_size\n\ndef g():\n    grid = [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]\n    return grid\n\nassert f(g()) == 4\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Given a string and a list of words, determine if it is possible to form the string by concatenating the words in the list.\n    The words can be concatenated in any order and any word can be used multiple times.\n    Return True if it is possible, False otherwise.\"\"\"\n    def dfs(s: str, words: List[str]) -> bool:\n        if not s:\n            return True\n        for word in words:\n            if s.startswith(word):\n                if dfs(s[len(word):], words):\n                    return True\n        return False\n    \n    return dfs(s, words)\n\ndef g(s: str, words: List[str]) -> Tuple[str, List[str]]:\n    return (s, words)\n\ns = \"leetcode\"\nwords = [\"leet\", \"code\"]\nassert f(*g(s, words))\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> int:\n    \"\"\"Determine the minimum number of steps required to convert number n to number m using bitwise operations (AND, OR, XOR) and k as a mask\"\"\"\n    def count_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n    \n    diff = n ^ m\n    steps = count_bits(diff)\n    mask = 1\n    while mask <= diff:\n        if mask & diff:\n            new_diff = diff & ~mask\n            new_steps = count_bits(new_diff)\n            steps = min(steps, new_steps + 1)\n        mask <<= 1\n    return steps\ndef g():\n    return 10, 15, 7\nassert f(*g()) == 2\n",
        "idx_generation": 86,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to the target value.\"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target, n-1) or subset_sum(nums, target-nums[n-1], n-1)\n    \n    return subset_sum(nums, target, len(nums))\n\ndef g(nums=[1, 5, 9, 12, 3], target=15):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 82,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle.\n    Return True if a cycle exists, otherwise False.\"\"\"\n    def has_cycle_util(node, visited, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle_util(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if has_cycle_util(node, visited, -1):\n                return True\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 299,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in the given directed graph.\"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(graph[node])\n\n    return False\n\ndef g():\n    return ([[1, 2], [2, 3], [3], []], 0, 3)\n\nassert f(*g())\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there is a path from start to end.\"\"\"\n    visited = [False] * len(graph)\n\n    def dfs(node: int) -> bool:\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor, connected in enumerate(graph[node]):\n            if connected and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    return dfs(start)\n\ndef g(graph=[[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]], start=0, end=3):\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 127,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a 2D grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    that passes through all the cells with a non-zero value, without visiting any cell more than once.\n    The grid is represented as a list of lists, where each inner list represents a row in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    \n    def dfs(x, y):\n        if x == rows - 1 and y == cols - 1:\n            return True\n        \n        if grid[x][y] == 0 or (x, y) in visited:\n            return False\n        \n        visited.add((x, y))\n        \n        if x - 1 >= 0 and dfs(x - 1, y):\n            return True\n        if x + 1 < rows and dfs(x + 1, y):\n            return True\n        if y - 1 >= 0 and dfs(x, y - 1):\n            return True\n        if y + 1 < cols and dfs(x, y + 1):\n            return True\n        \n        visited.remove((x, y))\n        \n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[1, 2, 3], [0, 4, 5], [6, 0, 7]]\n\nassert f(g())\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if a given string is a palindrome after rearranging its characters.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n    return odd_count <= 1 and is_palindrome(s)\ndef g():\n    return 'racecar'\nassert f(g())\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to choose k elements from a set of n elements, where k ranges from 0 to n.\"\"\"\n    def binomial_coefficient(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n    return [binomial_coefficient(n, k) for k in range(n + 1)]\ndef g(n: int):\n    return n\nassert f(g(n=5)) == [1, 5, 10, 10, 5, 1]\n",
        "idx_generation": 185,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=7) -> bool:\n    \"\"\"Find if two numbers in the list add up to the target\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 4, 1, 5, 3]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 3,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exist two elements whose sum is equal to the target.\"\"\"\n    def helper(arr, left, right, target):\n        if left >= right:\n            return False\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            return helper(arr, left + 1, right, target)\n        else:\n            return helper(arr, left, right - 1, target)\n    return helper(arr, 0, len(arr) - 1, target)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13)\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Find a subset of numbers that adds up to the target.\"\"\"\n    numbers.sort()\n    n = len(numbers)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < numbers[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - numbers[i - 1]]\n    return dp[n][target]\ndef g(target=10):\n    return [2, 4, 6, 8]\nassert f(g())\n",
        "idx_generation": 69,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string of parentheses, find the length of the longest valid parentheses substring.\n    Implement the solution using a stack.\"\"\"\n    stack = []\n    max_length = 0\n    stack.append(-1)\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if len(stack) == 0:\n                stack.append(i)\n            else:\n                current_length = i - stack[-1]\n                max_length = max(max_length, current_length)\n    return max_length\n\ndef g():\n    s = \"((())())\"\n    return s\n\nassert f(g()) == 8\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given an array of integers, determine if there are any three numbers that form a Pythagorean triplet.\"\"\"\n    nums.sort()\n    for i in range(len(nums)-1, 1, -1):\n        left = 0\n        right = i-1\n        while left < right:\n            if nums[left]**2 + nums[right]**2 == nums[i]**2:\n                return True\n            elif nums[left]**2 + nums[right]**2 < nums[i]**2:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [3, 1, 4, 6, 5]\n\nassert f(g())\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner of the grid. \n    You can only move down or right at any point in time.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n\ndef g(grid: List[List[int]]) -> None:\n    \"\"\"\n    Generate a grid of non-negative integers.\n    \"\"\"\n    return (grid,)\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(*g(grid)) == 7\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    n = len(nums)\n    num_dict = {}\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if it forms a magic square.\n    A magic square is a square grid of numbers where the sums of each row, each column, and both diagonals are the same value.\n    Return True if the grid is a magic square, and False otherwise.\"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n    \n    # Check rows\n    for i in range(n):\n        if sum(grid[i]) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        if sum(grid[i][j] for i in range(n)) != target_sum:\n            return False\n    \n    # Check diagonal\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check anti-diagonal\n    if sum(grid[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\ngrid = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\nassert f(g(grid))\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target=\"abc\") -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string.\"\"\"\n    s_count = {}\n    target_count = {}\n    for char in s:\n        s_count[char] = s_count.get(char, 0) + 1\n    for char in target:\n        target_count[char] = target_count.get(char, 0) + 1\n    return s_count == target_count\n\ndef g(s=\"bca\", target=\"abc\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Find all the words in a list that are palindromes.\"\"\"\n    def is_palindrome(word):\n        return word == word[::-1]\n\n    result = []\n\n    for word in words:\n        if is_palindrome(word):\n            result.append(word)\n\n    return result\n\ndef g():\n    return ([\"racecar\", \"python\", \"madam\", \"level\", \"algorithm\"],)\n\nassert f(g()[0]) == [\"racecar\", \"madam\", \"level\"]\n",
        "idx_generation": 229,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subarray with a sum divisible by 5.\n    Args:\n        arr: The input list of integers.\n    Returns:\n        True if a subarray with a sum divisible by 5 exists, False otherwise.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum = (prefix_sum + num) % 5\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    \"\"\"\n    Generates a sample list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 338,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list such that their sum is a perfect square.\"\"\"\n    squares = set(i*i for i in range(1, int(len(nums)**0.5) + 1))\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] in squares:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 340,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of numbers, find the length of the longest subarray with a sum equal to the target.\"\"\"\n    prefix_sum = {0: -1}\n    length = len(nums)\n    current_sum = 0\n    max_length = 0\n    for i in range(length):\n        current_sum += nums[i]\n        if current_sum - target in prefix_sum:\n            max_length = max(max_length, i - prefix_sum[current_sum - target])\n        if current_sum not in prefix_sum:\n            prefix_sum[current_sum] = i\n    return max_length\n\ndef g(nums=[1, -2, 3, 4, -5], target=2):\n    return (nums, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([-2, 1, -3, 4, -1, 2, 1, -5, 4])) == 6\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a valid path from the top-left corner to the bottom-right corner in a given grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = [(0, 0)]\n    while stack:\n        x, y = stack.pop()\n        if x == rows-1 and y == cols-1:\n            return True\n        if grid[x][y] == 1:\n            continue\n        grid[x][y] = 1\n        if x+1 < rows:\n            stack.append((x+1, y))\n        if y+1 < cols:\n            stack.append((x, y+1))\n    return False\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 1, 0],\n            [1, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target sum, determine if there exists a subset of the list that adds up to the target sum.\"\"\"\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(nums):\n            return False\n        include = subset_sum(nums, target - nums[index], index + 1)\n        exclude = subset_sum(nums, target, index + 1)\n        return include or exclude\n    return subset_sum(nums, target, 0)\ndef g(target=10):\n    nums = [1, 2, 3, 4, 5]\n    return nums\nassert f(g())\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: List[List[str]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of characters representing a maze, find the starting position of the maze.\n\n    Args:\n    - grid: A 2D list of strings representing a maze.\n\n    Returns:\n    - A tuple of integers representing the starting position coordinates (row, column).\n\n    Example:\n    f([\n        ['.', '.', '.', '.', '.'],\n        ['.', 'S', '.', '.', '.'],\n        ['.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.']\n    ]) -> (1, 1)\n    \"\"\"\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 'S':\n                return (i, j)\n\ndef g() -> List[List[str]]:\n    return [\n        ['.', '.', '.', '.', '.'],\n        ['.', 'S', '.', '.', '.'],\n        ['.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.']\n    ]\n\nassert f(g()) == (1, 1)\n",
        "idx_generation": 290,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move down or right at each step.\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g(n: int) -> int:\n    \"\"\"Return the size of the grid.\"\"\"\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])\n\ndef g():\n    return \"radar\"\n\nassert f(g())\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(a: int, b: int) -> int:\n    \"\"\"Perform XOR operation between two integers a and b and return the result.\"\"\"\n    return a ^ b\n\ndef g():\n    return (10, 15)\n\nassert f(*g()) == 5\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the n-th Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 94,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the number of islands.\n    An island is a group of connected 1s (horizontally or vertically).\n    Return the number of islands in the grid.\"\"\"\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(grid, i-1, j)\n        dfs(grid, i+1, j)\n        dfs(grid, i, j-1)\n        dfs(grid, i, j+1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(grid, i, j)\n                count += 1\n    \n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in a given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5],\n            [6],\n            [7],\n            [8],\n            [9],\n            [10],\n            [11],\n            [12],\n            [13],\n            [14],\n            [15],\n            []]\n\nassert f(g(), 0, 15)\n",
        "idx_generation": 159,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, visited: List[bool]) -> bool:\n    \"\"\"Given a graph represented as an adjacency matrix, determine if there exists a path from start to end.\n    Note: The graph is a directed graph and the adjacency matrix is a square matrix of size n x n, where n is the number of nodes.\n    You can assume that the graph is connected.\n    Sample input:\n    [[0, 1, 1, 0],\n     [0, 0, 0, 1],\n     [0, 0, 0, 1],\n     [0, 0, 0, 0]],\n    0, 3\n    Sample output:\n    True\"\"\"\n\n    if start == end:\n        return True\n        \n    visited[start] = True\n\n    for i in range(len(graph)):\n        if graph[start][i] == 1 and not visited[i]:\n            if f(graph, i, end, visited):\n                return True\n\n    return False\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    visited = [False] * len(graph)\n    return graph, 0, 3, visited\n\nassert f(*g())\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a valid bipartite graph.\"\"\"\n    n = len(matrix)\n    colors = [-1] * n\n    \n    def is_bipartite(node, color):\n        colors[node] = color\n        for neighbor in range(n):\n            if matrix[node][neighbor] == 1:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == -1 and not is_bipartite(neighbor, 1 - color):\n                    return False\n        return True\n    \n    for node in range(n):\n        if colors[node] == -1 and not is_bipartite(node, 0):\n            return False\n    return True\n\ndef g():\n    return [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(n: int, s='ABC') -> bool:\n    \"\"\"Return True if there exist n unique permutations of string s\"\"\"\n    def count_permutations(s):\n        if len(s) == 1:\n            return 1\n        else:\n            return len(s) * count_permutations(s[1:])\n    \n    return count_permutations(s) == n\n\ndef g(s='ABC'):\n    return len(set(itertools.permutations(s))) \nassert f(g())\n",
        "idx_generation": 52,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a set of distinct integers and a target sum, find the number of subsets that sum up to the target.\n    The function should return the number of such subsets.\n    For example, given the input nums = [1, 2, 3, 4, 5] and target = 5, the function should return 3,\n    since there are 3 subsets that sum up to 5: [1, 4], [2, 3], [5].\n    \"\"\"\n    \n    def helper(nums: List[int], target: int, index: int, curr_sum: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if index == len(nums):\n            if curr_sum == target:\n                return 1\n            return 0\n        \n        if (index, curr_sum) in memo:\n            return memo[(index, curr_sum)]\n        \n        count = 0\n        \n        count += helper(nums, target, index+1, curr_sum+nums[index], memo)\n        count += helper(nums, target, index+1, curr_sum, memo)\n        \n        memo[(index, curr_sum)] = count\n        \n        return count\n    \n    memo = {}\n    return helper(nums, target, 0, 0, memo)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 5)\n\nassert f(*g()) == 3\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(num_list: list, target=10) -> bool:\n    \"\"\"Find two numbers in the list whose sum is equal to the target\"\"\"\n    sorted_list = sorted(num_list)\n    left = 0\n    right = len(sorted_list) - 1\n    while left < right:\n        current_sum = sorted_list[left] + sorted_list[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g())\n",
        "idx_generation": 4,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D matrix where each row is sorted in ascending order and the first element of each row is greater than the last element of the previous row, determine if a target value exists in the matrix.\n    Return True if the target value is found, otherwise return False.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    left = 0\n    right = rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_element = matrix[mid // cols][mid % cols]\n        if mid_element == target:\n            return True\n        elif mid_element < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\ndef g():\n    return [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\nassert f(g(), 3)\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=100) -> bool:\n    \"\"\"Find a subset of numbers that multiplies to the target.\"\"\"\n    numbers.sort()\n    n = len(numbers)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][1] = True\n    for i in range(1, n + 1):\n        for j in range(2, target + 1):\n            if j < numbers[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j // numbers[i - 1]]\n    return dp[n][target]\ndef g(target=100):\n    return [2, 4, 5, 10]\nassert f(g())\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with the same elements but in sorted order.\"\"\"\n    def mergeSort(arr):\n        if len(arr) <= 1:\n            return arr\n        \n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        \n        left = mergeSort(left)\n        right = mergeSort(right)\n        \n        return merge(left, right)\n    \n    def merge(left, right):\n        result = []\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        \n        while i < len(left):\n            result.append(left[i])\n            i += 1\n        \n        while j < len(right):\n            result.append(right[j])\n            j += 1\n        \n        return result\n    \n    return mergeSort(nums)\n\ndef g(nums=[9, 5, 7, 3, 1]):\n    return nums\n\nassert f(g()) == [1, 3, 5, 7, 9]\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there are any two numbers that form a pair whose product is a perfect square.\"\"\"\n    def is_perfect_square(n):\n        return int(n ** 0.5) ** 2 == n\n    nums.sort()\n    for i in range(len(nums)-1):\n        for j in range(i+1, len(nums)):\n            if is_perfect_square(nums[i] * nums[j]):\n                return True\n    return False\n\ndef g():\n    return [2, 6, 4, 3, 9]\n\nassert f(g())\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left to the bottom-right corner of the grid\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j])\n\n    return dp[rows - 1][cols - 1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 419,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers that sum up to the target.\"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Calculate the factorial of a given number.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * f(n-1)\ndef g() -> int:\n    return 5\nassert f(g()) == 120\n",
        "idx_generation": 107,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str, target=\"abc\") -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string.\"\"\"\n    perms = [''.join(p) for p in permutations(s)]\n    return target in perms\n\ndef g(s=\"bca\", target=\"abc\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 53,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Check if the given string follows the given pattern\"\"\"\n    pattern_dict = {}\n    words = s.split()\n    if len(words) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_dict:\n            if words[i] in pattern_dict.values():\n                return False\n            pattern_dict[pattern[i]] = words[i]\n        elif pattern_dict[pattern[i]] != words[i]:\n            return False\n    return True\n\ndef g(pattern: str, words: List[str]):\n    return ' '.join(words)\n\nassert f(g('abba', ['cat', 'dog', 'dog', 'cat']), pattern='abba')\n",
        "idx_generation": 266,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subsequence of length 3 such that the sum of the first two elements is equal to the third element.\n    Return True if such a subsequence exists, False otherwise.\"\"\"\n    for i in range(len(nums)-2):\n        for j in range(i+1, len(nums)-1):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] == nums[k]:\n                    return True\n    return False\n\ndef g():\n    return [1, 3, 2, 5, 7, 8]\n\nassert f(g())\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a matrix is a magic square.\"\"\"\n    n = len(matrix)\n    sum_rows = [sum(row) for row in matrix]\n    sum_cols = [sum(col) for col in zip(*matrix)]\n    sum_diagonal1 = sum(matrix[i][i] for i in range(n))\n    sum_diagonal2 = sum(matrix[i][n-i-1] for i in range(n))\n    return all(s == sum_cols[0] for s in sum_rows) and all(s == sum_cols[0] for s in sum_cols) and sum_diagonal1 == sum_diagonal2 == sum_cols[0]\n\ndef g(matrix=[[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given an array of integers and a target value, return the number of subarrays that sum to the target.\n    The subarray must consist of consecutive elements from the original array.\"\"\"\n    count = 0\n    curr_sum = 0\n    prefix_sum = {0: 1}\n    for num in arr:\n        curr_sum += num\n        count += prefix_sum.get(curr_sum - target, 0)\n        prefix_sum[curr_sum] = prefix_sum.get(curr_sum, 0) + 1\n    return count\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9)) == 2\n",
        "idx_generation": 359,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given an array of integers nums and a target integer, find two numbers in the array that add up to the target. Return the sum of these two numbers.\"\"\"\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return num + (target - num)\n        seen.add(num)\n    return -1\ndef g(nums=[2, 4, 7, 11, 15], target=9):\n    return (nums, target)\nassert f(*g()) == 9\n",
        "idx_generation": 310,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid consisting of only 0s and 1s, determine if it is possible to reach the bottom-right corner of the grid starting from the top-left corner. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = [(0, 0)]\n    while queue:\n        x, y = queue.pop(0)\n        if x == rows - 1 and y == cols - 1:\n            return True\n        if x + 1 < rows and grid[x + 1][y] == 1:\n            queue.append((x + 1, y))\n        if y + 1 < cols and grid[x][y + 1] == 1:\n            queue.append((x, y + 1))\n    return False\n\ndef g():\n    return [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1], [0, 0, 0, 1]]\n\nassert f(g())\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target sum, determine if there exists a subset of the list that adds up to the target sum.\"\"\"\n    def subset_sum(nums, target, index):\n        if target == 0:\n            return True\n        if target < 0 or index >= len(nums):\n            return False\n        include = subset_sum(nums, target - nums[index], index + 1)\n        exclude = subset_sum(nums, target, index + 1)\n        return include or exclude\n    return subset_sum(nums, target, 0)\ndef g(target=10):\n    nums = [1, 2, 3, 4, 5]\n    return nums\nassert f(g())\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=10) -> bool:\n    \"\"\"Check if there exists a path in the grid to reach the target sum\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    def dfs(row, col, curr_sum):\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:\n            return False\n        curr_sum += grid[row][col]\n        if curr_sum == target:\n            return True\n        visited[row][col] = True\n        if dfs(row+1, col, curr_sum) or dfs(row-1, col, curr_sum) or dfs(row, col+1, curr_sum) or dfs(row, col-1, curr_sum):\n            return True\n        visited[row][col] = False\n        return False\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(target=10):\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the number of unique paths from the top-left to the bottom-right corner of a grid, where you can only move down or right.\n    The grid is represented as a matrix.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    \n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return 1\n        if memo[i][j] != 0:\n            return memo[i][j]\n        down_paths = right_paths = 0\n        if i + 1 < rows and grid[i + 1][j] != 1:\n            down_paths = dfs(i + 1, j)\n        if j + 1 < cols and grid[i][j + 1] != 1:\n            right_paths = dfs(i, j + 1)\n        memo[i][j] = down_paths + right_paths\n        return memo[i][j]\n    \n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[0, 0, 0], [0, 1, 0], [0, 0, 0]])) == 2\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string can be formed by concatenating elements from a given list of words.\"\"\"\n    def helper(string, words):\n        if string == \"\":\n            return True\n        for word in words:\n            if string.startswith(word) and helper(string[len(word):], words):\n                return True\n        return False\n    \n    return helper(string, [\"apple\", \"banana\", \"orange\", \"pear\"])\n\ndef g(string: str):\n    return string\n\n# Example usage:\nstring = \"applebanana\"\nassert f(g(string))\n",
        "idx_generation": 143,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, bit_pos: int) -> bool:\n    \"\"\"Given a number, check if the bit at the given position is set (1) or not (0).\"\"\"\n    return (num >> bit_pos) & 1 == 1\n\ndef g(num: int, bit_pos: int):\n    \"\"\"Return the number with the bit at the given position set (1).\"\"\"\n    return num | (1 << bit_pos)\n\nassert f(g(5, 2), 2) == True\n",
        "idx_generation": 95,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the factorial of a number.\"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in a directed graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    return False\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [4], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return graph, start, end\nassert f(*g())\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes start and end, check if there is a path from start to end in the graph.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }, 'A', 'E'\n\nassert f(*g())\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: str):\n        self.val = val\n        self.children = []\n\ndef f(root: Node) -> bool:\n    \"\"\"Check if the given tree is a binary tree.\"\"\"\n    def is_binary_tree(node: Node) -> bool:\n        if len(node.children) > 2:\n            return False\n        for child in node.children:\n            if not is_binary_tree(child):\n                return False\n        return True\n    \n    return is_binary_tree(root)\n\ndef g() -> Node:\n    a = Node(\"A\")\n    b = Node(\"B\")\n    c = Node(\"C\")\n    d = Node(\"D\")\n    e = Node(\"E\")\n    \n    a.children = [b, c]\n    b.children = [d, e]\n    \n    return a\n\nroot = g()\nassert f(root)\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the target node in the given graph using breadth-first search (BFS).\"\"\"\n    visited = set()\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        if node == target:\n            return True\n\n        # Add adjacent nodes to the queue\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n    \n    return False\n\ndef g():\n    return [\n        [1, 2],\n        [2, 3],\n        [3],\n        [4],\n        []\n    ]\n\nassert f(g(), 0, 4)\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> List[int]:\n    \"\"\"Given a non-negative integer n, generate the first n rows of Pascal's triangle.\"\"\"\n    triangle = []\n    for i in range(n):\n        row = [1] * (i+1)\n        if i > 1:\n            for j in range(1, i):\n                row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        triangle.append(row)\n    return triangle\ndef g():\n    return 5\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 54,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers, n and k, compute the number of ways to choose k items from a set of n items without repetition and without regard to the order of selection. This is known as the binomial coefficient.\n    Sample input:\n    n = 5\n    k = 3\n    Sample output:\n    10\n    There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Return the input values n and k.\"\"\"\n    return n, k\n\nassert f(*g(5, 3)) == 10\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose product is equal to the target number.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        product = arr[left] * arr[right]\n        if product == target:\n            return True\n        elif product < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr\n\n# Test case\narr = [2, 7, 5, 6, 4, 3, 1]\ntarget = 12\nassert f(g(arr, target), target)\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value using binary search.\n    If the target value is not present in the list, return -1.\n    Args:\n    - nums: A sorted list of integers\n    - target: The target value to search for\n    Returns:\n    - The index of the target value in the list, or -1 if it is not present\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 201,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(array: List[int], target: int) -> int:\n    \"\"\"Given an array of integers and a target sum, find the minimum number of elements from the array that add up to the target sum.\n    Return the minimum number of elements required, or -1 if it is not possible to achieve the target sum.\"\"\"\n    n = len(array)\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        for j in range(n):\n            if array[j] <= i:\n                dp[i] = min(dp[i], dp[i - array[j]] + 1)\n    if dp[target] == float('inf'):\n        return -1\n    return dp[target]\n\ndef g():\n    array = [2, 3, 5]\n    target = 11\n    return array, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum, where a subarray is a contiguous portion of the original array.\n- nums: List of integers\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\ndef g():\n    return [1, -2, 3, -4, 5]\nassert f(g()) == 5\n",
        "idx_generation": 492,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers from the list.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    Sample Output:\n    60\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\nassert f(*g()) == 60\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Count the number of islands in the given grid. An island is a group of connected '1's, where connections can be either horizontal or vertical.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    islands = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                dfs(grid, i, j)\n                islands += 1\n    return islands\n\ndef dfs(grid: List[List[str]], row: int, col: int) -> None:\n    rows = len(grid)\n    cols = len(grid[0])\n    if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] != '1':\n        return\n    grid[row][col] = '#'\n    dfs(grid, row - 1, col)\n    dfs(grid, row + 1, col)\n    dfs(grid, row, col - 1)\n    dfs(grid, row, col + 1)\n\ndef g():\n    grid = [['1', '1', '0', '0', '0'],\n            ['1', '1', '0', '0', '0'],\n            ['0', '0', '1', '0', '0'],\n            ['0', '0', '0', '1', '1']]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 426,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(k: int, nums: List[int]) -> List[int]:\n    \"\"\"Given an integer k and a list of integers, return the k most frequent elements in the list.\n    If there are multiple elements with the same frequency, return them in ascending order.\n    \"\"\"\n    frequency = {}\n    for num in nums:\n        frequency[num] = frequency.get(num, 0) + 1\n    sorted_nums = sorted(frequency.keys(), key=lambda x: (-frequency[x], x))\n    return sorted_nums[:k]\ndef g():\n    return (2, [1, 1, 1, 2, 2, 3])\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 304,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list whose elements sum up to the target value.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 110,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, s: str) -> bool:\n    \"\"\"Check if it is possible to form a string of length n using k distinct characters from the given string s.\"\"\"\n    if n > len(s):\n        return False\n    unique_chars = len(set(s))\n    return unique_chars >= k\ndef g(n=5, k=3, s=\"abracadabra\"):\n    return n, k, s[:k] * (n // k) + s[:n % k]\nassert f(*g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid palindrome after removing at most one character.\"\"\"\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    start = 0\n    end = len(s) - 1\n    while start < end:\n        if s[start] != s[end]:\n            return is_palindrome(s, start+1, end) or is_palindrome(s, start, end-1)\n        start += 1\n        end -= 1\n\n    return True\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 282,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid parentheses sequence.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g(s='((()))'):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the sum of all elements in the matrix that are divisible by 3.\"\"\"\n    total = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0:\n                total += num\n    return total\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 18\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there is a subarray with an equal number of even and odd elements.\n    Return True if such subarray exists, otherwise return False.\"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sums = {0: -1}\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count += 1\n        else:\n            count -= 1\n        if count in prefix_sums:\n            if i - prefix_sums[count] > 1:\n                return True\n        else:\n            prefix_sums[count] = i\n    return False\ndef g():\n    return [2, 4, 6, 3, 1, 8, 9, 10]\nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, return True if it is a power of two, False otherwise.\"\"\"\n    def is_power_of_two(n):\n        if n == 0:\n            return False\n        while n != 1:\n            if n % 2 != 0:\n                return False\n            n = n // 2\n        return True\n    \n    return is_power_of_two(n)\n\ndef g():\n    n = 16\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 310,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representation of a mathematical expression, determine if the expression is balanced.\n    An expression is balanced if it contains matching opening and closing parentheses, brackets, and braces.\n    \"\"\"\n\n    stack = []\n\n    for char in expression:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n        elif char in [')', ']', '}']:\n            if not stack:\n                return False\n            opening = stack.pop()\n            if (char == ')' and opening != '(') or \\\n               (char == ']' and opening != '[') or \\\n               (char == '}' and opening != '{'):\n                return False\n\n    return len(stack) == 0\n\ndef g():\n    return \"((3 + 4) * 5) + [2 * {5 - 2}]\"\n\nassert f(g())\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \n    Args:\n    - nums: A list of integers.\n    \n    Returns:\n    - The length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \n    Returns:\n    - A list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 55,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], rows=0, cols=0) -> bool:\n    \"\"\"Check if the given grid is a magic square\"\"\"\n    n = len(grid)\n    if n != rows or len(grid[0]) != cols:\n        return False\n\n    target_sum = sum(grid[0])\n\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(cols):\n        col_sum = 0\n        for i in range(rows):\n            col_sum += grid[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = 0\n    reverse_diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += grid[i][i]\n        reverse_diagonal_sum += grid[i][n - 1 - i]\n    if diagonal_sum != target_sum or reverse_diagonal_sum != target_sum:\n        return False\n\n    return True\n\ndef g(rows=0, cols=0):\n    grid = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return grid\n\nassert f(g(), rows=3, cols=3)\n",
        "idx_generation": 324,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner in a grid of size n x n.\n    You can only move down or right at each step.\"\"\"\n    def backtrack(row, col):\n        if row == n - 1 and col == n - 1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        return backtrack(row + 1, col) + backtrack(row, col + 1)\n    return backtrack(0, 0)\ndef g() -> int:\n    return 3\nassert f(g()) == 6\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> int:\n    \"\"\"Find the minimum number of operations required to transform the string s into the target string by performing the following operations:\n    1. Replace a character in s with any other character.\n    2. Insert any character at any position in s.\n    3. Delete any character from s.\"\"\"\n    m, n = len(s), len(target)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == target[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\ndef g():\n    return (\"kitten\", \"sitting\")\nassert f(*g()) == 3\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two positive integers n and k, find the maximum bitwise AND value of any two integers from 1 to n, inclusive,\n    such that the value is less than or equal to k.\"\"\"\n    def max_bitwise_and(n, k):\n        max_and = 0\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                bitwise_and = i & j\n                if bitwise_and <= k and bitwise_and > max_and:\n                    max_and = bitwise_and\n        return max_and\n    return max_bitwise_and(n, k)\n\ndef g():\n    n = 5\n    k = 3\n    return (n, k)\n\nassert f(*g()) == 2\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sums up to the target using recursion.\"\"\"\n    return find_pair(arr, target, 0, len(arr)-1)\n\ndef find_pair(arr: List[int], target: int, left: int, right: int) -> bool:\n    if left >= right:\n        return False\n    \n    curr_sum = arr[left] + arr[right]\n    if curr_sum == target:\n        return True\n    elif curr_sum < target:\n        return find_pair(arr, target, left+1, right)\n    else:\n        return find_pair(arr, target, left, right-1)\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return (arr, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n    Sample Input:\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n    Sample Output:\n    True\"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    return False\n\ndef g():\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n    return graph\nassert f(g())\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        curr_node = stack.pop()\n        if curr_node == end:\n            return True\n        visited.add(curr_node)\n        neighbors = graph[curr_node]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = [[1, 2], [3, 4], [4], [5], [5], []]\n    start = 0\n    end = 5\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 168,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: str):\n        self.val = val\n        self.children = []\n\ndef f(root: Node) -> bool:\n    \"\"\"Check if there is a path in the tree that forms a palindrome string.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    def dfs(node: Node, path: str) -> bool:\n        path += node.val\n        if is_palindrome(path):\n            return True\n        for child in node.children:\n            if dfs(child, path):\n                return True\n        return False\n    \n    return dfs(root, \"\")\n\ndef g() -> Node:\n    a = Node(\"A\")\n    b = Node(\"B\")\n    c = Node(\"C\")\n    d = Node(\"D\")\n    e = Node(\"E\")\n    \n    a.children = [b, c]\n    b.children = [d, e]\n    \n    return a\n\nroot = g()\nassert f(root)\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Determine if there exists a path in the given graph from start to end using at most 3 edges.\"\"\"\n    \n    def dfs(node, visited, edges):\n        if node == end and edges <= 3:\n            return True\n        \n        if edges > 3:\n            return False\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, edges+1):\n                    return True\n        \n        visited[node] = False\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(start, visited, 0)\n\ndef g(start=0, end=3):\n    graph = [[1, 2], [2, 3], [3], []]\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(n: int, k: int, num_list: list) -> bool:\n    \"\"\"Find if there exists a combination of k numbers in num_list whose sum is equal to n.\"\"\"\n    combinations = list(itertools.combinations(num_list, k))\n    for combination in combinations:\n        if sum(combination) == n:\n            return True\n    return False\n\ndef g(n: int, k: int):\n    num_list = list(range(1, n+1))\n    return num_list\n\nassert f(n=10, k=3, num_list=g(n=10, k=3))\n",
        "idx_generation": 73,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two positive integers n and k, determine if there exists a combination of k numbers from the range 1 to n\nsuch that the sum of the combination is divisible by k.\nArgs:\n    n: The range of numbers from 1 to n.\n    k: The number of elements in the combination.\nReturns:\n    True if such a combination exists, False otherwise.\"\"\"\n    def dfs(nums, target, k, start):\n        if k == 1:\n            return target in nums\n        for i in range(start, len(nums)):\n            if dfs(nums, (target + nums[i]) % k, k - 1, i + 1):\n                return True\n        return False\n    \n    nums = list(range(1, n + 1))\n    return dfs(nums, 0, k, 0)\n\ndef g(n=10, k=3):\n    \"\"\"\n    Returns the range of numbers from 1 to n and the number of elements in the combination.\n    \"\"\"\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, return the index of the target value in the list. If the target value is not found, return -1.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef g(arr=[1, 3, 5, 7, 9, 11, 13, 15, 17, 19], target=7):\n    return arr, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 5,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given array in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g():\n    arr = [5, 2, 8, 1, 9]\n    return arr\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, find if there exists a combination of numbers from the list that adds up to the target value.\n    Args:\n        nums: The list of integers.\n        target: The target value.\n    Returns:\n        True if there exists a combination of numbers that adds up to the target value, False otherwise.\n    \"\"\"\n    def dfs(start, cur_sum):\n        if cur_sum == target:\n            return True\n        if cur_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if dfs(i + 1, cur_sum + nums[i]):\n                return True\n        return False\n\n    nums.sort()\n    return dfs(0, 0)\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 15)\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum.\"\"\"\n    current_sum = max_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the product of the smallest and largest numbers in the list.\"\"\"\n    nums.sort()\n    return nums[0] * nums[-1]\ndef g():\n    return [5, 2, 9, 3, 1, 8]\nassert f(g()) == 9\n",
        "idx_generation": 342,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    Return the sum of the minimum path.\n    Sample Input:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    Sample Output:\n    7\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers arr and a target value, determine if the target exists in the array using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\ndef g(arr: List[int], target: int):\n    return (arr, target)\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 5\nassert f(*g(arr, target))\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum of a given list of integers.\nA subarray is a contiguous part of an array. The maximum subarray sum is the largest sum that can be obtained by summing the elements of any contiguous subarray.\"\"\"\n    current_sum = 0\n    max_sum = float('-inf')\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return ([-2, 1, -3, 4, -1, 2, 1, -5, 4],)\n\nassert f(*g()) == 6\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a string is a palindrome, considering only alphanumeric characters and ignoring case.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"\n    Generate a palindrome string by repeating a given string in reverse.\n    \"\"\"\n    return s + s[::-1]\n\n# Test case\nassert f(g(\"racecar\"))\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if it is possible to transform string s into string t by performing the following operations:\n    - Remove any character from s\n    - Insert any character at any position in s\n    - Replace any character in s with any other character\n    Each operation costs 1 unit.\"\"\"\n    m, n = len(s), len(t)\n    if abs(m - n) > 1:\n        return False\n    if m == n:\n        return sum([s[i] != t[i] for i in range(m)]) <= 1\n    else:\n        if m > n:\n            s, t = t, s\n            m, n = n, m\n        i, j = 0, 0\n        while i < m and j < n:\n            if s[i] != t[j]:\n                if i != j:\n                    return False\n                j += 1\n            else:\n                i += 1\n                j += 1\n        return True\ndef g(s: str, t: str):\n    if len(s) < len(t):\n        s, t = t, s\n    return s, t\nassert f(*g('abc', 'abcd'))\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a subset of integers from the given list that sums up to a target value\"\"\"\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        total, index = stack.pop()\n        if total == target:\n            return True\n        if index < len(nums):\n            stack.append((total + nums[index], index + 1))\n            stack.append((total, index + 1))\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 443,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Count the number of perfect squares in the given list of numbers\"\"\"\n    count = 0\n    for num in nums:\n        if int(num**0.5)**2 == num:\n            count += 1\n    return count\ndef g():\n    return [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nassert f(g()) == 10\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of subarrays in the given list that sum up to the target number.\"\"\"\n    prefix_sum = 0\n    count = 0\n    prefix_sums = {0: 1}\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            count += prefix_sums[prefix_sum - target]\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 5) == 2\n",
        "idx_generation": 400,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers arr, return a new list where each element is the product of all elements\n    in arr except itself.\"\"\"\n    product = 1\n    for num in arr:\n        product *= num\n    return [product // num for num in arr]\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([1, 2, 3, 4, 5])) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 311,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all the duplicates removed, using a stack.\"\"\"\n    stack = deque()\n    stack.append(nums[0])\n    for i in range(1, len(nums)):\n        if stack[-1] != nums[i]:\n            stack.append(nums[i])\n    return list(stack)\n\ndef g(nums: List[int]=[1, 2, 2, 3, 4, 4, 5, 5]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers and a target sum k, find if there exists a subset that sums up to k.\"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        return subset_sum(nums, target, index + 1, curr_sum + nums[index]) or subset_sum(nums, target, index + 1, curr_sum)\n    return subset_sum(nums, k, 0, 0)\ndef g():\n    return [1, 2, 3, 4, 5]\nassert f(g())\n",
        "idx_generation": 57,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Count the number of 'X' shapes in the grid\"\"\"\n    count = 0\n    n = len(grid)\n    m = len(grid[0])\n    \n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if grid[i][j] == 'X' and grid[i-1][j-1] == 'X' and grid[i-1][j+1] == 'X' and grid[i+1][j-1] == 'X' and grid[i+1][j+1] == 'X':\n                count += 1\n    \n    return count\n\ndef g():\n    return [['O', 'X', 'O', 'O', 'O'],\n            ['X', 'X', 'X', 'O', 'O'],\n            ['O', 'X', 'O', 'O', 'O'],\n            ['X', 'X', 'X', 'O', 'O'],\n            ['O', 'X', 'O', 'O', 'O']]\n\nassert f(g())\n",
        "idx_generation": 326,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell, moving only down and right.\nArgs:\n    grid: A grid of integers.\nReturns:\n    The maximum sum of a path from the top-left cell to the bottom-right cell.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    \n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n        \n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n            \n    return grid[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \nassert f(g()) == 12\n",
        "idx_generation": 357,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"Check if a string is a palindrome of its binary representation.\"\"\"\n    return bin(n)[2:] == s[::-1]\ndef g(s: str):\n    return int(s, 2)\nassert f(g('11011'), '11011')\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=4) -> bool:\n    \"\"\"Check if there exists a number in the range [1, n] that has exactly k set bits when converted to binary\"\"\"\n    for i in range(1, n+1):\n        if bin(i).count('1') == k:\n            return True\n    return False\ndef g(k=4):\n    return int('1' * k, 2)\nassert f(g())\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of unique paths from the top-left\n    corner to the bottom-right corner in a n x n grid. You can only move down or right.\"\"\"\n    def helper(row: int, col: int) -> int:\n        if row == n-1 and col == n-1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        return helper(row + 1, col) + helper(row, col + 1)\n    return helper(0, 0)\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 99,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], u: int, v: int) -> bool:\n    \"\"\"Given an undirected graph and two vertices u and v, determine if there is a path between u and v.\"\"\"\n    visited = set()\n    stack = [u]\n    while stack:\n        node = stack.pop()\n        if node == v:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n    u = 0\n    v = 4\n    return (graph, u, v)\n\nassert f(*g())\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    Each node in the graph is represented as a string.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current_node = stack.pop()\n        if current_node == end:\n            return True\n        if current_node not in visited:\n            visited.add(current_node)\n            if current_node in graph:\n                stack.extend(graph[current_node])\n    return False\ndef g():\n    return {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['E'], 'E': []}, 'A', 'E'\nassert f(*g())\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph, determine if there is a path from `start` to `end` using depth-first search.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [5],\n        4: [],\n        5: [6],\n        6: []\n    }\n    start = 1\n    end = 6\n    return graph, start, end\nassert f(*g()) == True\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it contains a cycle.\n    Return True if a cycle exists, otherwise return False.\n    \"\"\"\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        \n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, node):\n                        return True\n                elif parent != neighbor:\n                    return True\n        \n        return False\n\n    visited = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    \n    return False\n\ndef g(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the adjacency matrix of the undirected graph.\n    \"\"\"\n\n    return graph\n\nassert f(g([\n    [0, 1, 0, 0],\n    [1, 0, 1, 1],\n    [0, 1, 0, 1],\n    [0, 1, 1, 0]\n]))\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is an anagram of a palindrome.\"\"\"\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    odd_count = 0\n    \n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    \n    return True\n\ndef g(s: str):\n    return s\n\nassert f(g(\"aab\"))\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given a list of integers and a target number, determine all combinations that add up to the target.\"\"\"\n    def backtrack(nums, target, start, current, result):\n        if target == 0:\n            result.append(list(current))\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(nums, target-nums[i], i, current, result)\n            current.pop()\n    \n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return result\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\n\nnums = [2, 3, 6, 7]\ntarget = 7\n\nassert f(g(nums, target), target) == [[2, 2, 3], [7]]\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, return the index of the target value in the list. If the target value is not found, return -1. The list is guaranteed to be sorted in ascending order, but rotated at an unknown pivot point.\"\"\"\n    def binary_search(arr: List[int], target: int, low: int, high: int) -> int:\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] >= arr[low]:\n                if target >= arr[low] and target < arr[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                if target > arr[mid] and target <= arr[high]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return -1\n    \n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[6, 7, 8, 9, 10, 1, 2, 3, 4, 5], target=3):\n    return arr, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, sort the array in non-decreasing order using the Bubble Sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef g():\n    return [64, 34, 25, 12, 22, 11, 90]\n\nassert f(g()) == [11, 12, 22, 25, 34, 64, 90]\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in a sorted list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python', char='y') -> bool:\n    \"\"\"Check if the given string has the character 'y' at the same index as in the target string.\"\"\"\n    return all(s[i] == char for i, c in enumerate(target) if c == char)\ndef g(target='python', char='y'):\n    return target\nassert f(g())\n",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort an array in ascending order using bubble sort algorithm\"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\ndef g():\n    arr = [5, 2, 9, 1, 3]\n    return arr\nassert f(g()) == [1, 2, 3, 5, 9]\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers arr, determine if there exists three elements a, b, c in arr such that a^2 + b^2 = c^2.\nReturns True if such elements exist, False otherwise.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 2):\n        a = arr[i]\n        left = i + 1\n        right = n - 1\n        while left < right:\n            b = arr[left]\n            c = arr[right]\n            if a * a + b * b == c * c:\n                return True\n            elif a * a + b * b < c * c:\n                right -= 1\n            else:\n                left += 1\n    return False\ndef g():\n    arr = [3, 4, 5, 6, 7, 8, 9, 10]\n    return arr\nassert f(g()) == True\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two integers in the given list that sum up to the target number. Return their indices in ascending order.\"\"\"\n    nums_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in nums_map:\n            return [nums_map[complement], i]\n        nums_map[num] = i\n    return []\ndef g(target: int):\n    \"\"\"\n    Returns a list of integers.\n    \"\"\"\n    return [2, 7, 11, 15]\nassert f(g(9), 9) == [0, 1]\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it can be represented as a sum of distinct Fibonacci numbers.\n    Return True if it can, False otherwise.\"\"\"\n    def is_sum_of_fibonacci_numbers(n, fib_nums, index):\n        if n == 0:\n            return True\n        if index < 0 or n < 0:\n            return False\n        if n < fib_nums[index]:\n            return is_sum_of_fibonacci_numbers(n, fib_nums, index - 1)\n        return is_sum_of_fibonacci_numbers(n - fib_nums[index], fib_nums, index - 1) or is_sum_of_fibonacci_numbers(n, fib_nums, index - 1)\n\n    fib_nums = [1, 1]\n    while fib_nums[-1] < n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n    return is_sum_of_fibonacci_numbers(n, fib_nums, len(fib_nums) - 1)\n\ndef g(n: int):\n    \"\"\"Generate a combination of distinct Fibonacci numbers that sum up to n.\"\"\"\n    def generate_sum_of_fibonacci_numbers(n, fib_nums, index, combination):\n        if n == 0:\n            return combination\n        if index < 0 or n < 0:\n            return []\n        if n < fib_nums[index]:\n            return generate_sum_of_fibonacci_numbers(n, fib_nums, index - 1, combination)\n        combination.append(fib_nums[index])\n        return generate_sum_of_fibonacci_numbers(n - fib_nums[index], fib_nums, index - 1, combination)\n    \n    fib_nums = [1, 1]\n    while fib_nums[-1] < n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n    return generate_sum_of_fibonacci_numbers(n, fib_nums, len(fib_nums) - 1, [])\n\nassert f(21)\nassert sum(g(21)) == 21\n",
        "idx_generation": 141,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome, considering only alphanumeric characters and ignoring case.\"\"\"\n    def is_valid_char(c):\n        return c.isalnum()\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if not is_valid_char(s[left]):\n            left += 1\n        elif not is_valid_char(s[right]):\n            right -= 1\n        elif s[left].lower() != s[right].lower():\n            return False\n        else:\n            left += 1\n            right -= 1\n\n    return True\n\ndef g():\n    return (\"A man, a plan, a canal: Panama\",)\n\nassert f(*g())\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of numbers, find the majority element(s) - the element(s) that appears more than n/2 times.\"\"\"\n    counts = {}\n    n = len(nums)\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    majority_elements = []\n    for num, count in counts.items():\n        if count > n // 2:\n            majority_elements.append(num)\n    return majority_elements\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nassert f(g(nums)) == [2]\n",
        "idx_generation": 337,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of prime numbers less than or equal to n.\"\"\"\n    primes = []\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return len(primes)\ndef g():\n    n = 20\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of non-negative integers, find the maximum product that can be obtained by multiplying a subarray of the list.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    max_so_far = nums[0]\n\n    for i in range(1, n):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n\n        max_so_far = max(max_so_far, max_product)\n\n    return max_so_far\n\ndef g(nums: List[int] = [2, 3, -2, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 452,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, coordinates: List[Tuple[int, int]]) -> bool:\n    \"\"\"Check if a given coordinate is in the form of (x, y) and lies on the circumference of a circle with radius n.\"\"\"\n    for coordinate in coordinates:\n        x, y = coordinate\n        if (x ** 2 + y ** 2) == n ** 2:\n            return True\n    return False\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate a positive integer and a list of coordinates.\n    \"\"\"\n    return (5, [(3, 4), (-3, -4), (0, 5)])\nassert f(*g()) == True\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a mathematical expression as a string, check if the parentheses are balanced.\n    Args:\n        expression: The mathematical expression as a string.\n    Returns:\n        True if the parentheses are balanced, False otherwise.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Returns a sample mathematical expression with balanced parentheses.\n    \"\"\"\n    return \"(1 + 2) * (3 - 4)\"\n\nassert f(g())\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence (not necessarily contiguous)\n    in the list.\n    \"\"\"\n    def longest_increasing_subsequence(arr):\n        lis = [1] * len(arr)\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                    lis[i] = lis[j] + 1\n        return max(lis)\n    \n    return longest_increasing_subsequence(arr)\n\ndef g():\n    arr = [1, 3, 2, 4, 5, 7, 6, 8]\n    return (arr,)\n\nassert f(*g()) == 6\n",
        "idx_generation": 58,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, return True if the grid contains a magic square, and False otherwise.\n    A magic square is a square grid of numbers such that the sums of the numbers in each row, each column,\n    and both diagonals are the same.\"\"\"\n    def is_magic_square(square: List[List[int]]) -> bool:\n        target_sum = sum(square[0])\n        for row in square:\n            if sum(row) != target_sum:\n                return False\n        for col in range(len(square[0])):\n            if sum(square[row][col] for row in range(len(square))) != target_sum:\n                return False\n        if sum(square[i][i] for i in range(len(square))) != target_sum:\n            return False\n        if sum(square[i][len(square)-i-1] for i in range(len(square))) != target_sum:\n            return False\n        return True\n\n    for row in range(len(grid)-2):\n        for col in range(len(grid[0])-2):\n            square = [[grid[row+i][col+j] for j in range(3)] for i in range(3)]\n            if is_magic_square(square):\n                return True\n    return False\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a grid of integers, return a magic square contained in the grid.\"\"\"\n    def is_magic_square(square: List[List[int]]) -> bool:\n        target_sum = sum(square[0])\n        for row in square:\n            if sum(row) != target_sum:\n                return False\n        for col in range(len(square[0])):\n            if sum(square[row][col] for row in range(len(square))) != target_sum:\n                return False\n        if sum(square[i][i] for i in range(len(square))) != target_sum:\n            return False\n        if sum(square[i][len(square)-i-1] for i in range(len(square))) != target_sum:\n            return False\n        return True\n\n    for row in range(len(grid)-2):\n        for col in range(len(grid[0])-2):\n            square = [[grid[row+i][col+j] for j in range(3)] for i in range(3)]\n            if is_magic_square(square):\n                return square\n    return []\n\n# Example usage:\ngrid = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\nassert f(g(grid))\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner.\nThe grid is represented by a 2D list of integers, where each element represents the cost of moving to that position.\nYou can only move down or right, and the minimum cost path should be chosen.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[rows - 1][cols - 1]\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 7\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Given a string and a list of words, determine if it is possible to form the string by concatenating the words in any order.\nThe string can be formed by concatenating the words without any additional characters in between.\nReturn True if it is possible, False otherwise.\"\"\"\n    def dfs(word_idx: int, start_idx: int) -> bool:\n        if start_idx == len(s):\n            return True\n        if word_idx >= len(words):\n            return False\n        if s.startswith(words[word_idx], start_idx):\n            return dfs(word_idx + 1, start_idx + len(words[word_idx]))\n        return dfs(word_idx + 1, start_idx)\n    return dfs(0, 0)\ndef g(s: str, words: List[str]):\n    return (s, words)\ns = \"leetcode\"\nwords = [\"leet\", \"code\"]\nassert f(*g(s, words))\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits (bits with value 1) in the binary representation of the given number.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 42\n\nassert f(g()) == 3\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of paths from the top-left corner to the bottom-right corner in a n x n grid.\n    You can only move down or right.\"\"\"\n    def dfs(x: int, y: int) -> int:\n        if x == n-1 and y == n-1:\n            return 1\n        if x >= n or y >= n:\n            return 0\n        return dfs(x+1, y) + dfs(x, y+1)\n    \n    return dfs(0, 0)\ndef g(n: int):\n    return n\nn = 3\nassert f(g(n)) == 6\n",
        "idx_generation": 116,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Given a grid represented by a 2D list of integers, determine if there exists a path from the start point to the end point.\n    A path can only be formed by moving in four directions: up, down, left, and right. 0 represents an empty cell, and 1 represents an obstacle.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 1 or visited[row][col]:\n            return False\n        \n        visited[row][col] = True\n        \n        if (row, col) == end:\n            return True\n        \n        return dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1)\n    \n    return dfs(start[0], start[1])\ndef g():\n    return [[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 1],\n            [0, 0, 0, 0, 0]], (0, 0), (4, 4)\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in the given graph.\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node in visited:\n            continue\n        visited.add(node)\n        if node in graph:\n            stack.extend(graph[node])\n    return False\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['A']\n    }\n    return graph\nassert f(g(), 'A', 'D')\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner, where the path only moves down or right.\"\"\"\n    def helper(matrix, row, col):\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return True\n        if row >= len(matrix) or col >= len(matrix[0]):\n            return False\n        \n        return helper(matrix, row + 1, col) or helper(matrix, row, col + 1)\n    \n    return helper(matrix, 0, 0)\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 134,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner\n    consisting only of 1s.\n    Example:\n    Input:\n    [[1, 1, 0, 0],\n     [1, 1, 1, 0],\n     [0, 1, 1, 1],\n     [0, 0, 1, 1]]\n    Output: True\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n        visited[i][j] = True\n        \n        if i + 1 < m and grid[i + 1][j] == 1 and not visited[i + 1][j]:\n            if dfs(i + 1, j):\n                return True\n        if j + 1 < n and grid[i][j + 1] == 1 and not visited[i][j + 1]:\n            if dfs(i, j + 1):\n                return True\n        \n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    return [[1, 1, 0, 0],\n            [1, 1, 1, 0],\n            [0, 1, 1, 1],\n            [0, 0, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the total number of distinct combinations of two numbers in the list.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] != nums[j]:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 10\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of distinct subsets of nums that sum up to the target value.\n    Return the count of the distinct subsets.\n    \"\"\"\n    def count_subsets(nums: List[int], target: int, index: int, memo: dict) -> int:\n        if target == 0:\n            return 1\n        if index == len(nums):\n            return 0\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        count = count_subsets(nums, target - nums[index], index + 1, memo) + count_subsets(nums, target, index + 1, memo)\n        memo[(index, target)] = count\n        return count\n\n    return count_subsets(nums, target, 0, {})\n\ndef g(nums=[2, 4, 6, 8], target=14):\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if n is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> Tuple[int, int]:\n    return 17, 3\n\nassert f(*g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 213,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    The subarray must contain at least one element.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2,1,-3,4,-1,2,1,-5,4]\n\nassert f(g()) == 6\n",
        "idx_generation": 93,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern='abc') -> bool:\n    \"\"\"Find a string that follows a specific pattern by repeating a given substring.\"\"\"\n    return s == pattern * (len(s) // len(pattern))\ndef g(pattern='abc'):\n    return pattern * 3\nassert f(g())\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with the squares of each number, sorted in non-decreasing order.\"\"\"\n    return sorted([num ** 2 for num in nums])\n\ndef g(nums=[-4, -2, 0, 2, 4]):\n    return nums\n\nassert f(g()) == [0, 4, 4, 16, 16]\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import *\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a permutation of the range from 0 to n-1 (inclusive), where n is the length of the array.\"\"\"\n    n = len(arr)\n    return sorted(arr) == list(range(n))\n\ndef g(n: int) -> List[int]:\n    \"\"\"Generate a random permutation of the range from 0 to n-1 (inclusive).\"\"\"\n    import random\n    return random.sample(range(n), n)\n\nassert f(g(10))\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'arr' and a target value 'target', find the minimum number of elements from the list that sum up to the target value. Return the count of the minimum elements.\n\"\"\"\n    n = len(arr)\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        for j in range(n):\n            if arr[j] <= i:\n                dp[i] = min(dp[i], dp[i - arr[j]] + 1)\n    return dp[target]\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 5], 11)) == 3\n",
        "idx_generation": 164,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if they are isomorphic to each other.\"\"\"\n    if len(s) != len(t):\n        return False\n    mapping = {}\n    used = set()\n    for i in range(len(s)):\n        if s[i] not in mapping and t[i] not in used:\n            mapping[s[i]] = t[i]\n            used.add(t[i])\n        elif s[i] in mapping and mapping[s[i]] == t[i]:\n            continue\n        else:\n            return False\n    return True\ndef g():\n    return 'egg', 'add'\nassert f(*g())\n",
        "idx_generation": 122,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s, check if there exists a substring of length k that is a palindrome.\"\"\"\n    for i in range(len(s) - k + 1):\n        sub = s[i:i+k]\n        if sub == sub[::-1]:\n            return True\n    return False\n\ndef g(k: int) -> str:\n    return 'racecar' if k == 7 else 'python' if k == 6 else 'level'\n\nassert f(g(5), 3)\n",
        "idx_generation": 354,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of trailing zeros in the factorial of a given number\"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 6\n",
        "idx_generation": 386,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, return a new array such that each element at index 'i' of the new array is the product of all the numbers in the original array except the one at 'i'.\n    Solve it without using the division operator and in O(n) time complexity.\"\"\"\n    n = len(nums)\n    left = [1] * n\n    right = [1] * n\n    output = [1] * n\n    \n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n        \n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n        \n    for i in range(n):\n        output[i] = left[i] * right[i]\n        \n    return output\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return the array of integers.\n    \"\"\"\n    return nums\nassert f(g([1, 2, 3, 4, 5])) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid is a valid Sudoku solution.\"\"\"\n    def is_valid(arr: List[int]) -> bool:\n        \"\"\"Check if a list of numbers contains all digits from 1 to 9 without repetition.\"\"\"\n        return set(arr) == set(range(1, 10))\n    \n    for row in grid:\n        if not is_valid(row):\n            return False\n    \n    for col in zip(*grid):\n        if not is_valid(col):\n            return False\n    \n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid(subgrid):\n                return False\n    \n    return True\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\ngrid = [\n    [5, 3, 4, 6, 7, 8, 9, 1, 2],\n    [6, 7, 2, 1, 9, 5, 3, 4, 8],\n    [1, 9, 8, 3, 4, 2, 5, 6, 7],\n    [8, 5, 9, 7, 6, 1, 4, 2, 3],\n    [4, 2, 6, 8, 5, 3, 7, 9, 1],\n    [7, 1, 3, 9, 2, 4, 8, 5, 6],\n    [9, 6, 1, 5, 3, 7, 2, 8, 4],\n    [2, 8, 7, 4, 1, 9, 6, 3, 5],\n    [3, 4, 5, 2, 8, 6, 1, 7, 9]\n]\nassert f(g(grid))\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string 'expression' containing only the characters '(', ')', '{', '}', '[', and ']',\n    determine if the input string is valid according to the following rules:\n    - Open brackets must be closed by the same type of brackets.\n    - Open brackets must be closed in the correct order.\n    Return True if the string is valid, False otherwise.\"\"\"\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in expression:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or bracket_map[char] != stack.pop():\n                return False\n    return len(stack) == 0\ndef g():\n    expression = \"({[()]})\"\n    return expression\nassert f(g())\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"Given a grid of integers, find the shortest path from the start cell to the end cell using only right and down movements. Return the sum of the values along the shortest path.\n    Sample Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    Sample Output:\n    7\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[start[0]][start[1]] = grid[start[0]][start[1]]\n    for i in range(start[0]+1, m):\n        dp[i][start[1]] = dp[i-1][start[1]] + grid[i][start[1]]\n    for j in range(start[1]+1, n):\n        dp[start[0]][j] = dp[start[0]][j-1] + grid[start[0]][j]\n    for i in range(start[0]+1, m):\n        for j in range(start[1]+1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[end[0]][end[1]]\ndef g(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> None:\n    \"\"\"\n    Generate a grid of integers, start cell, and end cell.\n    \"\"\"\n    return (grid, start, end)\ngrid = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\nstart = (0, 0)\nend = (2, 2)\nassert f(*g(grid, start, end)) == 7\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed using only 1s.\n    The sides of the rectangle must be parallel to the axes.\n    Return the maximum area.\"\"\"\n    def largest_rectangle_histogram(heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        i = 0\n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i if not stack else i - stack[-1] - 1)\n                max_area = max(max_area, area)\n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i if not stack else i - stack[-1] - 1)\n            max_area = max(max_area, area)\n        return max_area\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_area = 0\n    heights = [0] * cols\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n\n        max_area = max(max_area, largest_rectangle_histogram(heights))\n\n    return max_area\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\ngrid = [[1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]]\nassert f(g(grid)) == 6\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int, target_sum: int = 10) -> bool:\n    \"\"\"Given a grid of integers, find a subgrid with a sum equal to or less than the target_sum, such that it contains\n    at least k numbers.\n    Sample Input:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    k = 3\n    target_sum = 10\n    Sample Output:\n    [[1, 2], [4, 5]]\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for r1 in range(rows):\n        for r2 in range(r1, rows):\n            for c1 in range(cols):\n                for c2 in range(c1, cols):\n                    subgrid = [grid[i][j] for i in range(r1, r2 + 1) for j in range(c1, c2 + 1)]\n                    if sum(subgrid) <= target_sum and len(subgrid) >= k:\n                        return True\n    return False\n\ndef g(grid: List[List[int]], k: int, target_sum: int = 10) -> List[List[int]]:\n    \"\"\"Given a grid of integers, find a subgrid with a sum equal to or less than the target_sum, such that it contains\n    at least k numbers.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for r1 in range(rows):\n        for r2 in range(r1, rows):\n            for c1 in range(cols):\n                for c2 in range(c1, cols):\n                    subgrid = [grid[i][j] for i in range(r1, r2 + 1) for j in range(c1, c2 + 1)]\n                    if sum(subgrid) <= target_sum and len(subgrid) >= k:\n                        return [[i, j] for i in range(r1, r2 + 1) for j in range(c1, c2 + 1)]\n    return []\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nk = 3\ntarget_sum = 10\nassert f(g(grid, k, target_sum), k, target_sum)\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a palindrome.\"\"\"\n    return nums == nums[::-1]\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 4, 3, 2, 1]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a power of 2\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    \"\"\"Generate a number that is a power of 2\"\"\"\n    return 16\n\nassert f(g())\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be expressed as a sum of distinct Fibonacci numbers.\n    For example, if n = 11, the function should return True, as 11 can be expressed as 8 + 3.\"\"\"\n    def can_sum(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n == 0:\n            return True\n        if n < 0:\n            return False\n        if can_sum(n - 1) or can_sum(n - 2):\n            memo[n] = True\n            return True\n        memo[n] = False\n        return False\n    return can_sum(n)\n\ndef g(n=11):\n    return n\n\nassert f(g())\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Optional\n\nclass Node:\n    def __init__(self, value: int) -> None:\n        self.value = value\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\ndef f(root: Optional[Node]) -> bool:\n    \"\"\"Check if the binary tree is a valid binary search tree\"\"\"\n    def is_bst(node: Optional[Node], min_val: float, max_val: float) -> bool:\n        if node is None:\n            return True\n        if node.value <= min_val or node.value >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.value) and is_bst(node.right, node.value, max_val)\n    \n    return is_bst(root, float('-inf'), float('inf'))\n\ndef g() -> Node:\n    root = Node(5)\n    root.left = Node(3)\n    root.right = Node(7)\n    root.left.left = Node(2)\n    root.left.right = Node(4)\n    root.right.left = Node(6)\n    root.right.right = Node(8)\n    return root\n\nassert f(g())\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a number n and a list of edges, determine if it is possible to construct a directed acyclic graph (DAG) with n nodes.\n    Return True if it is possible, False otherwise.\"\"\"\n    if len(edges) != n-1:\n        return False\n    \n    graph = [[] for _ in range(n)]\n    in_degree = [0] * n\n    \n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n    \n    queue = []\n    \n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    count = 0\n    \n    while queue:\n        node = queue.pop(0)\n        count += 1\n        \n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            \n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return count == n\n\ndef g(n: int, edges: List[List[int]]):\n    return (n, edges)\n\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\nassert f(*g(n, edges))",
        "idx_generation": 179,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"Given a directed graph and two nodes start and end, determine if there exists a path from start to end.\n    Use Dijkstra's algorithm for the search.\n    \n    The graph is represented as a dictionary where the keys are the nodes and the values are lists of tuples.\n    Each tuple consists of a neighbor node and the weight of the edge connecting them.\n    Example:\n    graph = {\n        'A': [('B', 2), ('C', 3)],\n        'B': [('C', 1), ('D', 4)],\n        'C': [('D', 2)],\n        'D': []\n    }\n    \"\"\"\n\n    # Initialize distances dictionary with infinity for all nodes except start node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    # Initialize priority queue with start node\n    queue = [(distances[start], start)]\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If the current node is the end node, a path from start to end has been found\n        if current_node == end:\n            return True\n\n        # If the current distance is greater than the distance to the current node, skip it\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors of the current node\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n\n            # If the new distance is smaller than the previous distance, update the distance and add to the queue\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return False\n\ndef g(graph: dict, start: str, end: str):\n    return (graph, start, end)\n\ngraph = {\n    'A': [('B', 2), ('C', 3)],\n    'B': [('C', 1), ('D', 4)],\n    'C': [('D', 2)],\n    'D': []\n}\nstart = 'A'\nend = 'D'\nassert f(*g(graph, start, end))\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where all the 1s in the path are connected horizontally or vertically (no diagonal movement allowed).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int) -> bool:\n        if row == rows - 1 and col == cols - 1:\n            return True\n\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 0:\n            return False\n\n        grid[row][col] = -1\n\n        if dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        [0, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 250,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Generate a Pascal's Triangle with n number of rows.\n    Each row of the triangle is represented as a list of integers.\"\"\"\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i-1][j-1] + triangle[i-1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle\n\ndef g(n: int):\n    return n\n\n# Test Case\nn = 5\nassert f(g(n)) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 99,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of ways to partition nums into two subsets such that the difference between the sum of the subsets is equal to the target value.\n    Return the count of possible partitions.\n    \"\"\"\n    def count_partitions(nums: List[int], target: int, index: int, current_sum: int, memo: dict) -> int:\n        if index == len(nums):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        if (index, current_sum) in memo:\n            return memo[(index, current_sum)]\n        \n        count = count_partitions(nums, target, index + 1, current_sum + nums[index], memo) + count_partitions(nums, target, index + 1, current_sum - nums[index], memo)\n        memo[(index, current_sum)] = count\n        return count\n\n    return count_partitions(nums, target, 0, 0, {})\n\ndef g(nums=[1, 1, 1, 1, 1], target=3):\n    return (nums, target)\n\nassert f(*g()) == 5\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is symmetric along its main diagonal.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\ndef g():\n    return [[1, 2, 3],\n            [2, 4, 5],\n            [3, 5, 6]]\nassert f(g())\n",
        "idx_generation": 14,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using a stack.\"\"\"\n    stack = []\n    for num in arr:\n        if not stack or num >= stack[-1]:\n            stack.append(num)\n        else:\n            sorted_stack = []\n            while stack and num < stack[-1]:\n                sorted_stack.append(stack.pop())\n            stack.append(num)\n            while sorted_stack:\n                stack.append(sorted_stack.pop())\n    return stack\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([5, 2, 7, 1, 4])) == [1, 2, 4, 5, 7]\n",
        "idx_generation": 213,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers 'arr', determine if it is possible to find 'k' distinct integers in 'arr'\n    that add up to 'target'.\n    Return True if such a combination exists, False otherwise.\"\"\"\n    arr.sort()\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(k + 1)]\n    dp[0][0] = True\n    for i in range(1, k + 1):\n        for j in range(1, target + 1):\n            if j >= arr[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[k][target]\n\ndef g(arr=[2, 4, 6, 8, 10], target=12, k=3):\n    return (arr, target, k)\n\nassert f(*g())\n",
        "idx_generation": 93,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape']) -> bool:\n    \"\"\"Find the longest word in the list that can be formed by rearranging the characters of the input string.\"\"\"\n    sorted_s = ''.join(sorted(s))\n    sorted_words = [''.join(sorted(word)) for word in words]\n    sorted_words.sort(key=len, reverse=True)\n    for word in sorted_words:\n        if all(ch in sorted_s for ch in word):\n            return word\n    return None\n\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape']):\n    return max(words, key=len)\n\nassert f(g()) is not None\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three integers in the list.\n    Return the maximum product.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 720\n",
        "idx_generation": 397,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring='abc') -> bool:\n    \"\"\"Check if the substring can be formed by repeating a pattern within s\"\"\"\n    pattern = substring * (len(s) // len(substring))\n    if len(s) % len(substring) != 0:\n        pattern += substring[:len(s) % len(substring)]\n    return pattern == s\n\ndef g(substring='abc'):\n    return substring * 3\n\nassert f(g())\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\"\"\"\n    if len(s) != len(t):\n        return False\n    mapping = {}\n    for i in range(len(s)):\n        if s[i] in mapping:\n            if mapping[s[i]] != t[i]:\n                return False\n        else:\n            if t[i] in mapping.values():\n                return False\n            mapping[s[i]] = t[i]\n    return True\n    \ndef g(s: str, t: str):\n    return (s, t)\n\nassert f(*g(\"egg\", \"add\"))\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a subset of nums whose sum is equal to the target value.\"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if sum(subset) == target:\n            return True\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Determine the number of trailing zeros in the factorial of a given number.\"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef g():\n    return 25\n\nassert f(g()) == 6\n",
        "idx_generation": 388,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of numbers in a contiguous subgrid within the given grid.\"\"\"\n    max_sum = float('-inf')\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid = [grid[x][y] for x in range(i, k+1) for y in range(j, l+1)]\n                    max_sum = max(max_sum, sum(subgrid))\n    \n    return max_sum\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\ngrid = [\n    [1, 2, -1, -4, -20],\n    [-8, -3, 4, 2, 1],\n    [3, 8, 10, 1, 3],\n    [-4, -1, 1, 7, -6]\n]\nassert f(g(grid)) == 29\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], target: str) -> bool:\n    \"\"\"Check if the given target word can be formed by traversing the grid horizontally or vertically\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    stack = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target[0]:\n                stack.append((i, j, 0))\n    while stack:\n        (x, y, idx) = stack.pop()\n        if idx == len(target) - 1:\n            return True\n        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < rows and 0 <= new_y < cols and (grid[new_x][new_y] == target[idx + 1]):\n                stack.append((new_x, new_y, idx + 1))\n    return False\n\ndef g():\n    grid = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]\n    target = 'SEE'\n    return (grid, target)\n\nassert f(*g())\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine whether a given number n can be represented as a sum of distinct Fibonacci numbers.\n    Return True if n can be represented as a sum of distinct Fibonacci numbers, False otherwise.\"\"\"\n    def is_sum_of_fibonacci(n, fib):\n        if n == 0:\n            return True\n        if n < 0 or len(fib) < 2:\n            return False\n        if n == fib[-1]:\n            return True\n        return is_sum_of_fibonacci(n - fib[-1], fib[:-1]) or is_sum_of_fibonacci(n, fib[:-1])\n    \n    fib = [1, 2]\n    while fib[-1] < n:\n        fib.append(fib[-1] + fib[-2])\n    \n    return is_sum_of_fibonacci(n, fib[:-1])\n\ndef g():\n    return 21\n\nassert f(g())\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"Find the coordinates (row, column) of the target number in the grid.\"\"\"\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == target:\n                return (i, j)\n    return (-1, -1)\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 5) == (1, 1)\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum path sum from the top left to the bottom right of the grid.\n    You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n",
        "idx_generation": 402,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome after removing exactly one character.\"\"\"\n    def is_palindrome(s: str, left: int, right: int, deleted: bool) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if deleted:\n                    return False\n                return is_palindrome(s, left + 1, right, True) or is_palindrome(s, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)\n\ndef g():\n    return \"abca\"\n\nassert f(g())\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, k=3) -> bool:\n    \"\"\"Check if the kth bit from the right in the binary representation of the given number is set (1) or not (0).\"\"\"\n    binary = bin(num)[2:]\n    return binary[-k] == '1'\n\ndef g(k=3):\n    return 13\n\nassert f(g())\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a power of two.\"\"\"\n    if n < 1:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a given matrix is a valid binary tree\"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False\n\n    # Check if there is a cycle in the matrix\n    visited = set()\n    stack = [(0, -1)]\n    while stack:\n        node, parent = stack.pop()\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in range(n):\n            if matrix[node][neighbor] == 1:\n                stack.append((neighbor, node))\n\n    # Check if each node has exactly one parent\n    parents = [0] * n\n    for node in range(n):\n        for neighbor in range(n):\n            if matrix[node][neighbor] == 1:\n                parents[neighbor] += 1\n    if parents.count(0) != 1:\n        return False\n    if any(parent > 1 for parent in parents):\n        return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary, determine if there exists a path from 'start' to 'end'.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    return False\ndef g(graph={'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}, start='A', end='D'):\n    return (graph, start, end)\nassert f(*g())\n",
        "idx_generation": 191,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented by a 2D list of integers, determine if it is possible to reach the bottom-right cell from the top-left cell.\n    The maze contains 0s and 1s, where 0s represent walls and 1s represent open paths.\n    The player can only move right or down in the maze.\"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n\n    def dfs(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if row >= rows or col >= cols:\n            return False\n        if maze[row][col] == 0:\n            return False\n        return dfs(row + 1, col) or dfs(row, col + 1)\n\n    return dfs(0, 0)\n\ndef g() -> List[List[int]]:\n    return [[1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 1], [1, 0, 0, 1]]\n\nassert f(g()) == True\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary of nodes and their neighbors, determine if there exists a path from the start node to the end node.\"\"\"\n    def dfs(graph, node, visited):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, visited):\n                    return True\n        return False\n    return dfs(graph, start, set())\ndef g():\n    graph = {\n        'A': ['B', 'D'],\n        'B': ['C', 'E'],\n        'C': [],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    start = 'A'\n    end = 'F'\n    return graph, start, end\nassert f(*g())\n",
        "idx_generation": 251,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there is a unique combination of numbers in the list that adds up to the target.\n    The combination should not contain duplicates of the same number.\n\n    Return True if a unique combination exists, False otherwise.\n    \"\"\"\n\n    def backtrack(index: int, curr_sum: int, path: List[int]) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            if backtrack(i+1, curr_sum+nums[i], path):\n                return True\n            path.pop()\n\n        return False\n\n    nums.sort()\n    return backtrack(0, 0, [])\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Calculate the number of ways to arrange n objects in k distinct groups.\n    Return the total number of arrangements.\"\"\"\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        for j in range(min(i,k)+1):\n            if j == 0 or j == i:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n    return dp[n][k]\n\ndef g(n=5, k=3):\n    return (n, k)\n\nassert f(*g()) == 10\n",
        "idx_generation": 235,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if the given list of numbers can be rearranged to form a sequence of consecutive positive integers.\n    \n    Args:\n    nums -- the list of numbers\n    \n    Returns:\n    True if the list of numbers can be rearranged to form a sequence of consecutive positive integers, False otherwise\n    \"\"\"\n    # Sort the list of numbers in ascending order\n    nums.sort()\n    \n    # Check if the difference between each pair of consecutive numbers is equal to 1\n    for i in range(len(nums) - 1):\n        if nums[i+1] - nums[i] != 1:\n            return False\n    \n    return True\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Rearrange the given list of numbers to form a sequence of consecutive positive integers.\n    \n    Args:\n    nums -- the list of numbers\n    \n    Returns:\n    A list of numbers rearranged in such a way that they form a sequence of consecutive positive integers\n    \"\"\"\n    # Sort the list of numbers in ascending order\n    nums.sort()\n    \n    return nums\n\nassert f([3, 2, 1, 4, 5])\nassert g([3, 2, 1, 4, 5]) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the index of the target number in a sorted list using binary search.\n\n    Args:\n    - nums: A list of integers sorted in ascending order.\n    - target: The number to be found in the list.\n\n    Returns:\n    - The index of the target number in the list, or -1 if it is not found.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9, 11, 13], target=7):\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n    Return True if there exists two numbers in the list that add up to the target, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 93,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome and contains only lowercase alphabetic characters.\"\"\"\n    return s == s[::-1] and s.islower()\ndef g():\n    return 'radar'\nassert f(g())\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Determine if a given list of integers forms a valid arithmetic progression.\n    An arithmetic progression is a sequence of numbers in which the difference between consecutive numbers is constant.\n    - nums: a list of integers\n    \n    Returns True if the given list forms a valid arithmetic progression, False otherwise.\n    \"\"\"\n    nums.sort()\n    diff = nums[1] - nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n    return True\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [1, 3, 5, 7, 9]\nassert f(g(nums))\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of distinct integers, determine if there exists a subsequence whose sum is equal to the target value.\"\"\"\n    def backtrack(i, total):\n        if total == target:\n            return True\n        if i == len(nums) or total > target:\n            return False\n        return backtrack(i + 1, total + nums[i]) or backtrack(i + 1, total)\n    \n    return backtrack(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Check if a given string matches a specific pattern.\"\"\"\n    if len(s) != len(pattern):\n        return False\n    mapping = {}\n    used = set()\n    for i in range(len(s)):\n        if pattern[i] not in mapping:\n            if s[i] in used:\n                return False\n            mapping[pattern[i]] = s[i]\n            used.add(s[i])\n        else:\n            if mapping[pattern[i]] != s[i]:\n                return False\n    return True\n\ndef g(s: str, pattern: str):\n    return s, pattern\n\nassert f(*g(\"abb\", \"baa\"))\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid palindrome after removing at most one character.\"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\n\ndef g():\n    return \"abca\"\n\nassert f(g())\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\nimport math\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n    \"\"\"\n    max1 = max2 = max3 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for num in nums:\n        if num > max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max3 = max2\n            max2 = num\n        elif num > max3:\n            max3 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    return max(max1 * max2 * max3, max1 * min1 * min2)\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums)) == 60\n",
        "idx_generation": 409,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Given a list of integers and a target value k, find the maximum sum of any subarray of length k.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for i, num in enumerate(nums):\n        curr_sum += num\n        \n        if i >= k:\n            curr_sum -= nums[i - k]\n        \n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value k that has a valid solution.\n    Return the generated list of integers and the target value as a tuple.\n    \"\"\"\n    nums = [1, -2, 3, -1, 2]\n    k = 3\n    return nums, k\n\n# Test the generated list and k\nassert f(*g()) == 4\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 1s and 0s, find the maximum area of a rectangle that can be formed by connecting 1s.\n    Return the maximum area.\"\"\"\n    max_area = 0\n    rows = len(grid)\n    if rows == 0:\n        return 0\n    cols = len(grid[0])\n    heights = [0] * cols\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n        area = largest_rectangle_area(heights)\n        max_area = max(max_area, area)\n    return max_area\n\ndef largest_rectangle_area(heights):\n    stack = []\n    max_area = 0\n    i = 0\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i if not stack else i - stack[-1] - 1)\n            max_area = max(max_area, area)\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i if not stack else i - stack[-1] - 1)\n        max_area = max(max_area, area)\n    return max_area\n\ndef g():\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\nassert f(g()) == 6\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth number in the Fibonacci sequence.\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return f(n - 1) + f(n - 2)\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 76,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a 2D grid of integers, return the matrix rotated 90 degrees clockwise.\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            rotated[j][n - i - 1] = matrix[i][j]\n    return rotated\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of moves required to reach the bottom-right cell from the top-left cell.\n    - You can only move down or right.\n    - You can only move to adjacent cells.\n    Return the minimum number of moves.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\n\ndef g():\n    \"\"\"\n    Generate a grid where the minimum number of moves required to reach the bottom-right cell from the top-left cell is known.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1],\n    ]\n    return grid\n\n\nassert f(g()) == 7\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: int) -> bool:\n    \"\"\"Check if it is possible to form the target integer using all the digits in the string s, \n    with each digit being used exactly once, and performing addition and subtraction operations in any order.\"\"\"\n    digits = [int(ch) for ch in s]\n    return can_form_target(digits, target)\n\ndef can_form_target(digits, target):\n    if len(digits) == 0:\n        return target == 0\n    for i in range(len(digits)):\n        remaining_digits = digits[:i] + digits[i+1:]\n        if can_form_target(remaining_digits, target - digits[i]) or can_form_target(remaining_digits, target + digits[i]):\n            return True\n    return False\n\ndef g():\n    return ('12345', 5)\n\nassert f(*g())\n",
        "idx_generation": 238,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of num\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\ndef g(num=25):\n    return (num,)\nassert f(*g()) == 3\n",
        "idx_generation": 118,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase with `n` steps. You can climb 1 or 2 steps at a time.\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\ndef g():\n    n = 5\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if it is possible to reach the target sum by moving through the grid in a specific pattern.\n    Sample Input:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 17\n    Sample Output:\n    True\"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    def dfs(i: int, j: int, current_sum: int) -> bool:\n        if i < 0 or i >= rows or j < 0 or j >= cols or visited[i][j]:\n            return False\n        if current_sum + grid[i][j] == target:\n            return True\n        visited[i][j] = True\n        if dfs(i + 1, j, current_sum + grid[i][j]) or dfs(i - 1, j, current_sum + grid[i][j]) or \\\n                dfs(i, j + 1, current_sum + grid[i][j]) or dfs(i, j - 1, current_sum + grid[i][j]):\n            return True\n        visited[i][j] = False\n        return False\n\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(grid: List[List[int]], target: int):\n    \"\"\"\n    Generate a grid of integers and the target sum.\n    \"\"\"\n    return (grid, target)\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntarget = 17\nassert f(*g(grid, target))\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    queue = [start]\n    visited = set()\n    while queue:\n        curr_node = queue.pop(0)\n        if curr_node == end:\n            return True\n        visited.add(curr_node)\n        neighbors = graph[curr_node]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return False\ndef g():\n    graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 0\n    end = 5\n    return (graph, start, end)\nassert f(*g())\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start_node: str, end_node: str) -> bool:\n    \"\"\"Check if there exists a path from 'start_node' to 'end_node' in the graph.\"\"\"\n    def dfs(node: str, visited: Set[str]) -> bool:\n        if node == end_node:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start_node, set())\n\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': [], 'E': []}\n    start_node = 'A'\n    end_node = 'E'\n    return (graph, start_node, end_node)\n\n\nassert f(*g())\n",
        "idx_generation": 161,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Check if a given graph is a binary tree.\"\"\"\n    if len(edges) != n - 1:\n        return False\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = [False] * n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != parent:\n                return False\n        return True\n    return dfs(0, -1) and all(visited)\n\ndef g(n: int, edges: List[List[int]]):\n    return (n, edges)\n\n# Test case\ngraph = [\n    [0, 1],\n    [1, 2],\n    [1, 3],\n    [3, 4]\n]\nassert f(*g(5, graph)) == True\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(s: str, n=5) -> bool:\n    \"\"\"Find a string that can be formed by rearranging the characters of a given string\"\"\"\n    import itertools\n    permutations = list(itertools.permutations(s))\n    for permutation in permutations:\n        if ''.join(permutation) == s:\n            continue\n        return True\n    return False\ndef g():\n    return \"abcd\"\nassert f(g())\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the number of ways to climb to the top of a staircase with n steps. You can climb 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g(n: int):\n    return n\nn = 5\nassert f(g(n)) == 8\n",
        "idx_generation": 240,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other (contain the same characters in any order).\"\"\"\n    return sorted(s1) == sorted(s2)\ndef g():\n    return 'listen', 'silent'\nassert f(*g())\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there is a pair of numbers in the list that add up to the target sum.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target: int):\n    return [1, 5, 3, 7, 2, 9, 4, 6, 8]\n\ntarget = 10\nassert f(g(target), target)\n",
        "idx_generation": 230,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence\n    in the list. A subsequence is a sequence that can be derived from another sequence\n    by deleting some or no elements without changing the order of the remaining elements.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig']) -> bool:\n    \"\"\"Find the longest word in a list that can be formed by rearranging the characters in a given string.\"\"\"\n    sorted_string = ''.join(sorted(s))\n    return max([word for word in words if ''.join(sorted(word)) in sorted_string], key=len) == s\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig']):\n    return max(words, key=len)\nassert f(g())\n",
        "idx_generation": 31,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the squares of each number, sorted in non-decreasing order.\n    \"\"\"\n    return sorted([num**2 for num in nums])\n\ndef g():\n    return [4, 3, 2, 1]\n\nassert f(g()) == [1, 4, 9, 16]\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if it is possible to select a subset of the numbers\n    such that their sum is equal to the target.\n    The function should return True if such a subset exists, and False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\n\nassert f(g(), 12)\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='abcdefghijklmnopqrstuvwxyz') -> bool:\n    \"\"\"Check if a string contains all the characters of the target string in the same order.\"\"\"\n    target_index = 0\n    for ch in s:\n        if ch == target[target_index]:\n            target_index += 1\n            if target_index == len(target):\n                return True\n    return False\n\ndef g(target='abcdefghijklmnopqrstuvwxyz'):\n    return target\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='hello') -> bool:\n    \"\"\"Check if the given string s can be transformed into the target string by performing the following operations:\n    - Append 'o' to the end of the string\n    - Double the string\n    - Reverse the string\n    Return True if the transformation is possible, False otherwise.\"\"\"\n    def transform(s: str, target: str) -> bool:\n        if s == target:\n            return True\n        if len(s) > len(target):\n            return False\n        if target.endswith('o'):\n            if transform(s, target[:-1]):\n                return True\n        if target.startswith(s):\n            if transform(s * 2, target):\n                return True\n        if s[::-1] == target:\n            if transform(s, target[::-1]):\n                return True\n        return False\n    \n    return transform(s, target)\n\ndef g(target='hello'):\n    return target[::-1]\n\nassert f(g())\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in a list of consecutive integers from 0 to n.\"\"\"\n    n = len(nums)\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum\n\ndef g():\n    return [0, 1, 2, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 3\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right, and the minimum cost path should be chosen.\"\"\"\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n            \n    return dp[rows - 1][cols - 1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the factorial of n using a stack.\nReturn the factorial value.\"\"\"\n    stack = []\n    stack.append(1)\n    for i in range(2, n+1):\n        stack.append(stack[-1] * i)\n    return stack[-1]\n\ndef g():\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 301,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid consisting of 0s and 1s, determine the maximum area of a square that can be formed by 1s in the grid.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    max_square_area = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                square_size = 1\n                while i + square_size < rows and j + square_size < cols:\n                    valid_square = True\n                    for x in range(i, i + square_size + 1):\n                        if grid[x][j + square_size] != 1:\n                            valid_square = False\n                            break\n                    for y in range(j, j + square_size + 1):\n                        if grid[i + square_size][y] != 1:\n                            valid_square = False\n                            break\n                    if valid_square:\n                        square_size += 1\n                    else:\n                        break\n                max_square_area = max(max_square_area, square_size ** 2)\n    return max_square_area\ndef g() -> List[List[int]]:\n    \"\"\"Returns a grid with 1s forming a square.\"\"\"\n    return [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\nassert f(g()) == 16\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=10) -> bool:\n    \"\"\"Check if there exists a path in the matrix that sums up to the target value.\"\"\"\n    def dfs(row, col, curr_sum):\n        if row < 0 or col < 0 or row >= len(matrix) or col >= len(matrix[0]):\n            return False\n        curr_sum += matrix[row][col]\n        if curr_sum == target:\n            return True\n        return dfs(row+1, col, curr_sum) or dfs(row, col+1, curr_sum)\n    \n    return dfs(0, 0, 0)\n\ndef g(matrix: List[List[int]], target=10):\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a happy number.\"\"\"\n    def is_happy(n):\n        visited = set()\n        while n != 1 and n not in visited:\n            visited.add(n)\n            n = sum(int(digit) ** 2 for digit in str(n))\n        return n == 1\n\n    return is_happy(n)\n\ndef g():\n    return 19\n\nassert f(g())\n",
        "idx_generation": 245,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in nums such that the bitwise XOR of its elements is 0\"\"\"\n    prefix_xor = [0]\n    for num in nums:\n        prefix_xor.append(prefix_xor[-1] ^ num)\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_xor[i] == prefix_xor[j]:\n                return True\n    return False\n\ndef g():\n    nums = [4, 2, 2, 6, 4]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 123,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    \n    Use dynamic programming to optimize the search for the minimum path sum.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D grid to store the minimum path sums\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Populate the first row and column with cumulative sums\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return (grid,)\n\ngrid = [\n    [1, 3, 1],\n    [1, 5, 1],\n    [4, 2, 1]\n]\nassert f(*g(grid)) == 7\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0, end=4, k=3) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node\n    with at most 'k' edges.\n    Args:\n        graph: The graph represented as an adjacency list.\n        start: The starting node.\n        end: The ending node.\n        k: The maximum number of edges allowed in the path.\n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, edges = stack.pop()\n        visited.add(node)\n        if node == end and edges <= k:\n            return True\n        if edges < k:\n            stack.extend((neighbor, edges + 1) for neighbor in graph[node] if neighbor not in visited)\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 4], [3]]\n\nassert f(g())\n",
        "idx_generation": 467,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        curr_node = stack.pop()\n        if curr_node == end:\n            return True\n        visited.add(curr_node)\n        neighbors = graph[curr_node]\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g():\n    graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 0\n    end = 5\n    return (graph, start, end)\nassert f(*g())\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a valid binary search tree (BST).\"\"\"\n    def is_bst(node, min_val, max_val):\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n    \n    return is_bst(nums, float('-inf'), float('inf'))\n    \nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef g():\n    # Create a valid binary search tree\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    return root\n\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a directed graph has a cycle.\"\"\"\n    def dfs(node):\n        if visited[node] == 1:\n            return True\n        if visited[node] == -1:\n            return False\n\n        visited[node] = 1\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n\n        visited[node] = -1\n        return False\n\n    num_nodes = len(graph)\n    visited = [0] * num_nodes\n\n    for node in range(num_nodes):\n        if dfs(node):\n            return True\n\n    return False\n\ndef g():\n    return [[1, 2], [2, 3], [3], [4, 5], [5], []]\n\nassert f(g()) == False\n",
        "idx_generation": 277,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two positive integers n and k, calculate the number of ways to choose k items from a set of n items.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n - 1, k - 1) + f(n - 1, k)\ndef g(n: int, k: int):\n    return n\nassert f(g(5, 3), 3) == 10\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target integer k, determine if there exists a subset of the list that adds up to k.\n    Each number in the list can only be used once.\"\"\"\n    def subsetSum(nums, k, index, current_sum):\n        if current_sum == k:\n            return True\n        if index >= len(nums) or current_sum > k:\n            return False\n        return subsetSum(nums, k, index + 1, current_sum + nums[index]) or subsetSum(nums, k, index + 1, current_sum)\n    return subsetSum(nums, k, 0, 0)\ndef g():\n    nums = [1, 5, 9, 3]\n    k = 10\n    return nums, k\nassert f(*g())\n",
        "idx_generation": 251,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, find if there exists two integers in the array such that their sum is equal to the target value.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    low, high = 0, len(arr) - 1\n    while low < high:\n        current_sum = arr[low] + arr[high]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers where the sum of any two integers in the array is equal to the target value.\n    \"\"\"\n    return [target - i for i in arr]\n\nassert f(g([1, 2, 3, 4, 5], 6), 6)\n",
        "idx_generation": 24,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return True\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Find the longest increasing subsequence (LIS) in the given list 'arr'. The LIS is a subsequence of 'arr' in which the elements are in increasing order, and its length is maximum.\nSample Input:\narr = [3, 10, 2, 1, 20]\nSample Output:\n4\nExplanation: The longest increasing subsequence is [3, 10, 20] with length 3, hence the output is 3.\"\"\"\n    n = len(arr)\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    return max(lis)\n\ndef g():\n    return [3, 10, 2, 1, 20]\n    \nassert f(g()) == 3\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two given strings are anagrams of each other.\"\"\"\n    return sorted(s1) == sorted(s2)\ndef g():\n    return ('listen', 'silent')\nassert f(*g())\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any three numbers in the list. Return the maximum product.\n    Sample input:\n    nums = [1, 2, 3, 4]\n    Sample output:\n    24\n    Explanation: The maximum product can be achieved by multiplying 2, 3, and 4 (2 * 3 * 4 = 24).\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the input list of integers.\"\"\"\n    return nums\n\nassert f(g([1, 2, 3, 4])) == 24\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    output = [1] * n\n    for i in range(1, n):\n        left_product[i] = left_product[i - 1] * nums[i - 1]\n    for i in range(n - 2, -1, -1):\n        right_product[i] = right_product[i + 1] * nums[i + 1]\n    for i in range(n):\n        output[i] = left_product[i] * right_product[i]\n    return output\ndef g():\n    return [1, 2, 3, 4, 5]\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other\"\"\"\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for char in s1:\n        count1[ord(char) - ord('a')] += 1\n\n    for char in s2:\n        count2[ord(char) - ord('a')] += 1\n\n    return count1 == count2\n\ndef g(s1=\"listen\", s2=\"silent\"):\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all positive integers less than n that are divisible by 3 or 5\"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\n\n\ndef g():\n    return 100\n\n\nassert f(g()) == 2318\n",
        "idx_generation": 415,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Determine if two numbers are coprime.\"\"\"\n    def gcd(a: int, b: int) -> int:\n        while b != 0:\n            a, b = b, a % b\n        return a\n    return gcd(n, m) == 1\n\ndef g():\n    n = 15\n    m = 28\n    return (n, m)\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, determine if the target value exists in the matrix using a stack-based search approach.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows, cols = len(matrix), len(matrix[0])\n    stack = [(0, 0)]\n    visited = set()\n    while stack:\n        row, col = stack.pop()\n        if matrix[row][col] == target:\n            return True\n        visited.add((row, col))\n        if row + 1 < rows and (row + 1, col) not in visited:\n            stack.append((row + 1, col))\n        if col + 1 < cols and (row, col + 1) not in visited:\n            stack.append((row, col + 1))\n    return False\n\ndef g():\n    return ([[1, 2, 3],\n             [4, 5, 6],\n             [7, 8, 9]], 5)\n\nassert f(*g())\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if it is possible to find a\ncombination of numbers from the list that adds up to the target number.\"\"\"\n    def helper(idx: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if idx == len(nums):\n            return False\n        if helper(idx + 1, curr_sum + nums[idx]):\n            return True\n        return helper(idx + 1, curr_sum)\n    return helper(0, 0)\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\nassert f(g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"Rotate the given grid 90 degrees clockwise.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    rotated_grid = [['' for _ in range(rows)] for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            rotated_grid[j][rows-i-1] = grid[i][j]\n    return rotated_grid\n\ndef g():\n    grid = [['1', '2', '3'],\n            ['4', '5', '6'],\n            ['7', '8', '9']]\n    return grid\n\nassert f(g()) == [['7', '4', '1'],\n                  ['8', '5', '2'],\n                  ['9', '6', '3']]\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"Given integers n and m, find the number of ways to tile a 2xN grid using 2x1 and 2xM tiles.\"\"\"\n    if n < m:\n        n, m = m, n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - m]\n    return dp[n]\n\ndef g():\n    n = 5\n    m = 2\n    return (n, m)\n\nassert f(*g()) == 8\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Given a string s and a target string, determine if it is possible to obtain the target string by repeatedly removing a subsequence of characters from s. Return True if it is possible, otherwise return False.\"\"\"\n    def helper(s: str, target: str) -> bool:\n        if len(target) == 0:\n            return True\n        if len(s) == 0:\n            return False\n        if s[0] == target[0]:\n            return helper(s[1:], target[1:])\n        return helper(s[1:], target)\n    return helper(s, target)\ndef g():\n    s = 'abracadabra'\n    target = 'car'\n    return (s, target)\nassert f(*g())\n",
        "idx_generation": 247,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a given integer.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    return 10\n\nassert f(g()) == 2\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Determine the factorial of the given number.\n\n    Args:\n        n: The number to find the factorial of.\n\n    Returns:\n        The factorial of the given number.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n - 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n\n    Returns:\n        A positive integer.\n    \"\"\"\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]], a=3, b=5) -> bool:\n    \"\"\"Given a graph with n nodes and a list of edges connecting these nodes, determine if there exists a path\n    from node a to node b that includes exactly one even number and one odd number. Each edge is represented\n    as a list [u, v] where u and v are the nodes connected by the edge.\"\"\"\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = set()\n    def dfs(node, even_count, odd_count):\n        visited.add(node)\n        if node == b:\n            if even_count == 1 and odd_count == 1:\n                return True\n        elif node % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, even_count, odd_count):\n                    return True\n        \n        return False\n    \n    return dfs(a, 0, 0)\n\ndef g(n=5, edges=[[1, 2], [2, 3], [3, 4], [4, 5]]):\n    return (n, edges)\n\nassert f(*g())\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a given graph is a tree.\"\"\"\n    visited = set()\n    stack = [(0, -1)]\n    while stack:\n        node, parent = stack.pop()\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node))\n    return len(visited) == len(graph)\n\ndef g(graph: List[List[int]]):\n    return graph\n\ngraph = [[1, 2], [0, 3], [0, 4], [1, 5], [2, 6], [3, 7], [4, 8], [5, 9], [6], [7]]\nassert f(g(graph))\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"Count the number of islands in a grid.\"\"\"\n    def dfs(i: int, j: int):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n\n    islands = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                islands += 1\n                dfs(i, j)\n    return islands\n\ndef g():\n    return [['1', '1', '0', '0', '0'],\n            ['1', '1', '0', '0', '0'],\n            ['0', '0', '1', '0', '0'],\n            ['0', '0', '0', '1', '1']]\n\nassert f(g()) == 3\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary, check if there is a path from start to end using depth-first search (DFS).\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\ndef g():\n    graph = {1: [2, 3], 2: [3, 4], 3: [4], 4: [5], 5: []}\n    start = 1\n    end = 5\n    return (graph, start, end)\nassert f(*g())\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of ways to select k non-empty subsets from a set of n elements.\"\"\"\n    def count_subsets(n: int, k: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if k == 0 or n == k:\n            return 1\n        if (n, k) in memo:\n            return memo[(n, k)]\n        memo[(n, k)] = count_subsets(n-1, k-1, memo) + count_subsets(n-1, k, memo)\n        return memo[(n, k)]\n\n    if k > n:\n        return 0\n    memo = {}\n    return count_subsets(n, k, memo)\n\ndef g(n=5, k=3):\n    return (n, k)\n\nassert f(*g()) == 10\n",
        "idx_generation": 204,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if there are k elements from the list\n    that add up to the target.\n    \"\"\"\n    def count_combinations(nums: List[int], k: int, target: int) -> int:\n        if k == 0 and target == 0:\n            return 1\n        if k < 0 or target < 0 or len(nums) == 0:\n            return 0\n        return count_combinations(nums[1:], k - 1, target - nums[0]) + count_combinations(nums[1:], k, target)\n    \n    return count_combinations(nums, k, target) > 0\n\ndef g(nums=[2, 4, 6, 8, 10], k=3, target=20):\n    return (nums, k, target)\n\nassert f(*g())\n",
        "idx_generation": 258,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=5) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a pair of numbers whose difference is equal to the target.\n    Otherwise, return False.\"\"\"\n    nums.sort()\n    left = 0\n    right = 1\n    while right < len(nums):\n        diff = nums[right] - nums[left]\n        if diff == target:\n            return True\n        elif diff < target:\n            right += 1\n        else:\n            left += 1\n    return False\ndef g(nums=[7, 2, 9, 1, 5, 3]):\n    return nums\nassert f(g())\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Sort the list of integers using the bubble sort algorithm.\"\"\"\n    return f(arr)\n\narr = [5, 3, 1, 4, 2]\nassert f(g(arr)) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 238,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that adds up to the target.\"\"\"\n    def subset_sum(nums, target, i):\n        if target == 0:\n            return True\n        if i < 0:\n            return False\n        if nums[i] > target:\n            return subset_sum(nums, target, i-1)\n        return subset_sum(nums, target-nums[i], i-1) or subset_sum(nums, target, i-1)\n    \n    return subset_sum(nums, target, len(nums)-1)\n\ndef g():\n    return ([4, 2, 7, 1], 9)\n\nassert f(*g())\n",
        "idx_generation": 102,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it can be formed by concatenating two smaller strings repeatedly.\n    The two smaller strings can be concatenated in any order.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if n % i == 0:\n            if s[:i] * (n // i) == s:\n                return True\n    return False\n\ndef g():\n    return 'abcabcabc'\n\nassert f(g())\n",
        "idx_generation": 39,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the median of a list of numbers.\"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2-1] + nums[n//2]) / 2\n    else:\n        return nums[n//2]\ndef g(nums=[9, 2, 5, 1, 7, 4, 6, 3, 8]):\n    return nums\nassert f(g()) == 5\n",
        "idx_generation": 452,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the integers that adds up to the target.\"\"\"\n    def subset_sum(nums, target, i, current_sum):\n        if current_sum == target:\n            return True\n        if i >= len(nums) or current_sum > target:\n            return False\n        include = subset_sum(nums, target, i+1, current_sum+nums[i])\n        exclude = subset_sum(nums, target, i+1, current_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums=[1, 3, 5, 7, 9], target=12):\n    return nums\n\nassert f(g(), target=12)\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Given a list of words, return a list of words that can be formed by concatenating two other words from the list.\"\"\"\n    word_set = set(words)\n    result = []\n\n    for word in words:\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n\n            if prefix in word_set and suffix in word_set:\n                result.append(word)\n                break\n\n    return result\n\ndef g():\n    return ([\"cat\", \"dog\", \"cats\", \"dogs\", \"catdog\"],)\n\nassert f(g()[0]) == [\"catdog\"]\n",
        "idx_generation": 229,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, primes=[2, 3, 5, 7, 11, 13, 17, 19, 23]) -> bool:\n    \"\"\"Determine if n can be expressed as a sum of two prime numbers from the given list.\"\"\"\n    for i in range(len(primes)):\n        for j in range(i+1, len(primes)):\n            if primes[i] + primes[j] == n:\n                return True\n    return False\n\ndef g(primes=[2, 3, 5, 7, 11, 13, 17, 19, 23]):\n    return primes[0] + primes[1]\n\nassert f(g())\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find a pair of numbers in the given list that add up to the target value.\nReturn the pair of numbers as a list.\"\"\"\n    seen = set()\n    for num in arr:\n        complement = target - num\n        if complement in seen:\n            return [complement, num]\n        seen.add(num)\n    return []\ndef g(arr=[2, 7, 11, 15], target=9):\n    return arr, target\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Check if the given arithmetic expression is balanced.\nReturn True if the expression is balanced, False otherwise.\"\"\"\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            top = stack.pop()\n            if opening_brackets.index(top) != closing_brackets.index(char):\n                return False\n    return len(stack) == 0\ndef g(expression='(2 + 3) * [5 / 2]'):\n    return expression\nassert f(g()) == True\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=8) -> bool:\n    \"\"\"Given a matrix of integers and a target number, determine if it is possible to find a\npath from the top-left cell to the bottom-right cell that adds up to the target number.\nYou can only move down or right.\"\"\"\n    def helper(row: int, col: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if row == len(matrix) or col == len(matrix[0]):\n            return False\n        if helper(row + 1, col, curr_sum + matrix[row][col]):\n            return True\n        return helper(row, col + 1, curr_sum + matrix[row][col])\n    return helper(0, 0, 0)\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\nassert f(g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid with 0s and 1s, find the maximum length of a subarray that contains only 1s.\nA subarray is a contiguous sequence of elements within the grid.\nReturn the length of the maximum subarray.\"\"\"\n    max_length = 0\n    for row in grid:\n        length = 0\n        for num in row:\n            if num == 1:\n                length += 1\n                max_length = max(max_length, length)\n            else:\n                length = 0\n    return max_length\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 1, 1, 0, 0], [1, 1, 1, 1, 0], [0, 1, 1, 1, 1], [0, 0, 1, 1, 1]])) == 4\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of 1s and 0s, determine if it is possible to reach the bottom-right corner starting from the top-left corner. You can only move down or right, and you can only move to cells that contain 1s.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def backtrack(row, col):\n        if row == rows-1 and col == cols-1:\n            return True\n        if row >= rows or col >= cols or grid[row][col] == 0:\n            return False\n        return backtrack(row+1, col) or backtrack(row, col+1)\n    \n    return backtrack(0, 0)\n\ndef g():\n    grid = [[1, 1, 0, 0],\n            [1, 0, 1, 1],\n            [1, 1, 1, 1],\n            [0, 0, 1, 1]]\n    return (grid,)\n\nassert f(*g()) == True\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if there exists a binary string of length n that contains exactly k 1's.\"\"\"\n    def countOnes(string):\n        return sum([1 for char in string if char == '1'])\n\n    def generateBinaryStrings(n, k, curr_string, ones_count):\n        if len(curr_string) == n:\n            if ones_count == k:\n                return True\n            else:\n                return False\n\n        # Append 0 to the current string\n        if generateBinaryStrings(n, k, curr_string + '0', ones_count):\n            return True\n\n        # Append 1 to the current string\n        if generateBinaryStrings(n, k, curr_string + '1', ones_count + 1):\n            return True\n\n        return False\n\n    return generateBinaryStrings(n, k, '', 0)\n\ndef g(n=5, k=2):\n    return (n, k)\n\nassert f(*g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between two elements in the list.\n    Note: XOR is a binary operation that takes two equal-length binary representations and returns their bitwise exclusive or.\n    Sample input:\n    [3, 10, 5, 25, 2, 8]\n    Sample output:\n    28\"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner of a matrix.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    return dp[m - 1][n - 1]\n\ndef g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return matrix\n\nassert f(g()) == 12\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary of nodes and their neighbors, determine if there is a path from the start node to the end node.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n\nassert f(g(), 'A', 'E')\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their neighbors, check if there exists a path from the start node to the end node\n    using Breadth First Search (BFS).\n    Args:\n        graph: The graph represented as a dictionary.\n        start: The starting node.\n        end: The ending node.\n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as a dictionary.\n    \"\"\"\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n\nassert f(g(), 'A', 'E')\n",
        "idx_generation": 232,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there exists a path from a starting node to an ending node.\n    Return True if a path exists, False otherwise.\"\"\"\n    def dfs(node: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start, set())\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [5],\n        5: []\n    }\n    start = 1\n    end = 5\n    return (graph, start, end)\nassert f(*g())\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(path: List[int], weights=[{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound=1000) -> bool:\n    \"\"\"Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\"\"\"\n    return path[0] == 0 and path[-1] == 1 and (sum((weights[a][b] for (a, b) in zip(path, path[1:]))) <= bound)\n\ndef g(weights=[{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound=1000):\n    (u, v) = (0, 1)\n    import heapq\n    queue = [(0, u, u)]\n    trails = {}\n    while queue:\n        (dist, i, j) = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g())\n",
        "idx_generation": 312,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(word: str) -> List[str]:\n    \"\"\"Generate all possible permutations of the given string.\"\"\"\n    if len(word) <= 1:\n        return [word]\n    else:\n        perms = []\n        for i in range(len(word)):\n            char = word[i]\n            remaining = word[:i] + word[i+1:]\n            for perm in f(remaining):\n                perms.append(char + perm)\n        return perms\n\ndef g():\n    word = \"abc\"\n    return word\n\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to arrange n distinct objects in a circle.\"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return (n - 1) * f(n - 1)\ndef g():\n    return 5\nassert f(g()) == 24\n",
        "idx_generation": 264,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there exists a pair of numbers in the list\n    whose sum is equal to the target number and the absolute difference between the two numbers is less than or equal\n    to k. Otherwise, return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            if abs(arr[left] - arr[right]) <= k:\n                return True\n            else:\n                left += 1\n                right -= 1\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9], target=12, k=2):\n    return (arr, target, k)\n\nassert f(*g())\n",
        "idx_generation": 27,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given list in ascending order using bubble sort.\"\"\"\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\ndef g():\n    return [5, 4, 3, 2, 1]\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there is a unique combination of numbers in the list that adds up to the target.\n    The combination should not contain duplicates of the same number.\n\n    Return True if a unique combination exists, False otherwise.\n    \"\"\"\n\n    def backtrack(index: int, curr_sum: int, path: List[int]) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            if backtrack(i+1, curr_sum+nums[i], path):\n                return True\n            path.pop()\n\n        return False\n\n    nums.sort()\n    return backtrack(0, 0, [])\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 104,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the largest number that can be formed by combining the digits in the list.\"\"\"\n    nums.sort(reverse=True)\n    return int(''.join(map(str, nums)))\n\ndef g(nums=[5, 8, 2, 1, 6]):\n    return nums\n\nassert f(g()) == 86521\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return the square of each number in ascending order.\"\"\"\n    return sorted(num**2 for num in nums)\n\ndef g():\n    return [-4, -2, 0, 2, 4]\n\nassert f(g()) == [0, 4, 4, 16, 16]\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers `arr` and a target integer `target`, determine if there exists a subset of `arr`\n    that sums up to the target.\n    Return True if a subset exists, otherwise return False.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][target]\ndef g(arr=[3, 1, 5, 9, 12], target=8):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 221,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 and s2 are anagrams.\"\"\"\n    from collections import Counter\n    return Counter(s1) == Counter(s2)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"Generate two strings that are anagrams of each other.\"\"\"\n    import random\n    import string\n    letters = string.ascii_lowercase\n    s1 = ''.join(random.sample(letters, k=random.randint(3, 10)))\n    s2 = ''.join(random.sample(s1, k=len(s1)))\n    return s1, s2\n\nassert f(*g())\n\n",
        "idx_generation": 241,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'arr', return a new list where each element is the product of all the elements in the original list\n    except for the element at that index.\n    \"\"\"\n    n = len(arr)\n    prefix_product = [1] * n\n    suffix_product = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        prefix_product[i] = arr[i-1] * prefix_product[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix_product[i] = arr[i+1] * suffix_product[i+1]\n\n    for i in range(n):\n        result[i] = prefix_product[i] * suffix_product[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target', find the contiguous subarray within the list that has the largest sum and return the sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = i\n        if current_sum < 0:\n            current_sum = 0\n            start = i + 1\n    return max_sum\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    target = 15\n    return (nums, target)\nassert f(*g()) == 6\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Check if it is possible to navigate from the start position to the end position in the given maze. You can only move up, down, left, or right.\"\"\"\n    n = len(maze)\n    if n == 0:\n        return False\n    m = len(maze[0])\n    if m == 0:\n        return False\n    visited = [[False] * m for _ in range(n)]\n    queue = [(start[0], start[1], 0)]\n    while queue:\n        x, y, steps = queue.pop(0)\n        if x == end[0] and y == end[1]:\n            return True\n        if x < 0 or y < 0 or x >= n or y >= m or maze[x][y] == 1 or visited[x][y]:\n            continue\n        visited[x][y] = True\n        queue.append((x - 1, y, steps + 1))\n        queue.append((x + 1, y, steps + 1))\n        queue.append((x, y - 1, steps + 1))\n        queue.append((x, y + 1, steps + 1))\n    return False\n\ndef g():\n    maze = [\n        [0, 0, 1, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    return [maze, start, end]\n\nassert f(*g())\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find if there is a subset of numbers that add up to a target value.\"\"\"\n    n = len(nums)\n    \n    def subsetSum(curr_sum, i):\n        if curr_sum == target:\n            return True\n        if i == n or curr_sum > target:\n            return False\n        return subsetSum(curr_sum + nums[i], i + 1) or subsetSum(curr_sum, i + 1)\n    \n    return subsetSum(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. You can only move down or right.\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\ndef g():\n    return 3\nassert f(g()) == 6\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"Generate a palindrome string.\"\"\"\n    palindrome = random.choice(['racecar', 'level', 'deified', 'madam'])\n    return palindrome\n\nassert f(g())\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value between any two numbers in the given list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    return ([3, 5, 9, 2, 4],)\n\nassert f(*g()) == 13\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid contains a path from the top-left corner to the bottom-right corner,\n    where each cell in the path has a value that is a power of 2.\n    The path can only move down or right.\n    Return True if such a path exists, False otherwise.\n    \"\"\"\n    def is_power_of_two(n: int) -> bool:\n        \"\"\"Check if a number is a power of 2.\"\"\"\n        return n != 0 and (n & (n - 1)) == 0\n\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = is_power_of_two(grid[0][0])\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] and is_power_of_two(grid[i][0])\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] and is_power_of_two(grid[0][j])\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if is_power_of_two(grid[i][j]):\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[1, 2, 4], [8, 16, 32], [64, 128, 256]]))\n",
        "idx_generation": 171,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, a start node, an end node, and a maximum hop count 'k', determine if there is a path from 'start' to 'end' within 'k' hops.\nArgs:\n    graph: The directed graph represented as an adjacency matrix, where graph[i][j] = 1 if there is a directed edge from node 'i' to node 'j', and 0 otherwise.\n    start: The starting node in the graph.\n    end: The ending node in the graph.\n    k: The maximum hop count allowed to reach from 'start' to 'end'.\nReturns:\n    True if there is a path from 'start' to 'end' within 'k' hops, False otherwise.\n\"\"\"\n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        node, hops = queue.pop(0)\n        \n        if node == end and hops <= k:\n            return True\n        \n        if hops < k:\n            for neighbor in range(len(graph[node])):\n                if graph[node][neighbor] == 1 and neighbor not in visited:\n                    queue.append((neighbor, hops+1))\n                    visited.add(neighbor)\n    \n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample directed graph represented as an adjacency matrix.\n    \"\"\"\n    return [[0, 1, 1, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), 0, 4, 2)\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> bool:\n    \"\"\"\n    Given a list of words, check if there is a cycle of words where the last character of each word matches the first character of the next word.\n    \"\"\"\n    visited = set()\n    stack = [words[0]]\n    while stack:\n        word = stack.pop()\n        if word in visited:\n            return True\n        visited.add(word)\n        for next_word in words:\n            if word[-1] == next_word[0]:\n                stack.append(next_word)\n    return False\n\ndef g():\n    return ['apple', 'elephant', 'tiger', 'rabbit', 'tomato']\n\nassert f(g())\n",
        "idx_generation": 165,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int, max_length: int, weights: Dict[int, int]) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph, with a maximum length constraint and weight optimization.\"\"\"\n    queue = [(start, 0, 0)]\n    visited = set()\n    while queue:\n        curr_node, curr_length, curr_weight = queue.pop(0)\n        if curr_node == end:\n            return True\n        visited.add(curr_node)\n        neighbors = graph[curr_node]\n        for neighbor in neighbors:\n            if neighbor not in visited and curr_length + 1 <= max_length:\n                queue.append((neighbor, curr_length + 1, curr_weight + weights[(curr_node, neighbor)]))\n    return False\n\ndef g():\n    graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 0\n    end = 5\n    max_length = 3\n    weights = {(0, 1): 10, (0, 2): 5, (1, 3): 7, (1, 4): 3, (2, 4): 4, (3, 5): 2, (4, 5): 6}\n    return (graph, start, end, max_length, weights)\n\nassert f(*g())\n",
        "idx_generation": 312,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\ndef f(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, return the number of combinations of k elements from a set of n elements.\nThe order of the elements does not matter.\"\"\"\n    return len(list(itertools.combinations(range(n), k)))\ndef g(n=5, k=3):\n    return (n, k)\nassert f(*g()) == 10\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Given a positive integer n, generate all distinct subsets of the set [1, 2, ..., n].\"\"\"\n    def backtrack(start, subset):\n        res.append(subset[:])\n        for i in range(start, n + 1):\n            subset.append(i)\n            backtrack(i + 1, subset)\n            subset.pop()\n    res = []\n    backtrack(1, [])\n    return res\ndef g(n=3):\n    return n\nassert f(g()) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers, find k consecutive numbers whose sum is divisible by k.\"\"\"\n    def sum_divisible(nums, k):\n        for i in range(len(nums) - k + 1):\n            if sum(nums[i:i+k]) % k == 0:\n                return True\n        return False\n    return len(nums) >= k and sum_divisible(nums, k)\ndef g(k=3):\n    nums = [i for i in range(1, 2*k+1)]\n    return nums\nassert f(g())\n",
        "idx_generation": 30,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, check if it is a valid parentheses sequence.\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return '((()))'\n\nassert f(g())\n",
        "idx_generation": 265,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, return True if there exists a pair of elements in the list that sum up to the target value.\n    Otherwise, return False.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[3, 1, 6, 2, 4], target=7):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring='abc') -> bool:\n    \"\"\"Check if the substring exists in the string in a sorted order\"\"\"\n    sorted_substring = ''.join(sorted(substring))\n    for i in range(len(s) - len(substring) + 1):\n        if ''.join(sorted(s[i:i+len(substring)])) == sorted_substring:\n            return True\n    return False\n\ndef g(s='bacdafeg'):\n    return s\n\nassert f(g())\n",
        "idx_generation": 48,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of nums whose sum is equal to the target value.\"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset_sum = sum(nums[j] for j in range(n) if (i & (1 << j)) != 0)\n        if subset_sum == target:\n            return True\n    return False\n\ndef g():\n    return ([1, 3, 5, 7, 9], 14)\n\nassert f(*g())\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Given a string s, find the longest substring of length k that contains only unique characters. Return True if such a substring exists, otherwise return False.\nSample Input:\ns = \"abcbde\"\nk = 3\nSample Output:\nTrue\"\"\"\n    n = len(s)\n    if n < k:\n        return False\n    for i in range(n - k + 1):\n        substring = s[i:i + k]\n        if len(set(substring)) == k:\n            return True\n    return False\ndef g(s=\"abcbde\", k=3):\n    return s\nassert f(g())\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"Given an integer n, return a list of all prime numbers smaller than or equal to n.\"\"\"\n    primes = []\n    for num in range(2, n+1):\n        is_prime = True\n        for i in range(2, int(math.sqrt(num))+1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n\ndef g(n: int):\n    return (n,)\n\nassert f(*g(20)) == [2, 3, 5, 7, 11, 13, 17, 19]\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in the given list such that the sum of its elements is equal to the target number.\"\"\"\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n    def helper(start: int, end: int) -> bool:\n        if start == end:\n            return False\n        if prefix_sum[end] - prefix_sum[start] == target:\n            return True\n        return helper(start, end - 1) or helper(start + 1, end)\n    return helper(0, len(nums))\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 9)\n",
        "idx_generation": 400,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list is a palindrome.\nA palindrome list is a list that reads the same forwards and backwards.\nReturn True if the list is a palindrome, and False otherwise.\"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    reverse_nums = []\n    while stack:\n        reverse_nums.append(stack.pop())\n    return nums == reverse_nums\ndef g():\n    return ([1, 2, 3, 2, 1],)\nassert f(*g())\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, return True if there is a path from the top-left corner to the bottom-right corner,\n    only moving right or down.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    # Create a 2D array to store the boolean values\n    dp = [[False] * cols for _ in range(rows)]\n    dp[0][0] = True  # Starting point\n    # Iterate through the matrix\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] |= dp[i-1][j]  # Move down\n            if j > 0:\n                dp[i][j] |= dp[i][j-1]  # Move right\n    return dp[rows-1][cols-1]  # Return the value at the bottom-right corner\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix where there is a path from the top-left corner to the bottom-right corner,\n    only moving right or down.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            if i == rows-1 and j == cols-1:\n                matrix[i][j] = 0  # Set bottom-right corner as 0\n            else:\n                matrix[i][j] = 1  # Set all other cells as 1\n    return matrix\n\n# Test\nmatrix = [[0, 1, 1], [1, 1, 1], [1, 1, 0]]\nassert f(g(matrix))\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n- You can only move down or right.\n- You can only move to adjacent cells.\nReturn the maximum sum.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    \"\"\"\n    Generate a grid where the maximum sum of a path from the top-left cell to the bottom-right cell is known.\n    \"\"\"\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 462,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(palindrome: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    def is_palindrome(s):\n        if len(s) < 2:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n\n    return is_palindrome(palindrome)\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an integer array nums, every element appears twice except for one. Find that single one.\n    You must implement a solution with a linear runtime complexity and without using extra memory.\"\"\"\n    single = 0\n    for num in nums:\n        single ^= num\n    return single\n\ndef g() -> List[int]:\n    return [4, 1, 2, 1, 2]\n\nassert f(g()) == 4\n",
        "idx_generation": 140,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of non-negative integers, find the path from the top-left cell to the bottom-right cell with the maximum sum. You can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Generate a matrix with random non-negative integer values for testing.\"\"\"\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int, max_distance: int) -> bool:\n    \"\"\"Given a graph represented as a dictionary and two nodes start and end, check if there is a path from start to end in the graph with a total distance not exceeding max_distance.\"\"\"\n    visited = set()\n    stack = [(start, 0)]\n    while stack:\n        node, distance = stack.pop()\n        if node == end and distance <= max_distance:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, distance + 1))\n    return False\n\ndef g():\n    return ({1: [2, 3], 2: [4, 5], 3: [6], 4: [7], 5: [7], 6: [7], 7: []}, 1, 7, 5)\n\nassert f(*g())\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> List[int]:\n    \"\"\"\n    Given the root of a binary tree, return a list of values of all the nodes at the deepest level in any order.\n    \"\"\"\n    deepest_level = 0\n    deepest_nodes = []\n\n    def dfs(node: TreeNode, level: int):\n        nonlocal deepest_level, deepest_nodes\n\n        if node is None:\n            return\n        \n        if level > deepest_level:\n            deepest_level = level\n            deepest_nodes = [node.val]\n        elif level == deepest_level:\n            deepest_nodes.append(node.val)\n        \n        dfs(node.left, level + 1)\n        dfs(node.right, level + 1)\n    \n    dfs(root, 0)\n    return deepest_nodes\n\ndef g():\n    \"\"\"\n    Returns the root of the binary tree:\n            1\n           / \\\n          2   3\n         / \\\n        4   5\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    return root\n\nassert f(g()) == [4, 5]\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the minimum number of steps required to reach the bottom right corner, starting from the top left corner.\n    You can move in any of the four cardinal directions (up, down, left, or right), but you can only move to a cell containing a 1.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = deque([(0, 0, 0)])  # (row, col, steps)\n    visited = set([(0, 0)])\n    while queue:\n        row, col, steps = queue.popleft()\n        if row == rows-1 and col == cols-1:\n            return steps\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_row = row + dr\n            new_col = col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, steps+1))\n                visited.add((new_row, new_col))\n    return -1\n\ndef g():\n    grid = [[1, 1, 1, 1],\n            [0, 1, 0, 1],\n            [1, 1, 1, 1],\n            [1, 0, 0, 1]]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Generate a staircase pattern of numbers from 1 to n. Each row of the staircase should have one less number than\n    the previous row, with the first row having n numbers.\n    \n    Example:\n    n = 4\n    \n    Output:\n    [[1, 2, 3, 4],\n     [1, 2, 3],\n     [1, 2],\n     [1]]\n    \"\"\"\n    staircase = []\n    \n    for i in range(n, 0, -1):\n        row = [j for j in range(1, i+1)]\n        staircase.append(row)\n    \n    return staircase\n\ndef g():\n    return 4\n\nassert f(g()) == [[1, 2, 3, 4],\n                  [1, 2, 3],\n                  [1, 2],\n                  [1]]",
        "idx_generation": 260,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers 'arr', find the majority element if it exists.\n    The majority element is defined as the element that appears more than n/2 times, where n is the length of the array.\n    If there is no majority element, return -1.\"\"\"\n    n = len(arr)\n    count = 0\n    candidate = None\n    \n    for num in arr:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n    \n    count = 0\n    for num in arr:\n        if num == candidate:\n            count += 1\n    \n    return candidate if count > n/2 else -1\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\narr = [2, 2, 1, 1, 1, 2, 2]\nassert f(g(arr)) == 2\n",
        "idx_generation": 285,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Count the number of pairs in the list whose sum is equal to the target\"\"\"\n    count = 0\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 36,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, sort the array using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    return arr\n\ndef g(arr: List[int]):\n    return arr[::-1]\n\nassert f(g([5, 3, 2, 4, 1])) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 274,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of pairs of integers in the list that sum up to the target value\"\"\"\n    nums.sort()\n    count = 0\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return count\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5, 6], 9)) == 2\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target=\"abc\") -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string.\"\"\"\n    return sorted(s) == sorted(target)\n\ndef g(s=\"bca\", target=\"abc\"):\n    return \"\".join(sorted(s))\n\nassert f(g())\n",
        "idx_generation": 53,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in nums whose sum is divisible by k.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] + nums[j]) % k == 0:\n                return True\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 3)\n\nassert f(*g())\n",
        "idx_generation": 223,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Given a list of strings 'words', return a new list of strings that contains only the words with the shortest length.\n    If multiple words have the same shortest length, include all of them in the output list.\"\"\"\n    shortest_length = float('inf')\n    shortest_words = []\n    for word in words:\n        word_length = len(word)\n        if word_length < shortest_length:\n            shortest_length = word_length\n            shortest_words = [word]\n        elif word_length == shortest_length:\n            shortest_words.append(word)\n    return shortest_words\ndef g():\n    words = [\"cat\", \"dog\", \"bird\", \"fish\", \"ant\"]\n    return words\nassert f(g()) == [\"cat\", \"dog\", \"ant\"]\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import *\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Generate a Pascal's triangle of size n.\n    Pascal's triangle is a triangular array of binomial coefficients, named after the French mathematician Blaise Pascal.\n    Each number in the triangle is the sum of the two numbers directly above it.\n    Return the Pascal's triangle as a list of lists.\"\"\"\n    triangle = []\n    for i in range(n):\n        row = [1] * (i + 1)\n        if i > 1:\n            for j in range(1, i):\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    return triangle\ndef g(n: int) -> int:\n    return n\nn = 5\nassert f(g(n)) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 450,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers 'arr', find if there exists a subarray whose sum is equal to zero.\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g():\n    return [2, -1, 3, -4, 1]\n\nassert f(g())\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Reverse the elements of a list using a stack.\"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n    return reversed_nums\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum you can achieve by starting at the top-left corner and moving to the bottom-right corner. You can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\ndef g(grid=[[1,3,1],[1,5,1],[4,2,1]]):\n    return (grid,)\nassert f(*g()) == 12\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path in a grid, where each number represents the value of the cell.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n    \n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing at most one character.\"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g() -> str:\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 372,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, count the number of set bits (1's) in its binary representation.\n    Return the count of set bits.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 25\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a given number is a power of 2.\n\"\"\"\n    def is_power_of_two(n):\n        if n == 1:\n            return True\n        if n % 2 != 0 or n == 0:\n            return False\n        return is_power_of_two(n // 2)\n    return is_power_of_two(n)\ndef g(n=16):\n    return n\nassert f(g())\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there exists a path from start to end in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    \n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n    return graph, 'A', 'F'\n\nassert f(*g())\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left corner to the bottom-right corner in a grid\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if there exists a path in the grid that sums up to the target value.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    def dfs(row: int, col: int, current_sum: int) -> bool:\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col]:\n            return False\n        current_sum += grid[row][col]\n        if current_sum == target:\n            return True\n        visited[row][col] = True\n        found = dfs(row + 1, col, current_sum) or dfs(row - 1, col, current_sum) or dfs(row, col + 1, current_sum) or dfs(row, col - 1, current_sum)\n        visited[row][col] = False\n        return found\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n    return False\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    target = 18\n    return (grid, target)\nassert f(*g())\n",
        "idx_generation": 333,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring='abc') -> bool:\n    \"\"\"Check if the given substring appears exactly twice in the string.\"\"\"\n    return s.count(substring) == 2\ndef g(substring='abc'):\n    return substring * 2\nassert f(g())\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target=10, k=3) -> bool:\n    \"\"\"Check if there exists a sublist of size k in arr that sums up to the target\"\"\"\n    def helper(sublist, target, k):\n        if k == 0:\n            return target == 0\n        if not sublist:\n            return False\n        return helper(sublist[1:], target - sublist[0], k-1) or helper(sublist[1:], target, k)\n    \n    return helper(arr, target, k)\n\ndef g():\n    return ([1, 2, 3, 4, 5],)\n\nassert f(g()[0])\n",
        "idx_generation": 298,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, char='a', count=2) -> bool:\n    \"\"\"Check if the given character appears at least a specified number of times in the string\"\"\"\n    return s.count(char) >= count\n\ndef g(char='a', count=2):\n    return 'banana'\n\nassert f(g())\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Find the maximum number of elements you can select from arr such that their sum is less than or equal to target\"\"\"\n    arr.sort(reverse=True)\n    count = 0\n    total = 0\n    for num in arr:\n        if total + num <= target:\n            total += num\n            count += 1\n        else:\n            break\n    return count\n\ndef g(arr: List[int], target: int):\n    return arr\n\nassert f(g([4, 5, 10, 3, 1], 12), target=12)\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and a window size k, return the maximum element in each sliding window of size k.\"\"\"\n    max_elements = []\n    window = deque()\n    for i in range(len(nums)):\n        while window and nums[i] >= nums[window[-1]]:\n            window.pop()\n        window.append(i)\n        if i >= k-1:\n            max_elements.append(nums[window[0]])\n            if window[0] == i - k + 1:\n                window.popleft()\n    return max_elements\n\ndef g(nums=[1, 3, -1, -3, 5, 3, 6, 7], k=3):\n    return nums\n\nassert f(g(), 3) == [3, 3, 5, 5, 6, 7]\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the minimum number of steps required to reach the bottom-right cell of the matrix starting from the top-left cell.\n    You can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    return ([[1, 3, 1],\n             [1, 5, 1],\n             [4, 2, 1]],)\n\nassert f(*g()) == 7\n",
        "idx_generation": 129,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if a target number is present in a grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target=5):\n    return grid, target\nassert f(*g())\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Check if there exists a subset of integers in the list that can add up to the target number n.\"\"\"\n    def subset_sum(n: int, nums: List[int], index: int, memo: dict) -> bool:\n        if n == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if (n, index) in memo:\n            return memo[(n, index)]\n        include = False\n        if nums[index] <= n:\n            include = subset_sum(n - nums[index], nums, index + 1, memo)\n        exclude = subset_sum(n, nums, index + 1, memo)\n        memo[(n, index)] = include or exclude\n        return memo[(n, index)]\n    return subset_sum(n, nums, 0, {})\n\ndef g():\n    n = 9\n    nums = [2, 3, 5, 6]\n    return (n, nums)\n\nassert f(*g()) == True\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length: int) -> bool:\n    \"\"\"Given a string s, determine if it is possible to obtain a string of length target_length by repeating a substring of s.\n    The goal is to find if there exists a substring of s that, when repeated, forms a string of length target_length.\"\"\"\n    if target_length == 0:\n        return True\n    for i in range(1, target_length + 1):\n        if target_length % i == 0:\n            substring = s[:i]\n            if substring * (target_length // i) == s:\n                return True\n    return False\ndef g(s='abcabc', target_length=6):\n    return (s, target_length)\nassert f(*g())\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Find the number of trailing zeros in the factorial of a given number.\"\"\"\n    count = 0\n    i = 5\n    while num // i >= 1:\n        count += num // i\n        i *= 5\n    return count\n\ndef g():\n    num = 25\n    return num\n\nassert f(g()) == 6\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    n = 17\n    return n\nassert f(g())\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a string of parentheses, determine if it is balanced. A string is balanced if it consists of only opening and closing parentheses and each opening parenthesis has a corresponding closing parenthesis in the correct order.\"\"\"\n    stack = []\n    for char in n:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack or stack.pop() != \"(\":\n                return False\n    return len(stack) == 0\ndef g(n=\"((()))\"):\n    return n\nassert f(g()) == True\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of different ways to climb to the top of a staircase\n    with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move down or right at each step.\n    Return the number of unique paths.\n    \"\"\"\n    def count_unique_paths(i: int, j: int) -> int:\n        if i == 0 or j == 0:\n            return 1\n        return count_unique_paths(i - 1, j) + count_unique_paths(i, j - 1)\n    return count_unique_paths(n - 1, n - 1)\ndef g(n=3):\n    return n\nassert f(g()) == 6\n",
        "idx_generation": 489,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"Find the minimum number of operations required to convert string s to string t. Allowed operations are insertion, deletion, and substitution of a character.\"\"\"\n    def edit_distance(s: str, t: str, m: int, n: int) -> int:\n        if m == 0:\n            return n\n        if n == 0:\n            return m\n        if s[m-1] == t[n-1]:\n            return edit_distance(s, t, m-1, n-1)\n        return 1 + min(edit_distance(s, t, m, n-1), edit_distance(s, t, m-1, n), edit_distance(s, t, m-1, n-1))\n    return edit_distance(s, t, len(s), len(t))\ndef g(s=\"kitten\", t=\"sitting\"):\n    return s, t\nassert f(*g()) == 3\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a power of 2 using bit manipulation.\"\"\"\n    return n & (n-1) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 142,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there exists a subset of the list\n    such that the sum of the subset is equal to k.\n    \"\"\"\n    def subset_sum(nums: List[int], k: int, n: int) -> bool:\n        if k == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > k:\n            return subset_sum(nums, k, n-1)\n        return subset_sum(nums, k-nums[n-1], n-1) or subset_sum(nums, k, n-1)\n\n    return subset_sum(nums, k, len(nums))\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 9)\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(edges: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in a graph\"\"\"\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            if node in graph:\n                stack.extend(graph[node])\n    return False\n\ndef g(n=5):\n    edges = [[1, 2], [1, 3], [2, 4], [3, 4], [4, 5]]\n    start = 1\n    end = n\n    return edges, start, end\n\nassert f(*g())\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine if the graph contains a cycle.\n    \"\"\"\n\n    def is_cyclic(graph: List[List[int]], visited: List[bool], current_node: int, parent_node: int) -> bool:\n        visited[current_node] = True\n\n        for neighbor in graph[current_node]:\n            if not visited[neighbor]:\n                if is_cyclic(graph, visited, neighbor, current_node):\n                    return True\n            elif neighbor != parent_node:\n                return True\n\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if is_cyclic(graph, visited, node, -1):\n                return True\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0],\n            [1, 0, 1, 1],\n            [0, 1, 0, 1],\n            [0, 1, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in a directed graph.\"\"\"\n    stack = [start]\n    visited = set()\n    \n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node in visited:\n            continue\n        visited.add(node)\n        stack.extend(adjacency_list[node])\n    \n    return False\n\ndef g():\n    adjacency_list = [[1, 2], [3], [4], [], [5], []]\n    start = 0\n    end = 5\n    return [adjacency_list, start, end]\n\nassert f(*g())\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target integer, count the number of occurrences of the target in the list.\"\"\"\n    count = 0\n    for num in nums:\n        if num == target:\n            count += 1\n    return count\ndef g():\n    nums = [1, 2, 3, 1, 4, 1, 5, 1]\n    target = 1\n    return (nums, target)\nassert f(*g()) == 4\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target value, return the number of ways to combine the numbers in nums using addition and subtraction to reach the target.\"\"\"\n    def backtrack(nums, target, curr_sum, idx, count):\n        if idx == len(nums):\n            if curr_sum == target:\n                count += 1\n        else:\n            count = backtrack(nums, target, curr_sum + nums[idx], idx + 1, count)\n            count = backtrack(nums, target, curr_sum - nums[idx], idx + 1, count)\n        return count\n    \n    return backtrack(nums, target, 0, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 5\n    return (nums, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 305,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Find a substring of length k that appears the most number of times in the string.\"\"\"\n    counts = {}\n    for i in range(len(s) - k + 1):\n        substring = s[i:i+k]\n        if substring in counts:\n            counts[substring] += 1\n        else:\n            counts[substring] = 1\n    max_count = max(counts.values())\n    return sum(count == max_count for count in counts.values()) == 1\n\ndef g(k=3):\n    return 'abcaabcbabccabcaabcb'  # Example string\n\nassert f(g())\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of integers in the given sorted array that sums up to the target value\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return arr\nassert f(g())\n",
        "idx_generation": 38,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, sort the array in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\ndef g():\n    return ([4, 3, 2, 1],)\nassert f(*g()) == [1, 2, 3, 4]\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of distinct integers and a target value, determine if there are three integers in the list that sum up to the target value.\n    Example:\n    arr = [2, 4, 6, 8, 10]\n    target = 16\n    Output:\n    True (2 + 6 + 8 = 16)\n    \"\"\"\n    n = len(arr)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\nassert f(*g([2, 4, 6, 8, 10], 16))\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if t is an anagram of s.\n    Return True if t is an anagram of s, otherwise return False.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    s_count = [0] * 26\n    t_count = [0] * 26\n    for char in s:\n        s_count[ord(char) - ord('a')] += 1\n    for char in t:\n        t_count[ord(char) - ord('a')] += 1\n    return s_count == t_count\n\ndef g():\n    s = \"anagram\"\n    t = \"nagaram\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 62,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and an integer k, determine if there exists a subarray with a sum divisible by k.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = {0}\n    \n    for num in nums:\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g(nums: List[int], k: int):\n    return nums, k\n\nnums = [4, 5, 6, 7, 8, 9]\nk = 3\nassert f(*g(nums, k))\n",
        "idx_generation": 239,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(sentence: str, word1='apple', word2='banana', count1=2, count2=3) -> bool:\n    \"\"\"Count the number of occurrences of word1 and word2 in the sentence, and return True if the count of word1 is\n    greater than or equal to count1 and the count of word2 is less than count2\"\"\"\n    return sentence.count(word1) >= count1 and sentence.count(word2) < count2\ndef g(word1='apple', word2='banana', count1=2, count2=3):\n    sentence = word1 * count1 + word2 * (count2 - 1)\n    return sentence\nassert f(g())\n",
        "idx_generation": 322,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum, which is the sum of a contiguous subarray with the largest possible sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(nums)) == 6\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid representing a maze, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    The grid is represented by a list of lists, where 0 represents an empty cell and 1 represents a wall.\n    Return the length of the shortest path, or -1 if there is no valid path.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = deque([(0, 0, 0)])\n    visited = set([(0, 0)])\n    \n    while queue:\n        i, j, steps = queue.popleft()\n        if i == rows - 1 and j == cols - 1:\n            return steps\n        \n        for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 and (x, y) not in visited:\n                queue.append((x, y, steps + 1))\n                visited.add((x, y))\n    \n    return -1\n\ndef g():\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 8\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Given an integer n, generate all possible combinations of n pairs of parentheses, such that they are well-formed.\n\"\"\"\n    def backtrack(s, left, right, res):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right, res)\n        if right < left:\n            backtrack(s + ')', left, right + 1, res)\n    res = []\n    backtrack('', 0, 0, res)\n    return res\ndef g():\n    n = 3\n    return n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str, target: str) -> bool:\n    \"\"\"Given a string s and a target string, find the minimum number of operations required to transform s into the target string.\n    The allowed operations are:\n    1. Insert a character at any position.\n    2. Delete a character from any position.\n    3. Replace a character at any position.\nSample Input:\ns = \"kitten\"\ntarget = \"sitting\"\nSample Output:\n3\"\"\"\n    m = len(s)\n    n = len(target)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(m+1):\n        dp[i][0] = i\n    for j in range(n+1):\n        dp[0][j] = j\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == target[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]\ndef g():\n    s = \"kitten\"\n    target = \"sitting\"\n    return s, target\nassert f(*g()) == 3\n",
        "idx_generation": 395,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number n is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef g(n: int):\n    return n\n\nassert f(g(n=16))\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be expressed as a sum of distinct powers of k.\n    For example, if n = 21 and k = 2, the function should return True since 21 can be expressed as 2^4 + 2^2 + 2^0 = 16 + 4 + 1 = 21.\n    If it is not possible to express n as a sum of distinct powers of k, the function should return False.\"\"\"\n    \n    def helper(n: int, k: int, curr_power: int, used_powers: Set[int]) -> bool:\n        if n == 0:\n            return True\n        if n < 0 or curr_power < 0:\n            return False\n        if curr_power in used_powers:\n            return helper(n, k, curr_power - 1, used_powers)\n        return helper(n - k ** curr_power, k, curr_power - 1, used_powers) or helper(n, k, curr_power - 1, used_powers)\n\n    return helper(n, k, int(n ** 0.5), set())\n\ndef g():\n    return (21, 2)\n\nassert f(*g()) == True\n",
        "idx_generation": 192,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the shortest path from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = deque([(0, 0, grid[0][0])])\n    min_path_sum = float('inf')\n\n    while queue:\n        i, j, path_sum = queue.popleft()\n\n        if i == rows - 1 and j == cols - 1:\n            min_path_sum = min(min_path_sum, path_sum)\n        \n        # Move down\n        if i + 1 < rows:\n            queue.append((i + 1, j, path_sum + grid[i + 1][j]))\n        \n        # Move right\n        if j + 1 < cols:\n            queue.append((i, j + 1, path_sum + grid[i][j + 1]))\n    \n    return min_path_sum\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a cycle in a directed graph represented by the given list of edges.\"\"\"\n    graph = {}\n    for u, v in nums:\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n    visited = set()\n    for node in graph:\n        if node not in visited:\n            if has_cycle(graph, node, visited, set()):\n                return True\n    return False\n\ndef has_cycle(graph, node, visited, path):\n    visited.add(node)\n    path.add(node)\n    if node in graph:\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if has_cycle(graph, neighbor, visited, path):\n                    return True\n            elif neighbor in path:\n                return True\n    path.remove(node)\n    return False\n\ndef g():\n    return [[1, 2], [2, 3], [3, 4], [4, 1]]\n\nassert f(g())\n",
        "idx_generation": 194,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Determine if a given grid represents a valid path from start to finish.\n    The grid is represented by a 2D list of characters, where 'S' represents the start, 'F' represents the finish,\n    'X' represents obstacles, and '.' represents empty spaces.\n    Return True if there is a valid path from start to finish, False otherwise.\"\"\"\n    \n    def dfs(i: int, j: int) -> bool:\n        if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == 'X':\n            return False\n        if grid[i][j] == 'F':\n            return True\n        grid[i][j] = 'X'\n        return dfs(i+1, j) or dfs(i-1, j) or dfs(i, j+1) or dfs(i, j-1)\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 'S':\n                return dfs(i, j)\n    return False\n\ndef g():\n    grid = [\n        ['S', '.', '.', '.', 'X'],\n        ['.', 'X', '.', 'X', 'X'],\n        ['.', '.', '.', '.', '.'],\n        ['X', '.', 'X', '.', 'F'],\n    ]\n    return (grid,)\n\nassert f(*g()) == True\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k=3) -> bool:\n    \"\"\"Given a positive integer n, find the number of distinct k-digit numbers that can be formed using the digits 1 to n.\n    Return True if the count is greater than 0, otherwise return False.\"\"\"\n    if k > n:\n        return False\n    count = 1\n    for i in range(n, n - k, -1):\n        count *= i\n    return count > 0\n\ndef g(k=3):\n    return 5\n\nassert f(g())\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find all combinations of numbers in the list that add up to the target sum.\n    Args:\n        nums: The list of integers.\n        target: The target sum.\n    Returns:\n        A list of lists containing the combinations of numbers that add up to the target sum.\n    \"\"\"\n    res = []\n    dfs(nums, target, [], res)\n    return res\n\ndef dfs(nums: List[int], target: int, path: List[int], res: List[List[int]]):\n    if target < 0:\n        return\n    if target == 0:\n        res.append(path)\n        return\n    for i in range(len(nums)):\n        dfs(nums[i:], target - nums[i], path + [nums[i]], res)\n\ndef g():\n    \"\"\"\n    Returns a list of integers and the target sum.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: List[str]) -> bool:\n    \"\"\"Given a list of strings, return True if there exists a string that contains at least 3 vowels and 2 consonants,\n    and False otherwise.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    return any((sum(x.count(v) for v in vowels) >= 3 and len(x) - sum(x.count(v) for v in vowels) >= 2 for x in s))\ndef g():\n    return ['hello', 'world', 'python', 'programming', 'puzzle']\nassert f(g())\n",
        "idx_generation": 28,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the given list that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"Given a positive integer n, generate the first n Fibonacci numbers using a stack.\nReturn a list of the first n Fibonacci numbers.\"\"\"\n    stack = []\n    stack.append(0)\n    stack.append(1)\n    for i in range(2, n):\n        stack.append(stack[-1] + stack[-2])\n    return stack\n\ndef g():\n    return 8\n\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8, 13]\n",
        "idx_generation": 301,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a pair of numbers in the list that sum up to the target value.\n    Return True if such pair exists, and False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 134,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, nums=[5, 7, 2, 9, 3, 1, 4, 6, 8]) -> bool:\n    \"\"\"Check if the given string is a concatenation of all numbers from 1 to 9 (inclusive) in a sorted order.\"\"\"\n    sorted_nums = ''.join(map(str, sorted(nums)))\n    return s == sorted_nums\ndef g(nums=[5, 7, 2, 9, 3, 1, 4, 6, 8]):\n    return ''.join(map(str, sorted(nums)))\nassert f(g())\n",
        "idx_generation": 79,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, determine if it can be divided into two subsets with equal sum.\n    \"\"\"\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    n = len(arr)\n\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target_sum]\n\ndef g():\n    arr = [1, 5, 11, 5]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"Split a string into chunks of length 3, ignoring any remaining characters.\"\"\"\n    chunks = []\n    for i in range(0, len(s), 3):\n        if i + 3 <= len(s):\n            chunks.append(s[i:i+3])\n    return chunks\n\ndef g():\n    return (\"Hello, World!\",)\n\nassert f(*g()) == [\"Hel\", \"lo,\", \" Wo\", \"rld\"]\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a permutation of the first n natural numbers.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        if i+1 not in arr:\n            return False\n    return True\n\ndef g():\n    arr = [3, 2, 1, 4, 5]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the length of the shortest path from the top-left corner to the bottom-right corner in a grid.\n    The grid is represented as a 2D list of integers, where 0 represents an empty cell and 1 represents an obstacle.\"\"\"\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque([(0, 0, 0)])  # (row, col, path_length)\n    visited = set([(0, 0)])\n    while queue:\n        row, col, path_length = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0:\n                queue.append((new_row, new_col, path_length + 1))\n                visited.add((new_row, new_col))\n    return -1  # No valid path found\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[0, 0, 0], [0, 1, 0], [0, 0, 0]])) == 4\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(maze: List[List[int]]) -> int:\n    \"\"\"Find the maximum number of points that can be collected by moving from the top-left corner to the bottom-right corner of the maze,\nwhere each move can only be made to a neighboring cell with a larger value.\"\"\"\n    (m, n) = (len(maze), len(maze[0]))\n    memo = [[-1] * n for _ in range(m)]\n    def dfs(row, col):\n        if row == m - 1 and col == n - 1:\n            return maze[row][col]\n        if memo[row][col] != -1:\n            return memo[row][col]\n        max_points = 0\n        if row + 1 < m and maze[row + 1][col] > maze[row][col]:\n            max_points = max(max_points, dfs(row + 1, col) + maze[row][col])\n        if col + 1 < n and maze[row][col + 1] > maze[row][col]:\n            max_points = max(max_points, dfs(row, col + 1) + maze[row][col])\n        memo[row][col] = max_points\n        return max_points\n    return dfs(0, 0)\ndef g(maze: List[List[int]]):\n    return maze\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 29\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if a string is a palindrome.\"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])\ndef g():\n    return \"radar\"\nassert f(g())\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in the given list of consecutive numbers from 1 to n.\"\"\"\n    n = len(nums) + 1\n    xor_val = 0\n    for i in range(1, n + 1):\n        xor_val ^= i\n    for num in nums:\n        xor_val ^= num\n    return xor_val\ndef g():\n    return [1, 2, 4, 5, 6]\nassert f(g()) == 3\n",
        "idx_generation": 147,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two positive integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\nYou can only move down or right.\"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n - 1, m) + f(n, m - 1)\ndef g(n: int, m: int):\n    return n\nassert f(g(3, 4), 4) == 10\n",
        "idx_generation": 197,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], start=0, end=4) -> bool:\n    \"\"\"Given a graph represented as an adjacency list, find the shortest path from the start node to the end node\nusing Breadth First Search (BFS).\nArgs:\n    graph: The graph represented as an adjacency list.\n    start: The starting node.\n    end: The ending node.\nReturns:\n    The shortest path from start to end if a path exists, an empty list otherwise.\"\"\"\n    queue = [(start, [start])]\n    while queue:\n        curr_node, path = queue.pop(0)\n        if curr_node == end:\n            return path\n        for neighbor in graph[curr_node]:\n            if neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n    return []\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2, 4], [3]]\nassert f(g()) == [0, 1, 3, 4]\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented by its edges, determine if there is a cycle in the graph.\"\"\"\n    def has_cycle(node):\n        visited.add(node)\n        recursion_stack.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if has_cycle(neighbor):\n                    return True\n            elif neighbor in recursion_stack:\n                return True\n\n        recursion_stack.remove(node)\n        return False\n\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n\n    visited = set()\n    recursion_stack = set()\n\n    for node in range(n):\n        if node not in visited:\n            if has_cycle(node):\n                return True\n\n    return False\n\ndef g():\n    return 4, [[0, 1], [1, 2], [2, 3], [3, 1]]\n\nassert f(*g())\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> int:\n    \"\"\"Given a grid represented as a binary matrix, find the number of unique paths to reach the bottom right corner from the top left corner\"\"\"\n    m, n = matrix.shape\n    dp = np.zeros((m, n), dtype=int)\n    dp[0, 0] = 1\n    for i in range(1, m):\n        if matrix[i, 0] == 0:\n            dp[i, 0] = dp[i - 1, 0]\n    for j in range(1, n):\n        if matrix[0, j] == 0:\n            dp[0, j] = dp[0, j - 1]\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i, j] == 0:\n                dp[i, j] = dp[i - 1, j] + dp[i, j - 1]\n    return dp[-1, -1]\n\ndef g(matrix=np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]])):\n    \"\"\"Generate a binary matrix\"\"\"\n    return matrix\n\nassert f(g()) == 2\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and an integer k, determine if there exists a subset of the list where the sum of its elements is divisible by k.\"\"\"\n    n = len(arr)\n    for i in range(1, n+1):\n        subsets = list(itertools.combinations(arr, i))\n        for subset in subsets:\n            if sum(subset) % k == 0:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 7) == True\n",
        "idx_generation": 290,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"Given a string, return a list of all possible permutations of the characters in the string.\"\"\"\n    if len(s) == 1:\n        return [s]\n    permutations = []\n    for i in range(len(s)):\n        char = s[i]\n        remaining = s[:i] + s[i+1:]\n        for perm in f(remaining):\n            permutations.append(char + perm)\n    return permutations\ndef g(s='abc'):\n    return s\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 314,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 and s2 can be rearranged to form an anagram of each other.\"\"\"\n    def count_letters(s):\n        letter_count = {}\n        for letter in s:\n            if letter in letter_count:\n                letter_count[letter] += 1\n            else:\n                letter_count[letter] = 1\n        return letter_count\n\n    s1_letters = count_letters(s1)\n    s2_letters = count_letters(s2)\n\n    return s1_letters == s2_letters\n\ndef g():\n    return (\"listen\", \"silent\")\n\nassert f(*g())\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two elements that sum up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8], 10\n\nassert f(*g())\n",
        "idx_generation": 41,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list is a permutation of the numbers from 1 to n, where n is the length of the list.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i + 1:\n            return False\n    return True\ndef g(nums: List[int]=[4, 1, 3, 2]):\n    return nums\nassert f(g())\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 3, 5, 9, 10, 12, 15], 17\n\nassert f(*g()) == True\n",
        "idx_generation": 138,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"Check if the given string is a concatenation of all strings in the list in a sorted order.\"\"\"\n    sorted_strings = ''.join(sorted(strings))\n    return s == sorted_strings\ndef g(strings=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return ''.join(sorted(strings))\nassert f(g())\n",
        "idx_generation": 79,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of valid parentheses expressions of length 2n. A valid parentheses expression must have n opening parentheses and n closing parentheses, and must be balanced.\"\"\"\n    if n == 0:\n        return 1\n    count = 0\n    for i in range(n):\n        count += f(i) * f(n-i-1)\n    return count\ndef g():\n    return 3\nassert f(g()) == 5\n",
        "idx_generation": 275,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, determine if it is possible to rearrange the characters of s such that no two adjacent characters are the same, and the resulting string has exactly k distinct characters.\"\"\"\n    from collections import Counter\n    if k > len(set(s)):\n        return False\n    counts = Counter(s)\n    max_count = max(counts.values())\n    return (len(s) - max_count) >= k - 1\ndef g(s: str, k: int):\n    distinct_chars = set(s)\n    if len(distinct_chars) < k:\n        return \"\"\n    counts = {c: 0 for c in distinct_chars}\n    result = []\n    def backtrack():\n        if len(result) == len(s):\n            return True\n        for c in distinct_chars:\n            if counts[c] < k and (not result or result[-1] != c):\n                result.append(c)\n                counts[c] += 1\n                if backtrack():\n                    return True\n                result.pop()\n                counts[c] -= 1\n        return False\n    if backtrack():\n        return \"\".join(result)\n    return \"\"\nassert f(g(\"aabbc\", 2), 2)\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nArgs:\n    nums: The array of integers.\n    target: The target sum.\nReturns:\n    The indices of the two numbers that add up to the target sum.\"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g():\n    \"\"\"\n    Returns an array of integers and the target sum for testing.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 471,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a valid parentheses sequence.\n    Sample Input:\n    s = \"((()))\"\n    Sample Output:\n    True\"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\ndef g(s='((()))'):\n    return s\nassert f(g())\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> int:\n    \"\"\"\n    Given two strings s1 and s2, find the minimum number of operations required to transform s1 into s2.\n    The allowed operations are:\n     - Insert a character\n     - Delete a character\n     - Replace a character\n    Return the minimum number of operations.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    return dp[m][n]\n\ndef g(s1: str, s2: str):\n    return s1, s2\n\ns1 = \"algorithm\"\ns2 = \"altruism\"\nassert f(*g(s1, s2)) == 5\n",
        "idx_generation": 100,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Find the longest palindrome substring in the given string\"\"\"\n    n = len(s)\n    longest_palindrome = ''\n\n    def expand_from_center(left: int, right: int) -> str:\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    for i in range(n):\n        odd_palindrome = expand_from_center(i, i)\n        even_palindrome = expand_from_center(i, i + 1)\n        longest_palindrome = max(longest_palindrome, odd_palindrome, even_palindrome, key=len)\n\n    return longest_palindrome\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g('babad')) == 'bab'\n",
        "idx_generation": 419,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a subset of the given list of numbers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    n = len(nums)\n    total = 1 << n\n    for i in range(total):\n        subset_xor = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_xor ^= nums[j]\n        if subset_xor == target:\n            return True\n    return False\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a list of numbers and a target number.\n    \"\"\"\n    nums = [3, 5, 9, 2, 7]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subarray with a sum equal to zero.\n    Return True if such subarray exists, otherwise return False.\n    Sample Input:\n    nums = [4, 2, -3, 1, 6]\n    Sample Output:\n    True\"\"\"\n    prefix_sum = set()\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if curr_sum == 0 or curr_sum in prefix_sum:\n            return True\n        prefix_sum.add(curr_sum)\n    return False\n\ndef g(nums: List[int] = [4, 2, -3, 1, 6]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 198,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int, max_length: int) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph, with a maximum length constraint.\"\"\"\n    queue = [(start, 0)]\n    visited = set()\n    while queue:\n        curr_node, curr_length = queue.pop(0)\n        if curr_node == end:\n            return True\n        visited.add(curr_node)\n        neighbors = graph[curr_node]\n        for neighbor in neighbors:\n            if neighbor not in visited and curr_length + 1 <= max_length:\n                queue.append((neighbor, curr_length + 1))\n    return False\n\ndef g():\n    graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [5], 4: [5], 5: []}\n    start = 0\n    end = 5\n    max_length = 3\n    return (graph, start, end, max_length)\n\nassert f(*g())\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right cell from the top-left cell in the grid\"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Initialize a 2D dp array to keep track of the possible paths\n    dp = [[0] * n for _ in range(m)]\n    \n    # Fill the first row and column with 1's\n    dp[0][0] = 1\n    for i in range(1, m):\n        if grid[i][0] == 0:\n            dp[i][0] = dp[i-1][0]\n    for j in range(1, n):\n        if grid[0][j] == 0:\n            dp[0][j] = dp[0][j-1]\n    \n    # Fill the rest of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    # Return True if the bottom-right cell is reachable\n    return dp[m-1][n-1] > 0\n\ndef g(grid: List[List[int]]):\n    \"\"\"Generate a grid with random obstacles\"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Randomly place obstacles in the grid\n    for i in range(m):\n        for j in range(n):\n            if random.random() < 0.2:\n                grid[i][j] = 1\n    \n    return grid\n\nassert f(g([[0, 0, 0], [0, 0, 0], [0, 0, 0]]))\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str, grid: List[List[str]]) -> bool:\n    \"\"\"Given a string and a grid of letters, determine if it is possible to form the string by traversing adjacent cells in the grid.\nThe string can be formed by moving up, down, left, or right in the grid, but not diagonally.\nEach cell in the grid can only be used once.\nReturn True if it is possible, False otherwise.\"\"\"\n    def dfs(i: int, j: int, idx: int) -> bool:\n        if idx == len(s):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or (j >= len(grid[0])) or (visited[i][j]) or (grid[i][j] != s[idx]):\n            return False\n        visited[i][j] = True\n        found = dfs(i + 1, j, idx + 1) or dfs(i - 1, j, idx + 1) or dfs(i, j + 1, idx + 1) or dfs(i, j - 1, idx + 1)\n        visited[i][j] = False\n        return found\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\ndef g(s: str, grid: List[List[str]]):\n    return (s, grid)\n\ngrid = [['A', 'B', 'C', 'D'], ['E', 'A', 'B', 'C'], ['D', 'E', 'F', 'A'], ['B', 'C', 'D', 'E']]\ns = 'ABCD'\nassert f(*g(s, grid))\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the string s can be rearranged to form a palindrome\"\"\"\n    counts = {}\n    odd_count = 0\n    \n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n        \n        if counts[char] % 2 == 1:\n            odd_count += 1\n        else:\n            odd_count -= 1\n    \n    return odd_count <= 1\n\ndef g():\n    s = \"level\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find all unique combinations of numbers in the list that add up to the target.\"\"\"\n    def backtrack(remaining, combination, start):\n        if remaining == 0:\n            return [combination]\n        if remaining < 0:\n            return []\n        results = []\n        for i in range(start, len(nums)):\n            results += backtrack(remaining - nums[i], combination + [nums[i]], i)\n        return results\n    \n    nums.sort()\n    return backtrack(target, [], 0)\n\ndef g():\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 323,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if a given string has a repeated substring of length at least 3.\"\"\"\n    for i in range(len(s) - 2):\n        for j in range(i + 1, len(s) - 1):\n            if s[i:j+1] in s[j+1:]:\n                return True\n    return False\n\ndef g():\n    return 'abcabcdabcde'\n\nassert f(g())\n",
        "idx_generation": 35,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"Calculate the amount of water that can be trapped between the bars in a given list of heights.\"\"\"\n    if len(heights) <= 2:\n        return 0\n    \n    total_water = 0\n    left_max = [0] * len(heights)\n    right_max = [0] * len(heights)\n    \n    left_max[0] = heights[0]\n    for i in range(1, len(heights)):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    right_max[-1] = heights[-1]\n    for i in range(len(heights)-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    for i in range(1, len(heights)-1):\n        water_height = min(left_max[i], right_max[i]) - heights[i]\n        if water_height > 0:\n            total_water += water_height\n    \n    return total_water\n\ndef g(heights: List[int]) -> List[int]:\n    return heights\n\nassert f(g([0,1,0,2,1,0,1,3,2,1,2,1])) == 6\n",
        "idx_generation": 42,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    \n    # Create a min heap\n    heap = []\n    for num in arr:\n        heapq.heappush(heap, num)\n\n    # Use two pointers to find the pair\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 318,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target.\"\"\"\n    def helper(nums, target, start, end):\n        if start >= end:\n            return False\n        if nums[start] + nums[end] == target:\n            return True\n        elif nums[start] + nums[end] < target:\n            return helper(nums, target, start + 1, end)\n        else:\n            return helper(nums, target, start, end - 1)\n    \n    return helper(nums, target, 0, len(nums) - 1)\n\ndef g():\n    return [-2, 1, 3, 5, 6, 8, 10, 12]\n\nassert f(g(), 9)\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"Check if the given string is a concatenation of all strings in the list in a sorted order, with each string repeated a number of times equal to its length.\"\"\"\n    sorted_strings = ''.join(sorted(strings * len(strings)))\n    return s == sorted_strings\ndef g(strings=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return ''.join(sorted(strings * len(strings)))\nassert f(g())\n",
        "idx_generation": 79,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of distinct valid parentheses expressions of length 2n. A valid parentheses expression consists of n opening parentheses '(' and n closing parentheses ')', with the property that every opening parenthesis has a corresponding closing parenthesis and vice versa.\"\"\"\n    def solve(open_count, close_count):\n        if open_count == 0 and close_count == 0:\n            return 1\n        res = 0\n        if open_count > 0:\n            res += solve(open_count - 1, close_count + 1)\n        if close_count > 0:\n            res += solve(open_count, close_count - 1)\n        return res\n    return solve(n, 0)\ndef g(n=3):\n    return n\nassert f(g()) == 5\n",
        "idx_generation": 282,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome and contains exactly two occurrences of the character 'z'.\"\"\"\n    return s == s[::-1] and s.count('z') == 2\ndef g():\n    return 'zaz'\nassert f(g())\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, grid: List[List[str]]) -> bool:\n    \"\"\"Check if the string can be formed by concatenating characters from the grid in a specific pattern.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    return dfs(0, 0, s, grid, visited)\n\ndef dfs(row: int, col: int, s: str, grid: List[List[str]], visited: List[List[bool]]) -> bool:\n    if len(s) == 0:\n        return True\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] != s[0]:\n        return False\n    visited[row][col] = True\n    if dfs(row - 1, col, s[1:], grid, visited) or dfs(row + 1, col, s[1:], grid, visited) or dfs(row, col - 1, s[1:], grid, visited) or dfs(row, col + 1, s[1:], grid, visited):\n        return True\n    visited[row][col] = False\n    return False\n\ndef g(grid: List[List[str]], s='ABCD') -> str:\n    return ''.join(s)\n\ngrid = [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L']]\nassert f(g(grid), grid)\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Determine if the given string s can be formed by repeating a smaller string of length n.\"\"\"\n    substring = s[:n]\n    return substring * (len(s) // n) == s\n\ndef g(n=3):\n    return 'abc' * n\n\nassert f(g())\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers arr, return True if there exists a non-empty subsequence of arr such that XOR of all elements in the subsequence is equal to 0. Otherwise, return False.\"\"\"\n    n = len(arr)\n    xor_sum = 0\n    for i in range(n):\n        xor_sum ^= arr[i]\n        if xor_sum == 0:\n            return True\n    return False\n\ndef g():\n    return [2, 3, 1, 0, 5]\n\nassert f(g())\n",
        "idx_generation": 155,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner, where the sum of the numbers along the path is a prime number.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    def path_exists(matrix, i, j, current_sum):\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return is_prime(current_sum + matrix[i][j])\n        if i >= len(matrix) or j >= len(matrix[0]):\n            return False\n        include = path_exists(matrix, i+1, j, current_sum + matrix[i][j])\n        exclude = path_exists(matrix, i, j+1, current_sum + matrix[i][j])\n        return include or exclude\n    \n    return path_exists(matrix, 0, 0, 0)\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency list, find the shortest path from the start node to the end node.\n    If there is no path, return an empty list.\n    \"\"\"\n    queue = [(start, [start])]\n    while queue:\n        node, path = queue.pop(0)\n        if node == end:\n            return path\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n    return []\n\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [5],\n        5: []\n    }\n    return (graph, 1, 5)\n\nassert f(*g()) == [1, 3, 5]\n",
        "idx_generation": 312,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], path: str) -> bool:\n    \"\"\"Check if the given path is a valid Eulerian path in the graph.\"\"\"\n    def eulerian_path(node: str, visited: Set[str]) -> bool:\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if not eulerian_path(neighbor, visited):\n                    return False\n        return True\n\n    # Check if all nodes in the path exist in the graph\n    for node in path:\n        if node not in graph:\n            return False\n\n    # Check if the path is a valid Eulerian path\n    visited = set()\n    if not eulerian_path(path[0], visited):\n        return False\n\n    # Check if all nodes in the graph are visited\n    for node in graph:\n        if node not in visited:\n            return False\n\n    return True\n\ndef g() -> Tuple[Dict[str, List[str]], str]:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['E'], 'E': []}\n    path = 'ABCDE'\n    return (graph, path)\n\nassert f(*g())\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if there exists a subsequence of nums that adds up to the target.\n    Return True if such subsequence exists, False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [2, 5, 8, 10, 4]\n    target = 13\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two positive integers n and m, return the number of ways to choose m elements from a set of n elements.\n    The order of the chosen elements does not matter.\"\"\"\n    if m > n:\n        return 0\n    \n    numerator = 1\n    denominator = 1\n    \n    for i in range(m):\n        numerator *= (n - i)\n        denominator *= (i + 1)\n    \n    return numerator // denominator\n\ndef g(n: int, m: int):\n    return (n, m)\n\nn = 5\nm = 3\nassert f(*g(n, m)) == 10\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, determine the number of ways to climb a staircase with n steps. You can climb one or two steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    prev, curr = 1, 2\n    for i in range(2, n):\n        prev, curr = curr, prev + curr\n    return curr\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 330,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, return the number of positive integers less than or equal to n that have at least one repeated digit.\n    - Example: Input: 20, Output: 1 (The only positive integer less than 20 with at least one repeated digit is 11)\"\"\"\n    def has_repeated_digit(num):\n        digits = set()\n        while num > 0:\n            digit = num % 10\n            if digit in digits:\n                return True\n            digits.add(digit)\n            num //= 10\n        return False\n    count = 0\n    for i in range(1, n + 1):\n        if has_repeated_digit(i):\n            count += 1\n    return count\ndef g():\n    return 20\nassert f(g())\n",
        "idx_generation": 65,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there is a pair of numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nassert f(g(), 20)\n",
        "idx_generation": 43,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and a window size k, find the maximum element in each window of size k.\"\"\"\n    result = []\n    queue = []\n    for i, num in enumerate(nums):\n        while queue and nums[queue[-1]] <= num:\n            queue.pop()\n        queue.append(i)\n        if queue[0] == i - k:\n            queue.pop(0)\n        if i >= k - 1:\n            result.append(nums[queue[0]])\n    return result\n\ndef g(nums: List[int]=[1, 3, -1, -3, 5, 3, 6, 7], k: int=3):\n    return nums, k\n\nassert f(*g()) == [3, 3, 5, 5, 6, 7]\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose sum is equal to the target value.\"\"\"\n    nums.sort()\n    (left, right) = (0, len(nums) - 1)\n    while left < right:\n        sum_val = nums[left] + nums[right]\n        if sum_val == target:\n            return True\n        elif sum_val < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [5, 7, 2, 9, 1, 4]\nassert f(g(), 10)\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string s is a palindrome when considering only alphanumeric characters and ignoring case.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\nassert f(g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers 'arr', find the maximum product of any two distinct elements in the array.\"\"\"\n    n = len(arr)\n    max_product = float('-inf')\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            max_product = max(max_product, arr[i]*arr[j])\n    \n    return max_product\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\narr = [1, 2, 3, 4, 5]\nassert f(g(arr)) == 20\n",
        "idx_generation": 285,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> int:\n    \"\"\"Count the number of occurrences of each character in a string and return the maximum count.\"\"\"\n    char_count = {}\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n    return max(char_count.values())\n\ndef g(string: str = \"abracadabra\"):\n    return string\n\nassert f(g()) == 5\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Determine if it is possible to select k numbers from the given list that sum up to the target\"\"\"\n    n = len(nums)\n    memo = [[-1] * (target + 1) for _ in range(n + 1)]\n    return helper(nums, target, k, n, memo)\n\ndef helper(nums: List[int], target: int, k: int, n: int, memo: List[List[int]]) -> bool:\n    if target == 0 and k == 0:\n        return True\n    if n == 0 or k == 0 or target < 0:\n        return False\n    if memo[n][target] != -1:\n        return memo[n][target]\n    \n    include = helper(nums, target - nums[n-1], k-1, n-1, memo)\n    exclude = helper(nums, target, k, n-1, memo)\n    \n    memo[n][target] = include or exclude\n    return memo[n][target]\n\ndef g(nums=[1, 2, 3, 4, 5], target=10, k=3):\n    \"\"\"Generate a list of numbers that can be used to solve the problem\"\"\"\n    return nums\n    \nassert f(g(), 10, 3)\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    def is_palindrome(s: str, start: int, end: int) -> bool:\n        if start >= end:\n            return True\n        return s[start] == s[end] and is_palindrome(s, start + 1, end - 1)\n    \n    return is_palindrome(str(n), 0, len(str(n)) - 1)\ndef g():\n    n = 1221\n    return n\nassert f(g())\n",
        "idx_generation": 443,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of two numbers in the given list using bit manipulation.\"\"\"\n    max_product = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    return ([3, 5, 9, 2, 4],)\n\nassert f(*g()) == 45\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be expressed as the sum of distinct powers of 3.\n\n    Return True if it can be expressed, False otherwise.\n    \"\"\"\n    def helper(n, current_sum, current_power):\n        if current_sum == n:\n            return True\n        if current_sum > n:\n            return False\n        return helper(n, current_sum + pow(3, current_power), current_power + 1) or helper(n, current_sum, current_power + 1)\n    \n    return helper(n, 0, 0)\n\ndef g():\n    n = 13\n    return n\n\nassert f(g())\n",
        "idx_generation": 207,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:\n    \"\"\"Find the shortest path from the start node to the end node in the given graph. Return the path as a list of nodes.\n    \"\"\"\n    queue = [(start, [start])]\n    while queue:\n        (node, path) = queue.pop(0)\n        if node == end:\n            return path\n        if node in graph:\n            for next_node in graph[node]:\n                if next_node not in path:\n                    queue.append((next_node, path + [next_node]))\n    return []\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    return (graph, 'A', 'D')\n\nassert f(*g()) == ['A', 'B', 'D']\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there exists a path from start to end.\"\"\"\n    visited = set()\n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    return dfs(start)\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }, 'A', 'E'\n\nassert f(*g())\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency matrix, determine if the graph contains a cycle.\n    Return True if a cycle exists, otherwise return False.\"\"\"\n    visited = set()\n    for node in range(len(graph)):\n        if node not in visited:\n            if dfs(graph, node, visited, parent=-1):\n                return True\n    return False\n\ndef dfs(graph, node, visited, parent):\n    visited.add(node)\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1:\n            if neighbor not in visited:\n                if dfs(graph, neighbor, visited, parent=node):\n                    return True\n            elif neighbor != parent:\n                return True\n    return False\n\ndef g():\n    return [[0, 1, 0, 1, 0],\n            [1, 0, 1, 0, 0],\n            [0, 1, 0, 0, 1],\n            [1, 0, 0, 0, 1],\n            [0, 0, 1, 1, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers and a target value, determine if there exists a subset of the numbers that adds up to the target.\n    The subset must contain at least two numbers.\"\"\"\n    \n    def backtrack(index, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(numbers):\n            return False\n        if backtrack(index + 1, current_sum + numbers[index]):\n            return True\n        if backtrack(index + 1, current_sum):\n            return True\n        \n    return backtrack(0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == True\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subset whose sum is equal to the target.\"\"\"\n    def subset_sum(nums, target, index, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        include = subset_sum(nums, target, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, current_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n    \ndef g(target=0):\n    return [1, 2, 3, 4, 5, 6]\nassert f(g())\n",
        "idx_generation": 343,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, target=3) -> bool:\n    \"\"\"Given a string, find the number of ways to split the string into three non-empty parts such that the number of\ndistinct characters in each part is equal to the target value.\nSample Input:\nstring = \"aabcbcdbca\"\ntarget = 3\nSample Output:\n2\"\"\"\n    n = len(string)\n    count = 0\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            left = set(string[:i])\n            mid = set(string[i:j])\n            right = set(string[j:])\n            if len(left) == len(mid) == len(right) == target:\n                count += 1\n    return count\ndef g(string=\"aabcbcdbca\", target=3):\n    return string, target\nassert f(*g())\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target integer 'target', determine if there exist two numbers in the list that sum up to the target\"\"\"\n    def helper(arr, left, right, target):\n        if left >= right:\n            return False\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            return helper(arr, left + 1, right, target)\n        else:\n            return helper(arr, left, right - 1, target)\n    return helper(arr, 0, len(arr) - 1, target)\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g(), 13)\n",
        "idx_generation": 44,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exists a pair of elements in the array whose sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    target = 10\n    return arr, target\nassert f(*g())\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers and a target number, find all unique combinations of numbers in the list that sum up to the target\"\"\"\n    def helper(nums, target, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        if target < 0:\n            return\n        for i in range(len(nums)):\n            helper(nums[i:], target - nums[i], path + [nums[i]], res)\n    \n    res = []\n    helper(nums, target, [], res)\n    unique_res = []\n    for r in res:\n        r.sort()\n        if r not in unique_res:\n            unique_res.append(r)\n    return unique_res\n\ndef g(nums=[2, 3, 6, 7, 8]):\n    return nums\n\nassert f(g()) == [[2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 8], [3, 7]]\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if the two given strings are anagrams of each other.\n    An anagram is a word or phrase formed by rearranging the letters of another word or phrase.\"\"\"\n    sorted_s1 = ''.join(sorted(s1))\n    sorted_s2 = ''.join(sorted(s2))\n    return sorted_s1 == sorted_s2\n\ndef g():\n    return ('listen', 'silent')\n\nassert f(*g())\n",
        "idx_generation": 84,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subarray of consecutive elements in the list that adds up to the target.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    prefix_sum_set = set(prefix_sum)\n\n    for i in range(n):\n        if prefix_sum[i] + target in prefix_sum_set:\n            return True\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subarray of consecutive elements in the list that adds up to the target number.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n\n    prefix_sum_set = set(prefix_sum)\n\n    for i in range(n):\n        if prefix_sum[i] + target in prefix_sum_set:\n            j = prefix_sum.index(prefix_sum[i] + target)\n            return nums[i:j]\n\n    return []\n\nnums = [1, 2, 3, 4, 5, 6]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the string s can be formed by concatenating n copies of a substring\"\"\"\n    if len(s) % n != 0:\n        return False\n    substring = s[:len(s) // n]\n    return substring * n == s\ndef g(n: int):\n    return 'abc' * n\nassert f(g(n=4), n=4)\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int):\n    return n\n\n# Example usage\nn = 6\nassert f(g(n)) == 8\n",
        "idx_generation": 109,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if string t is a subsequence of string s.\"\"\"\n    if len(t) > len(s):\n        return False\n    if t == \"\":\n        return True\n    if s[0] == t[0]:\n        return f(s[1:], t[1:])\n    else:\n        return f(s[1:], t)\ndef g() -> Tuple[str, str]:\n    s = \"programming\"\n    t = \"grin\"\n    return s, t\nassert f(*g())\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all even Fibonacci numbers less than n using recursion.\"\"\"\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n    def sum_even_fibonacci(n):\n        sum = 0\n        i = 1\n        fib = fibonacci(i)\n        while fib < n:\n            if fib % 2 == 0:\n                sum += fib\n            i += 1\n            fib = fibonacci(i)\n        return sum\n\n    return sum_even_fibonacci(n)\n\ndef g(n: int):\n    return (n,)\n\nn = 100\nassert f(*g(n)) == 44\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, target_sum: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find if there exists a path from the start node to the end node \n    where the sum of the weights of all edges in the path is equal to the target sum.\n    \"\"\"\n    stack = [(start, 0)]\n    while stack:\n        node, current_sum = stack.pop()\n        if node == end and current_sum == target_sum:\n            return True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] != 0:\n                stack.append((neighbor, current_sum + graph[node][neighbor]))\n    return False\n\ndef g():\n    graph = [[0, 1, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    target_sum = 4\n    return (graph, start, end, target_sum)\n\nassert f(*g())\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Any, Dict, List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> bool:\n    \"\"\"Check if a binary tree is symmetric, i.e., its left and right subtrees are mirror images of each other.\"\"\"\n    def is_mirror(left: TreeNode, right: TreeNode) -> bool:\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return left.val == right.val and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)\n    \n    if not root:\n        return True\n    return is_mirror(root.left, root.right)\n\ndef g():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n    return root\n\nassert f(g())\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list,\n    determine if there exists a path from a start node to an end node.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return {\n        1: [2, 3],\n        2: [4],\n        3: [5],\n        4: [],\n        5: [6],\n        6: [7],\n        7: [8],\n        8: []\n    }\n\nassert f(g(), 1, 8)\n",
        "idx_generation": 422,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of positive integers and a target sum, find a combination of numbers from the list that adds up to the target.\n    Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def find_combination(nums, target, i, combination):\n        if target == 0:\n            return True\n        if target < 0 or i >= len(nums):\n            return False\n        include = find_combination(nums, target - nums[i], i, combination + [nums[i]])\n        exclude = find_combination(nums, target, i + 1, combination)\n        if include or exclude:\n            return True\n        return False\n\n    return find_combination(nums, target, 0, [])\n\ndef g(nums=[2, 4, 6, 8, 10], target=20):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find all combinations of numbers from the input list that sum up to the target value.\"\"\"\n    def backtrack(remain, curr_combination, start):\n        if remain == 0:\n            result.append(list(curr_combination))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            curr_combination.append(nums[i])\n            backtrack(remain - nums[i], curr_combination, i)\n            curr_combination.pop()\n\n    result = []\n    backtrack(target, [], 0)\n    return result\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return (nums, target)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string s is a pangram (contains all the letters of the alphabet).\"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return all(c in s.lower() for c in alphabet)\ndef g(s='The quick brown fox jumps over the lazy dog'):\n    return s\nassert f(g())\n",
        "idx_generation": 83,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    Return True if such numbers exist, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the two numbers as a list.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 10\nassert f(g(arr, target), target)\n",
        "idx_generation": 44,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, remove all duplicates and return the result in ascending order using a queue.\"\"\"\n    queue = []\n    unique_nums = set(nums)\n    for num in unique_nums:\n        queue.append(num)\n    queue.sort()\n    return queue\ndef g():\n    return [4, 2, 6, 1, 4, 2, 3, 5, 6]\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Determine if the given matrix is a magic square, where the sum of each row, column, and diagonal is the same.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in matrix:\n            column_sum += row[col]\n        if column_sum != target_sum:\n            return False\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    return True\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\nassert f(g())\n",
        "idx_generation": 151,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='hello') -> bool:\n    \"\"\"Check if the string s can be transformed into the target string by rearranging its characters\"\"\"\n    return sorted(s) == sorted(target)\n\ndef g(target='hello'):\n    return 'lelho'\n\nassert f(g())\n",
        "idx_generation": 85,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence in the list.\n    An increasing subsequence is a sequence of numbers where each element is greater than the previous element.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums: List[int]):\n    return (nums,)\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nassert f(*g(nums)) == 4\n",
        "idx_generation": 308,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string, find the length of the longest substring without repeating characters.\"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    for end in range(len(s)):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        seen[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    return max_length\ndef g(s: str):\n    return s\ns = \"abcabcbb\"\nassert f(g(s)) == 3\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if there exists a valid arrangement of n queens on an n x n chessboard such that no two queens threaten each other.\"\"\"\n    def is_safe(board, row, col):\n        # Check if there is any queen in the same row or in the same diagonal\n        for i in range(col):\n            if board[row][i] == 1:\n                return False\n        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n            if board[i][j] == 1:\n                return False\n        for i, j in zip(range(row, n, 1), range(col, -1, -1)):\n            if board[i][j] == 1:\n                return False\n        return True\n\n    def backtrack(board, col):\n        if col == n:\n            return True\n        for row in range(n):\n            if is_safe(board, row, col):\n                board[row][col] = 1\n                if backtrack(board, col+1):\n                    return True\n                board[row][col] = 0\n        return False\n    \n    board = [[0] * n for _ in range(n)]\n    return backtrack(board, 0)\n\ndef g(n=4):\n    return n\n\nassert f(g())\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome after removing at most one character\"\"\"\n    def is_palindrome(s: str, left: int, right: int, removed: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if removed == 1:\n                    return False\n                return is_palindrome(s, left + 1, right, removed + 1) or is_palindrome(s, left, right - 1, removed + 1)\n            left += 1\n            right -= 1\n        return True\n    return is_palindrome(s, 0, len(s) - 1, 0)\ndef g():\n    return \"abca\"\nassert f(g())\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two numbers in the list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([3, 10, 5, 25, 2, 8])) == 28\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers `nums` and a target integer `target`, find the number of subsets of `nums` that sum up to the target.\n    Return the count of such subsets.\n    \"\"\"\n    n = len(nums)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return (nums, target)\nassert f(*g()) == 3\n",
        "idx_generation": 221,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there exists a path from start to end in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['E'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 336,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if the graph contains a cycle.\n\n    Example:\n    graph = [[0, 1, 0, 0],\n             [1, 0, 1, 1],\n             [0, 1, 0, 1],\n             [0, 1, 1, 0]]\n    Output: True\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 1.\n    \"\"\"\n    def has_cycle(node, visited, parent):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if has_cycle(neighbor, visited, node):\n                        return True\n                elif parent != neighbor:\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n    return False\n\n\ndef g(graph=[[0, 1, 0, 0],\n             [1, 0, 1, 1],\n             [0, 1, 0, 1],\n             [0, 1, 1, 0]]):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency matrix that contains a cycle.\n    \"\"\"\n    from random import randint\n\n    num_nodes = len(graph)\n    for i in range(num_nodes):\n        for j in range(i + 1, num_nodes):\n            if graph[i][j] == 0:\n                graph[i][j] = graph[j][i] = randint(0, 1)\n\n    return graph\n\n\nassert f(g())\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start node to end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [5], [], []]\n    return (graph, 0, 5)\n\nassert f(*g())\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if the given grid is a valid crossword puzzle.\n    A valid crossword puzzle has the same number of rows and columns, and contains only valid words.\n    \"\"\"\n    rows = len(grid)\n    if rows == 0:\n        return False\n    cols = len(grid[0])\n    if cols == 0 or rows != cols:\n        return False\n    \n    # Check if each row and column contains a valid word\n    for i in range(rows):\n        if not is_valid_word(grid[i]):\n            return False\n        col = [row[i] for row in grid]\n        if not is_valid_word(col):\n            return False\n            \n    return True\n\ndef is_valid_word(row: List[int]) -> bool:\n    \"\"\"Check if a given row or column contains a valid word.\n    A valid word consists of non-empty cells followed by empty cells.\n    \"\"\"\n    empty_cells = False\n    for cell in row:\n        if cell == 0:\n            empty_cells = True\n        elif empty_cells and cell != 0:\n            return False\n    return True\n\ndef g(n: int) -> List[List[int]]:\n    \"\"\"Generate a crossword puzzle grid with n rows and n columns.\n    The generated grid will contain random words and empty cells.\n    \"\"\"\n    grid = [[0] * n for _ in range(n)]\n    # TODO: Generate random words and fill the grid\n    return grid\n\nassert f(g(n=5))\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given positive integers n and k, compute the binomial coefficient C(n, k).\n    The binomial coefficient represents the number of ways to choose k items from a set of n items without repetition and without regard to the order of the items.\n    Return the computed binomial coefficient.\"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n - 1, k - 1) + f(n - 1, k)\ndef g(n: int, k: int) -> int:\n    \"\"\"\n    Return the positive integers n and k.\n    \"\"\"\n    return n, k\nassert f(*g(5, 2)) == 10\n",
        "idx_generation": 352,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, lst=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew']) -> bool:\n    \"\"\"Check if the given string can be formed by concatenating the elements from the list, in any order.\"\"\"\n    def backtrack(curr):\n        if ''.join(curr) == s:\n            return True\n        for i in range(len(lst)):\n            if not visited[i]:\n                visited[i] = True\n                curr.append(lst[i])\n                if backtrack(curr):\n                    return True\n                curr.pop()\n                visited[i] = False\n        return False\n\n    visited = [False] * len(lst)\n    return backtrack([])\n\ndef g(lst=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew']):\n    return ''.join(lst)\nassert f(g())\n",
        "idx_generation": 114,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are any two integers in the array\nwhose sum is equal to the target value.\nExample:\narr = [1, 2, 4, 5, 7, 8]\ntarget = 9\nOutput:\nTrue\nExplanation: The integers 1 and 8 sum up to 9.\nYou need to implement the function f() and provide a matching implementation for g() which returns the input values\nfor arr and target.\n\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 2, 4, 5, 7, 8]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 45,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers, sort the array in ascending order using the bubble sort algorithm.\n    Sample Input:\n    arr = [5, 2, 7, 1, 3]\n    Sample Output:\n    [1, 2, 3, 5, 7]\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef g(arr=[5, 2, 7, 1, 3]):\n    return arr\n\nassert f(g()) == [1, 2, 3, 5, 7]\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of nums that sums up to the target value.\"\"\"\n    def dfs(idx: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if idx == len(nums) or current_sum > target:\n            return False\n        if dfs(idx + 1, current_sum + nums[idx]):\n            return True\n        return dfs(idx + 1, current_sum)\n\n    return dfs(0, 0)\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [2, 4, 6, 8, 10]\ntarget = 14\nassert f(*g(nums, target))\n",
        "idx_generation": 153,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if a string s is an anagram of string t.\"\"\"\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\ndef g(s=\"listen\", t=\"silent\"):\n    return (s, t)\nassert f(*g())\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a permutation of the numbers from 1 to N, where N is the length of the list.\"\"\"\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    if actual_sum != expected_sum:\n        return False\n    num_set = set(nums)\n    if len(num_set) != n:\n        return False\n    return True\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nassert f(g([1, 3, 4, 2])) == True\n",
        "idx_generation": 316,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern='ABC') -> int:\n    \"\"\"Count the number of times a pattern occurs in a given string.\"\"\"\n    count = 0\n    for i in range(len(s)-len(pattern)+1):\n        if s[i:i+len(pattern)] == pattern:\n            count += 1\n    return count\n\ndef g(s='ABCDABCEABCFABC'):\n    return s\n\nassert f(g()) == 4\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=10) -> bool:\n    \"\"\"Find if there exists a path in the grid that adds up to the target\"\"\"\n    def dfs(i, j, curr_sum):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return False\n        curr_sum += grid[i][j]\n        if curr_sum == target:\n            return True\n        return dfs(i + 1, j, curr_sum) or dfs(i, j + 1, curr_sum)\n    \n    return dfs(0, 0, 0)\ndef g(target=10):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g())\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, p: str) -> bool:\n    \"\"\"Given a string s and a pattern p, determine if s matches the pattern.\nThe pattern p consists of lowercase English letters and '.' and '*'.\n'.' matches any single character, while '*' matches zero or more of the preceding element.\nReturn True if s matches the pattern, False otherwise.\"\"\"\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[0][0] = True\n    for j in range(1, len(p) + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    for i in range(1, len(s) + 1):\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2]\n                if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j]\n    return dp[len(s)][len(p)]\ndef g(s: str, p: str):\n    return (s, p)\ns = 'aab'\np = 'c*a*b'\nassert f(*g(s, p))\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of bits set to 1 in its binary representation.\nArgs:\n    n: A positive integer.\nReturns:\n    The number of bits set to 1 in the binary representation of n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    \"\"\"Returns a positive integer.\"\"\"\n    return 15\n\nassert f(g()) == 4\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, determine if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of the values along the path is divisible by 3. You can only move right or down.\n\n    Sample input:\n    [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\n\n    Sample output:\n    True\n\n    Explanation: The path (1 -> 4 -> 7 -> 8 -> 9) has a sum of 29, which is divisible by 3.\n    \"\"\"\n\n    def dfs(row: int, col: int, current_sum: int) -> bool:\n        # Base case: If we reach the bottom-right corner, check if the sum is divisible by 3\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return current_sum % 3 == 0\n\n        # Recursive case: Move right and down, and check if the sum is divisible by 3\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, current_sum + matrix[row][col + 1]):\n            return True\n        if row < len(matrix) - 1 and dfs(row + 1, col, current_sum + matrix[row + 1][col]):\n            return True\n\n        return False\n\n    return dfs(0, 0, matrix[0][0])\n\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\nassert f(g())\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_matrix: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, determine if there exists a path from the first vertex to the last vertex. Return True if a path exists, False otherwise.\"\"\"\n    num_vertices = len(adjacency_matrix)\n    visited = [False] * num_vertices\n    stack = [0]  # Start with the first vertex\n    \n    while stack:\n        current_vertex = stack.pop()\n        if current_vertex == num_vertices - 1:\n            return True\n        \n        visited[current_vertex] = True\n        \n        for neighbor, edge in enumerate(adjacency_matrix[current_vertex]):\n            if edge == 1 and not visited[neighbor]:\n                stack.append(neighbor)\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate an adjacency matrix representing a directed graph with a path from the first vertex to the last vertex. Return the adjacency matrix.\"\"\"\n    return [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n\nassert f(g())\n",
        "idx_generation": 341,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Check if a directed graph contains a cycle.\"\"\"\n    visited = set()\n    recursion_stack = set()\n\n    def is_cyclic(node):\n        visited.add(node)\n        recursion_stack.add(node)\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if is_cyclic(neighbor):\n                    return True\n            elif neighbor in recursion_stack:\n                return True\n\n        recursion_stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if is_cyclic(node):\n                return True\n\n    return False\n\ndef g():\n    return {1: [2], 2: [3], 3: [4], 4: [2]}\n\nassert f(g()) == True\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = 1\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] if grid[i][0] != 1 else 0\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] if grid[0][j] != 1 else 0\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    return (grid,)\n\nassert f(*g()) == 2\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"Generate all combinations of length k from a list of integers from 1 to n.\"\"\"\n    def backtrack(start, path):\n        if len(path) == k:\n            return [path]\n        res = []\n        for i in range(start, n + 1):\n            res += backtrack(i + 1, path + [i])\n        return res\n    return backtrack(1, [])\ndef g(n=4, k=2):\n    return (n, k)\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, check if there is a combination of numbers from the list that adds up to the target.\n    Return True if such combination exists, otherwise return False.\"\"\"\n    def backtrack(curr_sum, start):\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(curr_sum + nums[i], i + 1):\n                return True\n        return False\n    return backtrack(0, 0)\ndef g():\n    return ([2, 4, 6, 8], 10)\nassert f(*g())\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(s: str, words=['hello', 'world', 'python'], k=2) -> bool:\n    \"\"\"Given a string s, find a combination of k words from the list words such that concatenating them forms s.\n    Each word can be used only once in the combination.\"\"\"\n    combinations = list(itertools.combinations(words, k))\n    for combination in combinations:\n        if ''.join(combination) == s:\n            return True\n    return False\n\ndef g(words=['hello', 'world', 'python'], k=2):\n    return ''.join(words[:k])\n\nassert f(g())\n",
        "idx_generation": 115,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, return the index of the target if it is found in the list.\n    If the target is not found, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target value.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        if arr[low] + arr[high] == target:\n            return True\n        elif arr[low] + arr[high] < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not in the list, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 3)) == 2\n",
        "idx_generation": 153,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Check if the binary representation of a given number s has exactly n consecutive 0s.\"\"\"\n    binary = bin(int(s))[2:]\n    return '0' * n in binary\ndef g(n=4):\n    return '9' * n\nassert f(g())\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of numbers in the given list that sum up to the target.\"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        include = subset_sum(nums, target, index + 1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, curr_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 12\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, sub_str='abc', count=2) -> bool:\n    \"\"\"Find a string that contains exactly count occurrences of sub_str, with no other characters in between\"\"\"\n    return s.count(sub_str) == count and sub_str * count in s\ndef g(sub_str='abc', count=2):\n    return sub_str * count\nassert f(g())\n",
        "idx_generation": 407,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of numbers in a path from the top-left corner to the bottom-right corner in a grid.\n    You can only move down or right, and each cell contains either a positive or negative integer.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def helper(i: int, j: int) -> int:\n        if i == rows - 1 and j == cols - 1:\n            return grid[i][j]\n        elif i == rows - 1:\n            return grid[i][j] + helper(i, j + 1)\n        elif j == cols - 1:\n            return grid[i][j] + helper(i + 1, j)\n        else:\n            return grid[i][j] + max(helper(i + 1, j), helper(i, j + 1))\n    \n    return helper(0, 0)\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 29\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> int:\n    \"\"\"Find the minimum number of operations required to convert s1 to s2.\"\"\"\n    if len(s1) == 0:\n        return len(s2)\n    if len(s2) == 0:\n        return len(s1)\n    if s1[0] == s2[0]:\n        return f(s1[1:], s2[1:])\n    else:\n        insert = 1 + f(s1, s2[1:])\n        delete = 1 + f(s1[1:], s2)\n        replace = 1 + f(s1[1:], s2[1:])\n        return min(insert, delete, replace)\n\ndef g(s1: str, s2: str):\n    return (s1, s2)\n\nassert f(*g('kitten', 'sitting')) == 3\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if the given number is a power of two\"\"\"\n    if num <= 0:\n        return False\n    return (num & (num - 1)) == 0\n\ndef g(num=16):\n    return num\n\nassert f(g())\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"Find if there exists a subset of size k in the given list of integers that sums up to the target\"\"\"\n    def subset_sum(nums, k, target):\n        if target == 0 and k == 0:\n            return True\n        if target != 0 and k == 0:\n            return False\n        if len(nums) == 0:\n            return False\n        \n        if nums[-1] > target:\n            return subset_sum(nums[:-1], k, target)\n        else:\n            return subset_sum(nums[:-1], k-1, target-nums[-1]) or subset_sum(nums[:-1], k, target)\n\n    nums = [1, 2, 3, 4, 5]\n    return subset_sum(nums, k, target)\n\ndef g() -> Tuple[int, int, int]:\n    return (5, 3, 9)\n\nassert f(*g())\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Check if there exists a path from the start to the end in the grid, considering only up, down, left, and right movements.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    stack = [start]\n    while stack:\n        i, j = stack.pop()\n        visited[i][j] = True\n        if (i, j) == end:\n            return True\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] != 1 and not visited[ni][nj]:\n                stack.append((ni, nj))\n    return False\n\ndef g():\n    return ([[0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]], (0, 0), (4, 4))\n\nassert f(*g())",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum path from the top-left corner to the bottom-right corner. You can only move right or down.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    graph = [[1, 2], [0, 3], [0, 3], [1, 2, 4], [3]]\n    start = 0\n    end = 4\n    return (graph, start, end)\n\nassert f(*g())\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Calculate the number of ways to choose m items from a set of n items, where order does not matter.\"\"\"\n    if m > n:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(m):\n        numerator *= n - i\n        denominator *= i + 1\n    return numerator // denominator\n\ndef g():\n    return 6, 3\n\nassert f(*g()) == 20\n",
        "idx_generation": 390,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs. You can climb 1 or 2 steps at a time.\"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g():\n    n = 5\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(s: str, patterns=['abc', 'def', 'ghi'], n=3) -> bool:\n    \"\"\"Given a string s and a list of patterns, find a sequence of n patterns from the list such that concatenating them\n    forms the string s.\"\"\"\n    combinations = list(itertools.combinations(patterns, n))\n    for combination in combinations:\n        if ''.join(combination) == s:\n            return True\n    return False\n\ndef g(patterns=['abc', 'def', 'ghi'], n=3):\n    return ''.join(patterns[:n])\n\nassert f(g())\n",
        "idx_generation": 115,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, return True if there exists a pair of elements in the list that sum up to the target value.\n    Otherwise, return False.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[4, 2, 7, 1, 6], target=8):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given array in descending order using bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] < arr[j+1] :\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\ndef g(arr: List[int]):\n    return arr\narr = [64, 34, 25, 12, 22, 11, 90]\nassert f(g(arr)) == [90, 64, 34, 25, 22, 12, 11]\n",
        "idx_generation": 407,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list whose elements sum up to the target value.\n    Return True if such subset exists, and False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([2, 4, 6, 8], 10)) == True\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a palindrome.\"\"\"\n    return arr == arr[::-1]\ndef g() -> List[int]:\n    return [1, 2, 3, 2, 1]\nassert f(g()) == True\n",
        "idx_generation": 107,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, a=3, b=7) -> bool:\n    \"\"\"Determine if n is a prime number and its binary representation has a 1 at the a-th bit and a 0 at the b-th bit\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    binary = bin(n)[2:]  # Convert n to binary representation\n    return binary[a - 1] == '1' and binary[b - 1] == '0'\ndef g(a=3, b=7):\n    n = (2 ** (a - 1)) * (2 ** (b - 1))  # Find a number with a 1 at the a-th bit and a 0 at the b-th bit\n    while not f(n):\n        n += 1\n    return n\nassert f(g())\n",
        "idx_generation": 330,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"Given a list of words and a target string, find all words that can be formed by rearranging the letters in the target string.\"\"\"\n    target_count = {}\n    for char in target:\n        if char in target_count:\n            target_count[char] += 1\n        else:\n            target_count[char] = 1\n    result = []\n    for word in words:\n        word_count = {}\n        for char in word:\n            if char in word_count:\n                word_count[char] += 1\n            else:\n                word_count[char] = 1\n        if word_count == target_count:\n            result.append(word)\n    return result\ndef g():\n    return [\"cat\", \"act\", \"tac\", \"dog\", \"god\"]\nassert f(g(), \"act\") == [\"cat\", \"act\", \"tac\"]\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if a number n is a power of k using recursion.\"\"\"\n    if n == 1:\n        return True\n    if n % k != 0:\n        return False\n    return f(n // k, k)\ndef g(n=16, k=2):\n    return n, k\nassert f(*g())\n",
        "idx_generation": 118,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Remove duplicates from the given list of numbers using bit manipulation\"\"\"\n    unique_nums = []\n    seen = set()\n    for num in nums:\n        if num not in seen:\n            unique_nums.append(num)\n            seen.add(num)\n    return unique_nums\ndef g():\n    return ([1, 2, 2, 3, 4, 4, 5, 5],)\nassert f(*g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 186,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of numbers, return True if there exists a path from the top-left corner to the bottom-right corner, where the sum of the numbers along the path is a prime number.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    def dfs(row, col, current_sum):\n        if row < 0 or row >= rows or col < 0 or col >= cols:\n            return False\n        if visited[row][col]:\n            return False\n        \n        current_sum += grid[row][col]\n        \n        if row == rows - 1 and col == cols - 1:\n            return is_prime(current_sum)\n        \n        visited[row][col] = True\n        \n        if dfs(row + 1, col, current_sum):\n            return True\n        if dfs(row, col + 1, current_sum):\n            return True\n        \n        visited[row][col] = False\n        \n        return False\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    return dfs(0, 0, 0)\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 229,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph and two nodes, determine if there is a path from the start node to the end node.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current = stack.pop()\n        visited.add(current)\n        if current == end:\n            return True\n        neighbors = graph.get(current, [])\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': [],\n        'F': ['G'],\n        'G': []\n    }\n    return graph, 'A', 'G'\nassert f(*g())\n",
        "idx_generation": 354,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid represented as a 2D list, find the shortest path from the top-left corner to the bottom-right corner by only moving down or right.\nArgs:\n    grid: The grid represented as a 2D list where each cell contains a non-negative integer representing the cost to move to that cell.\nReturns:\n    The minimum cost to reach the bottom-right corner.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"\n    Returns a sample grid represented as a 2D list.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed acyclic graph represented as an adjacency list and two nodes 'start' and 'end', determine if there exists a path from 'start' to 'end'.\nReturn True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g(graph: List[List[int]], start: int, end: int):\n    return (graph, start, end)\ngraph = [[1, 2], [3, 4], [5, 6], [], [], [], [7, 8], [], []]\nstart = 0\nend = 8\nassert f(*g(graph, start, end))\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given a list of integers and a target integer, return all unique combinations of numbers that sum up to the target.\"\"\"\n    def backtrack(curr_sum, start, path):\n        if curr_sum == target:\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            if curr_sum + nums[i] > target:\n                continue\n            path.append(nums[i])\n            backtrack(curr_sum + nums[i], i, path)\n            path.pop()\n\n    result = []\n    nums.sort()\n    backtrack(0, 0, [])\n    return result\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [2, 3, 6, 7]\ntarget = 7\nassert f(*g(nums, target)) == [[2, 2, 3], [7]]\n",
        "idx_generation": 420,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, num_list: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a combination of k numbers from the given list that adds up to the target sum\"\"\"\n    def combination_sum(numbers, target_sum, current_sum, current_index, combination_size):\n        if current_sum == target_sum and combination_size == k:\n            return True\n        if current_sum > target_sum or combination_size > k or current_index >= len(numbers):\n            return False\n        if combination_sum(numbers, target_sum, current_sum, current_index + 1, combination_size):\n            return True\n        if combination_sum(numbers, target_sum, current_sum + numbers[current_index], current_index + 1, combination_size + 1):\n            return True\n        return False\n    \n    return combination_sum(num_list, target, 0, 0, 0)\n\ndef g(n=5, k=3, num_list=[1, 2, 3, 4, 5], target=9):\n    return (n, k, num_list, target)\n\nassert f(*g())\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the vowels in the string.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    s = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i].lower() in vowels and s[j].lower() in vowels:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        elif s[i].lower() in vowels:\n            j -= 1\n        elif s[j].lower() in vowels:\n            i += 1\n        else:\n            i += 1\n            j -= 1\n    return ''.join(s)\n\ndef g():\n    return 'hello world'\n\nassert f(g()) == 'hollo werld'\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there are two numbers in the array that sum up to the target.\"\"\"\n    (low, high) = (0, len(arr) - 1)\n    while low < high:\n        current_sum = arr[low] + arr[high]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            low += 1\n        else:\n            high -= 1\n    return False\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9], 10)\nassert f(*g()) == True\n",
        "idx_generation": 53,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that adds up to the target\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 4, 2, 7, 9], target=10):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers in non-decreasing order, find the index of the target element using binary search.\"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n    return binary_search(nums, target, 0, len(nums) - 1)\ndef g():\n    return ([1, 3, 5, 7, 9, 11, 13, 15, 17], 11)\nassert f(*g()) == 5\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='hello') -> bool:\n    \"\"\"Check if the given string is an anagram of the target string.\"\"\"\n    sorted_s = sorted(s.lower())\n    sorted_target = sorted(target.lower())\n    return sorted_s == sorted_target\n\ndef g(target='hello'):\n    return 'llohe'\n\nassert f(g())\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\ndef g(n: int):\n    return (n,)\nn = 6\nassert f(*g(n)) == 8\n",
        "idx_generation": 332,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, determine if it is possible to rearrange the characters of s such that no two adjacent characters are the same, and the resulting string has at least k distinct characters.\"\"\"\n    from collections import Counter\n    count = Counter(s)\n    max_freq = max(count.values())\n    return len(s) >= k and len(count) - 1 >= k - 1 and max_freq <= (len(s) - k + 1)\ndef g(s=\"aabbc\", k=3):\n    return (s, k)\nassert f(*g())\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray in the given list that sums up to the target value.\"\"\"\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n    def helper(start: int, end: int) -> bool:\n        if prefix_sum[end] - prefix_sum[start] == target:\n            return True\n        if start == end:\n            return False\n        return helper(start, end - 1) or helper(start + 1, end)\n    return helper(0, len(nums))\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g(), 9)\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Given a positive integer, count the number of bits that are set to 1 in its binary representation.\nReturn the count.\"\"\"\n    count = 0\n    while num > 0:\n        count += num & 1\n        num >>= 1\n    return count\ndef g(num: int):\n    return num\nassert f(g(10)) == 2\n",
        "idx_generation": 186,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the integers that sums up to the target.\"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        include = subset_sum(nums, target, index + 1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, curr_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums: List[int]=[1, 2, 3, 4, 5], target: int=9):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 231,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency list and two nodes start and end, determine if there is a path from start to end.\n    Return True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g(graph: List[List[int]], start: int, end: int):\n    return (graph, start, end)\ngraph = [[1, 2], [0, 3, 4], [0, 5, 6], [1], [1], [2, 7, 8], [2, 9], [5], [5], [6]]\nstart = 0\nend = 9\nassert f(*g(graph, start, end))\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Determine if there is a valid path from the top-left corner to the bottom-right corner in the grid.\"\"\"\n\n    def dfs(row: int, col: int) -> bool:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 1:\n            return False\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return True\n        grid[row][col] = 1\n        return dfs(row + 1, col) or dfs(row, col + 1) or dfs(row - 1, col) or dfs(row, col - 1)\n\n    if not grid or not grid[0]:\n        return False\n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]):\n    return (grid,)\n\nassert f(*g([[0, 0, 0], [0, 1, 0], [0, 0, 0]])) == True\n",
        "idx_generation": 255,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a maze represented as a 2D matrix of integers, determine if there is a path from the start cell to the end cell.\n    - A value of 0 represents an empty cell.\n    - A value of 1 represents a blocked cell that cannot be traversed.\n    - The start cell is represented by the value 2.\n    - The end cell is represented by the value 3.\n    You can move in four directions: up, down, left, and right.\n    Return True if a path exists, otherwise return False.\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    def dfs(row: int, col: int) -> bool:\n        if row < 0 or row >= rows or col < 0 or col >= cols or maze[row][col] == 1 or visited[row][col]:\n            return False\n\n        visited[row][col] = True\n\n        if maze[row][col] == 3:\n            return True\n\n        return (\n            dfs(row - 1, col)  # up\n            or dfs(row + 1, col)  # down\n            or dfs(row, col - 1)  # left\n            or dfs(row, col + 1)  # right\n        )\n\n    start_row, start_col = start\n    return dfs(start_row, start_col)\n\n\ndef g():\n    \"\"\"\n    Generate a maze where there is a path from the start cell to the end cell.\n    \"\"\"\n    maze = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1, 0],\n        [0, 1, 0, 0, 0, 3],\n        [0, 0, 0, 1, 0, 0],\n    ]\n    start = (0, 0)\n    end = (4, 5)\n    return maze, start, end\n\n\nassert f(*g()) == True\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> List[str]:\n    \"\"\"Find all possible permutations of a string\"\"\"\n    perms = permutations(s)\n    return [''.join(perm) for perm in perms]\n\ndef g(s: str) -> str:\n    return s\n\ns = \"abc\"\nassert f(g(s)) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the number of unique paths to reach the bottom-right corner of an n x n grid, moving only right or down.\"\"\"\n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        else:\n            return x * factorial(x-1)\n    \n    return factorial(2*n) // (factorial(n) ** 2)\n\ndef g():\n    return 3\n\nassert f(g()) == 20\n",
        "idx_generation": 385,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of occurrences of each character in a string and return the count of the character with the maximum occurrence.\"\"\"\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    max_count = max(char_count.values())\n    return max_count\n\ndef g(s=\"abracadabra\"):\n    return s\n\nassert f(g()) == 5\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists two numbers in the list that add up to the target number.\n    \n    Args:\n    - arr: A sorted list of integers.\n    - target: The target number.\n    \n    Returns:\n    - A boolean value indicating whether there exist two numbers in the list that add up to the target number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers that add up to the target number.\n    \n    Args:\n    - target: The target number.\n    \n    Returns:\n    - A sorted list of integers.\n    \"\"\"\n    return [i for i in range(target + 1)]\n\nassert f(g(10), 10)\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort a list of numbers using bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    return [9, 3, 6, 2, 8, 1, 5]\n\nassert f(g()) == [1, 2, 3, 5, 6, 8, 9]\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exists a pair of numbers in the array whose sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    i, j = 0, len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == target:\n            return True\n        elif arr[i] + arr[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\ndef g():\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 16\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in a sorted list that add up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([-2, 0, 3, 5, 7, 9, 11], 8)\n\nassert f(*g())\n",
        "idx_generation": 128,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"Generate the first n numbers in the Fibonacci sequence.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\n\ndef g() -> int:\n    \"\"\"Return the value of n\"\"\"\n    return 7\n\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8]\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings=['abc', 'def', 'ghi', 'jkl']) -> bool:\n    \"\"\"Check if the given string contains all the substrings in order\"\"\"\n    indices = [s.index(sub) for sub in substrings if sub in s]\n    return all(indices[i] < indices[i+1] for i in range(len(indices)-1))\ndef g(substrings=['abc', 'def', 'ghi', 'jkl']):\n    return ''.join(substrings)\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the n-th Fibonacci number using recursion.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g():\n    return (5,)\n\nassert f(*g()) == 5\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two different elements in the array.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    arr = [3, 10, 5, 25, 2, 8]\n    return arr\n\nassert f(g()) == 28\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer 'n', determine if it is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n /= 2\n    return n == 1\n\ndef g():\n    n = 1\n    while True:\n        yield n\n        n *= 2\n\nassert f(next(g()))\n",
        "idx_generation": 258,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\nfrom collections import deque\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency list, a start node, and a target node,\n    determine if there is a path from the start node to the target node using at most 3 edges.\n    Return True if a path exists, False otherwise.\"\"\"\n    queue = deque([(start, 0)])\n    while queue:\n        node, distance = queue.popleft()\n        if distance > 3:\n            return False\n        if node == target:\n            return True\n        for neighbor in graph[node]:\n            queue.append((neighbor, distance + 1))\n    return False\ndef g(graph: List[List[int]], start: int, target: int):\n    return (graph, start, target)\ngraph = [[1, 2], [0, 3, 4], [0, 5, 6], [1], [1], [2, 7], [2], [5]]\nstart = 0\ntarget = 7\nassert f(*g(graph, start, target))\n",
        "idx_generation": 397,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Given a directed graph, find if there exists a cycle in it.\"\"\"\n    visited = set()\n    stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        stack.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in stack:\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g() -> Dict[int, List[int]]:\n    \"\"\"Generate a random directed graph.\"\"\"\n    graph = {\n        1: [2, 3],\n        2: [3],\n        3: [4],\n        4: [2]\n    }\n    return graph\n\nassert f(g())\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there exists a path from the start node to the end node in the given directed graph.\"\"\"\n    def dfs(graph, start, end, visited):\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    return dfs(graph, start, end, visited)\n\ndef g():\n    graph = [[1, 2], [2], [3], []]\n    start = 0\n    end = 3\n    return (graph, start, end)\n\nassert f(*g())\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a combination of k numbers in the list that add up to the target.\n    Return True if such a combination exists, False otherwise.\"\"\"\n    combinations = list(itertools.combinations(nums, k))\n    for combination in combinations:\n        if sum(combination) == target:\n            return True\n    return False\n\ndef g(nums: List[int], target: int, k: int):\n    return (nums, target, k)\n\nassert f(*g([1, 2, 3, 4, 5], 9, 3))\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to climb n stairs, if you can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    prev = 1\n    curr = 1\n    for _ in range(2, n + 1):\n        temp = curr\n        curr += prev\n        prev = temp\n    return curr\ndef g():\n    return 5\nassert f(g()) == 8\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(s: str, substrings=['abc', 'def', 'ghi']) -> bool:\n    \"\"\"Check if there exists a permutation of the substrings that can be concatenated to form s\"\"\"\n    perms = list(itertools.permutations(substrings))\n    for perm in perms:\n        concat = ''.join(perm)\n        if concat == s:\n            return True\n    return False\n\ndef g(substrings=['abc', 'def', 'ghi']):\n    return ''.join(substrings)\n\nassert f(g())\n",
        "idx_generation": 167,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, use binary search to determine if the target value is present in the array.\n\"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    target = 12\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 57,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array arr of positive integers, find the length of the longest increasing subsequence in the array.\n    An increasing subsequence is a subsequence in which the elements are in increasing order, but not necessarily contiguous.\"\"\"\n    \n    n = len(arr)\n    dp = [1] * n  # dp[i] stores the length of the longest increasing subsequence ending at index i\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Given an array arr of positive integers, return the longest increasing subsequence in the array.\n    An increasing subsequence is a subsequence in which the elements are in increasing order, but not necessarily contiguous.\"\"\"\n    \n    n = len(arr)\n    dp = [1] * n  # dp[i] stores the length of the longest increasing subsequence ending at index i\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    max_length = max(dp)\n    max_index = dp.index(max_length)\n    \n    subsequence = [arr[max_index]]\n    for i in range(max_index - 1, -1, -1):\n        if arr[i] < arr[max_index] and dp[i] == dp[max_index] - 1:\n            subsequence.append(arr[i])\n            max_index = i\n    \n    return subsequence[::-1]\n\nassert f(g([1, 3, 2, 4, 3, 5, 4, 6, 5, 7])) == 6\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Rearrange the characters in the string to form the lexicographically smallest string possible\n    by swapping any two characters at most k times.\"\"\"\n    char_counts = {}\n    for char in s:\n        if char not in char_counts:\n            char_counts[char] = 0\n        char_counts[char] += 1\n    \n    sorted_chars = sorted(char_counts.keys())\n    result = [''] * len(s)\n    current_index = 0\n    \n    while current_index < len(s):\n        for char in sorted_chars:\n            if char_counts[char] == 0:\n                continue\n            if char == s[current_index]:\n                result[current_index] = char\n                current_index += 1\n                char_counts[char] -= 1\n                break\n            else:\n                num_swaps = 0\n                for i in range(current_index+1, len(s)):\n                    if s[i] == char:\n                        if num_swaps < k:\n                            result[current_index] = char\n                            result[i] = s[current_index]\n                            current_index += 1\n                            char_counts[char] -= 1\n                            break\n                        else:\n                            return \"\"\n                    num_swaps += 1\n    \n    return ''.join(result)\n\ndef g():\n    return ('aabbcc', 2)\n\nassert f(*g()) == 'aabbcc'\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of the first n Fibonacci numbers.\"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 0:\n            return 0\n        if n == 1:\n            return 1\n        return fibonacci(n-1) + fibonacci(n-2)\n    \n    sum_fibonacci = 0\n    for i in range(1, n+1):\n        sum_fibonacci += fibonacci(i)\n    return sum_fibonacci\n\ndef g(n: int):\n    return n\n\nn = 5\nassert f(g(n)) == 12\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Find all anagrams in the given list of words.\"\"\"\n    anagram_groups = []\n    word_map = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in word_map:\n            word_map[sorted_word].append(word)\n        else:\n            word_map[sorted_word] = [word]\n    \n    for sorted_word, anagrams in word_map.items():\n        if len(anagrams) > 1:\n            anagram_groups.append(anagrams)\n    \n    return anagram_groups\n\ndef g() -> List[str]:\n    return [\"cat\", \"dog\", \"tac\", \"god\", \"act\", \"good\"]\n\nassert f(g()) == [['cat', 'tac', 'act'], ['dog', 'god']]\n",
        "idx_generation": 460,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\"\"\"\n    if not grid or not grid[0]:\n        return False\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1] > 0\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"Count the number of set bits in a binary representation of a given integer.\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g():\n    return 23\n\nassert f(g()) == 4\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of numbers that add up to the target.\nArgs:\n    nums: A list of integers.\n    target: The target value.\nReturns:\n    True if there exists a subset of numbers that add up to the target, False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers and a target value.\n    \"\"\"\n    return ([2, 3, 7, 8, 10], 11)\n\nassert f(*g()) == True\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if there is a path from\n    a given start node to a target node using Depth First Search (DFS).\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n\n        if node == target:\n            return True\n\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representation of a directed graph.\n    \"\"\"\n    return [[1, 2], [2], [3], [4, 5], [], []]\n\nassert f(g(), 0, 5) == True\n",
        "idx_generation": 402,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given a number of nodes and a list of edges in a graph, determine the number of connected components.\n    \"\"\"\n    def dfs(node: int, visited: List[bool], adjacency_list: List[List[int]]) -> None:\n        visited[node] = True\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, adjacency_list)\n    \n    adjacency_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    \n    visited = [False] * n\n    components = 0\n    for node in range(n):\n        if not visited[node]:\n            dfs(node, visited, adjacency_list)\n            components += 1\n    \n    return components\n\ndef g(n=6, edges=[(0, 1), (1, 2), (3, 4), (4, 5)]):\n    return (n, edges)\n\nassert f(*g()) == 2\n",
        "idx_generation": 258,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, determine if there exists a path from 'start' to 'end'\n    with at most 'k' edges.\n    Args:\n        graph: The directed graph represented as a dictionary.\n        start: The starting node.\n        end: The ending node.\n        k: The maximum number of edges allowed in the path.\n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    stack = [(start, 0)]\n    while stack:\n        node, edges = stack.pop()\n        if node == end and edges <= k:\n            return True\n        if edges < k:\n            stack.extend((neighbor, edges + 1) for neighbor in graph.get(node, []))\n    return False\n\ndef g(graph={'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': []}, start='A', end='D', k=2):\n    return (graph, start, end, k)\n\nassert f(*g())\n",
        "idx_generation": 467,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Count the number of unique ways to climb to the top of a staircase with n steps, taking either 1 or k steps at a time.\"\"\"\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    counts = [0] * (n + 1)\n    counts[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                counts[i] += counts[i - j]\n    return counts[n]\ndef g():\n    \"\"\"\n    Returns the number of steps and the maximum number of steps that can be taken at a time.\n    \"\"\"\n    return 5, 2\nassert f(*g()) == 8\n",
        "idx_generation": 401,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string1: str, string2: str) -> bool:\n    \"\"\"Check if the two strings are isomorphic.\"\"\"\n    if len(string1) != len(string2):\n        return False\n    mapping = {}\n    mapped_chars = set()\n    for c1, c2 in zip(string1, string2):\n        if c1 in mapping:\n            if mapping[c1] != c2:\n                return False\n        else:\n            if c2 in mapped_chars:\n                return False\n            mapping[c1] = c2\n            mapped_chars.add(c2)\n    return True\n\ndef g() -> Tuple[str, str]:\n    string1 = 'paper'\n    string2 = 'title'\n    return (string1, string2)\n\nassert f(*g())\n",
        "idx_generation": 204,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    def helper(arr, target, start, end):\n        if start >= end:\n            return False\n        if arr[start] + arr[end] == target:\n            return True\n        elif arr[start] + arr[end] < target:\n            return helper(arr, target, start+1, end)\n        else:\n            return helper(arr, target, start, end-1)\n    return helper(arr, target, 0, len(arr)-1)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 58,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers arr and a target integer, determine if there are two numbers in arr that add up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[1, 2, 3, 4, 5], target=8):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\"\"\"\n    s1_sorted = sorted(s1)\n    s2_sorted = sorted(s2)\n    return s1_sorted == s2_sorted\n\ndef g():\n    return ('listen', 'silent')\n\nassert f(*g())\n",
        "idx_generation": 152,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find a combination of numbers that add up to the target using the fewest possible elements.\nEach number in the list can only be used once in a combination.\"\"\"\n    def backtrack(nums, target, start, current, result):\n        if target == 0:\n            result.append(list(current))\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(nums[:i] + nums[i + 1:], target - nums[i], i, current, result)\n            current.pop()\n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return len(result[0]) if result else -1\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\nnums = [1, 2, 3, 4]\ntarget = 5\nassert f(g(nums, target), target) == 2\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the list that sum up to the target value and return their indices.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums\n\nassert f(g(), target=9) == [0, 1]\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if the target sum can be achieved by combining elements from the array\"\"\"\n    def helper(i: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if i == len(arr):\n            return False\n        return helper(i + 1, curr_sum + arr[i]) or helper(i + 1, curr_sum)\n\n    return helper(0, 0)\n\ndef g() -> tuple:\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(a: int, b: int) -> int:\n    \"\"\"Given two integers a and b, calculate the sum of their binary XOR and binary AND values.\"\"\"\n    xor = a ^ b\n    and_ = a & b\n    return bin(xor)[2:].count('1') + bin(and_)[2:].count('1')\ndef g(a=5, b=3):\n    return (a, b)\nassert f(*g()) == 3\n",
        "idx_generation": 210,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers and a target number, determine if it is possible to obtain the target number by performing addition, subtraction, multiplication, or division on the elements of the array. Each element can be used exactly once.\"\"\"\n    def solve(index, curr_sum):\n        if index == len(arr):\n            return curr_sum == target\n        if solve(index + 1, curr_sum + arr[index]):\n            return True\n        if solve(index + 1, curr_sum - arr[index]):\n            return True\n        if solve(index + 1, curr_sum * arr[index]):\n            return True\n        if curr_sum % arr[index] == 0 and solve(index + 1, curr_sum // arr[index]):\n            return True\n        return False\n    return solve(0, 0)\ndef g(arr=[1, 2, 3, 4], target=10):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(graph: dict, start='A', end='E') -> bool:\n    \"\"\"Determine if there is a path from start to end in a directed graph\"\"\"\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            if node in graph:\n                queue.extend(graph[node])\n    return False\ndef g():\n    return ({'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F']}, 'A', 'E')\nassert f(*g())\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path\n    from the start node to the end node.\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node: int) -> bool:\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g():\n    \"\"\"\n    Returns the adjacency matrix of the graph:\n        [\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]\n        ]\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nstart = 0\nend = 3\nassert f(g(), start, end) is True\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a graph represented as an adjacency list, find if there exists a path from the start node to the end node.\nArgs:\n    graph: The graph represented as an adjacency list.\n    start: The start node.\n    end: The end node.\nReturns:\n    True if a path exists from the start node to the end node, False otherwise.\"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    visited = set()\n    return dfs(start, visited)\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list and the start and end nodes.\n    \"\"\"\n    graph = [[1, 2], [0, 3], [0, 4], [1], [2]]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 471,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if there exists a combination of k integers from 1 to n such that the sum of the combination is divisible by k.\"\"\"\n    def helper(nums, target, current_sum, current_count):\n        if current_count == k:\n            return current_sum % k == 0\n        if current_sum % k == 0 and current_count > 0:\n            return True\n        if current_count < k:\n            for i in range(len(nums)):\n                if helper(nums[i+1:], target, current_sum+nums[i], current_count+1):\n                    return True\n        return False\n    \n    nums = list(range(1, n+1))\n    return helper(nums, k, 0, 0)\n\ndef g(n=6, k=3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string can be rearranged to form a palindrome.\"\"\"\n    counts = [0] * 26\n    for char in s:\n        counts[ord(char) - ord('a')] += 1\n    odd_count = 0\n    for count in counts:\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\ndef g():\n    return 'aabbc'\n\nassert f(g())\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there exists a pair of numbers in the list whose sum is equal to the target. You can assume the input list is already sorted in ascending order.\"\"\"\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        curr_sum = nums[start] + nums[end]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 58,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target integer, find the indices of two numbers such that they add up to the target.\nReturn the indices in ascending order.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    return [-2, 0, 3, 5, 7, 9, 11, 15, 17], 10\nassert f(*g()) == [2, 4]\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome and contains only uppercase alphabetic characters.\"\"\"\n    return s == s[::-1] and s.isupper()\ndef g():\n    return 'MADAM'\nassert f(g())\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the number of unique subsets that can be formed using the numbers.\n    \"\"\"\n    n = len(nums)\n    subsets = set()\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        subsets.add(tuple(subset))\n    return len(subsets)\ndef g():\n    return ([1, 2, 3],)\nassert f(*g()) == 8\n",
        "idx_generation": 370,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums=[1, 3, 2, 4, 7, 6, 9, 8]):\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    \n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    Output:\n    28 (5 ^ 25)\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n            \n    return max_xor\n    \ndef g(nums: List[int]):\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return (nums,)\n    \nnums = [3, 10, 5, 25, 2, 8]\nassert f(*g(nums)) == 28\n",
        "idx_generation": 212,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Determine the number of ways to climb a staircase with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start node to end node in the given graph.\"\"\"\n    visited = set()\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    return False\n\ndef g():\n    graph = [[1, 2], [3], [4], [5], [], []]\n    return (graph, 0, 5)\n\nassert f(*g())\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency list, determine if the graph contains a cycle.\"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    return False\n\ndef g():\n    return ([[1, 2], [0, 2], [0, 1, 3], [2]],)\n\nassert f(*g())\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a 2D grid of integers, find the maximum sum of values obtained by traversing a path from the top-left cell to the bottom-right cell. The path can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    # Fill the first column\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    # Fill the rest of the grid\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\nassert f(g()) == 12\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Find all unique combinations of numbers in the given list that sum up to the target value.\"\"\"\n    def backtrack(nums: List[int], target: int, index: int, current_combination: List[int], combinations: List[List[int]]) -> None:\n        if target == 0:\n            combinations.append(current_combination[:])\n            return\n        if index >= len(nums) or target < 0:\n            return\n        current_combination.append(nums[index])\n        backtrack(nums, target - nums[index], index, current_combination, combinations)\n        current_combination.pop()\n        backtrack(nums, target, index + 1, current_combination, combinations)\n    \n    combinations = []\n    backtrack(nums, target, 0, [], combinations)\n    return combinations\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return (nums, target)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='world') -> bool:\n    \"\"\"Check if the given string contains all the characters of the target string in the same order, but not necessarily consecutively.\"\"\"\n    def is_subsequence(s, target, i, j):\n        if j == len(target):\n            return True\n        if i == len(s):\n            return False\n        if s[i] == target[j]:\n            return is_subsequence(s, target, i + 1, j + 1)\n        return is_subsequence(s, target, i + 1, j)\n    return is_subsequence(s, target, 0, 0)\ndef g(s='hello world'):\n    return s\nassert f(g())\n",
        "idx_generation": 235,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is sorted in ascending order.\"\"\"\n    return nums == sorted(nums)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target value 'target', find the minimum number of elements from the list that sum up to the target value. Return the count of the minimum elements.\"\"\"\n    n = len(nums)\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        for j in range(n):\n            if nums[j] <= i:\n                dp[i] = min(dp[i], dp[i - nums[j]] + 1)\n    return dp[target]\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([1, 2, 5], 11)) == 3\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring='abc') -> bool:\n    \"\"\"Check if a given string contains the same number of occurrences of each character as the given substring.\"\"\"\n    char_count_s = {c: s.count(c) for c in set(s)}\n    char_count_substring = {c: substring.count(c) for c in set(substring)}\n    return char_count_s == char_count_substring\ndef g(substring='abc'):\n    return ''.join(sorted(substring))\nassert f(g())\n",
        "idx_generation": 161,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers in non-decreasing order and a target number, determine if it is possible to select a subset of the numbers\nsuch that their sum is equal to the target.\nThe function should return True if such a subset exists, and False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\n\ndef g():\n    return [1, 2, 3, 5, 8, 13, 21]\n\nassert f(g(), 32)\n",
        "idx_generation": 374,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in a given list of integers using dynamic programming.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer, return the number of bits required to represent it in binary.\n    \"\"\"\n    if n == 0:\n        return 1\n    return len(bin(n)) - 2\n\ndef g():\n    return (42,)\n\nassert f(*g()) == 6\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome using recursion.\"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])\ndef g():\n    return 'level'\nassert f(g())\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an undirected graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end in the graph.\n\"\"\"\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g(graph: List[List[int]], start: int, end: int):\n    \"\"\"\n    Generate an undirected graph represented as an adjacency list, and two nodes start and end.\n    \"\"\"\n\n    return (graph, start, end)\n\ngraph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\nstart = 0\nend = 3\n\nassert f(*g(graph, start, end))\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representation of a directed graph, determine if there is a path from node 0 to node n-1.\"\"\"\n    def dfs(graph, visited, curr):\n        if curr == len(graph) - 1:\n            return True\n        visited[curr] = True\n        for neighbor in graph[curr]:\n            if not visited[neighbor] and dfs(graph, visited, neighbor):\n                return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, visited, 0)\n\ndef g():\n    return [[1, 2], [3], [3], []]\n\nassert f(g())\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given the number of nodes in a graph and a list of directed edges, determine if there is a valid topological ordering of the nodes.\nA topological ordering is an arrangement of the nodes in such a way that for every directed edge (u, v), node u comes before node v in the ordering.\nReturn True if a valid topological ordering exists, False otherwise.\"\"\"\n    graph = [[] for _ in range(n)]\n    in_degree = [0] * n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        in_degree[v] += 1\n    queue = []\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n    count = 0\n    while queue:\n        node = queue.pop(0)\n        count += 1\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return count == n\ndef g(n: int, edges: List[List[int]]):\n    return (n, edges)\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\nassert f(*g(n, edges))\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to arrange n distinct objects in a circle.\"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return (n-1) * f(n-2)\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 428,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"Given a string s and a list of words, return True if the string s can be formed by concatenating any number of words from the list, without any characters left over.\n    Example:\n    s = 'applebanana'\n    words = ['apple', 'banana', 'cat']\n    Output: True\n    Explanation: The string 'applebanana' can be formed by concatenating the words 'apple' and 'banana' from the given list.\n    \"\"\"\n    word_set = set(words)\n    if s in word_set:\n        return True\n    for i in range(1, len(s)):\n        prefix = s[:i]\n        suffix = s[i:]\n        if prefix in word_set and f(suffix, words):\n            return True\n    return False\n\ndef g():\n    s = 'applebanana'\n    words = ['apple', 'banana', 'cat']\n    return s, words\n\nassert f(*g())\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that adds up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 4, 3, 7, 9, 2]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all even Fibonacci numbers up to n.\"\"\"\n    if n < 2:\n        return 0\n    fib_sum = 0\n    fib_prev = 0\n    fib_curr = 1\n    while fib_curr <= n:\n        if fib_curr % 2 == 0:\n            fib_sum += fib_curr\n        fib_prev, fib_curr = fib_curr, fib_prev + fib_curr\n    return fib_sum\n\ndef g(n=100):\n    \"\"\"Return the sum of all even Fibonacci numbers up to n.\"\"\"\n    return f(n)\n\nassert f(g()) == 44\n",
        "idx_generation": 181,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if it is possible to rearrange the characters in the string 's' to obtain the string 'target'.\"\"\"\n    sorted_s = sorted(s)\n    sorted_target = sorted(target)\n    return sorted_s == sorted_target\ndef g():\n    return (\"abccde\", \"cdeabc\")\nassert f(*g()) == True\n",
        "idx_generation": 164,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the length of the longest increasing subsequence.\n    \n    Args:\n        nums: The list of integers.\n        \n    Returns:\n        The length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of distinct integers, find the length of the longest increasing subsequence.\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output:\n    4 (The longest increasing subsequence is [2, 3, 7, 101])\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 130,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the maximum sum of a subsequence from the list that is less than or equal to the target.\n    Return the maximum sum.\n    \"\"\"\n    dp = [0] * (target + 1)\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = max(dp[i], dp[i - num] + num)\n    return dp[target]\n\ndef g():\n    return [2, 5, 8, 10, 13]\n\nassert f(g(), 18) == 18\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a graph, determine if there is a path from the first node to the last node.\n    A path exists if there is a sequence of nodes that can be traversed starting from the first node and ending at the last node.\n    \"\"\"\n    stack = [0]  # Start at the first node\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == len(graph) - 1:  # Reached the last node\n            return True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Return an adjacency matrix representing a graph with a path from the first node to the last node.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [0, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Given a number of nodes and a list of edges in a directed graph, check if the graph contains a cycle.\"\"\"\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        u, v = edge\n        adj_list[u].append(v)\n    \n    visited = [False] * n\n    rec_stack = [False] * n\n    \n    def dfs(node: int) -> bool:\n        visited[node] = True\n        rec_stack[node] = True\n        \n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        \n        rec_stack[node] = False\n        return False\n    \n    for node in range(n):\n        if not visited[node]:\n            if dfs(node):\n                return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, determine if there is a path from start to end.\n    Return True if a path exists, otherwise return False.\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in range(len(graph[node])):\n        if graph[node][neighbor] != 0 and neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    return [[0, 1, 1, 0, 0],\n            [1, 0, 0, 1, 0],\n            [1, 0, 0, 1, 1],\n            [0, 1, 1, 0, 0],\n            [0, 0, 1, 0, 0]]\n\nassert f(g(), start=0, end=4) == True\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase of n steps.\n    Each time you can either climb 1 or 2 steps.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n - 1) + f(n - 2)\ndef g():\n    n = 5\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = [0] * 26\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for c in count:\n        if c != 0:\n            return False\n\n    return True\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g())\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target',\n    determine if there exists two numbers in the list that add up to the target.\n    Return True if such pair exists, otherwise return False.\n    \n    Sample Input:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    target = 9\n    \n    Sample Output:\n    True\n    \n    Explanation:\n    The numbers 1 and 8 in the list add up to the target 9.\n    Therefore, the output is True.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8], target=9):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 62,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the closest value to the target in the list.\n    \"\"\"\n    def find_closest(nums, target, low, high):\n        if low > high:\n            return nums[low] if abs(nums[low] - target) < abs(nums[high] - target) else nums[high]\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return nums[mid]\n        elif nums[mid] < target:\n            return find_closest(nums, target, mid + 1, high)\n        else:\n            return find_closest(nums, target, low, mid - 1)\n    \n    nums.sort()\n    return find_closest(nums, target, 0, len(nums) - 1)\n\ndef g():\n    return ([4, 8, 12, 16, 20], 10)\n\nassert f(*g()) == 8\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a binary string has alternating 0s and 1s.\"\"\"\n    for i in range(len(s)-1):\n        if s[i] == s[i+1]:\n            return False\n    return True\n\ndef g():\n    return '101010101010'\n\nassert f(g())\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Given two integers n and k, determine if it is possible to choose k integers from the range 1 to n (inclusive) such that the sum of the chosen integers is divisible by k.\"\"\"\n    def backtrack(curr_sum: int, curr_count: int, curr_index: int) -> bool:\n        if curr_count == k:\n            return curr_sum % k == 0\n        for i in range(curr_index, n+1):\n            if backtrack(curr_sum + i, curr_count + 1, i+1):\n                return True\n        return False\n    return backtrack(0, 0, 1)\n\ndef g():\n    return (10, 3)\n\nassert f(*g())\n",
        "idx_generation": 391,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr\nassert f(g()) == 4\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, count the number of set bits in its binary representation.\n    Example:\n    Input: 9\n    Output: 2 (binary representation: 1001)\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 9\n\nassert f(g()) == 2\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\"\"\"\n    memo = {}\n\n    def fibonacci(n: int) -> int:\n        if n in memo:\n            return memo[n]\n\n        if n <= 1:\n            return n\n\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 300,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]]) -> bool:\n    \"\"\"Given a dependency graph represented as a dictionary, return True if there is a cycle in the graph, False otherwise.\"\"\"\n    visited = set()\n    visiting = set()\n    def dfs(node):\n        if node in visited:\n            return False\n        if node in visiting:\n            return True\n        visiting.add(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n        visiting.remove(node)\n        visited.add(node)\n        return False\n    for node in graph:\n        if dfs(node):\n            return True\n    return False\ndef g():\n    return {'A': ['B', 'C'], 'B': ['C'], 'C': []}\nassert f(g()) == False\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a graph represented as a dictionary, determine if there exists a path from the start node to the end node.\nReturn True if a path exists, otherwise return False.\"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\ndef g():\n    return {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []}\nassert f(g(), start='A', end='F') == True\n",
        "idx_generation": 484,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to reach the target sum by selecting a subset of numbers from the given list.\n    Each number can be used only once.\"\"\"\n    def backtrack(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n        if backtrack(nums, target, index + 1, curr_sum + nums[index]):\n            return True\n        return backtrack(nums, target, index + 1, curr_sum)\n    \n    return backtrack(nums, target, 0, 0)\n\ndef g():\n    nums = [1, 5, 6, 8, 10]\n    target = 16\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 449,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of distinct substrings in a given string.\"\"\"\n    n = len(s)\n    distinct_substrings = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            distinct_substrings.add(s[i:j])\n    return len(distinct_substrings)\ndef g() -> str:\n    return 'ababa'\nassert f(g()) == 9\n",
        "idx_generation": 251,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=8) -> bool:\n    \"\"\"Given a matrix of integers, find if the target number is present in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    r = 0\n    c = cols - 1\n    while r < rows and c >= 0:\n        if matrix[r][c] == target:\n            return True\n        elif matrix[r][c] < target:\n            r += 1\n        else:\n            c -= 1\n    return False\ndef g(target=8):\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\nassert f(g())\n",
        "idx_generation": 62,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given an array of integers and a target number, find all unique combinations of numbers in the array that sum up to the target.\nEach number in a combination may be used multiple times.\"\"\"\n    def backtrack(combination, start, target):\n        if target == 0:\n            combinations.append(combination[:])\n        elif target > 0:\n            for i in range(start, len(arr)):\n                combination.append(arr[i])\n                backtrack(combination, i, target - arr[i])\n                combination.pop()\n    arr.sort()\n    combinations = []\n    backtrack([], 0, target)\n    return combinations\n\ndef g():\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings=['abc', 'def', 'ghi']) -> bool:\n    \"\"\"Check if each substring in substrings appears in s in the same order as given\"\"\"\n    start_index = 0\n    for sub in substrings:\n        index = s.find(sub, start_index)\n        if index == -1:\n            return False\n        start_index = index + len(sub)\n    return True\n\ndef g(substrings=['abc', 'def', 'ghi']):\n    return ''.join(substrings)\n\nassert f(g())\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of the list that adds up to the target.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    Sample Output:\n    True\n    Explanation: The subset [2, 3, 4] adds up to the target value 9, hence the output is True.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = True\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if nums[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n    return dp[n][target]\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of positive integers and a target number, return True if it is possible to express the target number as the sum of any combination of the numbers in the list.\"\"\"\n    def backtrack(index: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n        return backtrack(index + 1, curr_sum + nums[index]) or backtrack(index + 1, curr_sum)\n    \n    return backtrack(0, 0)\n\ndef g():\n    return ([1, 3, 5, 7], 10)\n\nassert f(*g())\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose XOR value is equal to the target.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(nums=[2, 5, 8, 10, 12], target=6):\n    return nums\n\nassert f(g(), 6) == True\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the sum of the first n Fibonacci numbers.\"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    sum_fibonacci = 0\n    for i in range(1, n+1):\n        sum_fibonacci += fibonacci(i)\n    \n    return sum_fibonacci\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 12\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, check if there is a path from the start node to the end node.\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [1, 0, 0, 1],\n             [0, 0, 0, 1]]\n    start = 0\n    end = 3\n    In this example, the graph has 4 nodes and the adjacency matrix represents the connections between the nodes.\n    The function should return True, as there is a path from node 0 to node 3 (0 -> 1 -> 2 -> 3).\n\n    :param graph: A graph represented as an adjacency matrix (2D list)\n    :param start: The start node\n    :param end: The end node\n    :return: True if a path from start to end exists, False otherwise\n    \"\"\"\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    visited = set()\n\n    return dfs(start)\n\ndef g():\n    return ([[0, 1, 1, 0], [0, 0, 1, 0], [1, 0, 0, 1], [0, 0, 0, 1]], 0, 3)\n\nassert f(*g())\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, check if there is a path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    def dfs(i, j):\n        if i == rows-1 and j == cols-1:\n            return True\n        if i < rows-1 and matrix[i+1][j] != -1:\n            if dfs(i+1, j):\n                return True\n        if j < cols-1 and matrix[i][j+1] != -1:\n            if dfs(i, j+1):\n                return True\n        return False\n    return dfs(0, 0)\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [0, 0, 0, 0],\n              [0, 1, 1, 0],\n              [0, 1, 0, 0]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of numbers in the given list that sums up to the target value.\"\"\"\n    def helper(nums, target, index):\n        if target == 0:\n            return True\n        if index == len(nums):\n            return False\n        if nums[index] > target:\n            return helper(nums, target, index+1)\n        return helper(nums, target-nums[index], index+1) or helper(nums, target, index+1)\n    return helper(nums, target, 0)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(n: int, m: int, k: int, s: str) -> bool:\n    \"\"\"Given a string s, find if it is possible to rearrange the characters in s such that no two adjacent characters are the same. The rearranged string should also have exactly n occurrences of 'a', m occurrences of 'b', and k occurrences of 'c'.\"\"\"\n    from itertools import permutations\n    for perm in permutations(s):\n        perm = ''.join(perm)\n        if all(perm[i] != perm[i+1] for i in range(len(perm)-1)):\n            if perm.count('a') == n and perm.count('b') == m and perm.count('c') == k:\n                return True\n    return False\n\ndef g(n: int, m: int, k: int, s: str):\n    from itertools import permutations\n    chars = ['a']*n + ['b']*m + ['c']*k\n    for perm in permutations(chars):\n        perm = ''.join(perm)\n        if all(perm[i] != perm[i+1] for i in range(len(perm)-1)):\n            return perm\n    return \"\"\n\nassert f(n=2, m=2, k=2, s=g(n=2, m=2, k=2, s='abacab'))\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find the two numbers in the list whose sum is closest to the target\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    closest_sum = float('inf')\n    closest_nums = []\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if abs(curr_sum - target) < abs(closest_sum - target):\n            closest_sum = curr_sum\n            closest_nums = [nums[left], nums[right]]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_nums\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return (nums, target)\nassert f(*g()) == [1, 5]\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if the target number is present in the list, \n    False otherwise. Use binary search for optimization.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 184,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with the words sorted based on their lengths.\n    If two words have the same length, sort them alphabetically.\n    \"\"\"\n    return sorted(words, key=lambda w: (len(w), w))\n\ndef g():\n    return [\"cat\", \"apple\", \"dog\", \"banana\", \"elephant\"]\n\nassert f(g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be represented as a sum of distinct powers of two.\"\"\"\n    def is_power_of_two(x):\n        return x and not (x & (x - 1))\n    def helper(n, k):\n        if n == 0:\n            return True\n        if n < 0 or k < 0:\n            return False\n        return helper(n, k-1) or helper(n - (2 ** k), k-1)\n    return helper(n, n-1)\ndef g(n: int):\n    return f(n)\nassert f(g(n=10))\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers nums and a target value, determine if there exists a subset of nums that sums up to the target value.\n    Return True if such a subset exists, otherwise return False.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers nums and a target value, find a subset of nums that sums up to the target value.\n    Return the subset of nums that sums up to the target value, or an empty list if no such subset exists.\"\"\"\n    def backtrack(curr_sum, idx, path):\n        if curr_sum == target:\n            return path\n        for i in range(idx, len(nums)):\n            if curr_sum + nums[i] <= target:\n                path.append(nums[i])\n                res = backtrack(curr_sum + nums[i], i + 1, path)\n                if res:\n                    return res\n                path.pop()\n        return []\n    return backtrack(0, 0, [])\n\nnums = [3, 1, 5, 8]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, y: int) -> int:\n    \"\"\"Perform bitwise XOR operation on x and y\"\"\"\n    return x ^ y\n\ndef g():\n    return 10, 7\n\nassert f(*g()) == 13\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of distinct paths from the top-left corner to the bottom-right corner of a grid (n x n) with obstacles.\nYou can only move down or right. Obstacles are represented as 1 and open paths as 0.\"\"\"\n    def helper(n: int, i: int, j: int, dp: List[List[int]]) -> int:\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i >= n or j >= n or dp[i][j] == 1:\n            return 0\n        if dp[i][j] != -1:\n            return dp[i][j]\n        dp[i][j] = helper(n, i + 1, j, dp) + helper(n, i, j + 1, dp)\n        return dp[i][j]\n    dp = [[-1] * n for _ in range(n)]\n    return helper(n, 0, 0, dp)\ndef g(n: int):\n    return n\nassert f(g(3)) == 2\n",
        "idx_generation": 311,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Given a directed graph, find the longest path from the source node to the target node.\"\"\"\n    def dfs(node):\n        if node == target:\n            return 0\n        if node not in graph:\n            return float('-inf')\n        max_path = float('-inf')\n        for neighbor in graph[node]:\n            max_path = max(max_path, dfs(neighbor) + 1)\n        return max_path\n    source = 1\n    target = 5\n    return dfs(source) >= 3\ndef g():\n    return {1: [2, 3], 2: [4], 3: [4, 5], 4: [5]}\nassert f(g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], source: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from the source node to the target node.\n    \n    Args:\n        graph: The directed graph represented as an adjacency list.\n        source: The source node.\n        target: The target node.\n        \n    Returns:\n        True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [source]\n    \n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample directed graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [2], [3, 4], [], [5], []]\n\nassert f(g(), 0, 5)\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target number, find the number of unique combinations that add up to the target.\n    Solve the problem using recursion and dynamic programming.\"\"\"\n    def backtrack(nums: List[int], target: int, index: int, memo: dict) -> int:\n        if target == 0:\n            return 1\n        if target < 0 or index >= len(nums):\n            return 0\n        if (index, target) in memo:\n            return memo[(index, target)]\n        count = 0\n        count += backtrack(nums, target - nums[index], index, memo)\n        count += backtrack(nums, target, index + 1, memo)\n        memo[(index, target)] = count\n        return count\n    \n    return backtrack(nums, target, 0, {})\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers nums and a target number.\n    \"\"\"\n    return (nums, target)\n\nnums = [2, 3, 6, 7]\ntarget = 7\nassert f(*g(nums, target)) == 2\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(n: int, k: int, s: str) -> bool:\n    \"\"\"Given a string s, find if it is possible to rearrange the characters in s such that no two adjacent characters are the same. The rearranged string should also have exactly n occurrences of 'a' and k occurrences of 'b'. Return True if such rearrangement is possible, otherwise return False.\"\"\"\n    from itertools import permutations\n    for perm in permutations(s):\n        perm = ''.join(perm)\n        if all(perm[i] != perm[i+1] for i in range(len(perm)-1)):\n            if perm.count('a') == n and perm.count('b') == k:\n                return True\n    return False\n\ndef g(n: int, k: int, s: str):\n    from itertools import permutations\n    chars = ['a']*n + ['b']*k\n    for perm in permutations(chars):\n        perm = ''.join(perm)\n        if all(perm[i] != perm[i+1] for i in range(len(perm)-1)):\n            return perm\n    return \"\"\n\nassert f(n=2, k=3, s=g(n=2, k=3, s='abaab'))\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the first occurrence of the target value using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            while mid > 0 and arr[mid - 1] == target:\n                mid -= 1\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g():\n    return ([1, 2, 3, 4, 4, 5, 6, 7, 8], 4)\nassert f(*g()) == 3\n",
        "idx_generation": 64,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subsequence in the list whose sum is equal to the target.\"\"\"\n    def backtrack(i, total):\n        if total == target:\n            return True\n        if i == len(nums) or total > target:\n            return False\n        return backtrack(i + 1, total + nums[i]) or backtrack(i + 1, total)\n    return backtrack(0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g()) == True\n",
        "idx_generation": 188,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string.\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\"\"\n    return ' '.join(s.split()[::-1])\ndef g(s: str) -> str:\n    return s\ns = \"Hello World\"\nassert f(g(s)) == \"World Hello\"\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique BSTs (Binary Search Trees) that can be formed with nodes labeled from 1 to n.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n\ndef g(n: int):\n    return n\n\nn = 4\nassert f(g(n)) == 14\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(m: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a matrix m of size n x n, find the minimum cost to reach from the top-left cell to the bottom-right cell.\n    You can only move down or right, and the cost of each cell represents the cost to move to that cell.\n    Implement the solution using dynamic programming and memoization.\n    \"\"\"\n    n = len(m)\n    dp = [[0] * n for _ in range(n)]\n\n    dp[0][0] = m[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + m[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + m[0][j]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + m[i][j]\n\n    return dp[n-1][n-1]\n\ndef g():\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return matrix\n\nassert f(g()) == 7\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find two distinct numbers in the list\n    such that their XOR is equal to the target. Return True if such a pair exists, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        complement = num ^ target\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return ([-2, 3, 5, 9, 12], 10)\n\nassert f(*g())\n",
        "idx_generation": 254,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a grid of integers, determine if there exists a path from the top-left cell to the bottom-right cell,\n    moving only down or right, such that the sum of all the values along the path is a prime number.\n    Return True if such a path exists, otherwise return False.\n    Sample Input:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    Sample Output:\n    True\"\"\"\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return is_prime(dp[rows-1][cols-1])\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return grid\nassert f(g())\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray with a sum equal to zero.\n    Return True if such a subarray exists, otherwise return False.\n    \"\"\"\n    prefix_sum = set()\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if current_sum in prefix_sum or current_sum == 0:\n            return True\n        prefix_sum.add(current_sum)\n    return False\ndef g():\n    return [4, -2, 3, 1, -3, 0, -4, 2]\nassert f(g())\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary and two nodes: start and end.\nDetermine if there exists a path from start to end in the graph.\nReturn True if a path exists, False otherwise.\"\"\"\n    visited = set()\n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    return dfs(start)\ndef g(graph: Dict[str, List[str]], start: str, end: str):\n    return (graph, start, end)\ngraph = {'A': ['B', 'C'],\n         'B': ['C', 'D'],\n         'C': ['D'],\n         'D': ['E'],\n         'E': []}\nstart = 'A'\nend = 'E'\nassert f(*g(graph, start, end))\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if it is possible to obtain the target integer by performing addition, subtraction, multiplication, and division operations on the numbers in nums, with the restriction that each number in nums can only be used once.\"\"\"\n    def dfs(nums: List[int], target: int, idx: int) -> bool:\n        if target == 0:\n            return True\n        if idx >= len(nums):\n            return False\n        return dfs(nums, target - nums[idx], idx + 1) or dfs(nums, target + nums[idx], idx + 1) or dfs(nums, target * nums[idx], idx + 1) or (nums[idx] != 0 and target % nums[idx] == 0 and dfs(nums, target / nums[idx], idx + 1))\n    return dfs(nums, target, 0)\n\ndef g(nums=[1, 2, 3, 4], target=10):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(n: int, k: int, s: str) -> bool:\n    \"\"\"Given a string s, find if it is possible to rearrange the characters in s such that no two adjacent characters are the same. The rearranged string should also have exactly n occurrences of '1' and k occurrences of '0'. Return True if such rearrangement is possible, otherwise return False.\"\"\"\n    from itertools import permutations\n    for perm in permutations(s):\n        perm = ''.join(perm)\n        if all(perm[i] != perm[i+1] for i in range(len(perm)-1)):\n            if perm.count('1') == n and perm.count('0') == k:\n                return True\n    return False\n\ndef g(n: int, k: int, s: str):\n    from itertools import permutations\n    chars = ['1']*n + ['0']*k\n    for perm in permutations(chars):\n        perm = ''.join(perm)\n        if all(perm[i] != perm[i+1] for i in range(len(perm)-1)):\n            return perm\n    return \"\"\n\nassert f(n=3, k=2, s=g(n=3, k=2, s='10101'))\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: List[int], target=12) -> bool:\n    \"\"\"Find if there is a pair of numbers in the list that sum up to the target value.\"\"\"\n    x.sort()\n    i = 0\n    j = len(x) - 1\n    while i < j:\n        if x[i] + x[j] == target:\n            return True\n        elif x[i] + x[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g():\n    x = [2, 4, 6, 8, 10]\n    return x\n\nassert f(g())\n",
        "idx_generation": 65,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(heights: List[int], k=1) -> bool:\n    \"\"\"Determine if it is possible to build k towers by selecting contiguous subarrays from the heights list.\n    Each tower must have a height greater than or equal to the previous tower.\"\"\"\n    n = len(heights)\n    if k > n:\n        return False\n    for i in range(k, n):\n        if heights[i] < heights[i - k]:\n            return False\n    return True\n\ndef g(k=1):\n    return [1] * k + [2] * (k + 1)\n\nassert f(g())\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate it 90 degrees clockwise.\"\"\"\n    return [list(row[::-1]) for row in zip(*matrix)]\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 193,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and an integer 'k', determine if there exists a subarray of 'nums' with a sum divisible by 'k'.\nSample Input:\nnums = [4, 7, 2, 3, 5]\nk = 6\nSample Output:\nTrue\nExplanation: The subarray [7, 2, 3] has a sum of 12, which is divisible by 6, hence the output is True.\"\"\"\n    sum_so_far = 0\n    mod_dict = {0: -1}\n    for i, num in enumerate(nums):\n        sum_so_far += num\n        mod = sum_so_far % k\n        if mod in mod_dict:\n            if i - mod_dict[mod] > 1:\n                return True\n        else:\n            mod_dict[mod] = i\n    return False\n\ndef g(nums=[4, 7, 2, 3, 5], k=6):\n    return (nums, k)\n\nassert f(*g())\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of numbers, return the maximum sum that can be achieved by starting at the top-left corner\n    and moving only rightward or downward to reach the bottom-right corner.\n    Return the maximum sum.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> bool:\n    \"\"\"Check if there exists a number in the grid whose kth bit from the right in its binary representation is set (1).\"\"\"\n    for row in grid:\n        for num in row:\n            binary = bin(num)[2:]\n            if len(binary) >= k and binary[-k] == '1':\n                return True\n    return False\n\ndef g():\n    return [[5, 10, 15], [20, 25, 30], [35, 40, 45]]\n\nassert f(g(), k=3)\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the minimum number of steps required to reach the bottom right corner, starting from the top left corner.\n    You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a binary tree represented as an array, return the sum of all the elements in the tree.\nEach element in the array represents a node in the tree, and the index of each element represents the parent-child relationship.\nFor example, given the array [1, 2, 3, 4, 5, 6, 7], the binary tree is:\n\n        1\n       / \\\n      2   3\n     / \\ / \\\n    4  5 6  7\n\nThe sum of all elements in the tree is 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.\"\"\"\n    def calculate_sum(arr, index):\n        if index >= len(arr):\n            return 0\n        return arr[index] + calculate_sum(arr, 2 * index + 1) + calculate_sum(arr, 2 * index + 2)\n    return calculate_sum(arr, 0)\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    return (arr,)\nassert f(*g()) == 28\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the length of the longest increasing path in a matrix, where each step can only be taken to a neighboring cell with a smaller value\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    memo = [[0] * cols for _ in range(rows)]\n    max_length = 0\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(matrix, i, j, memo))\n    return max_length\ndef dfs(matrix: List[List[int]], row: int, col: int, memo: List[List[int]]) -> int:\n    if memo[row][col] != 0:\n        return memo[row][col]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    max_length = 1\n    for dx, dy in directions:\n        new_row = row + dx\n        new_col = col + dy\n        if 0 <= new_row < len(matrix) and 0 <= new_col < len(matrix[0]) and matrix[new_row][new_col] < matrix[row][col]:\n            max_length = max(max_length, 1 + dfs(matrix, new_row, new_col, memo))\n    memo[row][col] = max_length\n    return max_length\ndef g():\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    return matrix\nassert f(g()) == 4\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, result: int) -> bool:\n    \"\"\"Given an integer n, the goal is to find an integer 'result' such that\n    the number of valid parentheses expressions of length 2n is equal to 'result'.\n    A valid parentheses expression is defined as:\n    - An empty string is a valid expression.\n    - If s is a valid expression, then (s) is a valid expression.\n    - If s and t are valid expressions, then st is a valid expression.\n    Return True if 'result' is correct, and False otherwise.\"\"\"\n    \n    def calculate_parentheses_expressions(n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            count = 0\n            for i in range(n):\n                count += calculate_parentheses_expressions(i) * calculate_parentheses_expressions(n-i-1)\n            return count\n        \n    return calculate_parentheses_expressions(n) == result\n\n\ndef g(n: int) -> int:\n    \"\"\"Given an integer n, the goal is to find an integer 'result' such that\n    the number of valid parentheses expressions of length 2n is equal to 'result'.\n    A valid parentheses expression is defined as:\n    - An empty string is a valid expression.\n    - If s is a valid expression, then (s) is a valid expression.\n    - If s and t are valid expressions, then st is a valid expression.\n    Return the value of 'result'.\"\"\"\n    \n    def calculate_parentheses_expressions(n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            count = 0\n            for i in range(n):\n                count += calculate_parentheses_expressions(i) * calculate_parentheses_expressions(n-i-1)\n            return count\n        \n    return calculate_parentheses_expressions(n)\n\n\nassert f(3, g(3))\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"Find a combination of n numbers from 1 to k such that their sum is equal to target_sum.\"\"\"\n    import itertools\n    combinations = list(itertools.combinations(range(1, k+1), n))\n    for combination in combinations:\n        if sum(combination) == target_sum:\n            return True\n    return False\n\ndef g(k: int, target_sum: int):\n    n = 1\n    while True:\n        if f(n, k, target_sum):\n            return n\n        n += 1\n\nassert f(g(k=10, target_sum=15), k=10, target_sum=15)\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and an integer k, find the kth largest element in the list.\"\"\"\n    nums.sort()\n    return nums[-k]\n\ndef g(nums=[4, 2, 7, 1, 3], k=2):\n    return nums, k\n\nassert f(*g()) == 4\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target value 'target', determine if there are two numbers in the list that sum up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 16)\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, find two numbers that sum up to the target value.\n    Return the indices of the two numbers in ascending order.\n    \"\"\"\n    nums = sorted(nums)\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given an integer 'n' and a list of integers 'arr', find if there exists a subarray with sum equal to 'n'.\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == n or prefix_sum - n in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(5, g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value of any two elements in the list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, determine the number of distinct paths from the top-left corner to the bottom-right corner\n    of an n x n grid, where only rightward and downward movements are allowed.\n    Return the number of distinct paths.\"\"\"\n    def count_paths(x, y):\n        if x == 0 or y == 0:\n            return 1\n        return count_paths(x - 1, y) + count_paths(x, y - 1)\n    \n    return count_paths(n - 1, n - 1)\n\ndef g(n: int) -> int:\n    \"\"\"\n    Return the positive integer n.\n    \"\"\"\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 329,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a path from the top-left corner to the bottom-right corner in the given maze.\"\"\"\n    def helper(row, col):\n        if row == len(maze) - 1 and col == len(maze[0]) - 1:\n            return True\n        if row >= len(maze) or col >= len(maze[0]) or maze[row][col] == 1:\n            return False\n        return helper(row + 1, col) or helper(row, col + 1)\n\n    return helper(0, 0)\n\ndef g():\n    return [[0, 0, 0, 0],\n            [0, 1, 1, 0],\n            [0, 0, 0, 0],\n            [0, 1, 1, 0]]\n\nassert f(g())\n",
        "idx_generation": 310,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"Given an undirected graph represented as an adjacency matrix 'graph', find the shortest path between two nodes.\n    Return the length of the shortest path.\"\"\"\n\n    def dfs(node, visited, target, length, shortest):\n        if node == target:\n            shortest[0] = min(shortest[0], length)\n            return\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] != 0 and not visited[neighbor]:\n                dfs(neighbor, visited, target, length + graph[node][neighbor], shortest)\n        visited[node] = False\n\n    source = 0\n    target = len(graph) - 1\n    shortest = [float('inf')]\n    dfs(source, [False] * len(graph), target, 0, shortest)\n    return shortest[0]\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 0, 0, 0],\n        [1, 0, 1, 1, 0],\n        [0, 1, 0, 0, 1],\n        [0, 1, 0, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 495,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to arrange n distinct objects in a row, where some objects have to be placed together and some have to be separated.\n    The objects that have to be placed together must be adjacent to each other.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Return the number of distinct objects to be arranged.\n    \"\"\"\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(string: str, k: int) -> bool:\n    \"\"\"Given a string and an integer k, determine if the string can be divided into k equal parts, where each part is a palindrome.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    n = len(string)\n    if n % k != 0:\n        return False\n    part_len = n // k\n    for i in range(0, n, part_len):\n        if not is_palindrome(string[i:i+part_len]):\n            return False\n    return True\ndef g():\n    return (\"abcbaabcba\", 2)\nassert f(*g()) == True\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums=[4, 2, 7, 1, 3]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 7]\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string s can be split into n equal parts, with each part being a palindrome.\"\"\"\n    m = len(s)\n    if m % n != 0:\n        return False\n    part_len = m // n\n    for i in range(0, m, part_len):\n        part = s[i:i + part_len]\n        if part != part[::-1]:\n            return False\n    return True\ndef g(s: str, n: int) -> List[str]:\n    \"\"\"\n    Return a list of n equal parts obtained by splitting the given string into palindromes.\n    If the string cannot be split, return an empty list.\n    \"\"\"\n    m = len(s)\n    if m % n != 0:\n        return []\n    part_len = m // n\n    parts = []\n    for i in range(0, m, part_len):\n        parts.append(s[i:i + part_len])\n    return parts\nassert f(g('abcdedcba', 3), 3)\n",
        "idx_generation": 196,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to the target value.\"\"\"\n    def backtrack(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums) or current_sum > target:\n            return False\n        return backtrack(nums, target, index + 1, current_sum + nums[index]) or backtrack(nums, target, index + 1, current_sum)\n    \n    return backtrack(nums, target, 0, 0)\n\ndef g(nums=[1, 2, 3, 4], target=7):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum path sum from the top left to the bottom right.\"\"\"\n    if not grid:\n        return 0\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 144,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum XOR value between any two numbers in the array.\"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(30, -1, -1):\n        mask |= 1 << i\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        max_possible_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if max_possible_xor ^ prefix in prefix_set:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor\n\ndef g():\n    return ([3, 10, 5, 25, 2, 8],)\n\nassert f(*g()) == 28\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if a number 'n' is a power of 'k'.\"\"\"\n    if n == 1:\n        return True\n    if n % k != 0:\n        return False\n    return f(n // k, k)\ndef g():\n    \"\"\"Returns a number that is a power of 2.\"\"\"\n    return 8\nassert f(g(), 2) is True\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented by a 2D grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner. You can only move down or right in the maze. Return True if a path exists, False otherwise.\"\"\"\n    def dfs(i, j):\n        if i == len(maze) - 1 and j == len(maze[0]) - 1:\n            return True\n        if i >= len(maze) or j >= len(maze[0]) or maze[i][j] == 1:\n            return False\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    return dfs(0, 0)\ndef g(maze=[[0,0,0],[0,1,0],[0,0,0]]):\n    return (maze,)\nassert f(*g()) == True\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if it is possible to select a subset\n    of the integers that adds up to the target value.\n    Return True if such a subset exists, False otherwise.\"\"\"\n    \n    def subsetSum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        \n        if nums[n-1] > target:\n            return subsetSum(nums, target, n-1)\n        \n        return subsetSum(nums, target, n-1) or subsetSum(nums, target-nums[n-1], n-1)\n    \n    return subsetSum(nums, target, len(nums))\n\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=7) -> bool:\n    \"\"\"Check if the binary representation of n is a substring of s\"\"\"\n    return bin(n)[2:] in s\ndef g(n=7):\n    return \"101\" if n == 5 else \"110\" if n == 6 else \"111\"\nassert f(g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there are two numbers in the list that add up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 3, 5, 7, 11, 13]\n\nassert f(g(), 18)\n",
        "idx_generation": 72,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in a sorted list of consecutive integers.\"\"\"\n    low, high = 0, len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] - nums[0] == mid - 0:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return nums[low] - 1\n\ndef g(nums=[1, 2, 3, 5, 6, 7, 8, 9]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_sentence = ' '.join(reversed_words)\n    return reversed_sentence\n\ndef g(s: str):\n    return s\n\nassert f(g(\"Hello, world!\")) == \"world! Hello,\"\n",
        "idx_generation": 252,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray in the given list with sum equal to the target value.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return ([3, 4, 7, 2, -3, 1, 4, 2], 7)\n\nassert f(*g())\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the longest increasing subsequence length.\"\"\"\n    def helper(nums, prev, curr):\n        if curr == len(nums):\n            return 0\n        taken = 0\n        if nums[curr] > prev:\n            taken = 1 + helper(nums, nums[curr], curr + 1)\n        not_taken = helper(nums, prev, curr + 1)\n        return max(taken, not_taken)\n    \n    return helper(nums, float('-inf'), 0)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subset of the list such that the bitwise XOR of all the elements in the subset is equal to zero.\"\"\"\n    n = len(nums)\n    subsets = []\n    for i in range(1 << n):\n        subset = [nums[j] for j in range(n) if i & (1 << j)]\n        subsets.append(subset)\n    for subset in subsets:\n        xor_result = 0\n        for num in subset:\n            xor_result ^= num\n        if xor_result == 0:\n            return True\n    return False\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\nassert f(*g())\n",
        "idx_generation": 289,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a subset of numbers in nums that adds up to the target.\"\"\"\n    def solve(i, total):\n        if total == target:\n            return True\n        if i == len(nums) or total > target:\n            return False\n        return solve(i + 1, total + nums[i]) or solve(i + 1, total)\n    return solve(0, 0)\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g())\n",
        "idx_generation": 332,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\"\"\"\n    def dfs(graph, visited, current):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if visited[neighbor]:\n                return True\n            if dfs(graph, visited, neighbor):\n                return True\n        visited[current] = False\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if dfs(graph, visited, node):\n            return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 313,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given a positive integer n, determine the number of different binary strings of length n that do not contain any consecutive 1's.\n    Returns the count of such binary strings.\"\"\"\n    if k == 0:\n        return 1\n    elif k == 1:\n        return 2\n    else:\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2, k + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[k]\n\ndef g(n=5, k=3):\n    return (n, k)\n\nassert f(*g()) == 5\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a string can be rearranged to form a palindrome.\n    \"\"\"\n    counts = {}\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    odd_count = 0\n    for count in counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\ndef g(s: str):\n    \"\"\"\n    Generate all possible permutations of a string.\n    \"\"\"\n    permutations = []\n    for perm in itertools.permutations(s):\n        permutations.append(\"\".join(perm))\n    return permutations\n\nassert f(g(\"aab\")) == True\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given array that sum up to the target value.\nSample Input:\narr = [2, 4, 6, 8, 10]\ntarget = 14\nSample Output:\nTrue\nExplanation: The pair (4, 10) sums up to 14, hence the output is True.\"\"\"\n    arr.sort()\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            low += 1\n        else:\n            high -= 1\n    return False\ndef g(arr=[2, 4, 6, 8, 10], target=14):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if it is possible to reach the bottom-right corner from the top-left corner in the grid\"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Initialize a 2D dp array to keep track of the minimum health required\n    dp = [[float('inf')] * n for _ in range(m)]\n    \n    # Fill the last cell with 1\n    dp[m-1][n-1] = 1\n    \n    # Fill the last row and column\n    for i in range(m-2, -1, -1):\n        dp[i][n-1] = dp[i+1][n-1] - grid[i][n-1]\n        if dp[i][n-1] <= 0:\n            dp[i][n-1] = 1\n    for j in range(n-2, -1, -1):\n        dp[m-1][j] = dp[m-1][j+1] - grid[m-1][j]\n        if dp[m-1][j] <= 0:\n            dp[m-1][j] = 1\n    \n    # Fill the rest of the dp array\n    for i in range(m-2, -1, -1):\n        for j in range(n-2, -1, -1):\n            dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - grid[i][j]\n            if dp[i][j] <= 0:\n                dp[i][j] = 1\n    \n    # Return True if the top-left corner can be reached without running out of health\n    return dp[0][0] > 0\n\ndef g(grid: List[List[int]]):\n    \"\"\"Generate a grid with random health points\"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    # Randomly assign health points to each cell\n    for i in range(m):\n        for j in range(n):\n            grid[i][j] = random.randint(1, 9)\n    \n    return grid\n\nassert f(g([[5, 3, 2], [2, 9, 6], [8, 1, 2]]))\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, check if it is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return 'racecar'\n\nassert f(g())\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, determine if there exists a submatrix in it such that the sum of its elements is a prime number.\n    \n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    Sample Output:\n    True\n    \n    Explanation: In the given matrix, the submatrix [[2, 3], [5, 6]] has a sum of 16, which is a prime number.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    submatrix_sum = sum(matrix[m][n] for m in range(i, k+1) for n in range(j, l+1))\n                    if is_prime(submatrix_sum):\n                        return True\n    return False\n    \ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"The Fibonacci sequence is defined by the recurrence relation: F(n) = F(n\u22121) + F(n\u22122), where F(0) = 0 and F(1) = 1. \nGiven a positive integer n, return the nth Fibonacci number.\"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    return fibonacci(n)\ndef g(n: int):\n    return n\nassert f(g(6)) == 8\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value, determine if there exist two numbers in the list such that their XOR is equal to the target value.\n    \n    Sample Input:\n    nums = [3, 5, 9, 10, 6]\n    target = 3\n    \n    Sample Output:\n    True\n    \n    Explanation: The pair of numbers (5, 6) has an XOR value of 3, which is equal to the target.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(nums=[3, 5, 9, 10, 6], target=3):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray in nums that sums up to k.\n- nums is a list of integers\n- k is the target sum\"\"\"\n    def helper(start, curr_sum):\n        if curr_sum == k:\n            return True\n        if start == len(nums):\n            return False\n        if helper(start + 1, curr_sum + nums[start]):\n            return True\n        return helper(start + 1, curr_sum)\n    return helper(0, 0)\ndef g(nums=[1, 2, 3, 4, 5, 6], k=9):\n    return nums, k\nassert f(*g())\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph as an adjacency matrix and two nodes start and end, \n    determine if there is a path from start to end in the graph.\n    \"\"\"\n    def dfs(graph, curr, target, visited):\n        if curr == target:\n            return True\n        visited[curr] = True\n        \n        for i in range(len(graph[curr])):\n            if graph[curr][i] == 1 and not visited[i]:\n                if dfs(graph, i, target, visited):\n                    return True\n        \n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef g() -> (List[List[int]], int, int):\n    \"\"\"\n    Generate a random directed graph as an adjacency matrix and two random nodes.\n    \"\"\"\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 1],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 317,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left cell to the bottom-right cell in an n x n grid. You can only move down or right.\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\ndef g():\n    return (3,)\nassert f(*g()) == 6\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport itertools\nfrom typing import *\ndef f(words: List[str]) -> bool:\n    \"\"\"Given a list of words, find the total number of distinct pairs of words that share at least one common character.\nSample Input:\nwords = [\"cat\", \"dog\", \"bat\", \"hat\"]\nSample Output:\n3\"\"\"\n    distinct_pairs = set()\n    for pair in itertools.combinations(words, 2):\n        if any(c in pair[1] for c in pair[0]):\n            distinct_pairs.add(pair)\n    return len(distinct_pairs)\ndef g():\n    words = [\"cat\", \"dog\", \"bat\", \"hat\"]\n    return words\nassert f(g()) == 3\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if the target number exists in the list.\nArgs:\n    arr: The list of integers.\n    target: The target number to search for.\nReturns:\n    True if the target number exists, False otherwise.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\ndef g():\n    \"\"\"\n    Returns a sample sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11, 13, 15]\nassert f(g(), 7)\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order, check if there exists a pair of numbers that sums up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substring='abc') -> bool:\n    \"\"\"Check if the given substring appears at least twice in the string.\"\"\"\n    return s.count(substring) >= 2\ndef g(substring='abc'):\n    return substring + substring\nassert f(g())\n",
        "idx_generation": 267,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of positive integers, find a subset of the numbers such that the sum of the subset is equal to the target value.\"\"\"\n    n = len(numbers)\n    for i in range(2**n):\n        subset = [numbers[j] for j in range(n) if (i & (1 << j)) > 0]\n        if sum(subset) == target:\n            return True\n    return False\n\ndef g(numbers: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9], target: int = 15) -> List[int]:\n    return numbers\n\nassert f(g(), target=15)\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence in the list.\n    An increasing subsequence is a sequence of numbers where each number is greater than the previous number.\"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value, determine if there exist a subarray (consecutive elements) in the list such that the bitwise OR of all elements in the subarray is equal to the target value.\n    \n    Sample Input:\n    nums = [2, 5, 8, 3, 10]\n    target = 15\n    \n    Sample Output:\n    True\n    \n    Explanation: The subarray [8, 3, 10] has a bitwise OR value of 15, which is equal to the target.\n    \"\"\"\n    for i in range(len(nums)):\n        cur = nums[i]\n        if cur == target:\n            return True\n        for j in range(i+1, len(nums)):\n            cur |= nums[j]\n            if cur == target:\n                return True\n    return False\n\ndef g(nums=[2, 5, 8, 3, 10], target=15):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner in a n x m grid.\nYou can only move down or right.\"\"\"\n    def unique_paths(n: int, m: int) -> int:\n        if n == 1 or m == 1:\n            return 1\n        return unique_paths(n-1, m) + unique_paths(n, m-1)\n    \n    return unique_paths(n, n)\n\ndef g(n: int):\n    return n\n\nn = 3\nassert f(g(n)) == 6\n",
        "idx_generation": 351,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Given a 2D grid of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner.\n    A path can only move down or right and can only traverse through cells with a value of 1.\n    Return True if there is a path, False otherwise.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    def dfs(i, j):\n        if i == n - 1 and j == m - 1:\n            return True\n        if i >= n or j >= m or grid[i][j] != 1:\n            return False\n\n        grid[i][j] = -1\n        return dfs(i + 1, j) or dfs(i, j + 1)\n\n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 323,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> int:\n    \"\"\"Given a list of integers and a target value, find the number of unique combinations of the integers that sum up to the target.\n    Each number in the list can be used an unlimited number of times in a combination.\"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return f(nums, target)\n\nassert g() == 7\n\nassert f(g()) == True",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if a string can be constructed by concatenating a prefix and a suffix of a given string.\"\"\"\n    n = len(string)\n    for i in range(1, n):\n        prefix = string[:i]\n        suffix = string[i:]\n        if suffix.startswith(prefix):\n            return True\n    return False\n\ndef g():\n    return \"abcabc\"\n\nassert f(g())\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target=100) -> bool:\n    \"\"\"Find two numbers in the list that add up to the target.\"\"\"\n    numbers.sort()\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=100):\n    return [10, 20, 30, 40, 50, 60]\n\nassert f(g())\n",
        "idx_generation": 77,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given list of integers in descending order using the quicksort algorithm.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[0]\n    smaller = [x for x in arr[1:] if x <= pivot]\n    greater = [x for x in arr[1:] if x > pivot]\n    return f(greater) + [pivot] + f(smaller)\n\ndef g() -> List[int]:\n    return [9, 4, 7, 2, 1, 5, 3, 8, 6]\n\nassert f(g()) == [9, 8, 7, 6, 5, 4, 3, 2, 1]\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find the two numbers that add up to the target and return their indices.\n    If multiple solutions exist, return the indices of the pair with the smallest difference between the two numbers.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    min_diff = float('inf')\n    result = []\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        diff = abs(curr_sum - target)\n        \n        if diff < min_diff:\n            min_diff = diff\n            result = [left, right]\n        \n        if curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return result\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(*g(nums, target)) == [0, 1]\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of unique binary strings of length n that do not contain consecutive ones.\"\"\"\n    def backtrack(curr, length):\n        if length == n:\n            return 1\n        count = 0\n        if curr == '0':\n            count += backtrack('0', length + 1)\n            count += backtrack('1', length + 1)\n        elif curr == '1':\n            count += backtrack('0', length + 1)\n        return count\n    \n    return backtrack('0', 1) + backtrack('1', 1)\n\ndef g():\n    n = 4\n    return (n,)\n\nassert f(*g()) == 8\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum that can be obtained by summing a contiguous subarray.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g()) == 6\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of a given number.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\ndef g():\n    return 23\nassert f(g()) == 4\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(m: int, n: int) -> int:\n    \"\"\"Given m and n, find the number of unique paths from the top-left corner to the bottom-right corner in a m x n grid.\n\n    Each movement can only go either down or right.\n    \"\"\"\n    if m == 1 or n == 1:\n        return 1\n    return f(m-1, n) + f(m, n-1)\ndef g():\n    m = 3\n    n = 3\n    return m, n\nassert f(*g()) == 6\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adj_list: Dict[int, List[int]]) -> bool:\n    \"\"\"Given an adjacency list of a directed graph, determine if it contains a cycle\"\"\"\n    visited = set()\n    rec_stack = set()\n\n    def dfs(v):\n        visited.add(v)\n        rec_stack.add(v)\n\n        for neighbor in adj_list[v]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in rec_stack:\n                return True\n\n        rec_stack.remove(v)\n        return False\n\n    for vertex in adj_list:\n        if vertex not in visited:\n            if dfs(vertex):\n                return True\n\n    return False\ndef g():\n    return {1: [2], 2: [3, 4], 3: [], 4: [2]}\nassert f(g()) == True\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> int:\n    \"\"\"Given a list of numbers and a target value, find the number of combinations that add up to the target.\"\"\"\n    def helper(index, current_sum):\n        if index == len(numbers):\n            if current_sum == target:\n                return 1\n            else:\n                return 0\n        count = 0\n        count += helper(index + 1, current_sum + numbers[index])\n        count += helper(index + 1, current_sum)\n        return count\n\n    return helper(0, 0)\n\ndef g():\n    numbers = [1, 2, 3, 4, 5]\n    target = 5\n    return (numbers, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string 's' consisting of lowercase English letters, return the longest substring that contains at most two distinct characters.\n    If there are multiple longest substrings, return the one that appears first in 's'.\"\"\"\n    \n    if len(s) <= 2:\n        return s\n    \n    start = 0\n    max_len = 2\n    max_start = 0\n    \n    char_count = {}\n    \n    for i, char in enumerate(s):\n        char_count[char] = i\n        \n        if len(char_count) > 2:\n            oldest_char = min(char_count.values())\n            del char_count[s[oldest_char]]\n            start = oldest_char + 1\n        \n        if i - start + 1 > max_len:\n            max_len = i - start + 1\n            max_start = start\n    \n    return s[max_start:max_start+max_len]\n    \ndef g(s=\"abcbbbbcccbdddadacb\"):\n    return s\n\nassert f(g()) == \"bcbbbbcccb\"\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists two numbers in the list whose sum is equal to the target number.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 15\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 81,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers, find if there are two numbers that add up to the target.\"\"\"\n    numbers.sort()  # Sorting the numbers in ascending order\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    numbers = [2, 7, 11, 15]\n    target = 9\n    return numbers, target\n\nassert f(*g()) == True\n",
        "idx_generation": 201,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if it is possible to form string s by repeating a specific substring n times\"\"\"\n    substring = s[:len(s)//n]\n    return substring * n == s\ndef g(n=3):\n    return \"abc\" * n\nassert f(g())\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target_sum=15) -> bool:\n    \"\"\"Find if there exists a subset of the given list such that the sum of all elements in the subset is greater than or equal to the target sum.\"\"\"\n    def helper(nums, index, curr_sum):\n        if curr_sum >= target_sum:\n            return True\n        if index == len(nums):\n            return False\n        return helper(nums, index + 1, curr_sum + nums[index]) or helper(nums, index + 1, curr_sum)\n    return helper(nums, 0, 0)\ndef g(nums: List[int], target_sum=15):\n    return nums\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums), target_sum=15)\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two integers n and m, where n represents the number of rows and m represents the number of columns,\n    find the number of unique paths from the top-left cell to the bottom-right cell in an n x m grid.\n    The player can only move right or down in the grid.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][m - 1]\n\ndef g() -> Tuple[int, int]:\n    return (3, 4)\n\nassert f(*g()) == 10\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum XOR value between any two numbers in the array using bitwise operations.\nReturn the maximum XOR value.\n\nExample:\nInput: [3, 10, 5, 25, 2, 8]\nOutput: 28\nExplanation: The maximum XOR value is between 5 and 25 (5 XOR 25 = 28).\"\"\"\n    max_xor = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return (nums,)\nassert f(*g()) == 28\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the nth number in the Fibonacci sequence using matrix exponentiation.\n\n    Note: The Fibonacci sequence starts from 0. For example, the first number in the Fibonacci sequence is 0, the second number is 1, and so on.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    F = [[1, 1], [1, 0]]\n    power(F, n-1)\n    return F[0][0]\n\ndef multiply(F, M):\n    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]\n    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]\n    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]\n    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]\n    F[0][0] = x\n    F[0][1] = y\n    F[1][0] = z\n    F[1][1] = w\n\ndef power(F, n):\n    M = [[1, 1], [1, 0]]\n    for _ in range(2, n+1):\n        multiply(F, M)\n\ndef g():\n    n = 6\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix,\n    check if the graph contains a cycle.\n    Return True if a cycle is found, False otherwise.\"\"\"\n    def dfs(graph, visited, stack, node):\n        visited[node] = True\n        stack[node] = True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(graph, visited, stack, neighbor):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        stack[node] = False\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n    \n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(graph, visited, stack, node):\n                return True\n    \n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [1, 0, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers 'nums' and a target integer, find the number of unique combinations that add up to the target.\n    Each number in 'nums' can only be used once.\"\"\"\n\n    def helper(nums, target, index, used):\n        if target == 0:\n            return 1\n        if target < 0 or index >= len(nums):\n            return 0\n        count = 0\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            used[i] = True\n            count += helper(nums, target - nums[i], i + 1, used)\n            used[i] = False\n        return count\n\n    nums.sort()\n    used = [False] * len(nums)\n    return helper(nums, target, 0, used)\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 2, 3, 4, 5], 7)\n\nassert f(*g()) == 4\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, target: str) -> bool:\n    \"\"\"Given a string s and a target string, determine if it is possible to form the target string by rearranging the characters in s.\"\"\"\n    char_count = [0] * 26\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n    for char in target:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n    return True\n\ndef g() -> List[str]:\n    return [\"programming\", \"gmrnogpaimr\"]\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there exists a pair of numbers in the list whose sum is equal to the target. Use binary search for a more optimized solution.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list using binary search.\"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return 0\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return 1 + binary_search(nums, target, left, mid - 1) + binary_search(nums, target, mid + 1, right)\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 3, 3, 5, 5, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(s: str) -> bool:\n    \"\"\"Given a string containing only 'a' and 'b' characters, determine if it is possible to transform the string into a palindrome \n    by performing the following operation any number of times: choose a non-empty substring (not necessarily contiguous) and \n    rearrange its characters in any order.\"\"\"\n    count_a = s.count('a')\n    count_b = s.count('b')\n    if count_a % 2 == 0 and count_b % 2 == 0:\n        return True\n    elif count_a % 2 == 1 and count_b % 2 == 1:\n        return True\n    else:\n        return False\ndef g():\n    s = 'aabbaa'\n    return s\nassert f(g())\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right, and you can only visit each cell once.\n    Return the maximum sum.\"\"\"\n    def dfs(i, j, path_sum):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return path_sum + grid[i][j]\n        if i == len(grid) - 1:\n            return dfs(i, j+1, path_sum + grid[i][j])\n        if j == len(grid[0]) - 1:\n            return dfs(i+1, j, path_sum + grid[i][j])\n        return max(dfs(i+1, j, path_sum + grid[i][j]), dfs(i, j+1, path_sum + grid[i][j]))\n    \n    return dfs(0, 0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 162,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in a binary representation of a given number\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 15\n\nassert f(g()) == 4\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move down or right.\n    Args:\n        n: The size of the grid.\n    Returns:\n        The number of unique paths.\n    \"\"\"\n    def backtrack(i, j):\n        if i == n - 1 and j == n - 1:\n            return 1\n        elif i >= n or j >= n:\n            return 0\n        else:\n            return backtrack(i + 1, j) + backtrack(i, j + 1)\n    \n    return backtrack(0, 0)\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given an adjacency list representing a graph and two nodes, determine if there is a path from the start node to the\n    end node.\n    Return True if a path exists, False otherwise.\n    Example:\n    adj_list = [[1, 2], [3, 4], [5], [], [6], [7], [8], [], []]\n    start = 0\n    end = 8\n    Output: True (0 -> 1 -> 4 -> 6 -> 7 -> 8)\n    \"\"\"\n    visited = [False] * len(adj_list)\n    return dfs(adj_list, start, end, visited)\n    \ndef dfs(adj_list: List[List[int]], current: int, end: int, visited: List[bool]) -> bool:\n    if current == end:\n        return True\n    visited[current] = True\n    for neighbor in adj_list[current]:\n        if not visited[neighbor]:\n            if dfs(adj_list, neighbor, end, visited):\n                return True\n    return False\n    \ndef g():\n    return [[1, 2], [3, 4], [5], [], [6], [7], [8], [], []]\n    \nassert f(g(), 0, 8)\n",
        "idx_generation": 331,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"Generate all possible substrings of a given string.\"\"\"\n    substrings = []\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substrings.append(s[i:j])\n    return substrings\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == ['a', 'ab', 'abc', 'b', 'bc', 'c']\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 86,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose summation is equal to the target.\"\"\"\n    nums.sort()\n    (left, right) = (0, len(nums) - 1)\n    while left < right:\n        summation = nums[left] + nums[right]\n        if summation == target:\n            return True\n        elif summation < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [5, 3, 9, 10, 7, 2]\nassert f(g(), 12)\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if the list is a palindrome, and False otherwise.\"\"\"\n    return arr == arr[::-1]\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\nassert f(g([1, 2, 3, 2, 1]))\n",
        "idx_generation": 329,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of numbers in the given list that adds up to the target number.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n    \ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\ndef g():\n    return ([-2, 1, -3, 4, -1, 2, 1, -5, 4],)\nassert f(*g()) == 6\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target value k, find if there exists two integers in the list such that their bitwise AND is equal to k.\nArgs:\n    nums: The list of integers.\n    k: The target value for bitwise AND.\nReturns:\n    True if there exists two integers whose bitwise AND is equal to k, False otherwise.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == k:\n                return True\n    return False\ndef g(nums=[4, 5, 6, 7, 8], k=4):\n    return (nums, k)\nassert f(*g())\n",
        "idx_generation": 325,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], k: int) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if it is possible to find a path from the top-left corner to the bottom-right corner\n    such that the sum of the numbers along the path is equal to k. You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Create a 2D grid to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Initialize the first cell\n    dp[0][0] = grid[0][0]\n    \n    # Calculate the maximum sum at each cell\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    # Check if there is a path with sum k\n    return dp[rows-1][cols-1] == k\n\ndef g(grid: List[List[int]], k: int) -> None:\n    \"\"\"\n    Generate a grid of integers and the value of k.\n    \"\"\"\n    return (grid, k)\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nk = 12\nassert f(*g(grid, k))\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner in an n x n grid.\"\"\"\n    memo = [[0] * (n + 1) for _ in range(n + 1)]\n    def unique_paths(row: int, col: int) -> int:\n        if row == n and col == n:\n            return 1\n        if row > n or col > n:\n            return 0\n        if memo[row][col] != 0:\n            return memo[row][col]\n        memo[row][col] = unique_paths(row + 1, col) + unique_paths(row, col + 1)\n        return memo[row][col]\n    return unique_paths(1, 1)\ndef g():\n    return (3,)\nassert f(*g()) == 6\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Find a string of length n that contains all possible permutations of the characters 'a', 'b', and 'c'.\"\"\"\n    perms = [''.join(p) for p in itertools.permutations(['a', 'b', 'c'], n)]\n    return all(p in s for p in perms)\ndef g(n=4):\n    return ''.join([c * (n // 3) for c in ['a', 'b', 'c']]) + 'abc'[:n % 3]\nassert f(g())\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if x is present in the list using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g(), 12)\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 213,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target sum, find two numbers in the list that add up to the target sum and return their indices.\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Sample Output:\n    [0, 1]\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 335,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Find the majority element in a list, which appears more than n/2 times.\"\"\"\n    count = 0\n    candidate = None\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n    return candidate\ndef g():\n    return [3, 2, 3]\nassert f(g()) == 3\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path starting from the top-left corner (0, 0) and ending at the bottom-right corner (n-1, n-1), moving only downwards or rightwards.\n    Return the maximum sum.\"\"\"\n    n = len(grid)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[n-1][n-1]\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\nassert f(g()) == 12\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Given a string, determine if it can be split into n equal parts such that each part is a palindrome.\"\"\"\n    if len(s) % n != 0:\n        return False\n\n    part_length = len(s) // n\n\n    for i in range(n):\n        start = i * part_length\n        end = start + part_length\n        part = s[start:end]\n\n        if part != part[::-1]:\n            return False\n\n    return True\n\ndef g(n=3):\n    return 'level' * n\n\nassert f(g())\n",
        "idx_generation": 0,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the k-th bit of n is set (1)\"\"\"\n    return n & (1 << (k-1)) != 0\ndef g() -> tuple:\n    \"\"\"Find a positive integer n and a bit position k such that the k-th bit of n is set (1)\"\"\"\n    n = 2\n    k = 1\n    while not f(n, k):\n        n += 1\n        if n > 10:\n            n = 2\n            k += 1\n    return (n, k)\nassert f(*g())\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers `nums` and a target integer `target`, determine if it is possible to obtain `target` by adding or subtracting the numbers in `nums` together, without changing their order and without using any number more than once.\"\"\"\n    def helper(index, current_sum):\n        if current_sum == target:\n            return True\n        if index == len(nums):\n            return False\n        return helper(index + 1, current_sum + nums[index]) or helper(index + 1, current_sum - nums[index])\n    \n    return helper(0, 0)\n\ndef g() -> tuple:\n    nums = [1, 3, 5, 7]\n    target = 4\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the length of the longest increasing path. An increasing path is defined as a path in the grid where each cell's value is strictly greater than the value of the previous cell in the path. The path can only move up, down, left, or right.\nExample:\ngrid = [\n    [9, 9, 4],\n    [6, 6, 8],\n    [2, 1, 1]\n]\nOutput: 4\"\"\"\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    memo = [[0] * n for _ in range(m)]\n\n    def dfs(i: int, j: int) -> int:\n        if memo[i][j]:\n            return memo[i][j]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:\n                memo[i][j] = max(memo[i][j], dfs(ni, nj))\n        memo[i][j] += 1\n        return memo[i][j]\n\n    return max(dfs(i, j) for i in range(m) for j in range(n))\n\ndef g(grid: List[List[int]]):\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return (grid,)\n\ngrid = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\nassert f(*g(grid)) == 4\n",
        "idx_generation": 335,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a target word, find all words from the list that can be formed by rearranging the letters of the target word.\n    Return a list of words that can be formed.\n    \"\"\"\n    target_count = count_letters(target)\n    result = []\n    for word in words:\n        if count_letters(word) == target_count:\n            result.append(word)\n    return result\n\ndef count_letters(word):\n    count = [0] * 26\n    for char in word:\n        count[ord(char) - ord('a')] += 1\n    return count\n\ndef g():\n    return ([\"cat\", \"act\", \"tac\", \"dog\", \"god\"], \"act\")\n\nassert f(*g()) == ['cat', 'act', 'tac']\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value exists in the list.\n    Return True if the target value is found, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13]\n\ntarget = 7\nassert f(g(), target)\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 219,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Find the longest common prefix among a list of strings.\"\"\"\n    if not s:\n        return \"\"\n    s.sort()\n    first = s[0]\n    last = s[-1]\n    i = 0\n    while i < len(first) and first[i] == last[i]:\n        i += 1\n    return first[:i]\n\ndef g(s: List[str]):\n    return s\n\nassert f(g([\"flower\", \"flow\", \"flight\"])) == \"fl\"\n",
        "idx_generation": 341,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers 'arr', find the longest increasing subsequence (LIS) in the list. The LIS is a subsequence of 'arr' in which the elements are in increasing order, and its length is maximum.\nReturn the length of the LIS.\n\"\"\"\n    n = len(arr)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis)\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string while maintaining their order\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s=\"Hello world\"):\n    return s\n\nassert f(g()) == \"world Hello\"\n",
        "idx_generation": 3,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose bitwise XOR is equal to the target\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\ndef g(nums=[1, 2, 3, 4, 5], target=6) -> tuple:\n    \"\"\"Find a list of positive integers and a target number such that there exists a pair of numbers in the list whose bitwise XOR is equal to the target\"\"\"\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, determine the sum of the first n even numbers.\"\"\"\n    if n == 0:\n        return 0\n    return 2 * n + f(n - 1)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 30\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Determine if there exists a cycle in a directed graph.\"\"\"\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor in visited or dfs(neighbor):\n                return True\n        visited.remove(node)\n        return False\n    \n    graph = {\n        'A': ['B'],\n        'B': ['C'],\n        'C': ['D'],\n        'D': ['E', 'A'],\n        'E': []\n    }\n    visited = set()\n    \n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n    \n    return False\n\ndef g():\n    return []\n\nassert f(g()) == True\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=10, target_count=3, target_char='a') -> bool:\n    \"\"\"Find a string that has a specific length, a specific character count, and a specific character\"\"\"\n    return len(s) == target_length and s.count(target_char) == target_count\ndef g(target_length=10, target_count=3, target_char='a'):\n    return target_char * target_count + '?' * (target_length - target_count)\nassert f(g())\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D grid of integers and a target number, determine if the target number exists in the grid.\n    The grid is sorted in non-decreasing order from left to right and top to bottom.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n\n    return False\n\ndef g(grid=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return grid\n\nassert f(g(), 5) == True\n",
        "idx_generation": 89,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists two numbers in the array such that their sum is equal to the target.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8], 10\n\nassert f(*g())\n",
        "idx_generation": 219,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Given a string and an integer k, rotate the characters in the string by k positions to the right.\n    Return the rotated string.\"\"\"\n    k = k % len(s)\n    return s[-k:] + s[:-k]\n\ndef g():\n    return (\"hello\", 2)\n\nassert f(*g()) == \"lohel\"\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"Given a list of n integers, determine if there exists a subsequence of length k such that the sum of the subsequence is equal to the target value.\"\"\"\n    def backtrack(i, count, total):\n        if count == k and total == target:\n            return True\n        if i == n or count > k or total > target:\n            return False\n        return backtrack(i + 1, count + 1, total + nums[i]) or backtrack(i + 1, count, total)\n    \n    nums = list(range(1, n + 1))\n    return backtrack(0, 0, 0)\n\ndef g(n=5, k=3, target=10):\n    return n, k, target\n\nassert f(*g())\n",
        "idx_generation": 168,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\n# Test case\nassert f(g())\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a power of two.\n    Return True if the number is a power of two, False otherwise.\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 338,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the sum of the first n natural numbers is divisible by n.\"\"\"\n    return sum(range(n+1)) % n == 0\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the sum of the squares of the first n natural numbers.\"\"\"\n    def recursive_sum(n: int) -> int:\n        if n == 0:\n            return 0\n        return n**2 + recursive_sum(n-1)\n    \n    return recursive_sum(n)\n\ndef g(n=5):\n    \"\"\"\n    Returns the value of n: 5\n    \"\"\"\n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a directed graph contains a cycle.\"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n    \n    def has_cycle(node):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    for node in range(len(graph)):\n        if not visited[node]:\n            if has_cycle(node):\n                return True\n    \n    return False\n\ndef g():\n    return ([[1], [2], [3], [0]],)\n\nassert f(*g())\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=10, target_char='a') -> bool:\n    \"\"\"Find a string that has a specific length and contains a specific character at an even index\"\"\"\n    return len(s) == target_length and s[::2].count(target_char) > 0\ndef g(target_length=10, target_char='a'):\n    return target_char + '?' * (target_length - 1)\nassert f(g())\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target using binary search.\"\"\"\n    def binary_search(arr: List[int], target: int) -> bool:\n        low = 0\n        high = len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return False\n    \n    nums.sort()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums[i+1:], complement):\n            return True\n    return False\n\ndef g(nums=[1, 4, 6, 8, 10, 12], target=14):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list where each element is the sum of all the even numbers in the original list up to that index.\"\"\"\n    def even_sum(idx: int) -> int:\n        if idx == 0:\n            return 0\n        curr_sum = 0\n        for i in range(idx + 1):\n            if nums[i] % 2 == 0:\n                curr_sum += nums[i]\n        return curr_sum\n    return [even_sum(i) for i in range(len(nums))]\n    \ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    return (nums,)\n    \nassert f(*g()) == [0, 2, 2, 6, 6, 12, 12, 20]\n",
        "idx_generation": 221,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, check if there exists a substring of length k in s that has even number of 1s in its binary representation.\"\"\"\n    for i in range(len(s) - k + 1):\n        substring = s[i:i+k]\n        num_ones = bin(int(substring, 2)).count('1')\n        if num_ones % 2 == 0:\n            return True\n    return False\n\ndef g(s: str=\"110101011011\"):\n    return s\n\nassert f(g(), k=3) == True\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of positive integers and a target number, determine if it is possible to select exactly 'k' numbers from the list such that their sum is equal to the target number.\"\"\"\n    def helper(curr_sum, curr_index, curr_count):\n        if curr_sum == target and curr_count == k:\n            return True\n        if curr_sum > target or curr_count > k or curr_index >= len(nums):\n            return False\n        return helper(curr_sum + nums[curr_index], curr_index + 1, curr_count + 1) or helper(curr_sum, curr_index + 1, curr_count)\n\n    return helper(0, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9, k=3):\n    return (nums, target, k)\n\nassert f(*g())\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(target: str, words: List[str]) -> bool:\n    \"\"\"Check if the target string can be constructed using the given list of words.\"\"\"\n    def can_construct(target, words, memo={}):\n        if target in memo:\n            return memo[target]\n        if target == '':\n            return True\n        for word in words:\n            if target.startswith(word):\n                suffix = target[len(word):]\n                if can_construct(suffix, words, memo):\n                    memo[target] = True\n                    return True\n        memo[target] = False\n        return False\n    return can_construct(target, words)\ndef g():\n    target = \"python\"\n    words = [\"py\", \"thon\", \"pyt\", \"pyth\", \"on\"]\n    return target, words\nassert f(*g())\n",
        "idx_generation": 10,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits (1s) in the binary representation of a given number.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\ndef g():\n    return 25\nassert f(g()) == 3\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(m: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(m)\n    target_sum = n * (n ** 2 + 1) // 2\n    \n    # Check rows\n    for row in m:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(m[i][col] for i in range(n)) != target_sum:\n            return False\n    \n    # Check diagonals\n    if sum(m[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(m[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a magic square.\"\"\"\n    import random\n\n    n = 3\n    magic_square = [[0] * n for _ in range(n)]\n    row = 0\n    col = n // 2\n\n    for num in range(1, n ** 2 + 1):\n        magic_square[row][col] = num\n        row -= 1\n        col += 1\n\n        if num % n == 0:\n            row += 2\n            col -= 1\n        elif col == n:\n            col = 0\n        elif row == -1:\n            row = n - 1\n    \n    return magic_square\n\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be represented as a sum of distinct Fibonacci numbers.\"\"\"\n    def fibonacci(n):\n        fib = [0, 1]\n        while fib[-1] < n:\n            fib.append(fib[-1] + fib[-2])\n        return fib\n    def helper(n, fib, k):\n        if n == 0:\n            return True\n        if n < 0 or k < 0:\n            return False\n        return helper(n, fib, k-1) or helper(n - fib[k], fib, k-1)\n    fib = fibonacci(n)\n    return helper(n, fib, len(fib)-1)\ndef g(n: int):\n    return f(n)\nassert f(g(n=21))\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, graph: List[List[int]]) -> int:\n    \"\"\"Given a graph represented as an adjacency list and an integer n, determine the number of unique paths\n    from node 0 to node n-1. Each path can only traverse the graph in the forward direction (from lower index to higher index).\n    Return the total number of unique paths.\"\"\"\n    def dfs(node: int) -> int:\n        if node == n-1:\n            return 1\n        if memo[node] != -1:\n            return memo[node]\n        total_paths = 0\n        for neighbor in graph[node]:\n            total_paths += dfs(neighbor)\n        memo[node] = total_paths\n        return total_paths\n        \n    memo = [-1] * n\n    return dfs(0)\n\ndef g(n: int, graph: List[List[int]]) -> Tuple[int, List[List[int]]]:\n    return (n, graph)\n\ngraph = [[1, 2], [3], [3], []]\nn = 4\nassert f(*g(n, graph)) == 2\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that add up to the target.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 3, 9, 2]\n\nassert f(g(), 7)\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer 'n', find if 'n' is a perfect square.\"\"\"\n    def helper(low, high, n):\n        if low > high:\n            return False\n        mid = (low + high) // 2\n        mid_square = mid**2\n        if mid_square == n:\n            return True\n        elif mid_square < n:\n            return helper(mid + 1, high, n)\n        else:\n            return helper(low, mid - 1, n)\n    return helper(0, n, n)\ndef g(n: int):\n    return f(n)\nassert f(g(25))\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists two numbers in the list such that their sum is equal to the target number.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    return (nums, target)\nassert f(*g()) == True\n",
        "idx_generation": 356,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a subset of numbers that sums up to the target.\"\"\"\n    def helper(numbers, target, index):\n        if target == 0:\n            return True\n        if index >= len(numbers):\n            return False\n        if numbers[index] > target:\n            return helper(numbers, target, index + 1)\n        return helper(numbers, target - numbers[index], index + 1) or helper(numbers, target, index + 1)\n\n    return helper(numbers, target, 0)\n\ndef g():\n    numbers = [1, 2, 3, 4, 5]\n    target = 9\n    return numbers, target\n\nassert f(*g()) == True\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python', substring='thon') -> bool:\n    \"\"\"Check if the given string contains the substring 'thon' at any position.\"\"\"\n    return substring in s\ndef g(target='python', substring='thon'):\n    return target\nassert f(g())\n",
        "idx_generation": 11,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return (42,)\n\nassert f(*g()) == 3\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, x=2) -> bool:\n    \"\"\"Determine if a number n is a power of x.\"\"\"\n    return math.log(n, x).is_integer()\n\ndef g(x=2):\n    return x ** 10\n\nassert f(g())\n",
        "idx_generation": 27,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the number of ways to form a staircase with n steps. Each step is either 1 or 2 units.\n    \n    Sample input:\n    4\n    Sample output:\n    5\n    Explanation: There are 5 different ways to form a staircase with 4 steps: [1, 1, 1, 1], [2, 1, 1], [1, 2, 1], [1, 1, 2], [2, 2]\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n: int):\n    return n\n\nassert f(g(4)) == 5\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(graph: Dict[int, List[int]]) -> bool:\n    \"\"\"Check if a given directed graph contains a cycle.\"\"\"\n    def dfs(node, visited, recursion_stack):\n        visited[node] = True\n        recursion_stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n    return False\ndef g(graph={0: [1, 2], 1: [2], 2: [3], 3: [4], 4: [2]}):\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 356,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if a target value is present in a sorted list using binary search without recursion.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\ndef g(arr=[2, 4, 6, 8, 10, 12, 14, 16, 18, 20], target=12):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the array that add up to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [2, 4, 1, 6, 5]\n    target = 7\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the order of words in the string.\nWords in the string are separated by a single space.\nReturn the reversed string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\ndef g():\n    return ('Hello World', )\nassert f(*g()) == 'World Hello'\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, a=5, b=37) -> bool:\n    \"\"\"Check if the binary representation of n has exactly a set of consecutive 1s of length b.\"\"\"\n    binary = bin(n)[2:]\n    return '1' * b in binary\ndef g(a=5, b=37):\n    n = int('1' * b + '0', 2)\n    return n\nassert f(g())\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to climb n stairs, where you can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string s is a palindrome\"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"radar\"\n\nassert f(g())\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of elements in the list such that their XOR is divisible by 7.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 7 == 0:\n                return True\n    return False\n\ndef g():\n    nums = [3, 7, 5, 6, 2, 9, 1, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Find the sum of the first n terms of the Fibonacci sequence and check if it is a palindrome.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    sum_fib = sum(fib)\n    return str(sum_fib) == str(sum_fib)[::-1]\ndef g(n=3):\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib\nassert f(g())\n",
        "idx_generation": 58,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if it is possible to obtain the target by performing a sequence of mathematical operations (+, -, *, /) on the numbers in nums, using each number exactly once.\"\"\"\n    def helper(nums, target):\n        if len(nums) == 1:\n            return nums[0] == target\n        for i in range(len(nums)):\n            remaining_nums = nums[:i] + nums[i+1:]\n            if helper(remaining_nums, target - nums[i]) or helper(remaining_nums, target + nums[i]) or helper(remaining_nums, target * nums[i]) or (target % nums[i] == 0 and helper(remaining_nums, target / nums[i])):\n                return True\n        return False\n    \n    return helper(nums, target)\n    \ndef g(nums=[1, 2, 3, 4, 5], target=12):\n    return (nums, target)\n    \nassert f(*g())\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\nYou can only move down or right at any point in time.\"\"\"\n    memo = [[0] * n for _ in range(n)]\n    def unique_paths(i: int, j: int) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if memo[i][j] != 0:\n            return memo[i][j]\n        memo[i][j] = unique_paths(i+1, j) + unique_paths(i, j+1)\n        return memo[i][j]\n    return unique_paths(0, 0)\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g(arr=[5, 2, 8, 1, 3]):\n    return arr\n\nassert f(g()) == [1, 2, 3, 5, 8]\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists a pair of elements whose sum is equal to the target value.\"\"\"\n    def helper(arr, target, left, right):\n        if left >= right:\n            return False\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            return helper(arr, target, left + 1, right)\n        else:\n            return helper(arr, target, left, right - 1)\n    return helper(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=12):\n    return arr\n\nassert f(g(), target=10)\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return 'racecar'\nassert f(g())\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\n# Test case\nassert f(g())\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence in the list.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(arr=[5, 2, 8, 6, 3, 6, 9, 7]):\n    return (arr,)\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome after removing exactly one character.\"\"\"\n    n = len(s)\n    i, j = 0, n - 1\n    while i < j:\n        if s[i] != s[j]:\n            return s[i + 1:j + 1] == s[i + 1:j + 1][::-1] or s[i:j] == s[i:j][::-1]\n        i += 1\n        j -= 1\n    return True\n\ndef g():\n    return 'racecar'\n\nassert f(g())\n",
        "idx_generation": 14,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the single number that appears only once in the given list. All other numbers appear twice.\"\"\"\n    unique = 0\n    for num in nums:\n        unique ^= num\n    return unique\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\nassert f(g()) == 3\n",
        "idx_generation": 351,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of valid strings of length n\"\"\"\n    return g(n) == 2**n\n\ndef g(n: int) -> int:\n    \"\"\"Calculate the number of valid strings of length n\"\"\"\n    return 2**n\n\nassert f(g(n=5))\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of valid parentheses expressions of length n.\n    A valid parentheses expression is one that:\n    - Contains only '(' and ')' characters\n    - Has an equal number of opening '(' and closing ')' parentheses\n    - Does not have any unclosed parentheses\n    Sample Input:\n    n = 4\n    Sample Output:\n    2\n    \"\"\"\n    if n % 2 != 0:\n        return 0\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(2, n + 1, 2):\n        for j in range(2, i + 1, 2):\n            dp[i] += dp[j - 2] * dp[i - j]\n\n    return dp[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of 0s and 1s, find the number of distinct islands in the grid.\n    An island is a group of connected 1s, where connectivity is determined by vertical and horizontal directions.\n    Two islands are considered distinct if they have different shapes or configurations, even if they have the same number of 1s.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    islands = set()\n    def dfs(i: int, j: int, shape: List[List[int]]) -> List[List[int]]:\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return shape\n        grid[i][j] = -1\n        shape.append([i, j])\n        shape = dfs(i - 1, j, shape)\n        shape = dfs(i + 1, j, shape)\n        shape = dfs(i, j - 1, shape)\n        shape = dfs(i, j + 1, shape)\n        return shape\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                shape = dfs(i, j, [])\n                islands.add(tuple(tuple(cell) for cell in shape))\n    return len(islands)\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]])) == 2\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target=5) -> bool:\n    \"\"\"Given a 2D grid of integers and a target value, check if the target value exists in the grid.\n    The grid is sorted in increasing order from left to right and top to bottom.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    return False\n\ndef g():\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 100,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, return the maximum product of any three numbers in the list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\ndef g(nums: List[int]):\n    return nums\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert f(g(nums)) == 504\n",
        "idx_generation": 240,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, remove all duplicates and return the modified list.\"\"\"\n    return list(set(nums))\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 2, 3, 5, 6, 4]\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, determine if it is a magic square. A magic square is a square matrix where the sums of each row, each column, and both diagonals are equal.\nSample input:\nmatrix = [\n    [2, 7, 6],\n    [9, 5, 1],\n    [4, 3, 8]\n]\nSample output:\nTrue\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Sum of the first row\n    # Check row sums\n    if any(sum(row) != target_sum for row in matrix):\n        return False\n    # Check column sums\n    if any(sum(col) != target_sum for col in zip(*matrix)):\n        return False\n    # Check diagonal sums\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    return True\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\nassert f(g())\n",
        "idx_generation": 5,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum of values from the top-left corner to the bottom-right corner.\n    The grid is represented by a 2D list of integers, where each integer represents the value of a cell.\n    The valid path can only consist of rightward and downward movements, and each cell can only be visited once.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 29\n",
        "idx_generation": 175,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python') -> bool:\n    \"\"\"Check if the given string is a rotation of the target string.\"\"\"\n    return len(s) == len(target) and target in s + s\n\ndef g(target='python'):\n    return target\n\nassert f(g())\n",
        "idx_generation": 14,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, m: int) -> bool:\n    \"\"\"Check if the bitwise XOR of two positive integers is equal to their bitwise OR operation.\"\"\"\n    xor_result = n ^ m\n    or_result = n | m\n    return xor_result == or_result\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers.\n    \"\"\"\n    return (7, 12)\nassert f(*g()) == False\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine whether it can be expressed as the sum of two prime numbers.\n    Return True if n can be expressed as the sum of two prime numbers, False otherwise.\"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    for i in range(2, n//2 + 1):\n        if is_prime(i) and is_prime(n-i):\n            return True\n    return False\n\ndef g():\n    return 25\n\nassert f(g())\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner in an\n    n x m grid. You can only move down or right.\"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n-1, m) + f(n, m-1)\n\ndef g(n: int, m: int) -> Tuple[int, int]:\n    return n, m\n\nn = 3\nm = 4\nassert f(*g(n, m)) == 10\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int] = []) -> bool:\n    \"\"\"Find if there is a path from start to end in a directed graph.\"\"\"\n    path = path + [start]\n    if start == end:\n        return True\n    if start not in range(len(graph)):\n        return False\n    for node in graph[start]:\n        if node not in path:\n            if f(graph, node, end, path):\n                return True\n    return False\n\ndef g():\n    graph = [[1, 2], [2], [0, 3], []]\n    start = 0\n    end = 3\n    return (graph, start, end)\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find a pair of numbers in the given list whose sum is closest to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    closest_sum = float('inf')\n    closest_pair = []\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if abs(current_sum - target) < abs(closest_sum - target):\n            closest_sum = current_sum\n            closest_pair = [arr[left], arr[right]]\n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_pair\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), 9) == [2, 7]\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a sorted array of integers, find the index of the target element using binary search.\"\"\"\n    def binary_search(arr, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, right)\n        else:\n            return binary_search(arr, target, left, mid - 1)\n\n    target = arr[-1]\n    return binary_search(arr, target, 0, len(arr) - 1) == len(arr) - 1\n\ndef g():\n    return [4, 8, 12, 16, 20, 24, 28, 32, 36, 40]\n\nassert f(g())\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Given a string and an integer k, rotate the string k times to the right.\"\"\"\n    n = len(s)\n    k %= n\n    return s[n - k:] + s[:n - k]\ndef g(s='hello world', k=3):\n    return s\nassert f(g(), k=2) == 'ldhello wor'\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray where the subarray must contain at least one positive number.\"\"\"\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < 0:\n            current_sum = 0\n        elif current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n\ndef g(nums=[-2, -3, 4, -1, -2, 1, 5, -3]):\n    return nums\n\nassert f(g()) == 7\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target_sum: int) -> bool:\n    \"\"\"Find if there exists a subset of the given array whose sum is equal to the target sum\"\"\"\n    n = len(arr)\n    dp = [[False for _ in range(target_sum+1)] for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(target_sum+1):\n            if j < arr[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]]\n\n    return dp[n][target_sum]\n\ndef g(arr: List[int], target_sum: int) -> List[int]:\n    return arr\n\nassert f(g([1, 2, 3, 4, 5], 10), 10)\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Check if there are at least k distinct characters in the string\"\"\"\n    return len(set(s)) >= k\n\ndef g(k=3):\n    return 'abccba'\n\nassert f(g())\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]], k: int) -> bool:\n    \"\"\"Given a matrix of integers and a target number 'k', determine if there exists a submatrix whose bitwise XOR is equal to 'k'.\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            for a in range(i, rows):\n                for b in range(j, cols):\n                    submatrix_xor = matrix[i][j]\n                    for x in range(i, a + 1):\n                        for y in range(j, b + 1):\n                            submatrix_xor ^= matrix[x][y]\n                    if submatrix_xor == k:\n                        return True\n    return False\ndef g(k: int) -> List[List[int]]:\n    \"\"\"Returns a matrix where there exists a submatrix whose bitwise XOR is equal to the given number 'k'.\"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, k]]\nassert f(g(9), 9)\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=13):\n    return n\n\nassert f(g())\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers `nums` and a target integer `target`, determine if it is possible to obtain `target` by performing mathematical operations (addition, subtraction, multiplication, and division) on the numbers in `nums`, without changing their order and without using any number more than once.\"\"\"\n    def helper(index, current_val):\n        if current_val == target:\n            return True\n        if index == len(nums):\n            return False\n        return helper(index + 1, current_val + nums[index]) or helper(index + 1, current_val - nums[index]) or helper(index + 1, current_val * nums[index]) or (nums[index] != 0 and current_val % nums[index] == 0 and helper(index + 1, current_val // nums[index]))\n    return helper(0, 0)\ndef g() -> tuple:\n    nums = [2, 4, 6]\n    target = 8\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 444,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains a cycle.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def has_cycle(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if has_cycle(node):\n                return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given sorted list using binary search.\n    If the target is not found, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]\nassert f(g(), 13) == 6\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Find a pair of numbers in the list that sum up to the target\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 7, 9, 3, 2, 6]\n\nassert f(g())\n",
        "idx_generation": 249,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\n\ndef f(s: str, sorted_strings=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew']) -> bool:\n    \"\"\"Check if a given string is present in the sorted list of strings.\"\"\"\n    return s in sorted_strings\n\ndef g(sorted_strings=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew']):\n    return random.choice(sorted_strings)\n\nassert f(g())\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a magic square, where the sum of each row, column, and diagonal is the same.\"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n    # Check rows\n    for row in grid:\n        if sum(row) != target_sum:\n            return False\n    # Check columns\n    for col in range(n):\n        if sum(grid[row][col] for row in range(n)) != target_sum:\n            return False\n    # Check diagonals\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    return True\n\ndef g(n=3):\n    from itertools import permutations\n    # Generate all possible permutations of numbers from 1 to n^2\n    numbers = list(range(1, n**2+1))\n    perms = permutations(numbers)\n    # Check each permutation to find a magic square\n    for perm in perms:\n        grid = [[perm[j+n*i] for j in range(n)] for i in range(n)]\n        if f(grid):\n            return grid\n    assert False, f\"No magic square found for size {n}\"\n    \nassert f(g())\n",
        "idx_generation": 12,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Return the maximum sum.\"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g(grid: List[List[int]]):\n    return (grid,)\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(*g(grid)) == 12\n",
        "idx_generation": 179,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if a given string can be converted to the target string by removing one character.\"\"\"\n    if len(s) != len(target) + 1:\n        return False\n    i = 0\n    j = 0\n    while i < len(s) and j < len(target):\n        if s[i] == target[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return j == len(target)\n\ndef g(target: str) -> str:\n    \"\"\"Generate a string by inserting a random character into the target string.\"\"\"\n    import random\n    index = random.randint(0, len(target))\n    return target[:index] + random.choice('abcdefghijklmnopqrstuvwxyz') + target[index:]\n\nassert f(g(\"hello\"), \"hello\")\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of non-negative integers, return the maximum XOR value between any two numbers in the list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\nassert f(*g()) == 7\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all even numbers less than or equal to n using mathematical formula.\"\"\"\n    m = n // 2\n    return m * (m + 1)\n\ndef g():\n    return 100\n\nassert f(g()) == 2550\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, result: int) -> bool:\n    \"\"\"Given two integers n and k, the goal is to find an integer 'result' such that\n    the sum of the first k terms in the Fibonacci sequence, starting from 0, is equal to 'result'.\n    Return True if 'result' is correct, and False otherwise.\"\"\"\n    \n    def calculate_fibonacci(n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)\n        \n    fibonacci_sum = 0\n    for i in range(k):\n        fibonacci_sum += calculate_fibonacci(i)\n        \n    return fibonacci_sum == result\n\n\ndef g(n: int, k: int) -> int:\n    \"\"\"Given two integers n and k, the goal is to find an integer 'result' such that\n    the sum of the first k terms in the Fibonacci sequence, starting from 0, is equal to 'result'.\n    Return the value of 'result'.\"\"\"\n    \n    def calculate_fibonacci(n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)\n        \n    fibonacci_sum = 0\n    for i in range(k):\n        fibonacci_sum += calculate_fibonacci(i)\n        \n    return fibonacci_sum\n\n\nassert f(10, 5, g(10, 5))\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine the number of unique paths to reach the bottom-right corner of an n x n grid from the top-left corner.\nYou can only move down or right.\"\"\"\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    return dp[n-1][n-1]\ndef g(n=3):\n    return n\nassert f(g()) == 6\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two integers in the list that add up to the target.\nReturn True if such integers exist, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there is a subset of the given list of numbers that adds up to the target.\"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, memo: dict) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        if nums[index] <= target:\n            if subset_sum(nums, target - nums[index], index + 1, memo):\n                memo[(index, target)] = True\n                return True\n        memo[(index, target)] = subset_sum(nums, target, index + 1, memo)\n        return memo[(index, target)]\n\n    nums.sort()\n    return subset_sum(nums, target, 0, {})\n\ndef g():\n    nums = [3, 4, 5, 6, 7]\n    target = 13\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string contains exactly n occurrences of the character 'a', and that the string is sorted in ascending order.\"\"\"\n    return s.count('a') == n and s == ''.join(sorted(s))\ndef g(n=3):\n    return 'a' * n\nassert f(g(), 3)\n",
        "idx_generation": 379,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=8) -> bool:\n    \"\"\"Check if the sum of any two numbers in the matrix equals the target\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(n):\n            for k in range(i+1, n):\n                for l in range(n):\n                    if matrix[i][j] + matrix[k][l] == target:\n                        return True\n    return False\n\ndef g(target=8):\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the length of the longest increasing path in a matrix\"\"\"\n    if not matrix:\n        return 0\n        \n    m, n = len(matrix), len(matrix[0])\n    memo = [[0] * n for _ in range(m)]\n    \n    def dfs(i, j):\n        if memo[i][j] != 0:\n            return memo[i][j]\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                memo[i][j] = max(memo[i][j], dfs(x, y))\n        \n        memo[i][j] += 1\n        return memo[i][j]\n    \n    result = 0\n    for i in range(m):\n        for j in range(n):\n            result = max(result, dfs(i, j))\n            \n    return result\n\ndef g(matrix=[[9, 9, 4], [6, 6, 8], [2, 1, 1]]):\n    return matrix\n\nassert f(g()) == 4\n",
        "idx_generation": 179,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"Generate a palindrome string.\"\"\"\n    import random\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    length = random.randint(1, 10)\n    s = ''.join(random.choice(letters) for _ in range(length))\n    return s + s[::-1]\n\nassert f(g())\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the total number of set bits in the binary representation of a given number.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int):\n    return n\n\nn = 15\nassert f(g(n)) == 4\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, x: int) -> bool:\n    \"\"\"Check if a number n is a power of x.\"\"\"\n    if n == 1:\n        return True\n    if n < 1 or x == 1:\n        return False\n    return f(n / x, x)\ndef g(n=16, x=2):\n    return (n, x)\nassert f(*g())\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib[n]\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph as an adjacency matrix, return the depth-first traversal starting from node 0.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        traversal.append(node)\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor)\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    traversal = []\n\n    dfs(0)\n\n    return traversal\n\ndef g():\n    return ([[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]],)\n\nassert f(*g()) == [0, 1, 3, 2]\n",
        "idx_generation": 382,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nassert f(g(), 10)\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of elements in the list that sum up to the target value.\n    Return True if the sum of any two elements equals to target, False otherwise.\"\"\"\n    arr.sort()\n    start = 0\n    end = len(arr) - 1\n    while start < end:\n        current_sum = arr[start] + arr[end]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9]):\n    \"\"\"Return the input list as it is\"\"\"\n    return arr\n\nassert f(g())\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string contains exactly n occurrences of the character 'a', and that the string is sorted in descending order.\"\"\"\n    return s.count('a') == n and s == ''.join(sorted(s, reverse=True))\ndef g(n=4):\n    return 'a' * n\nassert f(g(), 4)\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target_sum=100) -> bool:\n    \"\"\"Find a subset of numbers that adds up to the target sum.\"\"\"\n    subset_sum = 0\n    for num in numbers:\n        subset_sum += num\n        if subset_sum == target_sum:\n            return True\n        if subset_sum > target_sum:\n            return False\n    return False\n\ndef g(target_sum=100):\n    numbers = [10, 20, 30, 40, 50, 60, 70, 80, 90]\n    subset = []\n    for num in numbers:\n        if sum(subset) + num <= target_sum:\n            subset.append(num)\n    return subset\n\nassert f(g())\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid represented as a 2D list of integers, find the maximum sum of numbers in a path from the top-left cell to the bottom-right cell.\nThe path can only consist of rightward and downward movements.\nArgs:\n    grid: The grid represented as a 2D list of integers.\nReturns:\n    The maximum sum of numbers in a path from the top-left cell to the bottom-right cell.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g():\n    \"\"\"Returns a grid represented as a 2D list of integers.\"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, n=10) -> bool:\n    \"\"\"Check if the given string is a valid ISBN-10 number.\"\"\"\n    if len(s) != 10:\n        return False\n    \n    sum = 0\n    for i in range(1, 11):\n        if s[i-1] == 'X':\n            sum += 10 * (11-i)\n        elif not s[i-1].isdigit():\n            return False\n        else:\n            sum += int(s[i-1]) * (11-i)\n    \n    return sum % 11 == 0\n\ndef g() -> str:\n    \"\"\"Generate a valid ISBN-10 number.\"\"\"\n    import random\n\n    sum = 0\n    digits = []\n    for i in range(1, 10):\n        digit = random.randint(0, 9)\n        digits.append(str(digit))\n        sum += digit * (11-i)\n    \n    last_digit = (11 - (sum % 11)) % 11\n    digits.append(str(last_digit) if last_digit < 10 else 'X')\n    \n    return ''.join(digits)\n\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Find the kth digit from the right in the binary representation of n\"\"\"\n    binary = bin(n)[2:]\n    if k <= len(binary):\n        return int(binary[-k])\n    else:\n        return -1\ndef g():\n    n = 13\n    k = 3\n    return (n, k)\nassert f(*g()) == 1\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the smallest positive integer whose digits sum up to n.\"\"\"\n    s = sum(int(digit) for digit in str(n))\n    return s == n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the number of ways to climb n stairs, where you can take either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)  # Initialize a dynamic programming list to store the number of ways to climb each step\n    dp[0] = 1  # There is 1 way to climb 0 stairs (by not climbing any step)\n    dp[1] = 1  # There is 1 way to climb 1 stair (by taking 1 step)\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]  # The number of ways to climb the current step is equal to the sum of the number of ways to climb the previous step and the step before that\n    return dp[n]\n\ndef g():\n    return 5  # Example input\n\nassert f(g()) == 8  # There are 8 ways to climb 5 stairs\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"Check if it is possible to reach the end position from the start position in the maze.\"\"\"\n    rows = len(maze)\n    columns = len(maze[0])\n    \n    # Initialize a visited matrix\n    visited = [[False] * columns for _ in range(rows)]\n    \n    # Define the directions to move in the maze\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def dfs(row: int, column: int) -> bool:\n        # Check if the current position is out of bounds or a wall or already visited\n        if row < 0 or row >= rows or column < 0 or column >= columns or maze[row][column] == 1 or visited[row][column]:\n            return False\n        \n        # Check if the current position is the end position\n        if row == end[0] and column == end[1]:\n            return True\n        \n        # Mark the current position as visited\n        visited[row][column] = True\n        \n        # Explore all possible directions\n        for direction in directions:\n            new_row = row + direction[0]\n            new_column = column + direction[1]\n            if dfs(new_row, new_column):\n                return True\n        \n        # Mark the current position as unvisited\n        visited[row][column] = False\n        \n        return False\n    \n    return dfs(start[0], start[1])\n\ndef g(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]):\n    return (maze, start, end)\n\nassert f(*g([\n    [0, 1, 0, 0],\n    [0, 0, 0, 1],\n    [1, 1, 0, 0],\n    [0, 1, 0, 0]\n], (0, 0), (3, 3)))\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return ([4, 6, 2, 8, 3, 1], 10)\n\nassert f(*g()) == [2, 8]\n",
        "idx_generation": 107,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(array: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n    \n    Sample Input:\n    array = [10, 9, 2, 5, 3, 7, 101, 18]\n    \n    Sample Output:\n    4\n    \"\"\"\n    def helper(array, index, previous, length):\n        if index == len(array):\n            return length\n        \n        taken = 0\n        if array[index] > previous:\n            taken = helper(array, index + 1, array[index], length + 1)\n        \n        not_taken = helper(array, index + 1, previous, length)\n        \n        return max(taken, not_taken)\n    \n    return helper(array, 0, float('-inf'), 0)\n\ndef g(array=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return array\n\nassert f(g()) == 4\n",
        "idx_generation": 255,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = string.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words\ndef g() -> str:\n    return \"Hello World\"\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 385,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int, m: int) -> bool:\n    \"\"\"Check if the given string is a palindrome and if the sum of its digits is divisible by n, and if the count of vowels is divisible by m.\"\"\"\n    is_palindrome = s == s[::-1]\n    digit_sum = sum([int(d) for d in s if d.isdigit()])\n    vowel_count = sum([1 for c in s.lower() if c in ['a', 'e', 'i', 'o', 'u']])\n    return is_palindrome and digit_sum % n == 0 and vowel_count % m == 0\n\ndef g(n: int, m: int):\n    return '1221' if n == 2 and m == 3 else '12221'\n\nassert f(g(2, 3), 2, 3)\n",
        "idx_generation": 18,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Given a list of integers, find if there is a subset that sums up to the target value.\"\"\"\n    def subsetSum(nums, target, index):\n        if target == 0:\n            return True\n        if index < 0 or target < 0:\n            return False\n        include = subsetSum(nums, target - nums[index], index - 1)\n        exclude = subsetSum(nums, target, index - 1)\n        return include or exclude\n    \n    return subsetSum(nums, target, len(nums) - 1)\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 182,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if the given string is a palindrome after reversing it and removing non-alphabetic characters.\"\"\"\n    s = ''.join([c.lower() for c in s if c.isalpha()])\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"Generate a string that is a palindrome after reversing it and removing non-alphabetic characters.\"\"\"\n    import random\n    import string\n\n    length = random.randint(5, 10)\n    word = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    word += ''.join(random.choice(string.punctuation) for _ in range(random.randint(1, 3)))\n    return word + word[::-1]\n\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in a binary representation of a given number.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\ndef g(n: int):\n    return n\nassert f(g(10)) == 2\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a perfect square.\"\"\"\n    return n ** 0.5 % 1 == 0\ndef g(n: int):\n    return n ** 0.5\nassert f(g(n=16))\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move down or right at each step.\"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n-1)\n    return factorial(2*n-2) // (factorial(n-1) ** 2)\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef f(root: Node) -> int:\n    \"\"\"Given the root of a binary tree, determine the height of the tree.\"\"\"\n    if root is None:\n        return 0\n    \n    left_height = f(root.left)\n    right_height = f(root.right)\n    \n    return max(left_height, right_height) + 1\n\ndef g(root: Node):\n    return (root,)\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nassert f(*g(root)) == 3\n",
        "idx_generation": 387,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a pair of integers in the given list whose sum is equal to the target number.\"\"\"\n    sorted_arr = sorted(arr)\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = sorted_arr[left] + sorted_arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 116,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Determine if the target value exists in the grid, where each row and column is sorted in ascending order.\"\"\"\n\n    def search(matrix: List[List[int]], target: int, row: int, col: int) -> bool:\n        if row >= len(matrix) or col < 0:\n            return False\n        if matrix[row][col] == target:\n            return True\n        if matrix[row][col] < target:\n            return search(matrix, target, row + 1, col)\n        else:\n            return search(matrix, target, row, col - 1)\n\n    if not grid or not grid[0]:\n        return False\n    return search(grid, target, 0, len(grid[0]) - 1)\n\ndef g(grid: List[List[int]], target: int):\n    return (grid, target)\n\nassert f(*g([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5)) == True\n",
        "idx_generation": 255,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 and s2 are anagrams (have the same characters) after removing spaces.\"\"\"\n    s1 = s1.replace(' ', '')\n    s2 = s2.replace(' ', '')\n    return sorted(s1) == sorted(s2)\ndef g(s1: str, s2: str):\n    return s1, s2\nassert f(*g('a b c', 'cba')) \n",
        "idx_generation": 401,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Check if the binary representation of num has an equal number of 0's and 1's.\"\"\"\n    binary = bin(num)[2:]\n    return binary.count('0') == binary.count('1')\ndef g():\n    num = 0\n    while True:\n        if f(num):\n            return num\n        num += 1\nassert f(g())\n",
        "idx_generation": 20,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    def longest_increasing_subsequence(nums, n):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n    \n    return longest_increasing_subsequence(nums, len(nums))\n\ndef g():\n    return [3, 10, 2, 1, 20]\n\nassert f(g()) == 3\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if the given string is a palindrome after removing exactly one character.\"\"\"\n    n = len(s)\n    for i in range(n):\n        modified_str = s[:i] + s[i+1:]\n        if modified_str == modified_str[::-1]:\n            return True\n    return False\n\ndef g(s: str) -> str:\n    \"\"\"\n    Return the modified string obtained by removing one character from the given string.\n    If the string cannot be modified, return an empty string.\n    \"\"\"\n    n = len(s)\n    for i in range(n):\n        modified_str = s[:i] + s[i+1:]\n        if modified_str == modified_str[::-1]:\n            return modified_str\n    return \"\"\n\nassert f(g(\"racecar\"))\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subset of the given array whose bitwise XOR of all elements is equal to k.\"\"\"\n    def subset_xor(arr, k, n):\n        if n == 0 and k == 0:\n            return True\n        if n == 0:\n            return False\n        return subset_xor(arr, k, n - 1) or subset_xor(arr, k ^ arr[n - 1], n - 1)\n    return subset_xor(arr, k, len(arr))\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 7) == True\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    \n    root = int(n ** 0.5)\n    return root * root == n\n\ndef g() -> int:\n    \"\"\"Generate a perfect square number.\"\"\"\n    return 16\n\nassert f(g())\n",
        "idx_generation": 128,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k=3) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subset of the array with a sum divisible by k.\"\"\"\n    def subset_sum(nums, k, target, ind, memo):\n        if target == 0:\n            return True\n        if ind >= len(nums):\n            return False\n        if (target, ind) in memo:\n            return memo[(target, ind)]\n        memo[(target, ind)] = subset_sum(nums, k, (target + nums[ind]) % k, ind + 1, memo) or subset_sum(nums, k, target, ind + 1, memo)\n        return memo[(target, ind)]\n    return subset_sum(nums, k, 0, 0, {})\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\nassert f(g())\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(edges: List[Tuple[int, int]], n: int) -> bool:\n    \"\"\"Determine if there exists a path that visits every node exactly once in a given graph.\"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * n\n    def dfs(node, visited, count):\n        visited[node] = True\n        count += 1\n        if count == n:\n            return True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, count):\n                    return True\n        visited[node] = False\n        return False\n    for i in range(n):\n        if dfs(i, visited, 0):\n            return True\n    return False\ndef g():\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n    n = 4\n    return edges, n\nassert f(*g())\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and from top to bottom.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Start from the top right corner of the matrix\n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g(matrix: List[List[int]], target: int):\n    return (matrix, target)\n\nassert f(*g([[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5))\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g() -> str:\n    s = \"Hello World!\"\n    return s\n\nassert f(g()) == \"World! Hello\"\n",
        "idx_generation": 405,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if the given number n can be expressed as a sum of k consecutive positive integers.\n    \n    Args:\n    n -- the number to be checked\n    k -- the number of consecutive positive integers\n    \n    Returns:\n    True if n can be expressed as a sum of k consecutive positive integers, False otherwise\n    \"\"\"\n    # Check if n is divisible by k\n    if n % k != 0:\n        return False\n    \n    # Calculate the starting number\n    start = (n // k) - (k // 2)\n    \n    # Check if the sum of k consecutive positive integers starting from start is equal to n\n    if sum(range(start, start + k)) == n:\n        return True\n    \n    return False\n\ndef g(n: int) -> List[int]:\n    \"\"\"Find k consecutive positive integers that sum up to the given number n.\n    \n    Args:\n    n -- the number to be expressed\n    \n    Returns:\n    A list of k consecutive positive integers that sum up to n\n    \"\"\"\n    # Find the factors of n\n    factors = [i for i in range(1, n+1) if n % i == 0]\n    \n    # Find the maximum k value\n    max_k = n // 2\n    \n    # Find the first k consecutive positive integers that sum up to n\n    for k in range(2, max_k+1):\n        if f(n, k):\n            return list(range((n // k) - (k // 2), (n // k) - (k // 2) + k))\n    \n    return []\n\nassert f(15, 3)\nassert g(15) == [4, 5, 6]\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, nums=[2, 3, 5, 7, 11]) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to n.\"\"\"\n    def subset_sum(n, i):\n        if n == 0:\n            return True\n        if i == 0:\n            return False\n        if nums[i-1] > n:\n            return subset_sum(n, i-1)\n        return subset_sum(n, i-1) or subset_sum(n-nums[i-1], i-1)\n    return subset_sum(n, len(nums))\ndef g(nums=[2, 3, 5, 7, 11]):\n    return sum(nums) // 2\nassert f(g())\n",
        "idx_generation": 186,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Find if the given string can be partitioned into n equal parts.\"\"\"\n    m = len(s)\n    if m % n != 0:\n        return False\n    part_len = m // n\n    for i in range(0, m, part_len):\n        if s[i:i+part_len] != s[i:i+part_len][::-1]:\n            return False\n    return True\n\ndef g(s: str, n: int) -> List[str]:\n    \"\"\"\n    Return a list of n equal parts obtained by partitioning the given string.\n    If the string cannot be partitioned, return an empty list.\n    \"\"\"\n    m = len(s)\n    if m % n != 0:\n        return []\n    part_len = m // n\n    parts = []\n    for i in range(0, m, part_len):\n        parts.append(s[i:i+part_len])\n    return parts\n\nassert f(g(\"aabbaa\", 2), 2)\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of n multiplied by m.\"\"\"\n    binary = bin(n * m)[2:]\n    return binary.count('1')\ndef g(n: int, m: int):\n    return n, m\nassert f(*g(5, 3)) == 4\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import *\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"Given a list of points in a 2D plane, determine if there exists a line that can divide the plane into two equal areas.\n    Sample Input:\n    points = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Sample Output:\n    True\n    Explanation:\n    The line y = x divides the plane into two equal areas.\n    \"\"\"\n    n = len(points)\n    if n < 2:\n        return False\n    total_area = 0\n    for i in range(n - 1):\n        total_area += points[i][0] * points[i + 1][1] - points[i + 1][0] * points[i][1]\n    total_area += points[n - 1][0] * points[0][1] - points[0][0] * points[n - 1][1]\n    if total_area != 0:\n        return False\n    return True\n\ndef g():\n    return [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n\nassert f(g())\n",
        "idx_generation": 181,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, check if there is a cycle in the graph.\n    Return True if there is a cycle, False otherwise.\n    \"\"\"\n    num_nodes = len(adj_matrix)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(num_nodes):\n            if adj_matrix[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    adj_matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return adj_matrix\n\nassert f(g())\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a grid of integers and a target value, determine if the target value exists in the grid.\n    The grid is a 2D matrix where each row is sorted in non-decreasing order and the first element of each row is greater than the last element of the previous row.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Start from the top left corner of the grid\n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g(grid: List[List[int]], target: int):\n    return (grid, target)\n\nassert f(*g([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 9))\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, return the index if the target is found.\n    If the target is not found, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n    \"\"\"\n    n = len(nums)\n    left, right = 0, n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\ndef g():\n    return [1, 3, 5, 6], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of size n x m, rotate the matrix by 90 degrees clockwise.\"\"\"\n    rotated_matrix = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            rotated_matrix[i][j] = matrix[n - j - 1][i]\n    return rotated_matrix\ndef g():\n    n = 3\n    m = 3\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return n, m, matrix\nassert f(*g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find if there exists a subarray whose sum is equal to the target value.\nArgs:\n    arr: The list of integers.\n    target: The target sum value.\nReturns:\n    True if a subarray with the target sum exists, False otherwise.\"\"\"\n    n = len(arr)\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1]\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sums[j] - prefix_sums[i] == target:\n                return True\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers.\n    \"\"\"\n    return [3, 4, 7, 2, 1, 8, 5, 6]\n    \nassert f(g())\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int, target_sum: int, numbers: List[int]) -> bool:\n    \"\"\"Check if it is possible to find a subset of numbers that sum up to the target_sum.\"\"\"\n    def subset_sum(numbers, target_sum):\n        if target_sum == 0:\n            return True\n        if len(numbers) == 0:\n            return False\n        if numbers[0] > target_sum:\n            return subset_sum(numbers[1:], target_sum)\n        return subset_sum(numbers[1:], target_sum) or subset_sum(numbers[1:], target_sum - numbers[0])\n\n    return subset_sum(numbers, target_sum)\n\ndef g(n=5, target_sum=10):\n    numbers = [random.randint(1, 10) for _ in range(n)]\n    return (n, target_sum, numbers)\n\nassert f(*g())\n",
        "idx_generation": 187,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a palindrome.\"\"\"\n    number_str = str(n)\n    queue = deque(number_str)\n    while len(queue) > 1:\n        if queue.popleft() != queue.pop():\n            return False\n    return True\n\ndef g():\n    return 12321\n\nassert f(g())\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of the given positive integer.\n    \"\"\"\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 25\n\nassert f(g()) == 3\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, return True if it is a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g())\n",
        "idx_generation": 193,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(e: List[List[int]], target=0) -> bool:\n    \"\"\"Determine if a given target value can be reached by traversing a tree.\n\n    The input 'e' is a list of lists representing a tree structure. Each inner list\n    contains two integers: the first integer is the value of the node, and the second\n    integer represents the index of the parent node (-1 if it is the root node).\n\n    The function should return True if the target value can be reached by traversing\n    the tree from the root node to any leaf node, otherwise return False.\n    \"\"\"\n    graph = {}\n    for i, (val, parent) in enumerate(e):\n        if parent not in graph:\n            graph[parent] = []\n        graph[parent].append(i)\n\n    def dfs(node, curr_sum):\n        if node not in graph:\n            if curr_sum == target:\n                return True\n            return False\n\n        for child in graph[node]:\n            if dfs(child, curr_sum + e[child][0]):\n                return True\n\n        return False\n\n    return dfs(-1, 0)\n\ndef g():\n    return [[3, -1], [2, 0], [4, 0], [1, 1], [3, 1], [2, 2], [1, 3]]\n\nassert f(g(), target=7)\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the smallest subarray length whose sum is greater than or equal to the target.\n    Return the length of the subarray.\n    \"\"\"\n    min_length = float('inf')\n    current_sum = 0\n    left = 0\n\n    for right, num in enumerate(nums):\n        current_sum += num\n\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n\n    return min_length\n\ndef g(nums=[2, 3, 1, 2, 4, 3], target=7):\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers as a list.\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Sample Output:\n    [0, 1]\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n    \ndef g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 261,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"Find all words in the list that can be formed by rearranging the letters of the target word\"\"\"\n    def is_anagram(word1: str, word2: str) -> bool:\n        return sorted(word1) == sorted(word2)\n    \n    return [word for word in words if is_anagram(word, target)]\n\ndef g() -> Tuple[List[str], str]:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    target = \"ate\"\n    return words, target\n\nassert f(*g()) == [\"eat\", \"tea\", \"ate\"]\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the grid is a magic square\"\"\"\n    n = len(grid)\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    diagonal_sum1 = sum(grid[i][i] for i in range(n))\n    diagonal_sum2 = sum(grid[i][n-i-1] for i in range(n))\n    return all(sum == row_sums[0] for sum in row_sums) and \\\n           all(sum == col_sums[0] for sum in col_sums) and \\\n           diagonal_sum1 == diagonal_sum2 == row_sums[0]\n\ndef g():\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 34,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within the given list.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings=['foo', 'bar', 'baz', 'qux', 'quux', 'corge']) -> bool:\n    \"\"\"Find the longest substring in the input string that contains all the given substrings.\"\"\"\n    max_length = 0\n    max_substring = ''\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if all(sub in substring for sub in substrings) and len(substring) > max_length:\n                max_length = len(substring)\n                max_substring = substring\n    return max_substring\n\ndef g(substrings=['foo', 'bar', 'baz', 'qux', 'quux', 'corge']):\n    return ''.join(substrings)\n\nassert f(g()) != ''\n",
        "idx_generation": 23,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of positive integers, return the number of unique combinations of numbers that can be formed by\n    taking the bitwise XOR of all possible pairs of numbers.\"\"\"\n    unique_combinations = set()\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            bitwise_xor = nums[i] ^ nums[j]\n            unique_combinations.add(bitwise_xor)\n    return len(unique_combinations)\n\ndef g(nums: List[int]=[1, 2, 3, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a list of integers is sorted in non-decreasing order and contains only prime numbers.\"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    for num in nums:\n        if not is_prime(num):\n            return False\n    return True\n\ndef g():\n    return [2, 5, 7, 11, 13, 17]\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nassert f(g())\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(edges: List[Tuple[int, int]], start: int, end: int) -> bool:\n    \"\"\"Given a list of edges representing a graph and two nodes, check if there is a path from the start node to the end node.\"\"\"\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return ([(1, 2), (2, 3), (2, 4), (3, 5), (4, 5)], 1, 5)\n\nassert f(*g())\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, check if there exists two numbers in the list that sum up to the target.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 3, 5, 7, 9], 12)\n\nassert f(*g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of elements in the given list that sum up to the target.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 3, 8, 2, 9, 7, 4, 6]\n\nassert f(g(), 10)\n",
        "idx_generation": 265,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if a given string is a rotation of another string.\"\"\"\n    if len(s) != len(target):\n        return False\n    return target in s + s\ndef g() -> Tuple[str, str]:\n    return (\"waterbottle\", \"erbottlewat\")\nassert f(*g())\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if there exists a square-shaped subgrid of size 2x2 in the grid that contains all ones.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    for i in range(m - 1):\n        for j in range(n - 1):\n            if grid[i][j] == grid[i+1][j] == grid[i][j+1] == grid[i+1][j+1] == 1:\n                return True\n    \n    return False\n\ndef g(m=5, n=5):\n    import random\n    \n    grid = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\n    \n    return grid\n\nassert f(g())\n",
        "idx_generation": 40,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence. Return the length.\n    Sample input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Sample output:\n    4\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Return the input list of integers.\"\"\"\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape']) -> bool:\n    \"\"\"Find the longest word in the list that can be formed by combining adjacent characters in the input string.\"\"\"\n    max_length = 0\n    max_word = ''\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            word = s[i:j]\n            if word in words and len(word) > max_length:\n                max_length = len(word)\n                max_word = word\n    return max_word\n\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape']):\n    return max(words, key=len)\n\nassert f(g()) != ''\n",
        "idx_generation": 23,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a pair of numbers in a list that XOR to the target value.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(nums=[2, 5, 8, 10, 7]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number n is a perfect square.\"\"\"\n    return int(n**0.5)**2 == n\n\ndef g():\n    n = 16\n    return n\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node to the end node.\n    Return True if a path exists, otherwise return False.\"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]\n\nassert f(g(), start=0, end=4) == True\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order, determine if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == True\n",
        "idx_generation": 121,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\nArgs:\n    nums: A list of integers.\nReturns:\n    The length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string.\"\"\"\n    words = s.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words\n\ndef g(s: str):\n    \"\"\"Generate a string.\"\"\"\n    return (s,)\n\ns = \"Hello World\"\nassert f(*g(s)) == \"World Hello\"\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False\n\ndef g(nums=[5, 7, 2, 4, 8, 3]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 48,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n - 1) + f(n - 2)\ndef g(n=5):\n    return (n,)\nassert f(*g()) == 5\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of an integer is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g():\n    return 9\nassert f(g())\n",
        "idx_generation": 24,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a given integer.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n=42):\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"Given a list of points in 2D space, find the minimum distance between any two points.\n    Return the minimum distance as a float value.\"\"\"\n    min_distance = float('inf')\n    n = len(points)\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)**0.5\n            min_distance = min(min_distance, distance)\n    return min_distance\n\ndef g():\n    return ([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\n\nassert f(g()) == 2.8284271247461903\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers 'matrix', find the length of the longest increasing path.\n    An increasing path is defined as a path (from a given cell) consisting of four directions: up, down, left, or right.\n    Return the length of the longest increasing path.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    n, m = len(matrix), len(matrix[0])\n    dp = [[0] * m for _ in range(n)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        dp[i][j] = 1\n        for dx, dy in directions:\n            ni, nj = i + dx, j + dy\n            if 0 <= ni < n and 0 <= nj < m and matrix[ni][nj] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(ni, nj))\n        \n        return dp[i][j]\n    \n    max_length = 0\n    for i in range(n):\n        for j in range(m):\n            max_length = max(max_length, dfs(i, j))\n    \n    return max_length\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the matrix of integers.\n    \"\"\"\n    return matrix\n\nassert f(g([[9, 9, 4], [6, 6, 8], [2, 1, 1]])) == 4\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return target\n\nassert f([1, 4, 5, 8, 11, 15], g([1, 4, 5, 8, 11, 15], 9))\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(mat: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\"\"\"\n    rows = len(mat)\n    cols = len(mat[0])\n\n    def search(row, col, target):\n        if row >= rows or col >= cols:\n            return False\n        if mat[row][col] == target:\n            return True\n        if mat[row][col] < target:\n            return search(row + 1, col, target) or search(row, col + 1, target)\n        return False\n\n    return search(0, 0, target)\n\ndef g(mat=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return (mat, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"Given a list of words and a target word, return a list of words that can be formed by rearranging the letters of the target word.\n    The words in the output list should be in the same order as they appear in the input list.\"\"\"\n    def is_anagram(word1, word2):\n        return sorted(word1) == sorted(word2)\n    return [word for word in words if is_anagram(word, target)]\n\ndef g():\n    words = [\"cat\", \"tac\", \"dog\", \"god\", \"act\"]\n    target = \"cat\"\n    return (words, target)\n\nassert f(*g()) == [\"cat\", \"tac\", \"act\"]\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the smallest missing positive integer that does not exist in the list.\"\"\"\n    nums = set(nums)\n    n = 1\n    while n in nums:\n        n += 1\n    return n\n\ndef g(nums=[-1, 2, 3, 0, 5]):\n    return nums\n\nassert f(g()) == 1\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return f(n - 1) + f(n - 2)\ndef g(n: int):\n    return n\nassert f(g(6)) == 8\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, return True if s1 can be obtained by rotating s2 by any number of positions,\n    otherwise return False.\n    Example:\n    s1 = \"abcde\"\n    s2 = \"cdeab\"\n    Output: True\n    Explanation: s1 can be obtained by rotating s2 by 2 positions: \"cdeab\" -> \"deabc\" -> \"abcde\".\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    double_s2 = s2 + s2\n    return s1 in double_s2\n\ndef g():\n    return \"abcde\", \"cdeab\"\n\nassert f(*g())\n",
        "idx_generation": 26,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a power of 2\"\"\"\n    if n <= 0:\n        return False\n    return n & (n - 1) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers nums and a number k, find if there exists a subarray in nums that has a sum divisible by k.\nArgs:\n    nums: The list of integers.\n    k: The divisor.\nReturns:\n    True if a subarray exists, False otherwise.\"\"\"\n    prefix_sum = 0\n    prefix_mod = {0: -1}\n    for i, num in enumerate(nums):\n        prefix_sum = (prefix_sum + num) % k\n        if prefix_sum in prefix_mod:\n            if i - prefix_mod[prefix_sum] > 1:\n                return True\n        else:\n            prefix_mod[prefix_sum] = i\n    return False\ndef g():\n    return ([2, 4, 7, 6, 3, 9, 8], 5)\nassert f(*g())\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from `start` to `end`\n    with exactly `k` edges.\n    \"\"\"\n\n    def dfs(node: int, depth: int) -> bool:\n        if node == end and depth == k:\n            return True\n        if depth >= k:\n            return False\n        \n        for neighbor in graph[node]:\n            if dfs(neighbor, depth + 1):\n                return True\n        \n        return False\n\n    return dfs(start, 0)\n\ndef g():\n    return (\n        [\n            [1, 2, 3],  # Node 0 has outgoing edges to nodes 1, 2, and 3\n            [2, 4],     # Node 1 has outgoing edges to nodes 2 and 4\n            [3, 4],     # Node 2 has outgoing edges to nodes 3 and 4\n            [],         # Node 3 has no outgoing edges\n            [],         # Node 4 has no outgoing edges\n        ],\n        0,  # Start node\n        3,  # End node\n        2   # Number of edges\n    )\n\nassert f(*g())\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nassert f(*g([1, 3, 5, 7, 9, 11, 13], 7)) == 3\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a subsequence that adds up to the target number.\n    Return True if such subsequence exists, False otherwise.\n    \"\"\"\n    n = len(arr)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][target]\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find a subsequence from the list that adds up to the target number.\n    Return the subsequence if found, an empty list otherwise.\n    \"\"\"\n    n = len(arr)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    if not dp[n][target]:\n        return []\n    subsequence = []\n    i, j = n, target\n    while i > 0 and j > 0:\n        if dp[i - 1][j]:\n            i -= 1\n        else:\n            subsequence.append(arr[i - 1])\n            j -= arr[i - 1]\n            i -= 1\n    return subsequence[::-1]\n\narr = [2, 4, 6, 8, 10]\ntarget = 14\nassert f(g(arr, target), target)\n",
        "idx_generation": 273,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\"\"\"\n    def is_palindrome(left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s) - 1)\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) is True\n",
        "idx_generation": 490,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> List[int]:\n    \"\"\"Generate the first n numbers in the Fibonacci sequence.\"\"\"\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[:n]\ndef g():\n    return 10\nassert f(g()) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n",
        "idx_generation": 54,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of numbers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, p=17) -> bool:\n    \"\"\"Check if the binary representation of an integer n is a palindrome\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g(p=17):\n    return int(bin(p)[2:], 2)\nassert f(g())\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the number of subarrays in the given list that XOR to the target value.\"\"\"\n    count = 0\n    xor_sum = 0\n    xor_dict = {0: 1}\n    for num in nums:\n        xor_sum ^= num\n        count += xor_dict.get(xor_sum ^ target, 0)\n        xor_dict[xor_sum] = xor_dict.get(xor_sum, 0) + 1\n    return count\n\ndef g():\n    \"\"\"Generate a list of numbers and a target value such that the number of subarrays XORing to the target is non-zero.\"\"\"\n    import random\n    nums = random.choices(range(1, 10), k=10)\n    target = random.randint(1, 10)\n    return nums, target\n\nassert f(*g()) > 0\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine whether a given number n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    n = 2\n    while True:\n        if f(n):\n            return n\n        n += 1\nassert f(g())\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid contains a valid path from the top-left corner to the bottom-right corner.\"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(x, y):\n        if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0 or visited[x][y]:\n            return False\n        if x == m - 1 and y == n - 1:\n            return True\n\n        visited[x][y] = True\n\n        return dfs(x - 1, y) or dfs(x + 1, y) or dfs(x, y - 1) or dfs(x, y + 1)\n\n    return dfs(0, 0)\n\ndef g():\n    return [[1, 1, 0], [0, 1, 0], [0, 1, 1]]\n\nassert f(g())\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([1, 5, 3, 9, 2], 7)\nassert f(g()[0], g()[1])\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given an array of integers 'arr', return the array sorted in non-decreasing order.\"\"\"\n    n = len(arr)\n    \n    for i in range(n-1):\n        for j in range(n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    \n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\narr = [4, 2, 7, 1, 5]\nassert f(g(arr)) == [1, 2, 4, 5, 7]\n",
        "idx_generation": 285,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Sort the list of words based on their length in descending order.\"\"\"\n    return sorted(words, key=lambda x: len(x), reverse=True)\n\ndef g(words=[\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]):\n    return words\n\nassert f(g()) == ['elderberry', 'banana', 'cherry', 'apple', 'date']\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target: str) -> bool:\n    \"\"\"Determine if it is possible to create a string 'target' using exactly 'n' characters from the string 'source',\nwhere each character can be used at most 'k' times.\nSample Input:\nn = 7\nk = 2\ntarget = 'leetcode'\nSample Output:\nTrue\nExplanation: The string 'target' can be created using the characters 'l', 'e', 'e', 't', 'c', 'o', 'd' from the string 'source'.\nEach character is used at most 2 times, hence the output is True.\"\"\"\n    source = 'leetcode'\n    count = {}\n    for char in source:\n        count[char] = count.get(char, 0) + 1\n    \n    for char in target:\n        if count.get(char, 0) < 1:\n            return False\n        count[char] -= 1\n        if count[char] < -k:\n            return False\n    \n    return True\n\ndef g(n=7, k=2, target='leetcode'):\n    return (n, k, target)\n\nassert f(*g())\n",
        "idx_generation": 56,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of numbers, find the maximum sum of a subarray.\"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    curr_sum = 0\n    for i in range(n):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if a string is a palindrome when considering only alphanumeric characters and ignoring case.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n    \ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 31,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Given a number, check if it is a power of 2.\"\"\"\n    return num != 0 and (num & (num - 1)) == 0\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 422,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, x=3, y=5) -> bool:\n    \"\"\"Find a number n that is divisible by both x and y\"\"\"\n    return n % x == 0 and n % y == 0\n\ndef g(x=3, y=5):\n    n = math.lcm(x, y)\n    return n\n\nassert f(g())\n",
        "idx_generation": 268,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if there is a path in the matrix that sums up to the target value.\n    A valid path can move in any direction (up, down, left, right) and can only visit each cell once.\n    Solution should return True if such path exists, otherwise False.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def dfs(i, j, curr_sum, visited):\n        if curr_sum == target:\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or visited[i][j]:\n            return False\n\n        visited[i][j] = True\n        curr_sum += matrix[i][j]\n\n        if dfs(i+1, j, curr_sum, visited) or dfs(i-1, j, curr_sum, visited) or dfs(i, j+1, curr_sum, visited) or dfs(i, j-1, curr_sum, visited):\n            return True\n\n        curr_sum -= matrix[i][j]\n        visited[i][j] = False\n\n        return False\n\n    visited = [[False] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0, visited):\n                return True\n\n    return False\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 15)\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target number, find two numbers in the list that add up to the target.\"\"\"\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        if nums[start] + nums[end] == target:\n            return [nums[start], nums[end]]\n        elif nums[start] + nums[end] < target:\n            start += 1\n        else:\n            end -= 1\n    return []\ndef g(nums=[1, 2, 3, 5, 7, 9], target=10):\n    return nums\nassert f(g(), target=10) == [1, 9]\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int = 0) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose sum is equal to the target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    nums.sort() # Sorting the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [3, 5, 1, 7, 9, 2]\nassert f(g(), target=10) == True\n",
        "idx_generation": 285,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, target=10) -> bool:\n    \"\"\"Given an integer n, find if there exists a pair of integers (a, b) such that a^2 + b^2 = n.\nArgs:\n    n: The input integer.\n    target: The target sum.\nReturns:\n    True if a pair of integers with the target sum exists, False otherwise.\"\"\"\n    left, right = 0, int(n ** 0.5)\n    while left <= right:\n        curr_sum = left ** 2 + right ** 2\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    \"\"\"\n    Returns a sample integer.\n    \"\"\"\n    return 13\nassert f(g())\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the maximum sum of a contiguous subarray.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums: List[int]):\n    return (nums,)\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(*g(nums)) == 6\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if a given string is a palindrome after removing exactly one character.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    for i in range(len(s)):\n        if is_palindrome(s[:i] + s[i+1:]):\n            return True\n    return False\n\ndef g():\n    return 'abccba'\n\nassert f(g())\n",
        "idx_generation": 35,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, find if there exists a pair of numbers in the list such that their bitwise XOR is equal to the target number.\"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=14):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the sum of the first 'n' natural numbers.\n    \"\"\"\n    return n * (n + 1) // 2\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer 'n' representing the number of natural numbers to sum.\n    \"\"\"\n    return n\n\nassert f(g(10)) == 55\n",
        "idx_generation": 287,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode, target: int) -> List[List[int]]:\n    \"\"\"Given a binary tree and a target value, find all root-to-leaf paths where the sum of node values equals the target value.\"\"\"\n    def dfs(node, curr_sum, path, result):\n        if not node:\n            return\n        curr_sum += node.val\n        path.append(node.val)\n        if not node.left and not node.right and curr_sum == target:\n            result.append(path[:])\n        dfs(node.left, curr_sum, path, result)\n        dfs(node.right, curr_sum, path, result)\n        path.pop()\n    \n    result = []\n    dfs(root, 0, [], result)\n    return result\n\ndef g():\n    \"\"\"Returns a binary tree and a target value such that there are multiple root-to-leaf paths with the sum equal to the target value.\"\"\"\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(11)\n    root.left.left.left = TreeNode(7)\n    root.left.left.right = TreeNode(2)\n    root.right.left = TreeNode(13)\n    root.right.right = TreeNode(4)\n    root.right.right.left = TreeNode(5)\n    root.right.right.right = TreeNode(1)\n    return root, 22\n\nassert f(*g()) == [[5, 4, 11, 2], [5, 8, 4, 5]]\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there are three numbers in the array whose sum is equal to the target number.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = arr[i] + arr[left] + arr[right]\n            if total == target:\n                return True\n            elif total < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Generate a sequence of three numbers from the array that sums up to the target number.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = arr[i] + arr[left] + arr[right]\n            if total == target:\n                return [arr[i], arr[left], arr[right]]\n            elif total < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n\narr = [1, 4, 2, 3, 5]\ntarget = 9\nassert f(g(arr, target), target)\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in the given list of integers.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\nassert f(g()) == 4\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find the two numbers in the list whose sum is closest to the target using brute-force search.\"\"\"\n    closest_sum = float('inf')\n    closest_nums = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            curr_sum = nums[i] + nums[j]\n            if abs(curr_sum - target) < abs(closest_sum - target):\n                closest_sum = curr_sum\n                closest_nums = [nums[i], nums[j]]\n    return closest_nums\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return (nums, target)\nassert f(*g()) == [1, 5]\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number\"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int) -> int:\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 204,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of occurrences of a given substring in a string.\"\"\"\n    count = 0\n    sub_len = len(s)\n    for i in range(len(s)-sub_len+1):\n        if s[i:i+sub_len] == s:\n            count += 1\n    return count\ndef g():\n    return 'abcabcabc'\nassert f(g())\n",
        "idx_generation": 43,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, find if there exists a pair of numbers in the list such that their bitwise AND is equal to the target number.\"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if nums[i] & nums[j] == target:\n                return True\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=0):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers whose sum is a perfect square.\"\"\"\n    squares = set()\n    for i in range(1, int(len(nums)**0.5)+1):\n        squares.add(i*i)\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] in squares:\n                return True\n    return False\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nassert f(g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, check if there exists a cycle in the graph.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph with a cycle.\n    \"\"\"\n    import random\n\n    graph = [[0, 1, 0, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [1, 0, 0, 0]]\n\n    return graph\n\nassert f(g())\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a sorted matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n    \ndef g(matrix: List[List[int]], target: int):\n    return (matrix, target)\n\nassert f(*g([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5))\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there exists a pair of elements in the list whose sum equals the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    nums = [1, 2, 4, 5, 7, 8]\n    target = 10\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if it is possible to obtain the target number by performing\naddition or subtraction operations on the elements of the list in any order.\nArgs:\n    nums: The list of integers.\n    target: The target number to obtain.\nReturns:\n    True if it is possible to obtain the target number, False otherwise.\"\"\"\n    def dfs(nums, target, index):\n        if index == len(nums):\n            return target == 0\n        return dfs(nums, target - nums[index], index + 1) or dfs(nums, target + nums[index], index + 1)\n    \n    return dfs(nums, target, 0)\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers and a target number.\n    \"\"\"\n    return [1, 5, 3, 8], 9\n\nassert f(*g())\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings=['abc', 'def', 'ghi']) -> bool:\n    \"\"\"Find a string that contains each string in substrings as non-overlapping substrings\"\"\"\n    for i in range(len(substrings)):\n        for j in range(i + 1, len(substrings)):\n            if substrings[i] in s and substrings[j] in s:\n                first_index_i = s.index(substrings[i])\n                first_index_j = s.index(substrings[j])\n                if first_index_i + len(substrings[i]) <= first_index_j or first_index_j + len(substrings[j]) <= first_index_i:\n                    return True\n    return False\ndef g(substrings=['abc', 'def', 'ghi']):\n    return 'abcdefghixyzabcdefghidefghixyzabcdefghi'\nassert f(g())\n",
        "idx_generation": 49,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list such that their XOR is equal to the target.\"\"\"\n    num_set = set(nums)\n    for num in nums:\n        complement = target ^ num\n        if complement in num_set:\n            return [num, complement]\n    return []\ndef g(nums=[2, 4, 6, 8, 10], target=14):\n    return nums, target\nassert f(*g()) == [4, 10]\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given grid is a magic square.\n    A magic square is a grid of numbers where the sum of each row, each column, and both diagonals is the same.\n    \"\"\"\n    n = len(grid)\n    target_sum = n * (n**2 + 1) // 2  # The target sum for each row, column, and diagonal\n    # Check rows\n    if any(sum(row) != target_sum for row in grid):\n        return False\n    # Check columns\n    if any(sum(col) != target_sum for col in zip(*grid)):\n        return False\n    # Check diagonals\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    return True\n\ndef g(n=3):\n    \"\"\"\n    Generate a magic square of size n x n.\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"Magic square size should be 3 or greater.\")\n    if n % 2 == 1:\n        # For odd size, use Siamese method\n        grid = [[0] * n for _ in range(n)]\n        x = n // 2\n        y = 0\n        for num in range(1, n**2 + 1):\n            grid[y][x] = num\n            x = (x + 1) % n\n            y = (y - 1) % n\n            if grid[y][x] != 0:\n                y = (y + 2) % n\n                x = (x - 1) % n\n    else:\n        # For even size, use De la Loub\u00e8re method\n        grid = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                grid[i][j] = n * ((i + j + 1 + n // 2) % n) + ((i + 2 * j + 1) % n) + 1\n    return grid\n\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Given a directed graph represented as a dictionary, determine if there is a path from the start node to the end node.\"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    if node == end:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g(graph: Dict[str, List[str]], start: str, end: str) -> Tuple:\n    \"\"\"\n    Generate a directed graph represented as a dictionary, a start node, and an end node.\n    \"\"\"\n    return (graph, start, end)\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['C', 'D'],\n    'C': ['D'],\n    'D': ['E'],\n    'E': []\n}\nstart = 'A'\nend = 'E'\nassert f(*g(graph, start, end)) == True\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Check if a target value is present in a sorted list using linear search.\"\"\"\n    for num in arr:\n        if num == n:\n            return True\n    return False\ndef g(arr=[1, 3, 5, 7, 9, 11, 13, 15, 17, 19], n=13):\n    return (n, arr)\nassert f(*g())\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers arr and a target value, determine if there exist two elements in arr such that their sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 16\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root * root == n\n\ndef g():\n    return 144\n\nassert f(g())\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of non-negative integers, determine if there is a subset of the array that can sum up to the target value.\n\n    Return True if such subset exists, False otherwise.\n    \"\"\"\n    def helper(arr, target, index, current_sum):\n        if current_sum == target:\n            return True\n        if index == len(arr):\n            return False\n        return helper(arr, target, index + 1, current_sum + arr[index]) or helper(arr, target, index + 1, current_sum)\n    \n    return helper(arr, target, 0, 0)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, substr='abc') -> bool:\n    \"\"\"Find if the substring exists in the string\"\"\"\n    return substr in string\ndef g(substr='abc'):\n    string = \"defghabcijkl\"\n    return string\nassert f(g())\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subsequence in it such that the bitwise XOR of its elements is a palindrome.\n    \n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    \n    Sample Output:\n    True\n    \n    Explanation: The subsequence [1, 4, 5] has a bitwise XOR of 0, which is a palindrome.\n    \"\"\"\n    def is_palindrome(n: int) -> bool:\n        binary = bin(n)[2:]\n        return binary == binary[::-1]\n    \n    n = len(nums)\n    \n    for i in range(1, 2**n):\n        subsequence = [nums[j] for j in range(n) if (i & (1 << j))]\n        xor = subsequence[0]\n        for num in subsequence[1:]:\n            xor ^= num\n        if is_palindrome(xor):\n            return True\n    return False\n    \ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    \"\"\"\n    Generate a random prime number.\n    \"\"\"\n    import random\n    while True:\n        num = random.randint(1, 100)\n        if f(num):\n            return num\n\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list, determine if there exists a path from the start node to the end node using a Depth First Search (DFS) algorithm.\nArgs:\n    graph: The graph represented as an adjacency list.\n    start: The start node.\n    end: The end node.\nReturns:\n    True if a path exists from the start node to the end node, False otherwise.\"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\n\ndef g():\n    \"\"\"\n    Returns a sample graph represented as an adjacency list.\n    \"\"\"\n    return [[1, 2], [3], [4, 5], [2, 4], [], [6], []]\n\n\nassert f(g(), 0, 6)\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if a given array contains any duplicate elements.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(1, n):\n        if arr[i] == arr[i-1]:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 9]\n\nassert f(g())\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two numbers in the list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\nassert f(g()) == 28\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, a=1, b=2) -> bool:\n    \"\"\"Determine if a number is a Fibonacci number by checking if it can be expressed as a sum of two Fibonacci numbers\"\"\"\n    fib_nums = [a, b]\n    while fib_nums[-1] < n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n    for i in range(len(fib_nums)):\n        for j in range(i, len(fib_nums)):\n            if fib_nums[i] + fib_nums[j] == n:\n                return True\n    return False\n\ndef g(a=1, b=2):\n    \"\"\"Generate a number that is a sum of two Fibonacci numbers\"\"\"\n    fib_nums = [a, b]\n    while True:\n        n = fib_nums[-1] + fib_nums[-2]\n        fib_nums.append(n)\n        if n % 2 == 0:\n            return n\n\nassert f(g(), 2)\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of non-negative integers and a target value, find the minimum number of jumps needed to reach the target value.\n    Each element in the array represents the maximum number of steps that can be jumped from that position.\n    Return -1 if it is not possible to reach the target value.\n    \"\"\"\n    if len(arr) == 0 or arr[0] == 0:\n        return -1\n    \n    jumps = [float('inf')] * len(arr)\n    jumps[0] = 0\n    \n    for i in range(1, len(arr)):\n        for j in range(i):\n            if j + arr[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n    \n    return jumps[-1] if jumps[-1] != float('inf') else -1\n\ndef g():\n    arr = [2, 3, 1, 1, 4]\n    target = 4\n    return (arr, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string, while maintaining the order of characters within each word.\n    \"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g():\n    return \"Hello World! This is a test.\"\n\nassert f(g()) == \"test. a is This World! Hello\"\n",
        "idx_generation": 53,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in ascending order using bit manipulation.\"\"\"\n    max_num = max(nums)\n    num_bits = len(bin(max_num)) - 2\n    for bit in range(num_bits):\n        ones = []\n        zeros = []\n        for num in nums:\n            if (num >> bit) & 1:\n                ones.append(num)\n            else:\n                zeros.append(num)\n        nums = zeros + ones\n    return nums\n\ndef g(nums=[5, 3, 9, 2, 6, 1]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 6, 9]\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in a consecutive list of integers from 0 to n.\"\"\"\n    n = len(nums) + 1\n    expected_sum = (n * (n - 1)) // 2\n    actual_sum = sum(nums)\n    missing_number = expected_sum - actual_sum\n    return missing_number\n\ndef g(nums=[0, 1, 2, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, determine if it is possible to reach the bottom-right cell (denoted by value 1)\n    starting from the top-left cell (denoted by value 0). You can only move down or right in the grid.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    def dfs(row: int, col: int) -> bool:\n        if row == len(grid)-1 and col == len(grid[0])-1:\n            return True\n        if row >= len(grid) or col >= len(grid[0]):\n            return False\n        if grid[row][col] == 1:\n            return False\n        return dfs(row+1, col) or dfs(row, col+1)\n\n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]):\n    return (grid,)\n\ngrid = [[0,0,0],[0,1,0],[0,0,1]]\nassert f(*g(grid))\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if two numbers in the array can be summed to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\nassert f(*g([1, 4, 2, 7, 5, 3], 10))\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D matrix sorted in ascending order from left to right and top to bottom, determine if it contains the target value.\n    Implement the solution using a binary search approach.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows = len(matrix)\n    cols = len(matrix[0])\n    left = 0\n    right = rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        num = matrix[mid // cols][mid % cols]\n        if num == target:\n            return True\n        elif num < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n    return (matrix, target)\nassert f(*g())\n",
        "idx_generation": 292,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine whether it can be expressed as a sum of consecutive positive integers.\n    Return True if n can be expressed as a sum of consecutive positive integers, False otherwise.\"\"\"\n    def is_sum_of_consecutive(n):\n        for i in range(1, n//2 + 1):\n            sum = 0\n            j = i\n            while sum < n:\n                sum += j\n                j += 1\n            if sum == n:\n                return True\n        return False\n    \n    return is_sum_of_consecutive(n)\n\ndef g():\n    return 45\n\nassert f(g())\n",
        "idx_generation": 75,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a binary matrix, find the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Assume all four edges of the matrix are surrounded by water.\"\"\"\n    count = 0\n    m, n = len(matrix), len(matrix[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or matrix[i][j] == 0:\n            return\n        visited[i][j] = True\n        dfs(i-1, j)\n        dfs(i+1, j)\n        dfs(i, j-1)\n        dfs(i, j+1)\n    \n    for i in range(m):\n        for j in range(n):\n            if not visited[i][j] and matrix[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    return count\ndef g(matrix=[[1, 1, 0, 0, 0],\n              [1, 1, 0, 0, 0],\n              [0, 0, 1, 0, 0],\n              [0, 0, 0, 1, 1]]):\n    return matrix\nassert f(g()) == 3\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, remove all the vowels from the string and return the modified string.\"\"\"\n    def helper(s):\n        if s == '':\n            return ''\n        elif s[0] in 'aeiouAEIOU':\n            return helper(s[1:])\n        else:\n            return s[0] + helper(s[1:])\n    return helper(s)\n\ndef g():\n    return 'Hello, World!'\n\nassert f(g()) == 'Hll, Wrld!'\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=5) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there exists a pair of numbers in the list whose bitwise AND is equal to the target number.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] & nums[j] == target:\n                return True\n    return False\ndef g(nums=[2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return nums\nassert f(g())\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the squares of the first n positive integers.\n    Return the calculated sum.\n    \"\"\"\n    return (n * (n + 1) * (2 * n + 1)) // 6\n\ndef g():\n    return 5\n\nassert f(g()) == 55\n",
        "idx_generation": 349,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Determine if there exists a path from start to end in the given directed graph.\"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    return dfs(start, set())\n\ndef g():\n    return {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': []\n    }\n\nassert f(g(), 'A', 'D')\n",
        "idx_generation": 455,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find three numbers in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    for i in range(len(arr)-2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6], 12)\n\nassert f(*g())\n",
        "idx_generation": 129,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found. \n    If not, return the index where it would be if it were inserted in order.\n    You must write an algorithm with O(log n) runtime complexity.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\ndef g():\n    return ([1, 3, 5, 6], 5)\nassert f(*g()) == 2\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a power of two.\"\"\"\n    if n == 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid, determine if it is possible to reach the bottom-right cell\n    starting from the top-left cell. You can only move down or right.\"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    def explore(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        \n        if row < rows - 1 and maze[row + 1][col] != 1:\n            if explore(row + 1, col):\n                return True\n        \n        if col < cols - 1 and maze[row][col + 1] != 1:\n            if explore(row, col + 1):\n                return True\n        \n        return False\n    \n    return explore(0, 0)\n\ndef g():\n    maze = [\n        [0, 0, 1, 0],\n        [1, 0, 0, 0],\n        [0, 1, 1, 0],\n        [1, 1, 0, 0]\n    ]\n    \n    return maze\n\nassert f(g())\n",
        "idx_generation": 216,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string has alternating 0s and 1s of length 4 using string manipulation.\"\"\"\n    return '01' in s and '10' in s and '00' not in s and '11' not in s\ndef g() -> str:\n    \"\"\"Generate a string with alternating 0s and 1s of length 4.\"\"\"\n    return '0101'\nassert f(g())\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of the given list of integers that sums up to the target value.\"\"\"\n    n = len(nums)\n    for mask in range(1 << n):\n        subset_sum = sum(nums[i] for i in range(n) if mask & (1 << i))\n        if subset_sum == target:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), 10)\n",
        "idx_generation": 436,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square. A matrix is considered a magic square if the sum of each row, each column, and each diagonal is the same.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diag_sum = sum(matrix[i][i] for i in range(n))\n    if diag_sum != target_sum:\n        return False\n    \n    anti_diag_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if anti_diag_sum != target_sum:\n        return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    return [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n\nassert f(g())\n",
        "idx_generation": 372,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Given an undirected graph, check if it is a tree.\"\"\"\n    n = len(graph)\n    visited = [False] * n\n    if not dfs(graph, 0, visited, -1):\n        return False\n    if any(not visited[i] for i in range(n)):\n        return False\n    return True\n\ndef dfs(graph, node, visited, parent):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if not dfs(graph, neighbor, visited, node):\n                return False\n        elif neighbor != parent:\n            return False\n    return True\n\ndef g():\n    graph = [[1, 2], [0, 3], [0, 4], [1], [2]]\n    return (graph,)\nassert f(*g()) == True\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given an N x M matrix that is sorted row-wise and column-wise, determine if the matrix contains a target value.\n    Example:\n    matrix = [\n        [1,  4,  7, 11, 15],\n        [2,  5,  8, 12, 19],\n        [3,  6,  9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n    Output:\n    True\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row = 0\n    col = cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g(matrix: List[List[int]], target: int):\n    return matrix, target\n\nassert f(*g([\n    [1,  4,  7, 11, 15],\n    [2,  5,  8, 12, 19],\n    [3,  6,  9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n], 9))\n",
        "idx_generation": 130,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=5) -> bool:\n    \"\"\"Given a list of integers, find a subarray that sums up to the target value.\nReturn True if such a subarray exists, False otherwise.\"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    for i in range(n):\n        left, right = i, n\n        while left < right:\n            mid = (left + right) // 2\n            if prefix_sum[mid] - prefix_sum[i] < target:\n                left = mid + 1\n            else:\n                right = mid\n            if prefix_sum[right] - prefix_sum[i] == target:\n                return True\n    return False\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Check if a string is a palindrome when the first and last n characters are removed.\"\"\"\n    s = s[n:len(s)-n]\n    return s == s[::-1]\ndef g(s='racecar', n=4):\n    return s\nassert f(g())\n",
        "idx_generation": 77,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers nums and an integer n, determine if there exists a subsequence of length n in nums such that the sum of the subsequence is divisible by n.\"\"\"\n    def helper(nums, n, target_sum, index, current_sum):\n        if current_sum % n == target_sum:\n            return True\n        if index >= len(nums):\n            return False\n        return helper(nums, n, target_sum, index + 1, current_sum + nums[index]) or helper(nums, n, target_sum, index + 1, current_sum)\n    \n    target_sum = sum(nums) % n\n    return helper(nums, n, target_sum, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], n=3):\n    return (n, nums)\n\nassert f(*g())\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, a=1, b=2) -> bool:\n    \"\"\"Determine if a number is a palindrome in base `k`\"\"\"\n    num_str = str(n)\n    return num_str == num_str[::-1]\n\ndef g(k=2):\n    \"\"\"Generate a palindrome number in base `k`\"\"\"\n    return int(str(k) + '11' + str(k))\n\nassert f(g(), 2)\n",
        "idx_generation": 70,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the array whose XOR is equal to n.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == n:\n                return True\n    return False\n\ndef g() -> List[int]:\n    return [3, 5, 9, 2, 7, 13]\n\nassert f(14, g())\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the median element in a sorted list of integers.\"\"\"\n    n = len(arr)\n    if n % 2 == 0:\n        median = (arr[n//2] + arr[n//2 - 1]) / 2\n    else:\n        median = arr[n//2]\n    return median\n\ndef g():\n    return [1, 3, 4, 6, 8, 9, 10]\n\nassert f(g()) == 6\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start=0) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if it contains a cycle.\n    \"\"\"\n    visited = set()\n    stack = [(start, -1)]\n    \n    while stack:\n        node, parent = stack.pop()\n        if node in visited:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node))\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1]]\n    return graph\n\nassert f(g())\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers in the list that sum up to the target.\n    Note: You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    Sample input:\n    [2, 7, 11, 15], 9\n    Sample output:\n    [2, 7]\"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"Given an array of non-negative integers representing the elevation map where the width of each bar is 1,\n    compute how much water it can trap after raining.\"\"\"\n    \n    if not heights:\n        return 0\n    \n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], heights[i])\n    \n    right_max[n - 1] = heights[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right_max[i + 1], heights[i])\n    \n    total_water = 0\n    for i in range(n):\n        total_water += min(left_max[i], right_max[i]) - heights[i]\n    \n    return total_water\n\ndef g():\n    return [0,1,0,2,1,0,1,3,2,1,2,1]\n\nassert f(g()) == 6\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n    Return True if the matrix is a magic square, otherwise return False.\"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    for col in range(n):\n        if sum((matrix[row][col] for row in range(n))) != target_sum:\n            return False\n    diagonal_sum1 = sum((matrix[i][i] for i in range(n)))\n    diagonal_sum2 = sum((matrix[i][n-i-1] for i in range(n)))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 81,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase with n steps, where you can either take 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g(n: int) -> int:\n    \"\"\"Return the number of steps in the staircase.\"\"\"\n    return n\nassert f(g(4)) == 5\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Reverse the words in a string while keeping the words in the same order.\"\"\"\n    words = string.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello world\"\n\nassert f(g()) == \"olleH dlrow\"\n",
        "idx_generation": 72,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a power of two.\"\"\"\n    return n != 0 and (n & (n - 1)) == 0\ndef g():\n    n = 16\n    return n\nassert f(g())\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 17\nassert f(g())\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]]) -> bool:\n    \"\"\"Check if a graph is cyclic.\"\"\"\n    visited = set()\n    stack = set()\n\n    def is_cyclic(node):\n        visited.add(node)\n        stack.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if is_cyclic(neighbor):\n                    return True\n            elif neighbor in stack:\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if is_cyclic(node):\n                return True\n\n    return False\n\ndef g() -> Dict[str, List[str]]:\n    return {\n        'A': ['B', 'C'],\n        'B': ['C'],\n        'C': ['D'],\n        'D': ['A']\n    }\n\nassert f(g())\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target value.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return [arr[left], arr[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\nassert f(*g()) == [2, 5]\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if the target value exists in the sorted list using binary search recursively.\"\"\"\n    def binary_search(nums, target, start, end):\n        if start > end:\n            return False\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, end)\n        else:\n            return binary_search(nums, target, start, mid - 1)\n    nums.sort()\n    return binary_search(nums, target, 0, len(nums) - 1)\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15]\nassert f(g(), 9)\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix, check if it is a symmetric matrix.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g(n=4):\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = (i + j) % 2\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 85,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Count the number of ways to arrange n distinct objects in a circle, where some objects have to be placed together.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n] * m\ndef g(n: int, m: int) -> Tuple[int, int]:\n    \"\"\"Return the number of distinct objects to be arranged in a circle and the number of objects to be placed together.\"\"\"\n    return n, m\nassert f(*g(5, 3)) == 24\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Find if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 73,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of set bits (1s) in the binary representation of an integer n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\ndef g(n: int=25):\n    return n\nassert f(g()) == 3\n",
        "idx_generation": 448,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of prime numbers less than a given non-negative integer n.\"\"\"\n    if n <= 2:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    \n    count = sum(primes)\n    return count\n\ndef g(n: int) -> int:\n    return n\n\nn = 20\nassert f(g(n)) == 8\n",
        "idx_generation": 379,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[rows - 1][cols - 1]\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return (grid,)\nassert f(*g()) == 12\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists a pair of numbers in the list whose sum is equal to the target. \n    Otherwise, return False. You can assume the input list is not sorted.\n    \"\"\"\n    nums.sort()  # Sorting the list in ascending order\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        curr_sum = nums[start] + nums[end]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g(nums=[5, 2, 9, 1, 3], target=8):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in the sorted list using binary search recursively.\"\"\"\n    def binary_search(nums, target, start, end):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, end)\n        else:\n            return binary_search(nums, target, start, mid - 1)\n    nums.sort()\n    return binary_search(nums, target, 0, len(nums) - 1)\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16]\nassert f(g(), 8) == 3\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"Given a list of words, find the longest common prefix string among them.\"\"\"\n    if not words:\n        return \"\"\n    \n    prefix = words[0]\n    \n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\ndef g(words: List[str]) -> List[str]:\n    \"\"\"Generate a list of words with random string values for testing.\"\"\"\n    return words\n\nassert f(g(['apple', 'app', 'apply', 'applaud'])) == 'app'\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a contiguous subarray.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums: List[int]):\n    return (nums,)\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(*g(nums)) == 6\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Find if the character at index k in the given string is a vowel.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    return s[k] in vowels\n\ndef g():\n    return \"hello\"\n\nassert f(g(), k=1)\n",
        "idx_generation": 73,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a given number\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 453,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[int]:\n    \"\"\"Generate the first n elements of the Fibonacci sequence\"\"\"\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[:n]\ndef g(n=6):\n    return n\nassert f(g()) == [0, 1, 1, 2, 3, 5]\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"Check if there is a cycle in a directed graph.\"\"\"\n    visited = [False] * n\n    stack = [False] * n\n    \n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    for node in range(n):\n        if not visited[node]:\n            if dfs(node):\n                return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[1], [2], [3], [2]]\n    return (n, edges)\n\nassert f(*g())\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there are two numbers in the array that add up to the target value.\"\"\"\n    def helper(arr, target, start, end):\n        if start >= end:\n            return False\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        if arr[mid] > target:\n            return helper(arr, target, start, mid)\n        else:\n            return helper(arr, target, mid + 1, end)\n    \n    for i in range(len(arr)):\n        if helper(arr, target - arr[i], i + 1, len(arr)):\n            return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 10)\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers, find if there are any two numbers that sum up to a target value.\n    Args:\n        nums: A sorted list of integers\n    Returns:\n        True if there exists two numbers that sum up to the target value, False otherwise.\n    \"\"\"\n    target = 10\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Returns a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 304,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a subarray with a sum equal to zero.\n    Args:\n        nums: The list of integers.\n    Returns:\n        True if there exists a subarray with a sum equal to zero, False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample list of integers.\n    \"\"\"\n    return [4, 2, -3, 1, 6]\n\nassert f(g())\n",
        "idx_generation": 92,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using recursion.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n: int=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g(s: str):\n    return s\n\nassert f(g(\"madam\"))\n",
        "idx_generation": 78,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer k, determine if there exists a subarray with a sum equal to k.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return ([3, 4, 7, 2, -3, 1, 4, 2], 7)\n\nassert f(*g())\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if n is a perfect square.\"\"\"\n    def is_perfect_square(n):\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n    return is_perfect_square(n)\ndef g(n=16):\n    return n\nassert f(g())\n",
        "idx_generation": 383,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"Check if a path can be formed from top-left to bottom-right in a grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    visited = set()\n    \n    def dfs(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        \n        if (row, col) in visited:\n            return False\n        \n        visited.add((row, col))\n        \n        if row < rows - 1 and grid[row+1][col] == '.':\n            if dfs(row+1, col):\n                return True\n        \n        if col < cols - 1 and grid[row][col+1] == '.':\n            if dfs(row, col+1):\n                return True\n        \n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        ['.', '.', '.', '.'],\n        ['.', '#', '#', '.'],\n        ['.', '.', '.', '.'],\n        ['.', '.', '#', '.']\n    ]\n    return (grid,)\n\nassert f(*g())\n",
        "idx_generation": 488,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers, find all unique pairs that sum up to the target value.\nReturn a list of pairs as tuples.\"\"\"\n    pairs = []\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            pairs.append((nums[left], nums[right]))\n            left += 1\n            right -= 1\n            while left < right and nums[left] == nums[left - 1]:\n                left += 1\n            while left < right and nums[right] == nums[right + 1]:\n                right -= 1\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return pairs\ndef g(nums: List[int], target: int):\n    return (nums, target)\nassert f(*g([1, 2, 3, 4, 5, 6], 7)) == [(1, 6), (2, 5), (3, 4)]\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the minimum length of a subarray that has a sum greater than or equal to the target.\n    Return the minimum length of such subarray, or 0 if no such subarray exists.\"\"\"\n    n = len(nums)\n    left = 0\n    min_length = float(\"inf\")\n    current_sum = 0\n    for right in range(n):\n        current_sum += nums[right]\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    if min_length == float(\"inf\"):\n        return 0\n    return min_length\ndef g():\n    return ([2, 3, 1, 2, 4, 3], 7)\nassert f(*g()) == 2\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g() -> int:\n    \"\"\"Find the smallest prime number that can be represented as the sum of two prime numbers in at least two different ways\"\"\"\n    def is_sum_of_primes(n: int) -> bool:\n        primes = [i for i in range(2, n) if f(i)]\n        for i in range(len(primes)):\n            for j in range(i, len(primes)):\n                if primes[i] + primes[j] == n:\n                    return True\n        return False\n\n    n = 4\n    while not (is_sum_of_primes(n) and f(n)):\n        n += 1\n    return n\n\nassert f(g())\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using dynamic programming.\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones.\n    Return the nth Fibonacci number.\n    Example:\n    n = 6\n    The Fibonacci sequence is 0, 1, 1, 2, 3, 5, ...\n    The 6th Fibonacci number is 8.\n    Therefore, the output should be 8.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 233,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a palindrome\"\"\"\n    return str(n) == str(n)[::-1]\n\ndef g():\n    n = 12321\n    return n\n\nassert f(g())\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in a binary representation of a given number.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 27\n\nassert f(g()) == 4\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the smallest positive integer that is evenly divisible by all the numbers from 1 to n.\"\"\"\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n\n    lcm_result = 1\n    for i in range(1, n+1):\n        lcm_result = lcm(lcm_result, i)\n    return lcm_result\n\ndef g():\n    return 10\n\nassert f(g()) == 2520\n",
        "idx_generation": 385,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list,\n    check if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    visited = set()\n    def dfs(node, parent):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    for node in range(len(graph)):\n        if node not in visited:\n            if dfs(node, -1):\n                return True\n    return False\n\ndef g():\n    \"\"\"\n    Return an adjacency list representation of an undirected graph\n    which contains a cycle.\n    \"\"\"\n    return [[1, 2], [0, 2], [0, 1, 3], [2]]\n\nassert f(g())\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is a sorted arithmetic progression.\"\"\"\n    diff = arr[1] - arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] != diff:\n            return False\n    return True\n\ndef g():\n    return [1, 3, 5, 7, 9]\n\nassert f(g())\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of integers in the given list whose sum is equal to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [4, 2, 6, 8, 1, 3]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers nums and a positive integer k, determine if there exists k consecutive elements in nums that sum up to 0.\"\"\"\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n    for i in range(len(nums) - k + 1):\n        if prefix_sum[i + k] - prefix_sum[i] == 0:\n            return True\n    return False\n\ndef g():\n    nums = [-2, 1, 3, -4, 2, -3, 5]\n    k = 3\n    return (nums, k)\n\nassert f(*g())\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous).\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string s is a valid email address.\"\"\"\n    import re\n    pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n    return re.match(pattern, s) is not None\ndef g(s=\"example@email.com\"):\n    return s\nassert f(g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two elements.\nReturn the maximum XOR value.\"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        greedy_xor = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if (greedy_xor ^ prefix) in prefix_set:\n                max_xor = greedy_xor\n                break\n    return max_xor\ndef g(nums: List[int]):\n    return nums\nnums = [3, 10, 5, 25, 2, 8]\nassert f(g(nums)) == 28\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all positive integers up to n.\nArgs:\n    n: The positive integer.\nReturns:\n    The sum of all positive integers up to n.\"\"\"\n    return n * (n + 1) // 2\n\ndef g(n: int):\n    return n\n\nn = 10\nassert f(g(n)) == 55\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list,\n    find the shortest path from node 0 to node N-1.\n\n    Return a list of nodes representing the shortest path.\n    \"\"\"\n    N = len(graph)\n    dist = [float('inf')] * N\n    dist[0] = 0\n    prev = [-1] * N\n    queue = [0]\n\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            if dist[neighbor] == float('inf'):\n                dist[neighbor] = dist[node] + 1\n                prev[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    curr = N - 1\n    while curr != -1:\n        path.append(curr)\n        curr = prev[curr]\n    \n    return path[::-1]\n\ndef g():\n    \"\"\"\n    Return an adjacency list representation of an undirected graph\n    with a shortest path from node 0 to node N-1.\n    \"\"\"\n    return [[1, 2], [0, 3], [0, 3], [1, 2]]\n\nassert f(g()) == [0, 1, 3]",
        "idx_generation": 491,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the given list that sum up to the target, using a binary search approach.\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        left = i + 1\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == complement:\n                return True\n            elif nums[mid] < complement:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert f(g(), 10)\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence using dynamic programming.\"\"\"\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    \n    return max(dp)\n\ndef g():\n    return [3, 4, 2, 8, 10, 5, 1]\n\nassert f(g()) == 4\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the list contains a subarray with a sum equal to zero\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in seen or prefix_sum == 0:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g():\n    return [1, -2, 3, 4, -5]\n\nassert f(g())\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the longest increasing subsequence in the given list.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a given string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\ndef g(s: str) -> str:\n    return s\nassert f(g(\"Hello World\")) == \"World Hello\"\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in a binary representation of a positive integer n.\"\"\"\n    if n == 0:\n        return 0\n    return (n & 1) + f(n >> 1)\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique combinations of k elements that can be formed\n    from the numbers 1 to n such that the bitwise XOR of all the numbers in each combination is odd.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 == 1:\n            count += 1\n    return count\ndef g(n: int=6, k: int=3):\n    return (n, k)\nassert f(*g()) == 3\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there is a cycle in the graph represented by the list\"\"\"\n    visited = set()\n    for num in nums:\n        if num in visited:\n            return True\n        visited.add(num)\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 2, 5, 6, 7]\n\nassert f(g())\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if the target is present in the list, \n    and False otherwise. Implement the search algorithm using a binary search approach.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are three numbers in the list that add up to the target.\n    Return True if such a triplet exists, False otherwise.\"\"\"\n    for i in range(len(arr)):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g() -> List[int]:\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 318,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Return the elements of the matrix in spiral order\"\"\"\n    if not matrix:\n        return []\n    result = []\n    row_begin, row_end = 0, len(matrix) - 1\n    col_begin, col_end = 0, len(matrix[0]) - 1\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end + 1):\n            result.append(matrix[row_begin][i])\n        row_begin += 1\n        for i in range(row_begin, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n        if row_begin <= row_end:\n            for i in range(col_end, col_begin - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n        if col_begin <= col_end:\n            for i in range(row_end, row_begin - 1, -1):\n                result.append(matrix[i][col_begin])\n            col_begin += 1\n    return result\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\nassert f(*g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 118,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix represented as a list of lists, return the sum of each row as a list.\nArgs:\n    matrix: The matrix represented as a list of lists.\nReturns:\n    A list containing the sum of each row in the matrix.\n\"\"\"\n    row_sums = []\n    \n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    \n    return row_sums\n\ndef g():\n    \"\"\"\n    Returns a sample matrix represented as a list of lists.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [6, 15, 24]\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, num_bits=3) -> bool:\n    \"\"\"Check if the given string represents a binary number with the specified number of bits.\n    A binary number consists only of '0' and '1' characters.\"\"\"\n    if len(s) != num_bits:\n        return False\n    for char in s:\n        if char != '0' and char != '1':\n            return False\n    return True\n\ndef g(num_bits=3):\n    return '0' * num_bits\n\nassert f(g())\n",
        "idx_generation": 84,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a power of two.\"\"\"\n    return n > 0 and (n & (n - 1)) == 0\ndef g():\n    return 16\nassert f(g())\n",
        "idx_generation": 485,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if the given number 'n' is divisible by 'k' using the mathematical concept of divisibility.\n    \"\"\"\n    return n % k == 0\n\ndef g() -> tuple:\n    \"\"\"\n    Generate a pair of integers (n, k) where n is divisible by k.\n    \"\"\"\n    return (12, 2)\n\nassert f(*g()) == True\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of size m x n, determine if a target value exists in the matrix.\n    The matrix has the following properties:\n    - Integers in each row are sorted in ascending order from left to right.\n    - The first integer of each row is greater than the last integer of the previous row.\n    Sample Input:\n    matrix = [\n        [1, 3, 5, 7],\n        [10, 11, 16, 20],\n        [23, 30, 34, 60]\n    ]\n    target = 3\n    Sample Output:\n    True\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    m, n = len(matrix), len(matrix[0])\n    low, high = 0, m * n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        num = matrix[mid // n][mid % n]\n        if num == target:\n            return True\n        elif num < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\ndef g():\n    return ([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 3)\nassert f(*g())\n",
        "idx_generation": 140,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers, determine if there are three numbers that sum up to the target.\"\"\"\n    numbers.sort()\n    length = len(numbers)\n    for i in range(length - 2):\n        left = i + 1\n        right = length - 1\n        while left < right:\n            current_sum = numbers[i] + numbers[left] + numbers[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(numbers=[1, 2, 3, 4, 5], target=9):\n    return (numbers, target)\n\nassert f(*g())\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target value exists in the grid.\"\"\"\n    for row in grid:\n        if target in row:\n            return True\n    return False\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 5)\n",
        "idx_generation": 118,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if it is possible to convert s to the target string by performing the following operations:\n    - Remove any character from the string\n    - Insert any character at any position in the string\n    - Replace any character with any other character\n    \"\"\"\n    m = len(s)\n    n = len(target)\n    dp = [[False] * (n+1) for _ in range(m+1)]\n    for i in range(m+1):\n        dp[i][0] = True\n    for j in range(n+1):\n        dp[0][j] = True\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == target[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i-1][j-1]\n    return dp[m][n]\n\ndef g() -> Tuple[str, str]:\n    return ('kitten', 'sitting')\n\nassert f(*g())\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if a string is a palindrome after removing at most one character.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. The function should return True if the string is a palindrome after removing at most one character, and False otherwise.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return s[i:j] == s[i:j][::-1] or s[i+1:j+1] == s[i+1:j+1][::-1]\n        i += 1\n        j -= 1\n    return True\n\ndef g(s: str) -> str:\n    \"\"\"Generate a palindrome by removing at most one character from the input string.\n    The generated palindrome should be obtained by removing at most one character from the input string. If multiple palindromes can be generated, any valid palindrome can be returned.\n    \"\"\"\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            if s[i+1:j+1] == s[i+1:j+1][::-1]:\n                return s[i:j]\n            else:\n                return s[i+1:j+1]\n        i += 1\n        j -= 1\n    return s\n\ns = \"abbxa\"\nassert f(g(s))\n",
        "idx_generation": 84,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Count the number of set bits in the binary representation of n.\"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\ndef g():\n    n = random.randint(1, 1000)\n    return n\nassert f(g()) >= 0\n",
        "idx_generation": 489,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer 'n', determine if it is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Given a 2D grid of integers and a target value, determine if the target exists in the grid.\n    Return True if the target exists, otherwise return False.\"\"\"\n    m, n = len(grid), len(grid[0])\n    low, high = 0, m * n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        row, col = mid // n, mid % n\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    grid = [\n        [1, 3, 5, 7],\n        [10, 11, 16, 20],\n        [23, 30, 34, 60]\n    ]\n    target = 16\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 142,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> bool:\n    \"\"\"Given a list of integers representing the heights of buildings, determine the amount of water that can be trapped between them.\n    The buildings are represented by a histogram, where each bar represents the height of a building.\n    Return the total amount of water that can be trapped.\"\"\"\n    n = len(heights)\n    if n < 3:\n        return 0\n\n    left = [0] * n\n    right = [0] * n\n    left[0] = heights[0]\n    right[-1] = heights[-1]\n\n    for i in range(1, n):\n        left[i] = max(left[i - 1], heights[i])\n\n    for i in range(n - 2, -1, -1):\n        right[i] = max(right[i + 1], heights[i])\n\n    water = 0\n    for i in range(1, n - 1):\n        water += min(left[i], right[i]) - heights[i]\n\n    return water\n\ndef g():\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return heights\n\nassert f(g()) == 6\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the sum of all elements in the matrix that are divisible by 3.\"\"\"\n    count = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0:\n                count += num\n    return count\n\ndef g(matrix: List[List[int]]):\n    return matrix\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 18\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs, where each step can be climbed either by taking one step or two steps at a time\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, return True if it is a palindrome.\n    \"\"\"\n    string = string.lower()  # Convert to lowercase\n    string = ''.join(char for char in string if char.isalnum())  # Remove non-alphanumeric characters\n    return string == string[::-1]  # Check if the string is equal to its reverse\n\ndef g(string: str) -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return string + string[::-1]  # Append the reverse of the string to itself\n\n# Test\nstring = \"racecar\"\nassert f(g(string))\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits that are set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n    \ndef g(n=17):\n    return n\n    \nassert f(g())\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sums up to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    return [2, 4, 7, 11, 15], 9\n\nassert f(*g())\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    nums = [4, 12, 8, 1, 10]\n    return nums\n\nassert f(g()) == 14\n",
        "idx_generation": 327,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Determine if a number is a power of two.\"\"\"\n    if num == 0:\n        return False\n    while num % 2 == 0:\n        num //= 2\n    return num == 1\n\ndef g():\n    return 16\n\nassert f(g())\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Given two positive integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner in a grid of size n x m.\n    You can only move down or right.\"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n - 1, m) + f(n, m - 1)\n\ndef g(n: int, m: int):\n    return n, m\n\nn = 3\nm = 4\nassert f(*g(n, m)) == 10\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str, n: int, k: int) -> bool:\n    \"\"\"Determine if the given string s can be obtained by concatenating n copies of the string 'ab' and m copies of the string 'cd',\n    where n and m are non-negative integers and k = m - n.\"\"\"\n    count_ab = s.count('ab')\n    count_cd = s.count('cd')\n    return count_ab + k == count_cd and n >= count_ab and n - count_ab <= k\n\ndef g(n: int, k: int):\n    return 'ab' * n + 'cd' * (n + k)\n\nassert f(g(n=3, k=2), n=3, k=2)\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g())\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [-2, 0, 3, 5, 7, 9, 11]\n\nassert f(g(), 8)\n",
        "idx_generation": 144,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers whose sum equals the target.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9], 10\n\nassert f(*g())\n",
        "idx_generation": 330,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"Given a positive integer num, determine if it is a palindrome in binary representation.\"\"\"\n    binary = bin(num)[2:]\n    return binary == binary[::-1]\ndef g():\n    return 9\nassert f(g())\n",
        "idx_generation": 122,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if a target number can be obtained using all the numbers in the list by performing addition and subtraction operations in any order.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return target == 0\n\n    # Use dynamic programming to check if the target can be obtained\n    dp = [[False] * (target + 1) for _ in range(n)]\n    dp[0][nums[0]] = True\n\n    for i in range(1, n):\n        for j in range(target + 1):\n            if dp[i-1][j]:\n                dp[i][j] = True\n                if j + nums[i] <= target:\n                    dp[i][j + nums[i]] = True\n                if j - nums[i] >= 0:\n                    dp[i][j - nums[i]] = True\n\n    return dp[n-1][target]\n\ndef g():\n    nums = [1, 2, 3, 4]\n    target = 5\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a valid palindrome by ignoring non-alphanumeric characters and considering case insensitivity.\n    \"\"\"\n    string = ''.join(c.lower() for c in string if c.isalnum())\n    return string == string[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 93,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a list of integers contains a subsequence where the sum of all elements is equal to 0.\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\ndef g():\n    return [4, -2, 3, 1, -6, -3, -1, 2, 7]\nassert f(g())\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order. \n    Return the sorted list.\"\"\"\n    return sorted(nums)\n\ndef g():\n    nums = [4, 2, 7, 1, 5, 3]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5, 7]\n",
        "idx_generation": 145,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n    Example:\n    nums = [2, 5, 8, 11, 15]\n    target = 13\n    Output: True (2 + 11 = 13)\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n    \ndef g():\n    return [1, 6, 9, 12, 15]\n    \nassert f(g(), 21)\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum of a submatrix where the submatrix can only contain elements from the same row or column.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    row_sums = [0] * rows\n    col_sums = [0] * cols\n    for i in range(rows):\n        for j in range(cols):\n            row_sums[i] += matrix[i][j]\n            col_sums[j] += matrix[i][j]\n    max_sum = max(max(row_sums), max(col_sums))\n    return max_sum\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\nassert f(g()) == 24\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine if it is possible to form a sequence of length n where each number is a multiple of k and the sum of any two adjacent numbers is a perfect square.\"\"\"\n    sequence = [0] * n\n\n    def backtrack(index):\n        if index == n:\n            return True\n\n        for i in range(1, n+1):\n            if sequence[index-1] != 0 and (i + sequence[index-1]) not in perfect_squares:\n                continue\n\n            if i % k == 0:\n                sequence[index] = i\n                if backtrack(index + 1):\n                    return True\n                sequence[index] = 0\n\n        return False\n\n    perfect_squares = {i**2 for i in range(n)}\n\n    return backtrack(0)\n\ndef g():\n    n = 4\n    k = 2\n    return (n, k)\n\nassert f(*g())\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern='ABC') -> bool:\n    \"\"\"Check if the string follows a specific pattern where each letter in the pattern corresponds to a substring of s.\"\"\"\n    pattern_len = len(pattern)\n    s_len = len(s)\n    if pattern_len == 0 or s_len == 0:\n        return False\n    if s_len % pattern_len != 0:\n        return False\n    for i in range(0, s_len, pattern_len):\n        if s[i:i+pattern_len] != pattern:\n            return False\n    return True\ndef g(pattern='ABC'):\n    return pattern * 3\nassert f(g())\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a power of 2.\"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n    return True\ndef g(n=16):\n    return n\nassert f(g())\n",
        "idx_generation": 460,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    i, j = 0, len(nums) - 1\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return True\n        elif nums[i] + nums[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums\n\nassert f(g(), 9) == True\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list whose sum is equal to the target.\n    Each number in the list can only be used once in a subset.\"\"\"\n    def backtrack(nums, target, start, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if backtrack(nums, target, i+1, current_sum + nums[i]):\n                return True\n        return False\n\n    nums.sort()\n    return backtrack(nums, target, 0, 0)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\n\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 333,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a valid Sudoku solution\"\"\"\n    def is_valid(arr: List[int]) -> bool:\n        seen = set()\n        for num in arr:\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    # Check rows\n    for row in grid:\n        if not is_valid(row):\n            return False\n    # Check columns\n    for j in range(len(grid[0])):\n        column = [grid[i][j] for i in range(len(grid))]\n        if not is_valid(column):\n            return False\n    # Check subgrids\n    for i in range(0, len(grid), 3):\n        for j in range(0, len(grid[0]), 3):\n            subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid(subgrid):\n                return False\n    return True\ndef g():\n    return [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]\nassert f(g())\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner. A path can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    def helper(row: int, col: int) -> int:\n        if row == rows - 1 and col == cols - 1:\n            return grid[row][col]\n        if row == rows - 1:\n            return grid[row][col] + helper(row, col + 1)\n        if col == cols - 1:\n            return grid[row][col] + helper(row + 1, col)\n        return grid[row][col] + max(helper(row + 1, col), helper(row, col + 1))\n    return helper(0, 0)\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return (grid,)\nassert f(*g()) == 12\n",
        "idx_generation": 247,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=1, k=2) -> bool:\n    \"\"\"Check if a string s is a palindrome when its characters are reversed and\n    all uppercase letters are converted to lowercase.\"\"\"\n    reversed_s = s[::-1].lower()\n    return s.lower() == reversed_s\ndef g(s=\"Racecar\"):\n    return s\nassert f(g())\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of all positive integers less than or equal to n using the formula (n * (n + 1)) / 2.\"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    n = 10\n    return (n,)\n\nassert f(*g()) == 55\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exists two numbers in the list whose sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    \"\"\"Generate a sorted list of integers.\"\"\"\n    return [1, 3, 5, 7, 9]\n\ntarget = 10\nassert f(g(), target)\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'nums' in ascending order, determine if 'target' exists in the list.\"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, right)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 9)\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers arr, find the length of the longest subarray with equal number of 0's and 1's.\"\"\"\n    prefix_sum = 0\n    max_length = 0\n    sum_indices = {}\n    for i, num in enumerate(arr):\n        if num == 0:\n            prefix_sum -= 1\n        else:\n            prefix_sum += 1\n        if prefix_sum == 0:\n            max_length = i + 1\n        elif prefix_sum in sum_indices:\n            max_length = max(max_length, i - sum_indices[prefix_sum])\n        else:\n            sum_indices[prefix_sum] = i\n    return max_length\n\ndef g():\n    return [0, 1, 0, 1, 1, 0, 0, 1, 1]\n\nassert f(g()) == 8\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using recursion and memoization.\"\"\"\n    memo = {}\n\n    def fibonacci(n):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1) + fibonacci(n-2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g():\n    n = 8\n    return (n,)\n\nassert f(*g()) == 21\n",
        "idx_generation": 250,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 116,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given array where the sum of elements is divisible by 4.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        prefix_sums.add(prefix_sum)\n        if prefix_sum % 4 == 0 or prefix_sum - 4 in prefix_sums:\n            return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a list of 10 random integers between 1 and 10.\"\"\"\n    import random\n    return [random.randint(1, 10) for _ in range(10)]\n\nassert f(g())\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of numbers and a target value, find two numbers from the list that add up to the target.\n    Return the indices of the two numbers in the original list.\"\"\"\n    num_idx = {}\n    for i, num in enumerate(nums):\n        if target - num in num_idx:\n            return [num_idx[target - num], i]\n        num_idx[num] = i\n    return []\ndef g():\n    return [2, 7, 11, 15]\nassert f(g(), 9) == [0, 1]\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there are three integers in the list that sum up to the target value. Return True if such three integers exist, otherwise return False.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return (nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 18\nassert f(*g(nums, target)) == True\n",
        "idx_generation": 335,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid consisting of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle, determine the number of obstacles in the grid.\n    Return the count of obstacles in the grid.\"\"\"\n    count = 0\n    for row in grid:\n        count += row.count(1)\n    return count\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    return grid\n\nassert f(g([[0, 1, 0], [1, 1, 0], [0, 0, 1]])) == 4\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"Check if a string can be segmented into space-separated words from a given dictionary using dynamic programming.\"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n+1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g():\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n    return (s, wordDict)\n\nassert f(*g()) == True\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid URL.\"\"\"\n    return s.startswith('http://') or s.startswith('https://')\ndef g():\n    return 'https://www.example.com'\nassert f(g())\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose sum is equal to the target number.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14], 16\n\nassert f(*g())\n",
        "idx_generation": 151,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"Given a list of numbers, find all unique triplets that add up to zero.\"\"\"\n    nums.sort()\n    n = len(nums)\n    result = []\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        l, r = i + 1, n - 1\n        while l < r:\n            total = nums[i] + nums[l] + nums[r]\n            if total < 0:\n                l += 1\n            elif total > 0:\n                r -= 1\n            else:\n                result.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l + 1]:\n                    l += 1\n                while l < r and nums[r] == nums[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return result\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert f(g(nums)) == [[-1, -1, 2], [-1, 0, 1]]\n",
        "idx_generation": 337,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Remove duplicates from a sorted list and return the new list with duplicates removed.\"\"\"\n    unique_nums = []\n    for num in nums:\n        if not unique_nums or num != unique_nums[-1]:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g(nums=[1, 1, 2, 2, 3, 4, 4, 5]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if it is possible to split the list into two subarrays with equal sums.\n    Otherwise, return False.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n\n    def dfs(index: int, current_sum: int) -> bool:\n        if current_sum == target_sum:\n            return True\n        if index >= len(nums) or current_sum > target_sum:\n            return False\n        return dfs(index + 1, current_sum + nums[index]) or dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\ndef g(nums=[1, 5, 11, 5]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid phone number.\"\"\"\n    return s.isdigit() and len(s) == 10\ndef g():\n    return '1234567890'\nassert f(g())\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 3, 5, 2, 6, 9, 8], 10\nassert f(*g())\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target number exists in the matrix, where each row is sorted in ascending order and the first element of each row is greater than the last element of the previous row.\"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    left, right = 0, rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        row, col = mid // cols, mid % cols\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    return [[1, 3, 5], [7, 9, 11], [13, 15, 17]]\n\nassert f(g(), 11) == True\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, remove all duplicates in the list and return the modified list.\"\"\"\n    return list(set(nums))\n\ndef g():\n    \"\"\"Generate a list of integers with duplicates.\"\"\"\n    return [1, 2, 3, 1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 149,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where all the 1s in the path are surrounded by 0s.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def dfs(row: int, col: int) -> bool:\n        if row == rows - 1 and col == cols - 1:\n            return True\n\n        if row < 0 or row >= rows or col < 0 or col >= cols or matrix[row][col] != 0:\n            return False\n\n        matrix[row][col] = -1\n\n        if dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g():\n    matrix = [\n        [0, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 250,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if the given string is a palindrome and its length is a power of 2.\"\"\"\n    return s == s[::-1] and len(s) == 2 ** n\n\ndef g(n=3):\n    return 'a' * (2 ** n)\nassert f(g())\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(array: List[int], target: int, left: int = 0, right: int = None) -> bool:\n    \"\"\"\n    Given a sorted array of integers, implement a function to search for a target value.\n    If the target is found in the array, return True; otherwise, return False.\n    The array is sorted in ascending order.\n    You may assume that all elements in the array are unique.\n    \"\"\"\n    if right is None:\n        right = len(array) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if array[mid] == target:\n            return True\n        elif array[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(array: List[int], target: int):\n    return array, target\n\nassert f(*g([1, 3, 5, 7, 9], 5))\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 341,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return f(n - 1) + f(n - 2)\ndef g():\n    return 6\nassert f(g()) == 8\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python') -> bool:\n    \"\"\"Check if the given string is a rotation of the target string.\"\"\"\n    return s in target * 2\n\ndef g(target='python'):\n    return target[-1] + target[:-1]\nassert f(g())\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists two numbers in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 342,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if the given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 17\nassert f(g())\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, determine if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of values along the path equals the target value.\n    Each step in the path can only move down or right.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n\n    def backtrack(i: int, j: int, curr_sum: int) -> bool:\n        if curr_sum == target and i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return True\n        if i >= len(grid) or j >= len(grid[0]):\n            return False\n        return backtrack(i + 1, j, curr_sum + grid[i][j]) or backtrack(i, j + 1, curr_sum + grid[i][j])\n\n    return backtrack(0, 0, 0)\n\ndef g(grid: List[List[int]], target: int):\n    return (grid, target)\n\nassert f(*g([[1, 3, 1], [1, 5, 1], [4, 2, 1]], 8))\n",
        "idx_generation": 254,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=100) -> bool:\n    \"\"\"Check if the given string contains exactly n substrings that start with 'a' and end with 'b'.\"\"\"\n    return s.count('ab') == n\n\ndef g(n=100):\n    return 'ab' * n\nassert f(g())\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list containing only the prime numbers.\"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return [num for num in nums if is_prime(num)]\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]\nassert f(g()) == [3, 5, 7, 11, 13]\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return [2, 7, 11, 15, 3, 6, 9, 13]\n\nassert f(g(), 12) == [3, 9]\n",
        "idx_generation": 344,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Determine if the target number is present in the matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    r = 0\n    c = cols - 1\n    while r < rows and c >= 0:\n        if matrix[r][c] == target:\n            return True\n        elif matrix[r][c] < target:\n            r += 1\n        else:\n            c -= 1\n    return False\n\ndef g(rows=3, cols=3, target=5):\n    matrix = [[0] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            matrix[r][c] = r * cols + c + 1\n    return matrix\n\nassert f(g(), target=5)\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers representing a maze, find the maximum sum of values from the top-left corner to the bottom-right corner.\n    Each cell in the grid can be either positive or negative.\n    You can only move down or right from a cell to its neighboring cell.\n    Return the maximum sum of values.\n    \"\"\"\n\n    def dp(i: int, j: int) -> int:\n        if i < 0 or j < 0:\n            return float('-inf')\n        if i == 0 and j == 0:\n            return grid[i][j]\n        return grid[i][j] + max(dp(i - 1, j), dp(i, j - 1))\n\n    return dp(len(grid) - 1, len(grid[0]) - 1)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 254,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome and contains the word 'racecar'.\n    \"\"\"\n    return s == s[::-1] and 'racecar' in s\n\ndef g():\n    return 'racecar'\n\nassert f(g())\n",
        "idx_generation": 120,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are two numbers in the list\n    that sum up to the target.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 4, 7, 9, 11, 13], 16)\n\nassert f(*g()) == True\n",
        "idx_generation": 155,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target value 'target', determine if there are three numbers in the list that sum up to the target.\n    \"\"\"\n    def three_sum(arr: List[int], target: int, start: int, count: int) -> bool:\n        if target == 0 and count == 0:\n            return True\n        if start == len(arr) or count <= 0:\n            return False\n\n        # Include the current number and recursively check for the remaining count and target\n        if three_sum(arr, target - arr[start], start + 1, count - 1):\n            return True\n\n        # Exclude the current number and recursively check for the remaining count and target\n        if three_sum(arr, target, start + 1, count):\n            return True\n\n        return False\n\n    arr.sort()\n    return three_sum(arr, target, 0, 3)\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=15):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(num_list: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a geometric progression.\"\"\"\n    if len(num_list) < 2:\n        return False\n    \n    ratio = num_list[1] / num_list[0]\n    for i in range(1, len(num_list)):\n        if num_list[i] != num_list[i-1] * ratio:\n            return False\n    \n    return True\n\ndef g() -> List[int]:\n    return [2, 4, 8, 16, 32]\n\nassert f(g())\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target_sum=10) -> bool:\n    \"\"\"\n    Given a list of numbers, find a combination of numbers that adds up to the target sum.\n    Return True if such a combination exists, otherwise return False.\n    \n    Sample Input:\n    numbers = [1, 2, 3, 4, 5]\n    target_sum = 10\n    \n    Sample Output:\n    True\n    \"\"\"\n    def helper(numbers, target_sum, current_sum, index):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index >= len(numbers):\n            return False\n        \n        if helper(numbers, target_sum, current_sum + numbers[index], index + 1):\n            return True\n        \n        return helper(numbers, target_sum, current_sum, index + 1)\n    \n    return helper(numbers, target_sum, 0, 0)\n\ndef g(numbers=[1, 2, 3, 4, 5], target_sum=10):\n    return numbers\n\nassert f(g())\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Check if the given string contains exactly n occurrences of the substring 'abc'\n    and the length of the string is greater than or equal to n * 3.\n    \"\"\"\n    return s.count('abc') == n and len(s) >= n * 3\n\ndef g(n: int):\n    return 'abc' * n\n\nassert f(g(3), 3)\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n    \"\"\"\n    nums.sort()\n    return max(nums[0] * nums[1], nums[-2] * nums[-1])\n\ndef g() -> List[int]:\n    return [4, 1, 6, 3, 8, 2]\n\nassert f(g()) == 48\n",
        "idx_generation": 155,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous) in the list.\n    Return the length of the longest increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    n = 23\n    return n\n\nassert f(g())\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum possible sum of a subarray within the list.\n    You must solve this problem in O(n) time complexity.\n    \"\"\"\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += nums[i]\n        max_sum = max(max_sum, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, x: int) -> bool:\n    \"\"\"\n    Check if the given string contains 'x' concatenated with itself 'x' number of times.\n    \"\"\"\n    return s == 'x' * x\n\ndef g(x: int):\n    return 'x' * x\n\nassert f(g(5), 5)\n",
        "idx_generation": 120,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list that add up to the target value\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 5, 3, 9, 2]\n    target = 8\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 157,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the maximum sum of a subarray that is less than or equal to the target value.\"\"\"\n    prefix_sums = [0] * (len(nums) + 1)\n    for i in range(1, len(nums) + 1):\n        prefix_sums[i] = prefix_sums[i-1] + nums[i-1]\n    max_sum = float('-inf')\n    for i in range(len(prefix_sums)):\n        for j in range(i+1, len(prefix_sums)):\n            if prefix_sums[j] - prefix_sums[i] <= target:\n                max_sum = max(max_sum, prefix_sums[j] - prefix_sums[i])\n    return max_sum\n\ndef g(nums=[1, -2, 3, 4, -5], target=5):\n    return (nums, target)\n\nassert f(*g()) == 5\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 17\nassert f(g())\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there is a pair of numbers in the list whose sum is equal to the target value.\"\"\"\n    def helper(arr, target, index):\n        if target == 0:\n            return True\n        if index == len(arr):\n            return False\n        if arr[index] <= target:\n            if helper(arr, target - arr[index], index + 1):\n                return True\n        return helper(arr, target, index + 1)\n    return helper(arr, target, 0)\n\ndef g():\n    return ([2, 4, 6, 8, 10], 16)\n\nassert f(*g())\n",
        "idx_generation": 259,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome after removing exactly one character.\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    if is_palindrome(s):\n        return True\n    for i in range(len(s)):\n        modified = s[:i] + s[i+1:]\n        if is_palindrome(modified):\n            return True\n    return False\ndef g():\n    return 'radar'\nassert f(g())\n",
        "idx_generation": 122,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product of any two numbers in the list.\"\"\"\n    def max_product(nums):\n        max_product = float('-inf')\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                product = nums[i] * nums[j]\n                if product > max_product:\n                    max_product = product\n        return max_product\n\n    return max_product(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(*g()) == 20\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence (not necessarily contiguous) in the list.\"\"\"\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 354,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, a=100, b=200) -> bool:\n    \"\"\"Find a pair of integers (x, y) such that x^2 + y^2 = n, x <= a, and y <= b\"\"\"\n    for x in range(a + 1):\n        for y in range(b + 1):\n            if x**2 + y**2 == n:\n                return True\n    return False\ndef g(a=100, b=200):\n    return (a, b)\nassert f(*g())\n",
        "idx_generation": 175,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nassert f(g(nums)) == 4\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, check if s1 is a rotation of s2.\n\n    Args:\n    - s1: A string\n    - s2: Another string\n\n    Returns:\n    - True if s1 is a rotation of s2, False otherwise\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    s1s1 = s1 + s1\n\n    return s2 in s1s1\n\ndef g():\n    return (\"waterbottle\", \"erbottlewat\")\n\nassert f(*g())\n",
        "idx_generation": 123,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if a list of integers is a permutation of the numbers from 1 to n, where n is the length of the list.\n    Sample Input:\n    arr = [4, 2, 1, 3]\n    Sample Output:\n    True\"\"\"\n    n = len(arr)\n    sorted_arr = sorted(arr)\n    for i in range(n):\n        if sorted_arr[i] != i + 1:\n            return False\n    return True\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(g([4, 2, 1, 3]))\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray in the list.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid contains a valid Sudoku solution.\"\"\"\n    def is_valid_sudoku(grid):\n        # Check rows\n        for row in grid:\n            if not is_valid(row):\n                return False\n        \n        # Check columns\n        for col in range(9):\n            column = [grid[i][col] for i in range(9)]\n            if not is_valid(column):\n                return False\n        \n        # Check subgrids\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [grid[row][col] for row in range(i, i+3) for col in range(j, j+3)]\n                if not is_valid(subgrid):\n                    return False\n        \n        return True\n    \n    def is_valid(nums):\n        counts = [0] * 10\n        for num in nums:\n            if num != 0:\n                counts[num] += 1\n                if counts[num] > 1:\n                    return False\n        return True\n    \n    return is_valid_sudoku(grid)\n    \ndef g():\n    grid = [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, find if there exists a subsequence in nums that sums up to the target.\nArgs:\n    nums: The list of integers.\n    target: The target sum.\nReturns:\n    True if a subsequence exists, False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target+1) for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = True\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n    return dp[n][target]\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\nassert f(*g())\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a given string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\ndef g():\n    return (\"Hello World\",)\nassert f(g()[0]) == \"World Hello\"\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find two numbers that add up to the given target. Return True if such a pair exists, otherwise return False.\n    Sample input:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 9\n    Sample output:\n    True\n    Explanation: The pair (3, 6) adds up to the target 9.\"\"\"\n    low, high = 0, len(arr) - 1\n    \n    while low < high:\n        if arr[low] + arr[high] == target:\n            return True\n        elif arr[low] + arr[high] < target:\n            low += 1\n        else:\n            high -= 1\n    \n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to a given target.\n    Return True if there are two such numbers, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given array\"\"\"\n    max_sum = 0\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n        if curr_sum < 0:\n            curr_sum = 0\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\nassert f(g([-2, 1, -3, 4, -1, 2, 1, -5, 4])) == 6\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, determine the number of distinct ways to climb to the top of a staircase.\n    You can climb either 1 or 2 steps at a time. The goal is to find the number of distinct ways to reach the top.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n - 1) + f(n - 2)\ndef g(n=4):\n    return n\nassert f(g()) == 5\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalpha())\n    return s == s[::-1]\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\nassert f(g())\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if the target number is present in the given sorted list of integers.\n\n    Args:\n        nums: A sorted list of integers.\n        target: The number to search for in the list.\n\n    Returns:\n        True if the target number is present in the list, False otherwise.\n    \"\"\"\n    start = 0\n    end = len(nums) - 1\n\n    while start <= end:\n        mid = (start + end) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n\n    Returns:\n        A sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 9)\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    You can assume that the input array is sorted in ascending order.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 359,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers, rotate it 90 degrees clockwise.\"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-1-i] = matrix[i][j]\n    return rotated\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if it can be divided into two subarrays such that the sum of elements in both subarrays is equal.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target_sum]\ndef g():\n    nums = [1, 5, 11, 5]\n    return (nums,)\nassert f(*g()) == True\n",
        "idx_generation": 263,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\n    \ndef g(s: str):\n    return s\n\nassert f(g(\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target, find two numbers in the list that sum up to the target using a two-pointer approach.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    return ([2, 7, 11, 15], 9)\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers 'arr' and a target value 'target',\n    determine if there exists a pair of elements in the array such that their sum equals the target.\n\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    def twoSum(arr, target, start, end):\n        if start >= end:\n            return False\n\n        current_sum = arr[start] + arr[end]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            return twoSum(arr, target, start + 1, end)\n        else:\n            return twoSum(arr, target, start, end - 1)\n\n    return twoSum(arr, target, 0, len(arr) - 1)\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Return the sum of the largest numbers in each row of the grid.\"\"\"\n    row_sums = []\n    for row in grid:\n        max_num = max(row)\n        row_sums.append(max_num)\n    \n    return sum(row_sums)\n\ndef g():\n    \"\"\"\n    Return a grid containing integers.\n    \"\"\"\n    grid = [\n        [1, 3, 5],\n        [2, 4, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 5 + 6 + 9\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, word_dict: List[str]) -> bool:\n    \"\"\"Check if a given string can be segmented into a space-separated sequence of dictionary words.\"\"\"\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g(s: str, word_dict: List[str]):\n    return (s, word_dict)\n\n# Test case\nstring = \"leetcode\"\ndictionary = [\"leet\", \"code\"]\nassert f(*g(string, dictionary)) == True\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string s, find the length of the longest substring without repeating characters.\"\"\"\n    max_length = 0\n    start = 0\n    char_dict = {}\n    for i in range(len(s)):\n        if s[i] in char_dict and start <= char_dict[s[i]]:\n            start = char_dict[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_dict[s[i]] = i\n    return max_length\n\ndef g(s: str):\n    return s\n\nassert f(g('abcabcbb')) == 3\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists two numbers in the given array that sum up to the target\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr\n\narr = [1, 4, 7, 3, 9, 2]\ntarget = 11\nassert f(g(arr, target), target)\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exist two numbers in the list that sum up to the target\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([1, 4, 2, 7, 9, 5], 11)\nassert f(*g())\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a palindrome.\"\"\"\n    n = len(nums)\n    for i in range(n // 2):\n        if nums[i] != nums[n - i - 1]:\n            return False\n    return True\n\ndef g(nums: List[int]):\n    return nums\n\nnums = [1, 2, 3, 2, 1]\nassert f(g(nums))\n\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of ways to climb to the top of a staircase with n steps. You can only climb 1 or 2 steps at a time.\"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    a, b = 1, 2\n    for i in range(3, n + 1):\n        a, b = b, a + b\n    return b\ndef g():\n    return 10\nassert f(g()) == 89\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target word, determine if the target word can be formed by concatenating two words from the list.\n    The order of words in the list cannot be changed.\n    Example:\n    words = ['apple', 'banana', 'cat', 'dog']\n    target = 'applebanana'\n    Output: True\n    Explanation: 'apple' and 'banana' can be concatenated to form 'applebanana'\"\"\"\n    word_set = set(words)\n    for i in range(1, len(target)):\n        if target[:i] in word_set and target[i:] in word_set:\n            return True\n    return False\n\ndef g(words=['apple', 'banana', 'cat', 'dog'], target='applebanana'):\n    return (words, target)\n\nassert f(*g())\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target value 'target', find two numbers in the list that sum up to the target value.\nReturn True if such a pair exists, otherwise return False.\n\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 164,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists a pair of elements whose sum is equal to the target value.\"\"\"\n    def helper(nums, target, start, end):\n        if start >= end:\n            return False\n        if nums[start] + nums[end] == target:\n            return True\n        elif nums[start] + nums[end] < target:\n            return helper(nums, target, start + 1, end)\n        else:\n            return helper(nums, target, start, end - 1)\n    return helper(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums\n\nassert f(g(), target=7)\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth number in the Fibonacci sequence.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i-1] + fib[i-2])\n    return fib[n]\n\ndef g(n: int):\n    return n\n\nn = 6\nassert f(g(n)) == 8\n\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of arr that sums up to the target\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Find a subset from the given array that sums up to the target\"\"\"\n    arr = [2, 4, 6, 8]\n    target = 10\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string represents a valid phone number with the following format: (XXX) XXX-XXXX.\"\"\"\n    if len(s) != 14:\n        return False\n    if s[0] != '(' or s[4] != ')' or s[5] != ' ' or s[9] != '-':\n        return False\n    for i in range(1, 4):\n        if not s[i].isdigit():\n            return False\n    for i in range(6, 9):\n        if not s[i].isdigit():\n            return False\n    for i in range(10, 14):\n        if not s[i].isdigit():\n            return False\n    return True\n\ndef g():\n    return '(123) 456-7890'\n\nassert f(g())\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers, find the position of the target value using binary search.\n    If the target value is found, return its index. Otherwise, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, find if there exists a pair of numbers in the list that sum up to the target.\n    \n    Args:\n        nums: The list of integers.\n        target: The target sum.\n        \n    Returns:\n        True if a pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g())\n",
        "idx_generation": 375,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray in nums that sums up to k\"\"\"\n    prefix_sum = defaultdict(int)\n    prefix_sum[0] = 1\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum += num\n        if prefix_sum[curr_sum - k] > 0:\n            return True\n        prefix_sum[curr_sum] += 1\n    \n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], k=9):\n    return nums, k\n\nassert f(*g())\n",
        "idx_generation": 184,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the nth number in the Fibonacci sequence.\nArgs:\n    n: An integer.\nReturns:\n    The nth number in the Fibonacci sequence.\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0] * (n + 1)\n        fib[1] = 1\n        for i in range(2, n + 1):\n            fib[i] = fib[i - 1] + fib[i - 2]\n        return fib[n]\n\ndef g():\n    \"\"\"\n    Returns a sample integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if the string s is a palindrome\"\"\"\n    return s == s[::-1]\ndef g(s: str):\n    return s + s[::-1]\nassert f(g(s=\"racecar\"))\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [3, 5, 2, 8, 1]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return the longest increasing subsequence (not necessarily contiguous) in the list.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    longest_subsequence = []\n    for i in range(n-1, -1, -1):\n        if dp[i] == max_length:\n            longest_subsequence.insert(0, nums[i])\n            max_length -= 1\n    return longest_subsequence\n\ndef g():\n    nums = [3, 4, -1, 0, 6, 2, 3]\n    return nums\n\nassert f(g()) == [-1, 0, 2, 3]\n",
        "idx_generation": 379,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target integer 'k', determine if there are two distinct elements in the list whose sum is equal to 'k'.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == k:\n            return True\n        elif curr_sum < k:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr=[1, 2, 3, 4, 5], k=6):\n    return (arr, k)\nassert f(*g())\n",
        "idx_generation": 191,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers, check if it is possible to select k elements from the list that sum up to the target.\"\"\"\n    def subset_sum(nums, target, k, index, count):\n        if target == 0 and count == k:\n            return True\n        if target < 0 or index >= len(nums) or count > k:\n            return False\n        return subset_sum(nums, target - nums[index], k, index + 1, count + 1) or subset_sum(nums, target, k, index + 1, count)\n    \n    return subset_sum(nums, target, k, 0, 0)\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g(), 30, 4)\n",
        "idx_generation": 274,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\"\"\"\n    s = s.lower().replace(\" \", \"\").replace(\".\", \"\").replace(\",\", \"\")\n    return s == s[::-1]\ndef g():\n    return \"A man, a plan, a canal, Panama.\"\nassert f(g())\n",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int, y: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list whose sum is equal to x and the absolute difference is equal to y.\n    \"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        curr_diff = abs(arr[left] - arr[right])\n        \n        if curr_sum == x and curr_diff == y:\n            return True\n        elif curr_sum < x:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(x: int, y: int):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(10, 2), 10, 2)\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the number of paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = 1\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            \n    return dp[rows-1][cols-1]\n\ndef g(matrix: List[List[int]]):\n    return (matrix,)\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(*g(matrix)) == 6\n",
        "idx_generation": 387,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 193,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n-1) + f(n-2)\ndef g():\n    return 4\nassert f(g()) == 5\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the order of the words in the string.\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\ndef g():\n    return \"Hello, world!\"\nassert f(g()) == \"world! Hello,\"",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    s = \"listen\"\n    t = \"silent\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in nums that sum up to target, using binary search.\"\"\"\n    sorted_nums = sorted(nums)\n    for i in range(len(sorted_nums)):\n        complement = target - sorted_nums[i]\n        left = i + 1\n        right = len(sorted_nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_nums[mid] == complement:\n                return True\n            elif sorted_nums[mid] < complement:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [4, 2, 7, 1, 5]\ntarget = 9\nassert f(*g(nums, target))\n",
        "idx_generation": 388,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(rectangles: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> int:\n    \"\"\"Calculate the total area covered by a list of rectangles.\"\"\"\n    total_area = 0\n    for rectangle in rectangles:\n        bottom_left = rectangle[0]\n        top_right = rectangle[1]\n        length = top_right[0] - bottom_left[0]\n        width = top_right[1] - bottom_left[1]\n        area = length * width\n        total_area += area\n    return total_area\ndef g(rectangles: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    return rectangles\nassert f(g([((0, 0), (2, 2)), ((1, 1), (3, 3)), ((2, 2), (4, 4))])) == 12\n",
        "idx_generation": 194,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of positive integers, find the path from the top-left corner to the bottom-right corner\n    that minimizes the sum of values along the path. Return the minimum sum.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    n = 3\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return n, grid\n\nassert f(*g()) == 7\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if a string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return 'level'\nassert f(g())\n",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the maximum product of any two distinct numbers in the list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\nassert f(g()) == 20\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(target: int):\n    return [-2, 0, 3, 5, 9, 12]  # Assuming the list is already sorted\n\nassert f(g(target=9), target=9) == 4\n",
        "idx_generation": 388,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within a given array.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 195,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous).\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='hello') -> bool:\n    \"\"\"Find a string that contains all the characters of a given target string in any order.\"\"\"\n    return all(c in s for c in target)\ndef g(target='hello'):\n    return ''.join(sorted(target, reverse=True))\nassert f(g())\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, return True if the target number exists in the list,\n    otherwise return False. Implement the solution using binary search algorithm.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list that sums up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    nums = [1, 5, 3, 9, 2]\n    target = 8\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"Maximize the profit by buying and selling stocks, given a list of stock prices.\"\"\"\n    max_profit = 0\n    min_price = float('inf')\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit\n\ndef g():\n    return ([7, 1, 5, 3, 6, 4],)\n\nassert f(*g()) == 5\n",
        "idx_generation": 199,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of numbers, find the maximum possible product of a subarray using dynamic programming.\"\"\"\n    if not nums:\n        return 0\n    max_product = min_product = result = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        result = max(result, max_product)\n    return result\n\ndef g():\n    return ([2, 3, -2, 4],)\n\nassert f(*g()) == 6\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Check if the given string can be split into k equal parts\"\"\"\n    n = len(s)\n    if n % k != 0:\n        return False\n    part_len = n // k\n    for i in range(0, n, part_len):\n        if s[i:i+part_len] != s[:part_len]:\n            return False\n    return True\ndef g(k=3):\n    return 'abc' * k\nassert f(g())\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, determine if there exist two numbers in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [-2, 0, 3, 5, 7, 9, 11, 15, 17], 10\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=15) -> bool:\n    \"\"\"Determine if there are three numbers in the list that add up to the target number\"\"\"\n    def helper(nums: List[int], target: int, count: int) -> bool:\n        if count == 0:\n            return target == 0\n        if not nums:\n            return False\n        return helper(nums[1:], target - nums[0], count - 1) or helper(nums[1:], target, count)\n    nums.sort()\n    return helper(nums, target, 3)\ndef g(nums=[3, 5, 7, 11, 2, 4, 9]):\n    return nums\nassert f(g())\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using Kadane's algorithm.\n    Args:\n    - nums: A list of integers\n    Returns:\n    - The maximum sum of a subarray\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 201,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner using dynamic programming.\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    return dp[m-1][n-1]\n\ndef g():\n    return ([[1, 3, 1], [1, 5, 1], [4, 2, 1]],)\n\nassert f(*g()) == 12\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\ndef g():\n    return \"A man, a plan, a canal: Panama\"\nassert f(g())",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, check if there exists a pair of numbers in the list that sum up to the target number.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == n:\n            return True\n        elif arr[left] + arr[right] < n:\n            left += 1\n        else:\n            right -= 1\n    return False\n    \ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    n = 9\n    return n, arr\n\nassert f(*g())\n",
        "idx_generation": 174,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a perfect square.\"\"\"\n    low = 1\n    high = n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g(n: int):\n    return n\n\nassert f(g(16))\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing stock prices, find the maximum profit that can be obtained by buying and selling the stocks.\n    You can only make one transaction (buy and sell) and you cannot sell a stock before buying one.\n    Args:\n    - nums: A list of integers representing stock prices\n    Returns:\n    - The maximum profit that can be obtained\n    \"\"\"\n    min_price = float('inf')\n    max_profit = 0\n    for price in nums:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit\n\ndef g(nums=[7, 1, 5, 3, 6, 4]):\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if it is possible to construct the target integer using a combination of addition, subtraction, and multiplication operations on the numbers in nums, and using each number in nums exactly once.\"\"\"\n    if len(nums) == 0:\n        return False\n\n    def backtrack(index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        \n        # Try all possible combinations\n        return backtrack(index + 1, curr_sum + nums[index]) or \\\n            backtrack(index + 1, curr_sum - nums[index]) or \\\n            backtrack(index + 1, curr_sum * nums[index])\n\n    return backtrack(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 282,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if s is a palindrome and contains at least one digit.\"\"\"\n    if s == s[::-1] and any(char.isdigit() for char in s):\n        return True\n    return False\n\ndef g():\n    return \"12321\"\n\nassert f(g())\n",
        "idx_generation": 148,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the given list whose sum is equal to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 2, 9, 3, 7]\n\nassert f(g(), 10)\n",
        "idx_generation": 175,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if the target number is present in the list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return (sorted(nums), target)\n\nassert f(*g()) == True\n",
        "idx_generation": 392,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that sum up to the target.\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    arr = [2, 4, 6, 8, 10, 12]\n    target = 16\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence in the list.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int] = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 282,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, determine if s2 is a rotation of s1\"\"\"\n    if len(s1) != len(s2):\n        return False\n    return s2 in s1 + s1\n\ndef g(s1=\"hello\", s2=\"lohel\"):\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 151,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of three numbers in a list of integers.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == 60\n",
        "idx_generation": 176,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted array of integers, find two numbers that add up to a given target.\n    Return their indices in the array.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all positive integers less than or equal to n that are divisible by 3 or 5.\n    \n    Example:\n    n = 10\n    \n    Output:\n    33 (3 + 5 + 6 + 9 + 10)\n    \"\"\"\n    total = 0\n    \n    for i in range(1, n+1):\n        if i % 3 == 0 or i % 5 == 0:\n            total += i\n            \n    return total\n    \ndef g(n: int):\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return (n,)\n    \nn = 10\nassert f(*g(n)) == 33\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of the maximum subarray from a given list of integers.\nReturn the sum of the maximum subarray.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 284,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the words in the string while maintaining the original order of the words.\n    Words are separated by a single space.\n    Return the reversed string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string\n\ndef g(s: str):\n    return s\n\nassert f(g(\"Hello world\")) == \"world Hello\"\n",
        "idx_generation": 153,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers, find two numbers that sum up to the target value. Return the pair of numbers.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [arr[left], arr[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return arr, target\n\nassert f(*g()) == [1, 9]\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest increasing subsequence in the array.\"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth term in the Fibonacci sequence.\n    Return the value of the nth term.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        fib = [0, 1]\n        for _ in range(2, n + 1):\n            fib.append(fib[-1] + fib[-2])\n        return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the minimum path sum from the top-left cell to the bottom-right cell in a given grid.\nReturn the minimum path sum.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\nassert f(g()) == 7\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, convert all uppercase letters to lowercase and vice versa.\n    \"\"\"\n    return s.swapcase()\n\ndef g() -> str:\n    return \"HeLLo WoRLD\"\n\nassert f(g()) == \"hEllO wOrld\"\n",
        "idx_generation": 155,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value k, find the kth largest element in the list.\"\"\"\n    nums.sort(reverse=True)\n    return nums[k - 1]\n\ndef g():\n    nums = [5, 2, 8, 1, 9, 4]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 5\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Given a list of integers and a target number, find a combination of numbers from the list that adds up to the target.\"\"\"\n    def helper(nums, target, curr_sum, index):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or index >= len(nums):\n            return False\n        if helper(nums, target, curr_sum + nums[index], index + 1):\n            return True\n        return helper(nums, target, curr_sum, index + 1)\n\n    return helper(nums, target, 0, 0)\n\ndef g(nums=[1, 2, 3, 4], target=5):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are three numbers in the list that add up to the target.\nReturn True if such a triplet exists, False otherwise.\"\"\"\n    n = len(arr)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\ndef g(arr: List[int], target: int):\n    return (arr, target)\nassert f(*g([1, 2, 3, 4, 5, 6, 7], 12))\n",
        "idx_generation": 215,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    def recursive_search(i: int, j: int) -> int:\n        # Base case: reached the bottom-right corner\n        if i == m-1 and j == n-1:\n            return grid[i][j]\n        \n        # Recursive case: try moving down and right and take the minimum path sum\n        if i < m-1 and j < n-1:\n            return grid[i][j] + min(recursive_search(i+1, j), recursive_search(i, j+1))\n        elif i < m-1:\n            return grid[i][j] + recursive_search(i+1, j)\n        elif j < n-1:\n            return grid[i][j] + recursive_search(i, j+1)\n        \n        return float('inf')\n    \n    return recursive_search(0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid)) == 7\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='python', ignore_case=True) -> bool:\n    \"\"\"Check if a string contains all the characters of a target string, ignoring case.\"\"\"\n    if ignore_case:\n        s = s.lower()\n        target = target.lower()\n    return all(c in s for c in target)\ndef g(target='Python', ignore_case=True):\n    return 'pythoN' if ignore_case else 'python'\nassert f(g())\n",
        "idx_generation": 158,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exist two numbers in the list that add up to the target.\nArgs:\n    nums: A sorted list of integers.\n    target: The target value.\nReturns:\n    True if there exist two numbers that add up to the target, False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    \"\"\"Returns a sorted list of integers and a target value.\"\"\"\n    return [-2, 0, 3, 5, 7], 8\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of non-negative integers and a target sum, find the minimum number of coins needed to form the target sum.\n    You have an infinite supply of each coin denomination in the list.\"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] = min(dp[i], dp[i - num] + 1)\n    return dp[target] if dp[target] != float('inf') else -1\ndef g(nums: List[int], target: int):\n    return (nums, target)\nnums = [1, 2, 5]\ntarget = 11\nassert f(*g(nums, target)) == 3\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if n is a prime number.\"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g(n=17):\n    return n\n\nassert f(g())\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum subarray in the given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome, considering only alphanumeric characters and ignoring cases.\"\"\"\n    cleaned_s = ''.join(c.lower() for c in s if c.isalnum())  # Remove non-alphanumeric characters and convert to lowercase\n    return cleaned_s == cleaned_s[::-1]  # Check if the cleaned string is equal to its reverse\n\ndef g() -> str:\n    return 'A man, a plan, a canal: Panama!'\nassert f(g())\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product you can get by multiplying any three integers.\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24 (2 * 3 * 4 = 24)\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\ndef g(nums: List[int]) -> List[int]:\n    return nums\nnums = [1, 2, 3, 4]\nassert f(g(nums)) == 24\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Find the kth smallest element in the given list.\"\"\"\n    def quicksort(arr, low, high):\n        if low < high:\n            pivot_index = partition(arr, low, high)\n            if pivot_index == k - 1:\n                return arr[pivot_index]\n            elif pivot_index > k - 1:\n                return quicksort(arr, low, pivot_index - 1)\n            else:\n                return quicksort(arr, pivot_index + 1, high)\n    \n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    return quicksort(nums, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    return [10, 7, 8, 9, 1, 5]\n\nassert f(g(), 3) == 7\n",
        "idx_generation": 400,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of prime numbers less than or equal to n.\"\"\"\n    count = 0\n    for i in range(2, n+1):\n        prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            count += 1\n    return count\n\ndef g(n: int):\n    return n\n\nassert f(g(20)) == 8\n",
        "idx_generation": 216,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of unique paths in an n x n grid from the top-left corner to the bottom-right corner.\n    You can only move right or down.\"\"\"\n    def dfs(row: int, col: int) -> int:\n        if row == n-1 and col == n-1:\n            return 1\n        if row < n-1 and col < n-1:\n            return dfs(row+1, col) + dfs(row, col+1)\n        elif row < n-1:\n            return dfs(row+1, col)\n        elif col < n-1:\n            return dfs(row, col+1)\n        return 0\n    return dfs(0, 0)\ndef g() -> int:\n    return 3\nassert f(g()) == 6\n",
        "idx_generation": 289,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels in a given string.\"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\ndef g() -> str:\n    return 'Hello, World!'\nassert f(g()) == 3\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if a list is sorted in non-decreasing order and contains no duplicate elements.\"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1] or arr[i] == arr[i-1]:\n            return False\n    return True\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the array that sum up to the target\"\"\"\n    n = len(arr)\n    arr.sort()\n    left = 0\n    right = n - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [4, 2, 7, 1, 5, 3]\n    target = 8\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number exists in the given 2D grid.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\n\ndef g():\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5)\n\nassert f(*g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    Implement the solution using a dynamic programming approach.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target]\ndef g():\n    nums = [1, 5, 11, 5]\n    return nums\nassert f(g())\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse each word in a given string while maintaining the order of words.\"\"\"\n    return ' '.join(word[::-1] for word in s.split())\ndef g(s='Hello World'):\n    return s\nassert f(g()) == 'olleH dlroW'\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    Return -1 if the target is not found.\n    \"\"\"\n    def binary_search(nums, target, low, high):\n        if low > high:\n            return -1\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, high)\n        else:\n            return binary_search(nums, target, low, mid - 1)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    return ([-5, -2, 0, 3, 7, 10, 15, 20, 25], 10)\n\nassert f(*g()) == 5\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subarray of consecutive elements in the list that adds up to the target.\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == target:\n            return True\n        if prefix_sum - target in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find a subarray of consecutive elements in the list that adds up to the target number.\"\"\"\n    prefix_sum = 0\n    seen = {}\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        if prefix_sum == target:\n            return nums[:i+1]\n        if prefix_sum - target in seen:\n            return nums[seen[prefix_sum - target]+1:i+1]\n        seen[prefix_sum] = i\n    return []\n\nnums = [1, 2, 3, 4, 5, 6]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 403,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subset of nums whose sum is divisible by k.\"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset_sum = sum(nums[j] for j in range(n) if (i & (1 << j)) != 0)\n        if subset_sum % k == 0:\n            return True\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g())\n",
        "idx_generation": 223,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth number in the Fibonacci sequence using a recursive approach.\"\"\"\n    if n <= 1:\n        return n\n    return f(n - 1) + f(n - 2)\ndef g():\n    return 6\nassert f(g()) == 8\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> str:\n    \"\"\"\n    Given a matrix of integers, return a string representation of the matrix\n    where each row is separated by a newline and each element is separated by a space.\n    \"\"\"\n    return '\\n'.join([' '.join(map(str, row)) for row in matrix])\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == \"1 2 3\\n4 5 6\\n7 8 9\"\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target number, return the index of the target number in the list. \n    If the target number is not present, return -1. Use binary search for optimization.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 184,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target number.\n    Return True if such pair exists, False otherwise.\"\"\"\n    def helper(arr: List[int], left: int, right: int, target: int) -> bool:\n        if left >= right:\n            return False\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            return helper(arr, left + 1, right, target)\n        else:\n            return helper(arr, left, right - 1, target)\n    \n    return helper(arr, 0, len(arr) - 1, target)\n\ndef g() -> tuple:\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    target = 9\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 405,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid represents a valid tic-tac-toe board state.\n    A valid tic-tac-toe board state must have either three 'X's or three 'O's in a row, column, or diagonal, or an empty cell indicating an ongoing game.\"\"\"\n    \n    def check_rows():\n        for row in grid:\n            if row[0] == row[1] == row[2] and row[0] in ['X', 'O']:\n                return True\n        return False\n    \n    def check_columns():\n        for col in range(3):\n            if grid[0][col] == grid[1][col] == grid[2][col] and grid[0][col] in ['X', 'O']:\n                return True\n        return False\n    \n    def check_diagonals():\n        if grid[0][0] == grid[1][1] == grid[2][2] and grid[0][0] in ['X', 'O']:\n            return True\n        if grid[0][2] == grid[1][1] == grid[2][0] and grid[0][2] in ['X', 'O']:\n            return True\n        return False\n    \n    if check_rows() or check_columns() or check_diagonals():\n        return True\n    else:\n        return False\n\ndef g():\n    return [\n        ['X', 'O', 'X'],\n        ['O', 'X', 'O'],\n        ['X', 'O', 'O'],\n    ]\n\nassert f(g())\n",
        "idx_generation": 226,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers arr, determine if there is a subarray with a sum equal to zero. Return True if such subarray exists, otherwise return False.\"\"\"\n    def subarraySum(arr, start, end, prefixSum):\n        if start >= end:\n            return False\n        if prefixSum[end] - prefixSum[start] == 0:\n            return True\n        return subarraySum(arr, start+1, end, prefixSum) or subarraySum(arr, start, end-1, prefixSum)\n\n    prefixSum = [0] * (len(arr) + 1)\n    for i in range(1, len(arr) + 1):\n        prefixSum[i] = prefixSum[i-1] + arr[i-1]\n\n    return subarraySum(arr, 0, len(arr), prefixSum)\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g())\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list with only the words that start with the prefix.\n    \"\"\"\n    return [word for word in words if word.startswith(prefix)]\n\ndef g():\n    return [\"apple\", \"banana\", \"cat\", \"dog\", \"elephant\"]\n\nassert f(g(), \"c\") == [\"cat\"]\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists three elements in the array that sum up to the target value.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert f(g(), 18)\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two integers in the array that sum up to the target value.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17], 16\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib[n]\n\ndef g():\n    return 10\n\nassert f(g()) == 55\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value, determine if there exist three numbers in the list such that their XOR is equal to the target value.\n    \n    Sample Input:\n    nums = [2, 3, 5, 6, 9]\n    target = 7\n    \n    Sample Output:\n    True\n    \n    Explanation: The triplet of numbers (3, 5, 9) has an XOR value of 7, which is equal to the target.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                if nums[i] ^ nums[j] ^ nums[k] == target:\n                    return True\n    return False\n\ndef g(nums=[2, 3, 5, 6, 9], target=7):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, return True if it is a palindrome, False otherwise.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Ignore all non-alphanumeric characters and case sensitivity.\"\"\"\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\ndef g():\n    return \"A man, a plan, a canal: Panama\"\nassert f(g()) == True\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, use binary search to determine if the target number is present in the list.\"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9, 11, 13], target=9):\n    return (arr, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the length of the longest increasing subsequence in 'nums'.\n    An increasing subsequence is a sequence of numbers in 'nums' where each number is greater than the previous number.\"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Determine the number of different ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a positive integer for testing.\n    \"\"\"\n    return n\n\nassert f(g(5)) == 8\n",
        "idx_generation": 229,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of valid parentheses expressions consisting of n pairs of parentheses.\nA valid parentheses expression is defined as follows:\n- An empty string is a valid parentheses expression.\n- If x is a valid parentheses expression, then (x) is also a valid parentheses expression.\n- If x and y are valid parentheses expressions, then xy is also a valid parentheses expression.\nReturn the number of valid parentheses expressions modulo 10^9 + 7.\"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n            dp[i] %= 1000000007\n    return dp[n]\ndef g(n: int):\n    return n\nassert f(g(3)) == 5\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome, ignoring non-alphanumeric characters.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g(s: str):\n    \"\"\"\n    Remove non-alphanumeric characters from the given string.\n    \"\"\"\n    return ''.join(c for c in s if c.isalnum())\n\nassert f(g(\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value is present in the list using binary search.\nReturn True if the target value is found, and False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\ndef g(nums: List[int], target: int):\n    return (sorted(nums), target)\nassert f(*g([1, 2, 3, 4, 5], 3))\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(nums: List[int], k=0) -> bool:\n    \"\"\"Find the kth largest element in the given list.\"\"\"\n    def quickselect(nums, left, right, k):\n        if left == right:\n            return nums[left]\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(nums, left, right, pivot_index)\n        if k == pivot_index:\n            return nums[k]\n        elif k < pivot_index:\n            return quickselect(nums, left, pivot_index - 1, k)\n        else:\n            return quickselect(nums, pivot_index + 1, right, k)\n\n    def partition(nums, left, right, pivot_index):\n        pivot_value = nums[pivot_index]\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        store_index = left\n        for i in range(left, right):\n            if nums[i] < pivot_value:\n                nums[store_index], nums[i] = nums[i], nums[store_index]\n                store_index += 1\n        nums[right], nums[store_index] = nums[store_index], nums[right]\n        return store_index\n    \n    return quickselect(nums, 0, len(nums) - 1, k)\n\ndef g(k=0):\n    nums = [5, 2, 8, 1, 9, 3]\n    return nums\n\nassert f(g(), k=2)\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if there exists a subarray with a sum equal to 0.\"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == 0 or prefix_sum in prefix_sums:\n            return True\n        \n        prefix_sums.add(prefix_sum)\n    \n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g())\n",
        "idx_generation": 229,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the longest increasing path in the matrix.\n    An increasing path is defined as a path where each cell is greater than its adjacent cells (up, down, left, or right).\n    Return the length of the longest increasing path.\"\"\"\n    \n    def dfs(i, j):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        \n        dp[i][j] = 1\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n            if ni >= 0 and ni < m and nj >= 0 and nj < n and matrix[ni][nj] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(ni, nj))\n        \n        return dp[i][j]\n    \n    if not matrix:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dp = [[-1] * n for _ in range(m)]\n    result = 0\n    \n    for i in range(m):\n        for j in range(n):\n            result = max(result, dfs(i, j))\n    \n    return result\n\ndef g():\n    return [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n\nassert f(g()) == 4\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g(s=\"racecar\"):\n    return s\nassert f(g())\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there is a pair of numbers in the list whose sum is equal to the target number.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find a pair of numbers from the list whose sum is equal to the target number.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return [arr[left], arr[right]]\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\narr = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(arr, target), target)\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target integer, return the index of the first occurrence of the target in the list.\n    If the target is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            result = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\ndef g(target=3):\n    nums = [1, 2, 3, 3, 3, 4, 5, 6, 7, 8, 9]\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to reach the nth step in a staircase, where at each step you can either climb 1 or 2 steps at a time.\n    Return the count of possible ways to reach the nth step.\n    Example:\n    n = 4\n    There are 5 ways to reach the 4th step:\n    - 1, 1, 1, 1\n    - 1, 1, 2\n    - 1, 2, 1\n    - 2, 1, 1\n    - 2, 2\n    Therefore, the output should be 5.\"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 233,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"Given a 2D board and a word, determine if the word exists in the board.\n    The word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are horizontally or vertically neighboring.\n    The same letter cell may not be used more than once in a word.\"\"\"\n    \n    def dfs(i, j, word_index):\n        if word_index == len(word):\n            return True\n        \n        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[word_index]:\n            return False\n        \n        temp = board[i][j]\n        board[i][j] = '#'\n        found = dfs(i + 1, j, word_index + 1) or dfs(i - 1, j, word_index + 1) or dfs(i, j + 1, word_index + 1) or dfs(i, j - 1, word_index + 1)\n        board[i][j] = temp\n        \n        return found\n    \n    if not board:\n        return False\n    \n    m, n = len(board), len(board[0])\n    word = \"ABCCED\"\n    \n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == word[0] and dfs(i, j, 0):\n                return True\n    \n    return False\n\ndef g():\n    return [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]\n\nassert f(g()) == True\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s2 is a rotation of s1.\"\"\"\n    def is_rotation(s1, s2):\n        if len(s1) != len(s2):\n            return False\n        s1s1 = s1 + s1\n        return s2 in s1s1\n    \n    return is_rotation(s1, s2)\n\ndef g():\n    s1 = 'waterbottle'\n    s2 = 'erbottlewat'\n    return (s1, s2)\n\nassert f(*g())\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there is a triplet of numbers in the list whose sum is equal to the target number.\"\"\"\n    for i in range(len(arr) - 2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return True\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find a triplet of numbers from the list whose sum is equal to the target number.\"\"\"\n    for i in range(len(arr) - 2):\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return [arr[i], arr[left], arr[right]]\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(arr, target), target)\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n    Return the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)\n\nassert f(*g())\n",
        "idx_generation": 414,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subarray with a sum equal to zero.\n    The subarray can contain any number of elements and should be contiguous.\n\n    Example:\n    Input: [4, -2, 3, 1, 0, -5]\n    Output: True\n\n    Explanation: The subarray [3, 1, 0, -5] has a sum of zero.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, -2, 3, 1, 0, -5]\n\nassert f(g())\n",
        "idx_generation": 235,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of positive integers and a target value, determine if there is a subset of the list that adds up to the target value.\n    Return True if such a subset exists, otherwise False.\"\"\"\n    def subset_sum(nums, target, index, curr_sum):\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        include = subset_sum(nums, target, index + 1, curr_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, curr_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 299,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a palindrome when read forward and backward\"\"\"\n    binary_nums = [bin(num)[2:] for num in nums]\n    return binary_nums == binary_nums[::-1]\ndef g():\n    return ([5, 3, 6, 9, 6, 3, 5],)\nassert f(*g())\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given list of integers in ascending order using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1] :\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"Return the sorted list of integers using the bubble sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1] :\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\narr = [64, 34, 25, 12, 22, 11, 90]\nassert f(g(arr)) == [11, 12, 22, 25, 34, 64, 90]\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers arr and a target integer, determine if there are three elements in the array that sum up to the target.\"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 421,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Determine if the given string s is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    s = \"level\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', calculate the n-th Fibonacci number using dynamic programming.\n    Return the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 299,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=10) -> bool:\n    \"\"\"Check if a string can be transformed into another string by repeatedly appending a substring\"\"\"\n    substring = 'ab'\n    while len(s) < target_length:\n        s += substring\n        substring = substring[::-1]\n    return len(s) == target_length\ndef g(target_length=10):\n    return 'ab' * (target_length // 2) + 'a' * (target_length % 2)\nassert f(g())\n",
        "idx_generation": 188,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists a pair of elements whose sum is equal to the target value.\"\"\"\n    def helper(arr, target, start, end):\n        if start >= end:\n            return False\n        if arr[start] + arr[end] == target:\n            return True\n        elif arr[start] + arr[end] < target:\n            return helper(arr, target, start + 1, end)\n        else:\n            return helper(arr, target, start, end - 1)\n    return helper(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[2, 4, 6, 8, 10], target=12):\n    return arr\nassert f(g(), target=16)\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list that sums up to the target value.\n    \"\"\"\n    def helper(nums: List[int], target: int, index: int) -> bool:\n        if target == 0:\n            return True\n        if target < 0 or index >= len(nums):\n            return False\n        return helper(nums, target - nums[index], index + 1) or helper(nums, target, index + 1)\n\n    return helper(nums, target, 0)\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the largest power of 2 less than or equal to n\"\"\"\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\n\ndef g():\n    return 20\n\nassert f(g()) == 16\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of positive integers, find the minimum number of coins needed to make the target sum.\"\"\"\n    def min_coins(nums, target):\n        if target == 0:\n            return 0\n        if target < 0:\n            return float('inf')\n        min_count = float('inf')\n        for num in nums:\n            count = min_coins(nums, target - num)\n            min_count = min(min_count, count + 1)\n        return min_count\n    return min_coins(nums, target) <= 3\ndef g(nums=[2, 3, 5]):\n    return nums\nassert f(g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, check if it is a palindrome after removing all non-alphanumeric characters and ignoring case.\"\"\"\n    def is_palindrome(s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    cleaned_s = ''.join(char.lower() for char in s if char.isalnum())\n    return is_palindrome(cleaned_s)\n\ndef g():\n    return \"A man, a plan, a canal: Panama!\"\n\nassert f(g())\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given array that sum to a target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    target = 10\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 5, 3, 7, 9, 2]\n\nassert f(g())\n",
        "idx_generation": 191,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g(nums: List[int]):\n    return nums\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nassert f(g(nums)) == 4\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a valid Sudoku solution.\"\"\"\n    # Check rows\n    for row in grid:\n        if len(set(row)) != len(row):\n            return False\n\n    # Check columns\n    for col in range(len(grid[0])):\n        column = [grid[row][col] for row in range(len(grid))]\n        if len(set(column)) != len(column):\n            return False\n\n    # Check subgrids\n    for i in range(0, len(grid), 3):\n        for j in range(0, len(grid[0]), 3):\n            subgrid = [grid[r][c] for r in range(i, i + 3) for c in range(j, j + 3)]\n            if len(set(subgrid)) != len(subgrid):\n                return False\n\n    return True\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 242,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\ndef g(n: int):\n    return n\nassert f(g(6)) == 13\n",
        "idx_generation": 303,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome\"\"\"\n    return s == s[::-1]\ndef g():\n    return 'radar'\nassert f(g())\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, return the index of the target value in the list.\nIf the target value is not present in the list, return -1. The list may contain duplicate elements.\"\"\"\n    def binary_search(arr, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, right)\n        else:\n            return binary_search(arr, target, left, mid - 1)\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g():\n    arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10]\n    target = 5\n    return (arr, target)\n\nassert f(*g()) == 5\n",
        "idx_generation": 191,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in a given list of integers.\nArgs:\n- nums: A list of integers\nReturns:\n- The length of the longest increasing subsequence\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\nassert f(g()) == 4\n",
        "idx_generation": 429,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the length of the longest increasing subarray.\"\"\"\n    if not nums:\n        return 0\n    max_len = 1\n    curr_len = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n    return max(max_len, curr_len)\ndef g(nums=[1, 2, 3, 2, 4, 5, 6, 1]):\n    return (nums,)\nassert f(*g()) == 4\n",
        "idx_generation": 246,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum possible by traversing from the top-left corner to the bottom-right corner.\n    You can only move down or right. Return the maximum sum.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 12\n",
        "idx_generation": 304,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Check if a given string contains a specific substring.\n    Return True if the substring is found, False otherwise.\"\"\"\n    if substr in s:\n        return True\n    return False\n\ndef g(substr='abc'):\n    return substr\n\nassert f(g())\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target number, return a pair of numbers in the list whose sum is equal to the target. If no such pair exists, return an empty list.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g(nums=[-2, 0, 3, 5, 7, 9, 11], target=8):\n    return (nums, target)\nassert f(*g()) == [3, 5]\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 8\n    Sample Output:\n    7\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 8\n    return (nums, target)\n\nassert f(*g()) == 7\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix, transpose the matrix (rows become columns and columns become rows).\"\"\"\n    return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n",
        "idx_generation": 246,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to the target value.\"\"\"\n    def subsetSum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subsetSum(nums, target, n-1)\n        return subsetSum(nums, target-nums[n-1], n-1) or subsetSum(nums, target, n-1)\n    return subsetSum(nums, target, len(nums))\ndef g(nums=[2, 4, 6, 8]):\n    return nums\nassert f(g())\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=4) -> bool:\n    \"\"\"Determine if there exists a substring of length n that contains all unique characters.\"\"\"\n    substrings = [s[i:i+n] for i in range(len(s)-n+1)]\n    return any(len(set(sub)) == n for sub in substrings)\ndef g(n=4):\n    return \"abcd\" * (n // 4) + \"a\"\nassert f(g())\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [3, 5, 2, 8, 10, 4]\n\nassert f(g(), 12)\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    Implement the solution using dynamic programming.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers and a target value, find two numbers in the array that sum up to the target value.\nArgs:\n    nums: The array of integers.\n    target: The target value to find the pair that sums up to it.\nReturns:\n    The indices of the two numbers that sum up to the target value.\"\"\"\n    num_dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n    return []\n\ndef g():\n    \"\"\"\n    Returns a sample array of integers.\n    \"\"\"\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique ways to climb a staircase with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    def count_ways(n):\n        if n <= 1:\n            return 1\n        return count_ways(n-1) + count_ways(n-2)\n    \n    return count_ways(n)\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_word: str) -> bool:\n    \"\"\"Check if a given word is present in a string, but only if it is surrounded by spaces.\n    Sample Input:\n    s = 'The quick brown fox jumps over the lazy dog'\n    target_word = 'fox'\n    Sample Output:\n    True\"\"\"\n    return f' {target_word} ' in f' {s} '\ndef g(s: str, target_word: str) -> str:\n    return s.replace(target_word, f' {target_word} ')\nassert f(g('The quick brown fox jumps over the lazy dog', 'fox'), 'fox')\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"Given a list of numbers, find a pair of numbers from the list that sum up to the target.\n\n    Example:\n    numbers = [2, 5, 8, 3, 1, 6]\n    target = 10\n\n    The function should return True since there is a pair (2, 8) that sums up to 10.\n    \"\"\"\n    complement = set()\n\n    for num in numbers:\n        if num in complement:\n            return True\n        complement.add(target - num)\n\n    return False\n\ndef g(target=10):\n    numbers = [2, 5, 8, 3, 1, 6]\n    return numbers\n\nassert f(g())\n",
        "idx_generation": 194,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers 'arr' and an integer 'k', find the kth smallest element in the list.\nThe kth smallest element is the element that would appear at index k if the list was sorted in non-decreasing order.\"\"\"\n    def quick_select(arr, low, high, k):\n        if low == high:\n            return arr[low]\n        pivot_index = partition(arr, low, high)\n        if pivot_index == k:\n            return arr[pivot_index]\n        elif pivot_index < k:\n            return quick_select(arr, pivot_index + 1, high, k)\n        else:\n            return quick_select(arr, low, pivot_index - 1, k)\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[high] = arr[high], arr[i]\n        return i\n    return quick_select(arr, 0, len(arr) - 1, k - 1)\ndef g() -> Tuple[List[int], int]:\n    return ([7, 10, 4, 3, 20, 15], 3)\nassert f(*g()) == 7\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, target_sum: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it can be expressed as the sum of consecutive positive integers.\n    The goal is to find if there are any consecutive numbers that sum up to n and the sum of those numbers is equal to target_sum.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if sum(range(i, j + 1)) == target_sum:\n                count += 1\n    return count > 0\ndef g(n=10, target_sum=18):\n    return (n, target_sum)\nassert f(*g())\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb a staircase of n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g(n=4):\n    return n\nassert f(g()) == 5\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels (a, e, i, o, u) in a given string.\"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\ndef g(s: str) -> str:\n    return s\n\nassert f(g(\"hello world\")) == 3\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the median of a list of integers.\"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\ndef g(nums: List[int]) -> List[int]:\n    return nums\nassert f(g([7, 2, 5, 1, 3])) == 3\n",
        "idx_generation": 194,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted array 'arr' and a target value, find the index of the target value in the array using binary search.\n    If the target value is not found, return -1.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\nassert f(g(), 7) == 3\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid represents a valid Sudoku solution.\n\n    Args:\n    - grid: A 9x9 grid filled with numbers from 1 to 9. Each row, column, and 3x3 sub-grid should contain unique numbers.\n\n    Returns:\n    - True if the grid represents a valid Sudoku solution, False otherwise.\n    \"\"\"\n    def check_unique(lst: List[int]) -> bool:\n        \"\"\"Check if a list contains unique numbers from 1 to 9.\"\"\"\n        nums = set()\n        for num in lst:\n            if num in nums:\n                return False\n            nums.add(num)\n        return True\n\n    # Check rows\n    for row in grid:\n        if not check_unique(row):\n            return False\n\n    # Check columns\n    for col in range(9):\n        column = [grid[row][col] for row in range(9)]\n        if not check_unique(column):\n            return False\n\n    # Check sub-grids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            sub_grid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not check_unique(sub_grid):\n                return False\n\n    return True\n\ndef g():\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 267,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if it is possible to create a subset whose sum is equal to the target value. The elements in the subset can be used at most once.\"\"\"\n    def backtrack(arr, target, curr_sum, idx):\n        if curr_sum == target:\n            return True\n        if idx >= len(arr) or curr_sum > target:\n            return False\n        return backtrack(arr, target, curr_sum + arr[idx], idx + 1) or backtrack(arr, target, curr_sum, idx + 1)\n    return backtrack(arr, target, 0, 0)\n\ndef g():\n    arr = [2, 4, 6, 8, 10]\n    target = 18\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, reverse the order of words in the string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g():\n    return (\"Hello World\",)\n\nassert f(*g()) == \"World Hello\"\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\nThe solution should return True if such pair exists, and False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\nassert f(*g()) == True\n",
        "idx_generation": 195,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers 'nums', find the longest increasing subsequence in 'nums'.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    result = []\n    for i in range(n - 1, -1, -1):\n        if dp[i] == max_length:\n            result.append(nums[i])\n            max_length -= 1\n    return result[::-1]\n\ndef g():\n    return [4, 2, 7, 1, 3, 5]\n\nassert f(g()) == [1, 3, 5]\n",
        "idx_generation": 463,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find n such that it is a prime number and the sum of its digits is also a prime number.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n    \n    return is_prime(n) and is_prime(sum_of_digits(n))\n\ndef g():\n    num = 2\n    while True:\n        if f(num):\n            return num\n        num += 1\n\nassert f(g())\n",
        "idx_generation": 268,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, find if there exists a subsequence in the list whose sum is equal to the target value.\nArgs:\n    nums: The list of integers.\n    target: The target sum.\nReturns:\n    True if there exists a subsequence whose sum is equal to the target value, False otherwise.\"\"\"\n    return dfs(nums, target, 0, 0)\n\ndef dfs(nums, target, index, curr_sum):\n    if curr_sum == target:\n        return True\n    if index == len(nums) or curr_sum > target:\n        return False\n    return dfs(nums, target, index+1, curr_sum+nums[index]) or dfs(nums, target, index+1, curr_sum)\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=15):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 325,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k=2) -> bool:\n    \"\"\"Check if there exists a substring of length k in the given string s that is a perfect square.\"\"\"\n    def is_perfect_square(n):\n        \"\"\"Check if a number is a perfect square.\"\"\"\n        return int(n ** 0.5) ** 2 == n\n\n    for i in range(len(s) - k + 1):\n        substring = s[i:i+k]\n        if is_perfect_square(int(substring)):\n            return True\n    return False\n\ndef g(k=2):\n    \"\"\"Generate a string of digits such that there exists a substring of length k that is a perfect square.\"\"\"\n    i = 1\n    while True:\n        substring = str(i ** 2)\n        if len(substring) >= k:\n            return substring[:k]\n        i += 1\n\nassert f(g())\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, return True if there exists a pair of numbers in nums that sum up to the target, otherwise return False.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 196,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target number, find the index of the target number in the list using binary search.\n    If the target number is not in the list, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return (nums, target)\n\nnums = [1, 3, 5, 7, 9, 11]\ntarget = 7\nassert f(*g(nums, target)) == 3\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Find a square submatrix of size 3x3 in the given matrix where the product of all its elements is even.\"\"\"\n    def is_even(num: int) -> bool:\n        return num % 2 == 0\n    \n    for i in range(len(matrix)-2):\n        for j in range(len(matrix[0])-2):\n            submatrix = [matrix[i][j:j+3], matrix[i+1][j:j+3], matrix[i+2][j:j+3]]\n            product = 1\n            for row in submatrix:\n                for element in row:\n                    product *= element\n            if is_even(product):\n                return True\n    return False\n\ndef g():\n    matrix = [\n        [1, 2, 3, 4, 5],\n        [6, 7, 8, 9, 10],\n        [11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20],\n        [21, 22, 23, 24, 25]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 268,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of distinct ways to climb a staircase with n steps.\nEach time you can either climb 1 or 2 steps.\"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g():\n    return (5,)\nassert f(*g()) == 8\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, target_pattern='abc') -> bool:\n    \"\"\"Check if the given string contains a subsequence that matches the target pattern\"\"\"\n    def is_subsequence(string, pattern):\n        i = 0\n        j = 0\n        while i < len(string) and j < len(pattern):\n            if string[i] == pattern[j]:\n                j += 1\n            i += 1\n        return j == len(pattern)\n    \n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            subsequence = string[i:j]\n            if is_subsequence(subsequence, target_pattern):\n                return True\n    return False\n\ndef g():\n    return \"aabcbc\"\n\nassert f(g())\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([5, 2, 8, 4, 9], 10)\n\nassert f(*g())\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists a pair of elements whose sum is equal to the target value.\"\"\"\n    def helper(nums, target, start, end):\n        if start >= end:\n            return False\n        if nums[start] + nums[end] == target:\n            return True\n        elif nums[start] + nums[end] < target:\n            return helper(nums, target, start + 1, end)\n        else:\n            return helper(nums, target, start, end - 1)\n    return helper(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums\n\nassert f(g(), target=7)\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"Given a grid of size n x m, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right at any point in time.\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\ndef g(n=3, m=3):\n    return (n, m)\nassert f(*g()) == 6\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\ndef g():\n    \"\"\"Returns the index of a Fibonacci number.\"\"\"\n    return 8\nassert f(g()) == 21\n",
        "idx_generation": 329,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, check if it is a valid email address.\"\"\"\n    if '@' not in string:\n        return False\n    username, domain = string.split('@')\n    if len(username) == 0 or len(domain) == 0:\n        return False\n    if ' ' in username or ' ' in domain:\n        return False\n    if '.' not in domain or domain.startswith('.') or domain.endswith('.'):\n        return False\n    if '..' in domain:\n        return False\n    return True\n\ndef g():\n    return 'john.doe@example.com'\n\nassert f(g()) == True\n",
        "idx_generation": 224,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g(), 12)\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n\n    An increasing subsequence is a subsequence in which the elements are in strictly increasing order.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of all even numbers in the given list of integers.\"\"\"\n    evens = [num for num in nums if num % 2 == 0]\n    return sum(evens)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return (nums,)\n\nassert f(*g()) == 30\n",
        "idx_generation": 273,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n - 1) + f(n - 2)\ndef g(n: int):\n    return n\nassert f(g(6)) == 8\n",
        "idx_generation": 331,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 231,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if a pair of numbers exists in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g())\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers in ascending order and a target value, find the index of the target value using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == 4\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate the matrix 90 degrees clockwise.\"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated[j][n - i - 1] = matrix[i][j]\n    return rotated\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return the input matrix.\"\"\"\n    return matrix\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of non-negative integers and a target value, determine if it is possible to split the list into two non-empty subarrays\n    such that the sum of elements in both subarrays is equal to the target value.\n    Use dynamic programming to solve this problem in O(n) time complexity.\"\"\"\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    n = len(arr)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target_sum]\n\ndef g():\n    return [1, 5, 11, 5]\n\nassert f(g(), 11) == True\n",
        "idx_generation": 332,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, return True if it is a valid palindrome after deleting at most one character from it, and False otherwise.\"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n    return True\ndef g(s: str):\n    return s\ns = \"abcdedcba\"\nassert f(g(s)) == True\n",
        "idx_generation": 240,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers, find two numbers that sum up to the target. Return True if such numbers exist, False otherwise.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [4, 8, 2, 11, 5]\n    target = 13\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 202,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number appears in the grid diagonally from top-left to bottom-right.\"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    for i in range(min(n, m)):\n        if grid[i][i] == target:\n            return True\n    return False\n\ndef g(grid: List[List[int]], target: int):\n    return grid\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntarget = 5\nassert f(g(grid, target), target)\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the given target number exists in the grid using a depth-first search.\"\"\"\n    def dfs(row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return False\n        if grid[row][col] == target:\n            return True\n        if grid[row][col] > target:\n            return False\n        return dfs(row + 1, col) or dfs(row, col + 1)\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[List[List[int]], int]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g())\n",
        "idx_generation": 336,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string contains a valid URL.\"\"\"\n    import re\n    pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return bool(re.match(pattern, s))\n\ndef g() -> str:\n    \"\"\"Generate a random string that may or may not be a valid URL.\"\"\"\n    import random\n    import string\n    protocol = random.choice(['http://', 'https://', 'ftp://'])\n    domain = ''.join(random.choices(string.ascii_lowercase + string.digits, k=random.randint(3, 10)))\n    extension = random.choice(['.com', '.net', '.org'])\n    return protocol + domain + extension\n\nassert f(g())\n\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return sorted(nums), target\n\nassert f(*g([2, 7, 11, 15], 9)) == [0, 1]\n",
        "idx_generation": 203,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 491,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Return the maximum product of any three integers from the given list.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 720\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of ways to climb a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string s is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g() -> str:\n    \"\"\"Generate a random palindrome string.\"\"\"\n    import random\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    s = ''.join(random.choices(alphabet, k=random.randint(1, 10)))\n    return s + s[::-1]\nassert f(g())\n",
        "idx_generation": 242,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, determine if there exists a pair of elements whose sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and the target sum.\n    \"\"\"\n    return (arr, target)\n\narr = [1, 3, 5, 7, 9]\ntarget = 10\nassert f(*g(arr, target))\n",
        "idx_generation": 203,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using the quicksort algorithm.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[0]\n    less = [x for x in arr[1:] if x <= pivot]\n    greater = [x for x in arr[1:] if x > pivot]\n    return f(less) + [pivot] + f(greater)\n\ndef g(arr: List[int]):\n    return arr[::-1]\n\narr = [5, 3, 2, 4, 1]\nassert f(g(arr)) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 492,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if a given number is a perfect square and the sum of its digits is divisible by k.\"\"\"\n    def is_perfect_square(num):\n        return int(num ** 0.5) ** 2 == num\n        \n    def sum_of_digits(num):\n        return sum([int(digit) for digit in str(num)])\n        \n    return is_perfect_square(n) and sum_of_digits(n) % k == 0\n    \ndef g(k: int) -> int:\n    \"\"\"Find the smallest perfect square number whose sum of digits is divisible by k.\"\"\"\n    num = 1\n    while True:\n        if f(num, k):\n            return num\n        num += 1\n        \nassert f(g(k=3), k=3)\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Count the number of valid parentheses expressions that can be formed using 'n' pairs of parentheses.\nReturn the count.\"\"\"\n    if n == 0:\n        return 0\n    \n    dp = [0] * (n+1)\n    dp[0] = 1\n    \n    for i in range(1, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    \n    return dp[n]\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 337,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string contains a palindrome of length n.\"\"\"\n    for i in range(len(s) - n + 1):\n        if s[i:i+n] == s[i:i+n][::-1]:\n            return True\n    return False\n\ndef g(n: int):\n    return 'ab' + 'c' * (n-2) + 'ba'\n\nassert f(g(n=5), n=3)\n",
        "idx_generation": 244,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, find if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 10\nassert f(*g(nums, target)) == True\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if the target value is present in the list, and False otherwise.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a grid contains a square subgrid with all elements equal to 1.\"\"\"\n    def has_square_subgrid_with_ones(grid):\n        rows = len(grid)\n        cols = len(grid[0])\n        for i in range(rows - 1):\n            for j in range(cols - 1):\n                if grid[i][j] == 1 and grid[i][j+1] == 1 and grid[i+1][j] == 1 and grid[i+1][j+1] == 1:\n                    return True\n        return False\n        \n    return has_square_subgrid_with_ones(grid)\n    \ndef g() -> List[List[int]]:\n    \"\"\"Generate a grid with a square subgrid of all elements equal to 1.\"\"\"\n    return [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\n    \nassert f(g())\n",
        "idx_generation": 291,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, determine the number of unique permutations that add up to the target.\nEach number in the list can be used multiple times in a permutation.\"\"\"\n    def backtrack(nums, target, current, result):\n        if sum(current) == target:\n            result.append(list(current))\n            return\n        if sum(current) > target:\n            return\n        for num in nums:\n            current.append(num)\n            backtrack(nums, target, current, result)\n            current.pop()\n    result = []\n    backtrack(nums, target, [], result)\n    return len(result)\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums\nnums = [1, 2, 3]\ntarget = 4\nassert f(g(nums, target), target) == 7\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, sub_str1='foo', sub_str2='bar') -> bool:\n    \"\"\"Find a string that contains both sub_str1 and sub_str2, in any order\"\"\"\n    return sub_str1 in s and sub_str2 in s\ndef g(sub_str1='foo', sub_str2='bar'):\n    return sub_str1 + sub_str2\nassert f(g())\n",
        "idx_generation": 248,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using the insertion sort algorithm\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\nassert f(g([4, 2, 1, 3])) == [1, 2, 3, 4]\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, find if there exists a subset whose sum is equal to the target.\"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n - 1] > target:\n            return subset_sum(nums, target, n - 1)\n        return subset_sum(nums, target - nums[n - 1], n - 1) or subset_sum(nums, target, n - 1)\n    \n    return subset_sum(nums, target, len(nums))\n\ndef g():\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g(), 16)\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return a new list with all duplicate elements removed.\"\"\"\n    return list(set(arr))\n\ndef g(arr: List[int]) -> List[int]:\n    return arr\n\nassert f(g([1, 2, 3, 3, 4, 5, 5, 6])) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using dynamic programming.\"\"\"\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    \n    def fib(n):\n        if n == 0:\n            return 0\n        if memo[n] != 0:\n            return memo[n]\n        memo[n] = fib(n - 1) + fib(n - 2)\n        return memo[n]\n    \n    return fib(n)\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    \"\"\"Generate a random palindrome string.\"\"\"\n    import random\n    import string\n    chars = string.ascii_lowercase\n    length = random.randint(1, 10)\n    half_length = length // 2\n    prefix = ''.join(random.choice(chars) for _ in range(half_length))\n    suffix = prefix[::-1] if length % 2 == 0 else prefix[:-1][::-1]\n    return prefix + suffix\n\nassert f(g())\n",
        "idx_generation": 254,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    Return the index if the target value is found, -1 otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 4\n    return (arr, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 207,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the factorial of a given number.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g(n: int) -> int:\n    return n\n\nassert f(g(5)) == 120\n",
        "idx_generation": 292,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of a subgrid where the subgrid is a rectangle.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            dp[i][j] = grid[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    max_sum = float('-inf')\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            for k in range(i, rows + 1):\n                for l in range(j, cols + 1):\n                    subgrid_sum = dp[k][l] - dp[i - 1][l] - dp[k][j - 1] + dp[i - 1][j - 1]\n                    max_sum = max(max_sum, subgrid_sum)\n    return max_sum\n\ndef g():\n    return [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]\n\nassert f(g()) == 29\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, rotate the string to the right by k positions.\n    Return the rotated string.\n    \"\"\"\n    if not s:\n        return s\n    k %= len(s)\n    return s[-k:] + s[:-k]\n\ndef g():\n    return ('abcdefg', 3)\n\nassert f(*g()) == 'efgabcd'\n",
        "idx_generation": 254,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given array whose sum is equal to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [4, 2, 6, 8, 3]\n    target = 9\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 208,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n    return fib[n]\n\ndef g(n: int):\n    return n\n\nassert f(g(6)) == 8\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right at each step.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[rows - 1][cols - 1]\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g()) == 7\n",
        "idx_generation": 342,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome after removing one character.\"\"\"\n    n = len(s)\n    left, right = 0, n - 1\n    while left < right:\n        if s[left] != s[right]:\n            return s[left + 1:right + 1] == s[left + 1:right + 1][::-1] or s[left:right] == s[left:right][::-1]\n        left += 1\n        right -= 1\n    return True\ndef g(s: str) -> str:\n    \"\"\"\n    Return a string that is a palindrome after removing one character.\n    \"\"\"\n    n = len(s)\n    for i in range(n):\n        if s[i] != s[n - i - 1]:\n            return s[:i] + s[i + 1:]\n    return s[:-1]\nassert f(g(\"abca\"))\n",
        "idx_generation": 258,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, determine if the rows and columns are sorted in non-decreasing order.\n    Return True if the rows and columns are sorted, False otherwise.\"\"\"\n    n_rows = len(matrix)\n    n_cols = len(matrix[0])\n    \n    for i in range(n_rows):\n        if not all(matrix[i][j] <= matrix[i][j+1] for j in range(n_cols-1)):\n            return False\n    \n    for j in range(n_cols):\n        if not all(matrix[i][j] <= matrix[i+1][j] for i in range(n_rows-1)):\n            return False\n    \n    return True\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Sort the given matrix in non-decreasing order, both rows and columns.\"\"\"\n    matrix.sort(key=lambda x: x[0])\n    for i in range(len(matrix)):\n        matrix[i].sort()\n    return matrix\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nassert f(g(matrix))\n",
        "idx_generation": 209,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given an array of integers, check if there exists a pair of numbers whose sum is equal to a given target.\"\"\"\n    target = 10\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\ndef g(arr=[2, 4, 6, 8]):\n    return (arr,)\nassert f(*g()) == True\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if it is possible to partition the list into two subsets such that the sum of elements in each subset is equal to the target value.\n    Each element in the list can only be used once.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target_sum]\ndef g() -> Tuple[List[int], int]:\n    return ([1, 5, 11, 5], 11)\nassert f(*g())\n",
        "idx_generation": 342,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Reverse the words in a given string.\"\"\"\n    def reverse_words(string):\n        words = string.split()\n        return ' '.join(words[::-1])\n    \n    return reverse_words(string)\n\ndef g():\n    return (\"Hello World! This is a test\",)\n\nassert f(*g()) == \"test a is This World! Hello\"\n",
        "idx_generation": 259,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list whose multiplication is equal to the target.\"\"\"\n    nums.sort()\n    (left, right) = (0, len(nums) - 1)\n    while left < right:\n        multiplication = nums[left] * nums[right]\n        if multiplication == target:\n            return True\n        elif multiplication < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [5, 3, 9, 10, 7, 2]\nassert f(g(), 15)\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of numbers is a palindrome when represented in binary format.\n    \"\"\"\n    binary_nums = [bin(num)[2:] for num in nums]\n    binary_strings = [str(binary) for binary in binary_nums]\n    binary_string = ''.join(binary_strings)\n    return binary_string == binary_string[::-1]\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([5, 9, 3, 9, 5]))\n",
        "idx_generation": 300,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g():\n    nums = [2, 4, 3, 5, 1, 6, 8, 7, 9]\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 343,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the first non-repeating character and return its index.\n    If there is no non-repeating character, return -1.\n    Sample Input:\n    s = \"leetcode\"\n    Sample Output:\n    0\n    \"\"\"\n    char_count = [0] * 26\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n    for i, char in enumerate(s):\n        if char_count[ord(char) - ord('a')] == 1:\n            return i\n    return -1\n    \ndef g(s=\"leetcode\"):\n    return s\n\nassert f(g()) == 0\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers, determine if there exists two numbers such that their sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 4, 7, 11, 15]\n\nassert f(g(), 9) == True\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Find the length of the longest increasing path in a matrix.\n    A path is considered increasing if each cell is greater than its adjacent cells (up, down, left, and right).\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    max_length = 0\n    \n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        length = 1\n        \n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                length = max(length, 1 + dfs(x, y))\n        \n        dp[i][j] = length\n        return length\n    \n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n    \n    return max_length\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Return a matrix with random values.\"\"\"\n    return matrix\n\nassert f(g([[9, 9, 4], [6, 6, 8], [2, 1, 1]])) == 4\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subsequence with the constraint that no two numbers in the sequence are adjacent.\n- nums is a list of integers\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[n-1]\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return nums\nassert f(g()) == 12\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of times the word \"hello\" appears in the given string.\"\"\"\n    count = 0\n    index = s.find(\"hello\")\n    while index != -1:\n        count += 1\n        index = s.find(\"hello\", index + 1)\n    return count\ndef g():\n    return \"hellohellohello\"\nassert f(g()) == 3\n",
        "idx_generation": 262,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"Given a list of integers and an integer k, find the kth smallest element in the list.\"\"\"\n    arr.sort()\n    return arr[k-1]\n\ndef g(arr: List[int], k: int):\n    return (arr, k)\n\nassert f(*g([5, 2, 7, 1, 4], 3)) == 4\n",
        "idx_generation": 213,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, rotate it 90 degrees clockwise in-place.\"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    def fib(n: int, memo: dict) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fib(n-1, memo) + fib(n-2, memo)\n        return memo[n]\n    return fib(n, {})\ndef g():\n    n = 6\n    return n\nassert f(g()) == 8\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels (a, e, i, o, u) in the given string s.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum([1 for char in s if char.lower() in vowels])\n    return count\n\ndef g():\n    s = 'Hello, World!'\n    return (s,)\n\nassert f(*g()) == 3\n",
        "idx_generation": 273,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, find if there exists a pair of numbers that sum up to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return (arr, target)\n\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(*g(arr, target))\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a subarray in the given array that sums up to the target\"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n        \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return True\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5, 6, 7, 8, 9]):\n    return (arr,)\n    \nassert f(*g())\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, compute the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\n    Return the computed nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return f(n - 1) + f(n - 2)\ndef g(n: int) -> int:\n    \"\"\"\n    Return the positive integer n.\n    \"\"\"\n    return n\nassert f(g(8)) == 21\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Check if the given string matches the given pattern. The pattern consists of only '0' and '1', where '0' represents any single character and '1' represents any sequence of characters.\"\"\"\n    def match(s, p):\n        if len(s) == 0 and len(p) == 0:\n            return True\n        if len(s) == 0 or len(p) == 0:\n            return False\n        if p[0] == '0':\n            return match(s[1:], p[1:])\n        elif p[0] == '1':\n            for i in range(len(s)):\n                if match(s[i+1:], p[1:]):\n                    return True\n            return False\n    \n    return match(string, pattern)\n\ndef g():\n    return ('apple', '01')\n\nassert f(*g()) == True\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers nums and a target integer, return True if the target integer is present in the list, otherwise return False.\"\"\"\n    start = 0\n    end = len(nums) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return False\ndef g(nums: List[int], target: int):\n    return (nums, target)\nnums = sorted(random.sample(range(100), 50))\ntarget = random.randint(0, 99)\nassert f(*g(nums, target)) == (target in nums)\n",
        "idx_generation": 213,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists a subarray whose sum is equal to zero.\"\"\"\n    prefix_sum = 0\n    prefix_sum_set = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sum_set or prefix_sum == 0:\n            return True\n        prefix_sum_set.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, 2, -3, 1, 6]\n\nassert f(g())\n",
        "idx_generation": 308,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"Given a list of integers and two positive integers n and k, determine if it is possible to select k integers from the list such that the sum of any two selected integers is divisible by n.\n    Return True if such a selection is possible, otherwise return False.\"\"\"\n    \n    def is_divisible_by_n(a: int, b: int, n: int) -> bool:\n        return (a + b) % n == 0\n    \n    def select_k(nums: List[int], k: int, n: int) -> bool:\n        if k == 0:\n            return True\n        if not nums:\n            return False\n        \n        # Select first number from the list\n        num = nums[0]\n        remaining_nums = nums[1:]\n        \n        # Check if num can be paired with any other selected number to be divisible by n\n        for i in range(len(remaining_nums)):\n            if is_divisible_by_n(num, remaining_nums[i], n):\n                # Recurse with the remaining numbers and k-1\n                if select_k(remaining_nums[:i] + remaining_nums[i+1:], k-1, n):\n                    return True\n        \n        # Recurse without selecting the current number\n        if select_k(remaining_nums, k, n):\n            return True\n        \n        return False\n    \n    return select_k(nums, k, n)\n\ndef g(n: int, k: int, nums: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Return the values of n, k, and nums.\n    \"\"\"\n    return n, k, nums\n\nassert f(*g(3, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome, ignoring spaces and cases.\"\"\"\n    s = ''.join(s.lower().split())\n    return s == s[::-1]\n\ndef g():\n    return 'A man a plan a canal Panama'\n\nassert f(g())\n",
        "idx_generation": 279,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of numbers that sum up to the target.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 214,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a contiguous subarray in the given array.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    arr = random.choices(range(-100, 101), k=1000)\n    return arr\n\nassert f(g()) >= 0\n",
        "idx_generation": 309,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target_sum=10) -> bool:\n    \"\"\"Check if there exists a subset of numbers in the list that adds up to the target sum.\"\"\"\n    def subset_sum(nums, target_sum, i, curr_sum):\n        if curr_sum == target_sum:\n            return True\n        if i >= len(nums) or curr_sum > target_sum:\n            return False\n        include = subset_sum(nums, target_sum, i+1, curr_sum + nums[i])\n        exclude = subset_sum(nums, target_sum, i+1, curr_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target_sum, 0, 0)\n\ndef g():\n    \"\"\"Generate a list of integers.\"\"\"\n    return [2, 4, 6, 8, 10]\n\nassert f(g())\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern='0101') -> bool:\n    \"\"\"Check if a given string contains the binary pattern\"\"\"\n    return pattern in string\ndef g(pattern='0101'):\n    return pattern * (len(pattern) * 3)\nassert f(g())\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = arr[0]\n    curr_sum = arr[0]\n\n    for num in arr[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of binary digits, return the decimal value of the binary representation.\n    \"\"\"\n    decimal = 0\n    n = len(s)\n    for i in range(n):\n        if s[i] == '1':\n            decimal += 2 ** (n - i - 1)\n    return decimal\n\ndef g(n: int):\n    \"\"\"\n    Generate a binary string of length n with alternating 0s and 1s.\n    \"\"\"\n    binary = \"\"\n    for i in range(n):\n        binary += str(i % 2)\n    return binary\n\nassert f(g(6)) == 21\n",
        "idx_generation": 315,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list whose sum equals the target.\"\"\"\n    def subset_sum(nums, target, index, memo):\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        if nums[index] <= target:\n            if subset_sum(nums, target - nums[index], index + 1, memo):\n                memo[(index, target)] = True\n                return True\n        \n        memo[(index, target)] = subset_sum(nums, target, index + 1, memo)\n        return memo[(index, target)]\n    \n    memo = {}\n    return subset_sum(nums, target, 0, memo)\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == True\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, substrings=['abc', 'def', 'ghi']) -> bool:\n    \"\"\"Check if a given string can be formed by concatenating the substrings in any order\"\"\"\n    return all(substring in string for substring in substrings)\ndef g(substrings=['abc', 'def', 'ghi']):\n    return ''.join(substrings) + 'xyz'\nassert f(g())\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers nums and a target number, find a pair of numbers in the list that sum up to the target.\n    If such a pair does not exist, return an empty list.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=10):\n    return (nums, target)\nassert f(*g()) == [1, 9]\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    \n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate a random positive integer.\n    \"\"\"\n    return 16\n\nassert f(g())\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate its factorial.\n\n    Return the factorial of n.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g(s=\"Hello World\"):\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, return True if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 215,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in a list of consecutive integers from 1 to n.\"\"\"\n    n = len(nums) + 1\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum\n\ndef g():\n    return [1, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 2\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, target_sum: int) -> bool:\n    \"\"\"Find if there exists a subset of the given array such that the sum of its elements is equal to the target sum.\"\"\"\n    def subset_sum(nums, target, n):\n        dp = [[False] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if nums[i - 1] > j:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n        return dp[n][target]\n    \n    nums = [2, 3, 5, 7, 10]\n    return subset_sum(nums, target_sum, len(nums))\n    \ndef g(n: int, target_sum: int):\n    return n, target_sum\n    \nassert f(*g(5, 14)) == True\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string.\"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g() -> str:\n    \"\"\"Return a string with multiple words.\"\"\"\n    return \"Hello world!\"\n\nassert f(g()) == \"olleH !dlrow\"\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a saddle point in the given matrix.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        row_min = min(matrix[i])\n        for j in range(cols):\n            col_max = max(matrix[k][j] for k in range(rows))\n            if matrix[i][j] == row_min and matrix[i][j] == col_max:\n                return True\n    return False\n\ndef g():\n    matrix = [\n        [4, 5, 6],\n        [7, 8, 9],\n        [10, 11, 12]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 222,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of numbers, find the maximum sum of a subarray that is less than or equal to the target.\"\"\"\n    length = len(nums)\n    max_sum = float('-inf')\n    for i in range(length):\n        current_sum = 0\n        for j in range(i, length):\n            current_sum += nums[j]\n            if current_sum <= target:\n                max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums=[1, -2, 3, 4, -5], target=5):\n    return (nums, target)\n\nassert f(*g()) == 5\n",
        "idx_generation": 322,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(coins: List[int], amount: int) -> int:\n    \"\"\"Find the minimum number of coins needed to make up the given amount.\"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]\n    \ndef g(coins: List[int], amount: int):\n    return coins, amount\n    \nassert f(*g([1, 2, 5], 11)) == 3\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it can be formed by concatenating a subsequence of itself.\n    A subsequence of a string is a new string obtained by deleting some characters from the original string\n    without changing the relative order of the remaining characters.\n    Sample Input:\n    s = \"abcabcabcabc\"\n    Sample Output:\n    True\"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if n % i == 0 and s[:i] * (n // i) == s:\n            return True\n    return False\n\ndef g(s: str):\n    return \"abcabcabcabc\"\n\nassert f(g(\"abcabcabcabc\")) == True\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int]) -> int:\n    \"\"\"Find the largest product of three distinct numbers in the given list.\"\"\"\n    numbers.sort()\n    n = len(numbers)\n    return max(numbers[0] * numbers[1] * numbers[n-1], numbers[n-3] * numbers[n-2] * numbers[n-1])\n\ndef g():\n    numbers = [1, 2, 3, 4, 5, 6]\n    return numbers\n\nassert f(g()) == 120\n",
        "idx_generation": 222,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of numbers, find the minimum number of moves required to make all elements equal.\n    A move consists of incrementing n - 1 elements by 1, where n is the length of the list.\n    Return the minimum number of moves required.\n    \"\"\"\n    min_num = min(nums)\n    moves = sum(nums) - min_num * len(nums)\n    return moves\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 10\n",
        "idx_generation": 324,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number using dynamic programming.\n    Returns the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n+1)\n    fib[1] = 1\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"Check if the given string contains all the words in the list, in any order.\"\"\"\n    return all(word in string for word in words)\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return ''.join(words)\nassert f(g())\n",
        "idx_generation": 296,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(prices: List[int], k: int) -> List[int]:\n    \"\"\"Find the k cheapest items from the given price list.\"\"\"\n    prices.sort()\n    return prices[:k]\n\ndef g(k: int):\n    prices = [10, 5, 8, 3, 2, 7, 6, 4, 9, 1]\n    return (prices, k)\n\nk = 3\nassert f(*g(k)) == [1, 2, 3]\n",
        "idx_generation": 222,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given an n x n matrix, rotate the matrix 90 degrees clockwise.\n    Sample input:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Sample output:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n    \ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return [list(row) for row in matrix]\n    \nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find the contiguous subarray of the given list with the largest sum, and return the sum.\"\"\"\n    max_sum = nums[0]\n    current_sum = nums[0]\n    start = 0\n    end = 0\n    for i in range(1, len(nums)):\n        if current_sum < 0:\n            current_sum = nums[i]\n            start = i\n        else:\n            current_sum += nums[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = i\n    return max_sum\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return (nums, len(nums))\nassert f(*g()) == 6\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome when ignoring spaces and punctuation.\"\"\"\n    s = ''.join(ch for ch in s if ch.isalnum())\n    return s.lower() == s.lower()[::-1]\ndef g():\n    return \"A man, a plan, a canal: Panama!\"\nassert f(g())\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort the given list of integers in ascending order using bubble sort.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g():\n    nums = [9, 2, 7, 4, 1, 5, 3, 8, 6]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
        "idx_generation": 222,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a non-empty subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [[10, 9, 2, 5, 3, 7, 101, 18]]\n\nassert f(*g()) == 4\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are anagrams, considering only lowercase alphabets.\"\"\"\n    def countCharacters(string):\n        count = [0] * 26\n        for char in string:\n            count[ord(char) - ord('a')] += 1\n        return count\n\n    count1 = countCharacters(s1)\n    count2 = countCharacters(s2)\n\n    return count1 == count2\n\ndef g(s1='listen', s2='silent'):\n    return (s1, s2)\n\nassert f(*g())\n",
        "idx_generation": 302,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Given a positive integer n, determine if it is a prime number.\nReturn True if n is prime, otherwise return False.\nSample Input:\nn = 13\nSample Output:\nTrue\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\ndef g(n=13):\n    return n\nassert f(g())\n",
        "idx_generation": 226,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, return the product of all numbers except the current number.\"\"\"\n    n = len(nums)\n    result = [1] * n\n    left_product = 1\n    right_product = 1\n    \n    # Calculate product of all numbers to the left of each number\n    for i in range(n):\n        result[i] *= left_product\n        left_product *= nums[i]\n    \n    # Calculate product of all numbers to the right of each number\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n    \n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 341,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top left to the bottom right of the grid.\n    You can only move down or right at any point in time.\n    Return the minimum sum.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n    return dp[m-1][n-1]\n\ndef g():\n    return [[[1, 3, 1], [1, 5, 1], [4, 2, 1]]]\n\nassert f(*g()) == 7\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string s, return a new string where each word is reversed, but the order of the words remains the same.\"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello world, how are you?\"\n\nassert f(g()) == \"olleH ,dlrow woh era ?uoy\"\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Find the kth largest element in the given list of integers\"\"\"\n    def quickselect(nums, low, high, k):\n        pivot = partition(nums, low, high)\n        if pivot == k - 1:\n            return nums[pivot]\n        elif pivot < k - 1:\n            return quickselect(nums, pivot + 1, high, k)\n        else:\n            return quickselect(nums, low, pivot - 1, k)\n\n    def partition(nums, low, high):\n        pivot = nums[high]\n        i = low - 1\n        for j in range(low, high):\n            if nums[j] >= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1], nums[high] = nums[high], nums[i + 1]\n        return i + 1\n\n    return quickselect(nums, 0, len(nums) - 1, k)\n\ndef g() -> Tuple[List[int], int]:\n    return ([5, 3, 8, 2, 9], 3)\n\nassert f(*g()) == 5\n",
        "idx_generation": 227,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of trailing zeros in n factorial.\"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef g():\n    return 20\n\nassert f(g()) == 4\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Find the number of ways to climb a staircase with n steps, where you can take at most k steps at a time.\n    Return the result modulo 10^9 + 7.\"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                dp[i] += dp[i - j]\n    return dp[n] % (10**9 + 7)\ndef g(n=4, k=2):\n    return (n, k)\nassert f(*g()) == 5\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> int:\n    \"\"\"Given a string s, calculate the length of the longest substring without repeating characters.\"\"\"\n    start = 0\n    max_length = 0\n    used_chars = {}\n    for i, char in enumerate(s):\n        if char in used_chars and start <= used_chars[char]:\n            start = used_chars[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        used_chars[char] = i\n    return max_length\ndef g(s=\"abcabcbb\"):\n    return s\nassert f(g()) == 3\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers (in ascending order), determine if there are two numbers that add up to the target number.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 10\nassert f(*g(nums, target))\n",
        "idx_generation": 227,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the sum of all the multiples of 3 or 5 below n.\"\"\"\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\n\ndef g():\n    return 100\n\nassert f(g()) == 2318\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path from the top-left cell to the bottom-right cell in a grid,\n    where you can only move rightwards or downwards.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 12\n",
        "idx_generation": 367,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of digits, return the string with each digit repeated twice.\n    \"\"\"\n    doubled = \"\"\n    for digit in s:\n        doubled += digit * 2\n    return doubled\n\ndef g(s: str):\n    \"\"\"\n    Reverse the string.\n    \"\"\"\n    return s[::-1]\n\nassert f(g(\"1234\")) == \"44332211\"\n",
        "idx_generation": 315,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort a list of integers using the Bubble Sort algorithm.\n\n    Args:\n    - nums: A list of integers.\n\n    Returns:\n    - The sorted list of integers.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums\n\ndef g(nums=[5, 3, 8, 2, 1, 4]):\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5, 8]\n",
        "idx_generation": 228,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list of numbers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of positive integers and a target value, return the minimum number of elements from the list that sum up to the target.\nIf it is not possible to sum up to the target using the elements from the list, return -1.\"\"\"\n    def min_elements(nums, target, memo):\n        if target < 0:\n            return float('inf')\n        if target == 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        min_count = float('inf')\n        for num in nums:\n            count = min_elements(nums, target - num, memo)\n            if count != float('inf'):\n                min_count = min(min_count, count + 1)\n        memo[target] = min_count\n        return min_count if min_count != float('inf') else -1\n    return min_elements(nums, target, {})\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)\nassert f(*g()) == 2\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if it is possible to form string s by concatenating the same substring n times\"\"\"\n    m = len(s) // n\n    for i in range(1, m+1):\n        if s == s[:i] * n:\n            return True\n    return False\ndef g(n=3):\n    return \"abc\" * n\nassert f(g())\n",
        "idx_generation": 317,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a list of integers is sorted in non-decreasing order.\"\"\"\n    return nums == sorted(nums)\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 228,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> List[List[int]]:\n    \"\"\"Given an integer n, generate the first n rows of Pascal's triangle.\n\n    Each number in the triangle is the sum of the two numbers directly above it.\n    \"\"\"\n    triangle = []\n    for i in range(n):\n        row = []\n        for j in range(i+1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n        triangle.append(row)\n    return triangle\n\ndef g():\n    n = 5\n    return n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 357,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target_sum=10) -> bool:\n    \"\"\"Find if there exists a subset of the array that adds up to the target sum.\"\"\"\n    def subset_sum(arr, n, target_sum):\n        if target_sum == 0:\n            return True\n        if n == 0 and target_sum != 0:\n            return False\n        if arr[n-1] > target_sum:\n            return subset_sum(arr, n-1, target_sum)\n        return subset_sum(arr, n-1, target_sum) or subset_sum(arr, n-1, target_sum-arr[n-1])\n    \n    return subset_sum(arr, len(arr), target_sum)\n    \ndef g(target_sum=10):\n    arr = [2, 4, 6, 8]\n    return arr\n    \nassert f(g())\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome, i.e. reads the same forwards and backwards.\nSample Input:\ns = \"racecar\"\nSample Output:\nTrue\nExplanation: The given string \"racecar\" is a palindrome, hence the output is True.\"\"\"\n    return s == s[::-1]\ndef g(s=\"racecar\"):\n    return s\nassert f(g())\n",
        "idx_generation": 326,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three numbers in the list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 5, -3, 7, 2, -9, 4, 6, -8]\n\nassert f(g()) == 504\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target sum, find two numbers in the list that add up to the target.\n    Return their indices in the list.\"\"\"\n    num_set = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_set:\n            return [num_set[complement], i]\n        num_set[num] = i\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"Given a list of integers, a target value, and a parameter k, determine if it is possible to divide the list into k non-empty subarrays such that the sum of each subarray is equal to the target.\"\"\"\n    def dfs(nums, target, k, start, curr_sum, visited):\n        if k == 1:\n            return True\n        if curr_sum == target:\n            return dfs(nums, target, k-1, 0, 0, visited)\n        for i in range(start, len(nums)):\n            if not visited[i] and curr_sum + nums[i] <= target:\n                visited[i] = True\n                if dfs(nums, target, k, i+1, curr_sum+nums[i], visited):\n                    return True\n                visited[i] = False\n        return False\n    \n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target = total_sum // k\n    visited = [False] * len(nums)\n    return dfs(nums, target, k, 0, 0, visited)\n    \ndef g() -> Tuple[List[int], int, int]:\n    return ([1, 2, 3, 4, 5, 6], 7, 3)\n\nassert f(*g())\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=10) -> bool:\n    \"\"\"Check if it is possible to obtain a string of the target length by concatenating the given string repeatedly.\"\"\"\n    return len(s * (target_length // len(s))) == target_length\ndef g(target_length=10):\n    return 'abcde'\nassert f(g())\n",
        "idx_generation": 328,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a pair of numbers whose product is equal to the target value.\"\"\"\n    nums.sort()\n    (left, right) = (0, len(nums) - 1)\n    while left < right:\n        curr_product = nums[left] * nums[right]\n        if curr_product == target:\n            return True\n        elif curr_product < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10, 12]\n\nassert f(g(), 48)\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    prev = 0\n    curr = 1\n    for _ in range(2, n + 1):\n        curr, prev = curr + prev, curr\n    return curr\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if a target number can be obtained by adding or subtracting any combination of elements from a list.\"\"\"\n    def backtrack(index, curr_sum):\n        if index == len(arr):\n            return curr_sum == target\n        if backtrack(index + 1, curr_sum + arr[index]):\n            return True\n        if backtrack(index + 1, curr_sum - arr[index]):\n            return True\n        return False\n    return backtrack(0, 0)\n\ndef g(arr=[1, 2, 3, 4, 5], target=9):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        True if the string is a palindrome, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g():\n    \"\"\"\n    Returns a sample string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 333,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the sum of all prime numbers in the given list.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\ndef g():\n    return [2, 4, 6, 7, 9, 10, 11]\n\nassert f(g()) == 20\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subarray.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, -2, 3, -4, 5, -6, 7, -8, 9])) == 9\nassert f(g([-1, -2, -3, -4, -5])) == -1\n",
        "idx_generation": 359,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target number, find a subset of numbers that add up to the target.\nReturn the subset of numbers that sum to the target, or an empty list if no such subset exists.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n    if not dp[n][target]:\n        return []\n    subset = []\n    i, j = n, target\n    while i > 0 and j > 0:\n        if dp[i - 1][j]:\n            i -= 1\n        else:\n            subset.append(nums[i - 1])\n            j -= nums[i - 1]\n            i -= 1\n    return subset[::-1]\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14]\n\nassert f(g(), 20) == [2, 4, 6, 8]\n",
        "idx_generation": 374,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> bool:\n    \"\"\"Given a string representing a mathematical expression, determine if the parentheses are balanced.\"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    expression = \"((3 + 4) * 2 - (1 + 2))\"\n    return expression\nassert f(g())\n",
        "idx_generation": 334,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return -1\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [2, 4, 6, 8, 10, 12, 14]\ntarget = 6\nassert f(*g(nums, target)) == 2\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a perfect square sequence\"\"\"\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] != i**2:\n            return False\n    return True\ndef g():\n    return [0, 1, 4, 9, 16, 25, 36]\nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the nth Fibonacci number.\"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 374,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(string: str) -> str:\n    \"\"\"Given a string, reverse the words in the string while maintaining the order of characters within each word.\n    Sample input:\n    string = \"Hello World\"\n    Sample output:\n    \"olleH dlroW\"\n    \"\"\"\n    words = string.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n    \ndef g():\n    string = \"Hello World\"\n    return string\n    \nassert f(g()) == \"olleH dlroW\"\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum product that can be obtained by multiplying any three numbers from the list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 4, 2, 7, 3, 9, 10]\n\nassert f(g()) == 630\n",
        "idx_generation": 236,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there is a subarray with a sum equal to 0.\n    Return True if such subarray exists, otherwise return False.\"\"\"\n    prefix_sum = 0\n    visited = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in visited:\n            return True\n        visited.add(prefix_sum)\n    return False\ndef g():\n    return [4, 2, -3, 1, 6]\nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if it can be divided into two subsets with equal sum.\n    The goal is to find a subset sum that is equal to the total sum divided by 2.\"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - nums[i - 1] >= 0:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target_sum]\n    \ndef g(nums: List[int]) -> None:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return (nums,)\n\nnums = [1, 5, 11, 5]\nassert f(*g(nums))\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string s and an integer k, return True if it is possible to rearrange the characters\n    in s such that every character appears at most k times consecutively, and False otherwise.\"\"\"\n    if k == 0:\n        return False\n    counts = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            counts.append(count)\n            count = 1\n    counts.append(count)\n    return all(count <= k for count in counts)\n\ndef g(s: str, k: int) -> str:\n    \"\"\"Given a string s and an integer k, return a rearranged string where every character appears\n    at most k times consecutively.\"\"\"\n    if k == 0:\n        return \"\"\n    counts = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            counts.append(count)\n            count = 1\n    counts.append(count)\n    rearranged = \"\"\n    for count in counts:\n        rearranged += s[0]*min(count, k)\n        s = s[count:]\n    return rearranged\n\n# Example usage:\ns = \"aabbbcc\"\nk = 2\nassert f(g(s, k), k)\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of three numbers in the given list.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 236,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if the list contains a subarray with a sum equal to zero, \n    and False otherwise.\"\"\"\n    prefix_sum = set()\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        if curr_sum == 0 or curr_sum in prefix_sum:\n            return True\n        prefix_sum.add(curr_sum)\n    return False\n\ndef g() -> List[int]:\n    return [4, 2, -3, 1, 6]\n    \nassert f(g())\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum from top-left corner to bottom-right corner.\n    Each move can only be made to the right or down.\n    The goal is to find the path from top-left to bottom-right with the maximum sum.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    \n    return dp[rows - 1][cols - 1]\n\ndef g(grid: List[List[int]]) -> None:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return (grid,)\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(*g(grid)) == 12\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s2 can be formed by rearranging the characters of s1.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for c in s1:\n        count[ord(c) - ord('a')] += 1\n    for c in s2:\n        count[ord(c) - ord('a')] -= 1\n        if count[ord(c) - ord('a')] < 0:\n            return False\n    return True\n\ndef g():\n    return (\"listen\", \"silent\")\n\nassert f(*g())\n",
        "idx_generation": 340,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target',\n    determine if there are three integers in 'nums' such that the sum is equal to 'target'.\n    Return True if such triplets exist, otherwise return False.\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    Sample Output:\n    True\n    Explanation: The numbers 2, 4, and 3 can be added to get 9, hence the output is True.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 236,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(points: List[Tuple[int, int]]) -> int:\n    \"\"\"Given a list of (x, y) points, find the number of points that lie on the x-axis or y-axis.\n    Return the count of points.\"\"\"\n    count = 0\n    for point in points:\n        if point[0] == 0 or point[1] == 0:\n            count += 1\n    return count\n\ndef g(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Return the list of (x, y) points.\n    \"\"\"\n    return points\n\nassert f(g([(0, 1), (2, 0), (3, 4), (0, -2)])) == 3\n",
        "idx_generation": 363,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=100) -> bool:\n    \"\"\"Find a combination of numbers from the given list that adds up to the target.\"\"\"\n    def helper(i, current_sum):\n        if current_sum == target:\n            return True\n        if i == len(nums):\n            return False\n        return helper(i+1, current_sum + nums[i]) or helper(i+1, current_sum)\n    return helper(0, 0)\ndef g(target=100):\n    nums = [10, 20, 30, 40, 50]\n    return nums\nassert f(g())\n",
        "idx_generation": 377,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(words: List[str]) -> List[str]:\n    \"\"\"Given a list of words, return a new list where each word is reversed.\"\"\"\n    return [word[::-1] for word in words]\ndef g():\n    words = [\"hello\", \"world\", \"python\", \"puzzle\"]\n    return words\nassert f(g()) == [\"olleh\", \"dlrow\", \"nohtyp\", \"elzzup\"]\n",
        "idx_generation": 343,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    \n    while low < high:\n        current_sum = nums[low] + nums[high]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            low += 1\n        else:\n            high -= 1\n    \n    return False\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(*g(nums, target))\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the given list that add up to the target value. Return their indices.\"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\ndef g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number using recursion and dynamic programming\"\"\"\n    if n <= 1:\n        return n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    return fib[n]\n\ndef g(n: int) -> int:\n    return n\n\nassert f(g(7)) == 13\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 is a rotation of s2.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    return s1 in s2 + s2\n\ndef g():\n    return ('waterbottle', 'erbottlewat')\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target value 'target',\n    determine if there exists a pair of elements in the list whose sum is equal to the target value.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n    \ndef g():\n    arr = [1, 3, 5, 7, 9]\n    target = 12\n    return (arr, target)\n    \nassert f(*g())\n",
        "idx_generation": 242,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within the given list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers nums, find the maximum sum of a subarray using dynamic programming.\"\"\"\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    max_sum = nums[0]\n    for i in range(1, n):\n        dp[i] = max(nums[i], dp[i-1] + nums[i])\n        max_sum = max(max_sum, dp[i])\n    return max_sum\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers nums with both positive and negative numbers.\n    \"\"\"\n    return nums\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(nums)) == 6\n",
        "idx_generation": 383,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"Rotate the given string s by n characters to the right.\"\"\"\n    n = n % len(s)\n    return s[-n:] + s[:-n]\ndef g():\n    return ('hello', 3)\nassert f(*g()) == 'llohe'\n",
        "idx_generation": 349,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers, find the longest subarray with consecutive elements and return True if the length of the subarray is greater than or equal to 3. Otherwise, return False.\n    Sample Input:\n    arr = [1, 2, 3, 5, 8, 9, 10, 11, 12]\n    Sample Output:\n    True\"\"\"\n    n = len(arr)\n    max_length = 1\n    current_length = 1\n    for i in range(1, n):\n        if arr[i] == arr[i - 1] + 1:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n    return max_length >= 3\ndef g(arr=[1, 2, 3, 5, 8, 9, 10, 11, 12]):\n    return arr\nassert f(g())\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(word: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a word and a list of words, check if the word is an anagram of any word in the list.\n\n    Return True if the word is an anagram of any word in the list, otherwise return False.\n    \"\"\"\n    sorted_word = sorted(word)\n\n    for w in words:\n        if sorted(w) == sorted_word:\n            return True\n\n    return False\n\ndef g(word: str, words: List[str]) -> str:\n    \"\"\"\n    Generate an anagram of the word.\n\n    The generated anagram should be obtained by rearranging the letters of the word.\n\n    Return the generated anagram.\n    \"\"\"\n    return ''.join(sorted(word, reverse=True))\n\nword = 'listen'\nwords = ['silent', 'enlist', 'tinsel']\nassert f(g(word, words), words)\n",
        "idx_generation": 365,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the length of the longest increasing subsequence (LIS) in the list.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n    An increasing subsequence is a subsequence in which the elements are in strictly increasing order.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 395,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if a string contains a sequence of n consecutive digits\"\"\"\n    for i in range(len(s)-n+1):\n        if s[i:i+n].isdigit():\n            return True\n    return False\ndef g(n=3):\n    s = \"abc123def\"\n    return s\nassert f(g())\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, return True if the list is sorted in non-decreasing order.\"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    return True\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 246,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target value is present in the matrix.\"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n    if cols == 0:\n        return False\n    \n    row = 0\n    col = cols - 1\n    \n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 14\n    return (matrix, target)\n\nassert f(*g())\n",
        "idx_generation": 367,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, return the number of unique paths to reach the bottom-right corner of a grid of size n x n, moving only right and down.\n\n    Args:\n        n: The size of the grid.\n\n    Returns:\n        The number of unique paths to reach the bottom-right corner.\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n\n    dp = [0] * n\n    dp[0] = 1\n    dp[1] = 2\n\n    for i in range(2, n):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n-1]\n\ndef g() -> int:\n    \"\"\"\n    Returns a positive integer.\n    \"\"\"\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 396,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Check if the target number is present in the grid, where each element in the grid is a single-digit integer.\"\"\"\n    for row in grid:\n        if str(target) in ''.join(map(str, row)):\n            return True\n    return False\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 5)\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is sorted in descending order\"\"\"\n    return arr == sorted(arr, reverse=True)\n\ndef g():\n    return [9, 7, 5, 3, 1]\n\nassert f(g())\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all the multiples of 3 or 5 below n.\"\"\"\n    sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n    return sum\ndef g():\n    n = 1000\n    return n\nassert f(g()) == 233168\n",
        "idx_generation": 370,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(coins: List[int], amount: int) -> int:\n    \"\"\"Given a list of coin denominations and a target amount, find the minimum number of coins needed to make the amount\n    using dynamic programming approach.\"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\ndef g():\n    coins = [1, 2, 5]\n    amount = 11\n    return (coins, amount)\nassert f(*g()) == 3\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there are two numbers in the array that sum up to the target value. Return True if such pair exists, otherwise return False.\"\"\"\n    start = 0\n    end = len(arr) - 1\n    while start < end:\n        current_sum = arr[start] + arr[end]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g(arr=[1, 2, 4, 7, 11, 15], target=9):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 248,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the sum of all elements in the matrix.\"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target=100) -> List[int]:\n    \"\"\"Given a list of integers, find a combination of numbers that sum up to the target value.\nReturn the combination as a list if such a combination exists, an empty list otherwise.\"\"\"\n    def find_combination(curr_sum, curr_index, curr_combination):\n        if curr_sum == target:\n            return curr_combination\n        if curr_index == len(nums):\n            return []\n        if curr_sum + nums[curr_index] <= target:\n            include_combination = find_combination(curr_sum + nums[curr_index], curr_index + 1, curr_combination + [nums[curr_index]])\n            if include_combination:\n                return include_combination\n        return find_combination(curr_sum, curr_index + 1, curr_combination)\n    \n    return find_combination(0, 0, [])\ndef g(nums=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]):\n    return nums\nassert f(g()) == [10, 20, 30, 40]\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Count the number of uppercase letters in a given string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count\n\ndef g(s: str):\n    return s\n\nassert f(g('Hello, World!')) == 2\n",
        "idx_generation": 364,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are three numbers in the given list that add up to the target value.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i+1\n        right = n-1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [4, 5, 2, 8, 3]\n    target = 15\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 250,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all multiples of 3 or 5 below n.\n    \"\"\"\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\n\ndef g():\n    n = 100\n    return n\n\nassert f(g()) == 2318\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner in a grid of size n x n.\n    You can only move down, right, or diagonally (down-right) at each step.\n    \"\"\"\n    def backtrack(row, col):\n        if row == n - 1 and col == n - 1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        return (\n            backtrack(row + 1, col) +\n            backtrack(row, col + 1) +\n            backtrack(row + 1, col + 1)\n        )\n\n    return backtrack(0, 0)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 13\n",
        "idx_generation": 401,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome, ignoring non-alphanumeric characters and considering case insensitively.\"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\ndef g(s=\"A man, a plan, a canal, Panama!\"):\n    return s\nassert f(g())\n",
        "idx_generation": 367,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers in ascending order, determine if there exists a pair of numbers that sum up to the target value.\nArgs:\n    arr: The sorted array of integers.\n    target: The target value to find the pair that sums up to it.\nReturns:\n    True if a pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    \"\"\"\n    Returns a sorted array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13)\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n    Your algorithm should run in O(n) complexity.\n    \"\"\"\n\n    num_set = set(nums)\n    max_length = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n\n            max_length = max(max_length, current_length)\n\n    return max_length\n\ndef g():\n    return ([100, 4, 200, 1, 3, 2],)\n\nassert f(*g()) == 4\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs if you can climb either 1 or 2 steps at a time.\"\"\"\n    if n <= 2:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 406,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Check if the given string contains the given substring.\"\"\"\n\n    return substr in s\n\ndef g(substr='abc'):\n    return \"abcdefg\"\n\nassert f(g())\n",
        "idx_generation": 367,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list nums that XOR to the target\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[3, 6, 2, 5, 8, 1]):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum XOR value between any two numbers in the given list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\ndef g():\n    return [10, 15, 3, 7]\nassert f(g()) == 13\n",
        "idx_generation": 384,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find a subset of numbers whose sum equals the target value.\"\"\"\n    def helper(nums, target, i, current_sum):\n        if current_sum == target:\n            return True\n        if i >= len(nums) or current_sum > target:\n            return False\n        return helper(nums, target, i + 1, current_sum + nums[i]) or helper(nums, target, i + 1, current_sum)\n    \n    return helper(nums, target, 0, 0)\n\ndef g(target=0):\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), target=10)\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a given string.\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g(s: str):\n    return s\n\ns = \"Hello World!\"\nassert f(g(s)) == \"World! Hello\"\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists two distinct indices i and j such that arr[i] + arr[j] = k.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == k:\n            return True\n        elif arr[left] + arr[right] < k:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(k: int) -> List[int]:\n    \"\"\"Generate a sorted array of integers.\"\"\"\n    arr = []\n    for i in range(1, k+1):\n        arr.append(i)\n    return arr\n\nassert f(g(k=10), k=8)\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the number of increasing subarrays in a given list of integers.\n    An increasing subarray is defined as a contiguous subarray where the elements are in increasing order.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 6\n    Explanation: The increasing subarrays are [1], [2], [3], [4], [1, 2], [1, 2, 3, 4]\n\n    Args:\n    - nums: A list of integers\n\n    Returns:\n    - The number of increasing subarrays\n    \"\"\"\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i, n):\n            if nums[j] > nums[j-1]:\n                count += 1\n            else:\n                break\n    return count\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nassert f(g([1, 2, 3, 4])) == 6\n",
        "idx_generation": 391,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> int:\n    \"\"\"Evaluate a mathematical expression in reverse Polish notation.\"\"\"\n    stack = []\n    operators = {'+', '-', '*', '/'}\n    for token in expression.split():\n        if token.isdigit():\n            stack.append(int(token))\n        elif token in operators:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]\n\ndef g(expression=\"5 1 2 + 4 * + 3 -\"):\n    return expression\n\nassert f(g()) == 14\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"Given a list of words and a target word, find all words from the list that can be formed by rearranging the letters of the target word.\n    Return a list of words that can be formed from the target word.\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    target = \"eat\"\n    The words that can be formed from \"eat\" are [\"eat\", \"tea\", \"ate\"].\n    Hence, the output should be [\"eat\", \"tea\", \"ate\"].\n    \"\"\"\n    def get_char_count(word):\n        char_count = {}\n        for char in word:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        return char_count\n\n    target_count = get_char_count(target)\n    result = []\n    for word in words:\n        word_count = get_char_count(word)\n        if word_count == target_count:\n            result.append(word)\n    return result\n\ndef g():\n    return ([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \"eat\")\n\nassert f(*g()) == [\"eat\", \"tea\", \"ate\"]\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums: List[int], target: int) -> None:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return (nums, target)\nnums = [1, 4, 2, 7, 3, 6]\ntarget = 9\nassert f(*g(nums, target))\n",
        "idx_generation": 259,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(array: List[int], target_value=20) -> int:\n    \"\"\"Find the index of the first occurrence of the target value in the array.\"\"\"\n    for i in range(len(array)):\n        if array[i] == target_value:\n            return i\n    return -1\ndef g(target_value=20):\n    array = [10, 15, 20, 25, 30]\n    return array\nassert f(g()) == 2\n",
        "idx_generation": 392,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine if there exists a subset of the list that adds up to the target.\n    Return True if such a subset exists, otherwise return False.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, n: int) -> bool:\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        return subset_sum(nums, target, n-1) or subset_sum(nums, target-nums[n-1], n-1)\n    \n    return subset_sum(nums, target, len(nums))\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string s, determine if it is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\nassert f(g())",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value x, find if there exists a pair of numbers in the array whose sum is equal to x.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == x:\n            return True\n        elif arr[left] + arr[right] < x:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(x=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g(), x=10)\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(rectangles: List[List[List[int]]], target_area: int = 100) -> bool:\n    \"\"\"Given a list of rectangles in a 2D plane, find a combination of rectangles with a total area equal to or less\n    than the target_area.\n    Sample Input:\n    rectangles = [[[1, 1], [2, 3]], [[4, 2], [5, 5]], [[6, 4], [8, 6]]]\n    target_area = 50\n    Sample Output:\n    [[[1, 1], [2, 3]], [[4, 2], [5, 5]]]\"\"\"\n    total_area = 0\n    for rectangle in rectangles:\n        width = abs(rectangle[0][0] - rectangle[1][0])\n        height = abs(rectangle[0][1] - rectangle[1][1])\n        total_area += width * height\n    return total_area <= target_area\n\ndef g(rectangles: List[List[List[int]]], target_area: int = 100) -> List[List[List[int]]]:\n    \"\"\"Given a list of rectangles in a 2D plane, find a combination of rectangles with a total area equal to or less\n    than the target_area.\"\"\"\n    total_area = 0\n    result = []\n    for rectangle in rectangles:\n        width = abs(rectangle[0][0] - rectangle[1][0])\n        height = abs(rectangle[0][1] - rectangle[1][1])\n        total_area += width * height\n        if total_area <= target_area:\n            result.append(rectangle)\n        else:\n            break\n    return result\n\nrectangles = [[[1, 1], [2, 3]], [[4, 2], [5, 5]], [[6, 4], [8, 6]]]\ntarget_area = 50\nassert f(g(rectangles, target_area), target_area)\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, find if there is a subset of the list that adds up to the target number.\n    \"\"\"\n    n = len(arr)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find a subset of the list that adds up to the target number.\n    \"\"\"\n    n = len(arr)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    subset = []\n    i = n\n    j = target\n    while j > 0 and i > 0:\n        if dp[i - 1][j]:\n            i -= 1\n        else:\n            subset.append(arr[i - 1])\n            j -= arr[i - 1]\n            i -= 1\n    return subset[::-1]\n\narr = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(arr, target), target)\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g(s: str):\n    return s\n\nassert f(g('racecar'))\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there exists a pair of integers in the list whose sum is equal to the target number.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8]\ntarget = 10\nassert f(*g(nums, target))\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum product of any two numbers in the array.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray within a given list of integers.\"\"\"\n    def helper(nums, start, end):\n        if start == end:\n            return nums[start]\n        mid = (start + end) // 2\n        left_max = helper(nums, start, mid)\n        right_max = helper(nums, mid + 1, end)\n        cross_max = max_cross_sum(nums, start, mid, end)\n        return max(left_max, right_max, cross_max)\n    \n    def max_cross_sum(nums, start, mid, end):\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, start - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, end + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return helper(nums, 0, len(nums) - 1)\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if a string can be formed by rearranging the characters of another string.\"\"\"\n    if len(s) != len(target):\n        return False\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    for char in target:\n        count[ord(char) - ord('a')] -= 1\n        if count[ord(char) - ord('a')] < 0:\n            return False\n    return True\n\ndef g(s='listen', target='silent'):\n    return (s, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 392,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(lst: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is present in the sorted list using binary search.\"\"\"\n    (left, right) = (0, len(lst) - 1)\n    while left <= right:\n        mid = (left + right) // 2\n        if lst[mid] == target:\n            return True\n        elif lst[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 6) == True\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Determine if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    low = 1\n    high = n // 2\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\ndef g():\n    return 36\nassert f(g())\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers nums, determine if it is possible to split the list into two non-empty subarrays, such that the sum of the elements in the first subarray is equal to the sum of the elements in the second subarray.\"\"\"\n    n = len(nums)\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target_sum]\ndef g(nums=[1, 5, 11, 5]):\n    return (nums,)\nassert f(*g())\n",
        "idx_generation": 421,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"Check if a given string matches the given pattern. The pattern consists of lowercase letters and/or '.' which\n    matches any single character in the string.\n    Sample Input:\n    string = \"apple\"\n    pattern = \"a.ple\"\n    Sample Output:\n    True\"\"\"\n    if len(string) != len(pattern):\n        return False\n    \n    for i in range(len(string)):\n        if pattern[i] != '.' and pattern[i] != string[i]:\n            return False\n    \n    return True\n\ndef g():\n    return (\"apple\", \"a.ple\")\n\nassert f(*g())\n",
        "idx_generation": 392,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of elements in the given list such that their sum is divisible by 7.\"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] + arr[j]) % 7 == 0:\n                return True\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\nassert f(g())\n",
        "idx_generation": 262,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, return the count of numbers from 1 to n (inclusive)\nthat are divisible by 3 or 5.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 or i % 5 == 0:\n            count += 1\n    return count\ndef g(n=20):\n    return n\nassert f(g()) == 9\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of subsets that add up to the target value.\n    A subset is a collection of elements from the list, and the order of the elements does not matter.\n    \"\"\"\n    def backtrack(index, curr_sum):\n        if curr_sum == target:\n            return 1\n        if index == len(nums) or curr_sum > target:\n            return 0\n        \n        count = 0\n        count += backtrack(index + 1, curr_sum + nums[index])  # Include the current number\n        count += backtrack(index + 1, curr_sum)  # Exclude the current number\n        \n        return count\n    \n    return backtrack(0, 0)\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == 3\n",
        "idx_generation": 425,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string 's' is a valid palindrome, considering only alphanumeric characters and ignoring case.\n    \"\"\"\n    s = ''.join((c.lower() for c in s if c.isalnum()))\n    return s == s[::-1]\n\ndef g(s='A man, a plan, a canal, Panama!'):\n    return s\n\nassert f(g())\n",
        "idx_generation": 393,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport random\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is sorted in non-descending order.\"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True\n\ndef g():\n    arr = [random.randint(1, 100) for _ in range(10)]\n    arr.sort()\n    return arr\n\nassert f(g())\n",
        "idx_generation": 265,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, flip it vertically (reverse the order of rows in the matrix).\"\"\"\n    return matrix[::-1]\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 8, 9], [4, 5, 6], [1, 2, 3]]\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of elements from the list that add up to the target value.\n    You can use each element in the list multiple times.\n    \"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    \n    for i in range(1, target + 1):\n        for num in nums:\n            if num <= i:\n                dp[i] = min(dp[i], dp[i - num] + 1)\n    \n    return dp[target]\n\ndef g():\n    return ([1, 2, 5], 11)\n\nassert f(*g()) == 3\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(s: str) -> bool:\n    \"\"\"Given a string, return True if the string is a palindrome, False otherwise. Ignore non-alphanumeric characters and consider case insensitively.\"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\ndef g(s: str=\"A man, a plan, a canal: Panama\"):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum product of any two distinct numbers in the given list.\"\"\"\n    max_product = float('-inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    return [2, 4, 1, 5, 3]\n\nassert f(g()) == 20\n",
        "idx_generation": 265,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Given a string s and a target string, determine if s is a subsequence of target.\"\"\"\n    def is_subsequence(s: str, target: str) -> bool:\n        if len(s) == 0:\n            return True\n        if len(target) == 0:\n            return False\n        if s[0] == target[0]:\n            return is_subsequence(s[1:], target[1:])\n        else:\n            return is_subsequence(s, target[1:])\n    \n    return is_subsequence(s, target)\n\ndef g():\n    \"\"\"\n    Returns two strings, s and target: 'abc', 'ahbgdc'\n    \"\"\"\n    return 'abc', 'ahbgdc'\n\nassert f(*g()) is True\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Count the number of paths from the top-left cell to the bottom-right cell in a grid, moving only down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = 1\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] if grid[i][0] != 1 else 0\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] if grid[0][j] != 1 else 0\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] != 1:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[rows-1][cols-1]\ndef g():\n    grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    return (grid,)\nassert f(*g()) == 2\n",
        "idx_generation": 429,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"Given a string, return the first n characters in reverse order.\"\"\"\n    return s[:n][::-1]\ndef g():\n    s = \"Python is awesome\"\n    n = 6\n    return (s, n)\nassert f(*g()) == \"nohtyP\"\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum XOR value of any two elements in the array.\"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    arr = [3, 10, 5, 25, 2, 8]\n    return arr\n\nassert f(g()) == 28\n",
        "idx_generation": 267,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: str, y: str) -> bool:\n    \"\"\"Check if two binary strings are anagrams of each other.\"\"\"\n    return sorted(x) == sorted(y)\ndef g(x: str, y: str):\n    return x, y\nassert f(*g('10101', '11010'))\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\n    - n is a positive integer\"\"\"\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    return fibonacci(n)\ndef g():\n    return 6\nassert f(g()) == 8\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"Given a list of words, return a new list containing only the words that start with a specific prefix.\"\"\"\n    return [word for word in words if word.startswith(prefix)]\ndef g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n    prefix = \"b\"\n    return (words, prefix)\nassert f(*g()) == [\"banana\"]\n",
        "idx_generation": 400,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum of a given array\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"Generate an array with both positive and negative integers\"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"Given a sorted list of integers and a target integer k, find the number of unique pairs (a, b) in the list\nsuch that a + b = k. The pairs should be counted only once, even if they appear multiple times in the list.\nSample input:\n[1, 2, 3, 4, 5, 6], 7\nSample output:\n3\"\"\"\n    count = 0\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == k:\n            count += 1\n            left += 1\n            right -= 1\n        elif arr[left] + arr[right] < k:\n            left += 1\n        else:\n            right -= 1\n    return count\ndef g():\n    return ([1, 2, 3, 4, 5, 6], 7)\nassert f(*g()) == 3\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target', check if there exists a subset of 'nums' that sums up to 'target'.\nReturn True if such a subset exists, False otherwise.\"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    return dp[n][target]\ndef g(nums: List[int], target: int):\n    return (nums, target)\nnums = [2, 4, 6, 8]\ntarget = 10\nassert f(*g(nums, target))\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Check if the given string is a palindrome, considering only alphanumeric characters and ignoring case.\"\"\"\n    s = ''.join(ch.lower() for ch in string if ch.isalnum())\n    return s == s[::-1]\ndef g():\n    \"\"\"\n    Returns a sample string.\n    \"\"\"\n    return \"A man, a plan, a canal, Panama!\"\nassert f(g())\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\n    If the target is not found, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == 4\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'arr', find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Return the list of integers.\n    \"\"\"\n    return arr\n\nassert f(g([1, -2, 3, -1, 2, 0, -5, 4])) == 4\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(boxes: List[int], target_sum: int) -> bool:\n    \"\"\"\n    Given a list of boxes with different weights, check if it is possible to select a subset of boxes whose sum of weights is equal to the target sum.\n    \"\"\"\n    def subset_sum(boxes, target_sum, index):\n        if target_sum == 0:\n            return True\n        if index < 0 or target_sum < 0:\n            return False\n        return subset_sum(boxes, target_sum - boxes[index], index - 1) or subset_sum(boxes, target_sum, index - 1)\n    \n    return subset_sum(boxes, target_sum, len(boxes) - 1)\n\ndef g(boxes: List[int], target_sum: int) -> None:\n    \"\"\"\n    Generate a list of boxes with different weights and the target sum.\n    \"\"\"\n    return (boxes, target_sum)\n\nboxes = [1, 2, 3, 4, 5]\ntarget_sum = 9\nassert f(*g(boxes, target_sum))\n",
        "idx_generation": 438,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix of integers, flip it horizontally (reverse each row in the matrix).\"\"\"\n    return [row[::-1] for row in matrix]\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[3, 2, 1], [6, 5, 4], [9, 8, 7]]\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there is a pair of numbers that sum up to the target. \n    The solution should have a time complexity of O(n) or better.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return their indices in a list.\n\n    Example:\n    Input: [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the length of the longest increasing subsequence in the list.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g(nums: List[int]) -> None:\n    \"\"\"\n    Generate a list of numbers.\n    \"\"\"\n    return (nums,)\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nassert f(*g(nums)) == 4\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\n    \ndef g(s: str):\n    return s\nassert f(g(\"A man, a plan, a canal: Panama\"))\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search. If the target is not found, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 7\n    return (nums, target)\nassert f(*g()) == 3\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, ans: List[int]) -> bool:\n    \"\"\"Check if the given list of integers contains exactly 'n' even numbers.\"\"\"\n    count = 0\n    for num in ans:\n        if num % 2 == 0:\n            count += 1\n    return count == n\n\ndef g(n: int) -> List[int]:\n    \"\"\"Returns a list of consecutive even numbers starting from 2.\"\"\"\n    return [2 * i for i in range(1, n + 1)]\n\nassert f(4, g(4))\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a list of integers 'arr', find the length of the longest increasing subsequence (LIS) in the list.\nAn increasing subsequence is a sequence of numbers in the list where each number is greater than the previous number.\"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\nassert f(g()) == 4\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is palindrome when considering only alphanumeric characters and ignoring cases.\"\"\"\n    def is_alphanumeric(char):\n        return char.isalpha() or char.isdigit()\n    \n    s = ''.join(char.lower() for char in s if is_alphanumeric(char))\n    return s == s[::-1]\n\ndef g(s='A man, a plan, a canal: Panama!'):\n    return s\n\nassert f(g())\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    return nums\n\nassert f(g(), 10) == 4\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of size n x m, determine if there exists a saddle point in the matrix.\n    A saddle point is an element that is the minimum value in its row and the maximum value in its column.\"\"\"\n    rows_min = []\n    for row in matrix:\n        rows_min.append(min(row))\n    cols_max = []\n    for j in range(m):\n        col = [matrix[i][j] for i in range(n)]\n        cols_max.append(max(col))\n    saddle_points = [matrix[i][j] for i in range(n) for j in range(m) if matrix[i][j] == rows_min[i] and matrix[i][j] == cols_max[j]]\n    return len(saddle_points) > 0\ndef g():\n    n = 3\n    m = 4\n    matrix = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n    return n, m, matrix\nassert f(*g())\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Reverse the order of elements in a list using recursion.\"\"\"\n    if len(nums) <= 1:\n        return nums\n    return f(nums[1:]) + [nums[0]]\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome when only alphanumeric characters are considered.\n\n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n    Explanation: The input string, when considering only alphanumeric characters, is \"AmanaplanacanalPanama\" which is a palindrome.\n    \"\"\"\n    clean_s = ''.join(c.lower() for c in s if c.isalnum())\n    return clean_s == clean_s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers in ascending order.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([2, 7, 11, 15], 9)) == [0, 1]\n",
        "idx_generation": 279,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers arr contains a subarray with a sum equal to zero.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers containing a subarray with a sum equal to zero.\n    \"\"\"\n    import random\n    arr = random.choices(range(-10, 11), k=10)\n    while not f(arr):\n        arr = random.choices(range(-10, 11), k=10)\n    return (arr,)\n\nassert f(*g())\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers `arr` and a target integer `target`, return True if there exists a subset of `arr`\nthat sums up to the target and contains at least two elements. Otherwise, return False.\"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n    return dp[n][target] and sum(arr) - target > 0\n\ndef g(arr=[3, 1, 5, 9, 12], target=8):\n    return (arr, target)\n\nassert f(*g())\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(target: int, ans: List[List[str]]) -> bool:\n    \"\"\"Find a list of strings where the number of strings that contain the letter 'a' is equal to the given target.\"\"\"\n    count = 0\n    for i in range(len(ans)):\n        if 'a' in ans[i]:\n            count += 1\n    return count == target\n\ndef g(target: int) -> List[List[str]]:\n    \"\"\"Returns a list of strings, where each string contains the letter 'a'.\"\"\"\n    return [['a']] * target\n\nassert f(5, g(5))\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [3, 1, 7, 9, 2]\n    target = 10\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are three integers in the list that sum up to the target value.\n    \"\"\"\n    n = len(nums)\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if nums[i] + nums[j] + nums[k] == target:\n                    return True\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 12\n    return (nums, target)\n\nassert f(g()[0], g()[1])\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Count the number of subsets in the given list whose sum is equal to the target value.\n    - nums: A list of integers\n    - target: The target sum\n    \n    Returns the count of subsets.\n    \"\"\"\n    n = len(nums)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Return the list of numbers and the target sum.\"\"\"\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5], 5)) == 3\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string 's' and an integer 'k', determine if there exists a substring of length 'k' in 's' that contains all unique characters.\"\"\"\n    if k > len(s):\n        return False\n    for i in range(len(s) - k + 1):\n        substring = s[i:i + k]\n        if len(set(substring)) == k:\n            return True\n    return False\n\ndef g() -> Tuple[str, int]:\n    \"\"\"Generate a string and an integer.\"\"\"\n    return \"abcbde\", 3\n\nassert f(*g()) == True\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the number of elements that are less than or equal to the target.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] <= target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\ndef g():\n    return ([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 10)\nassert f(*g()) == 5\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in a list that sum up to the target value.\nArgs:\n- nums: A list of integers\n- target: The target sum\nReturns:\n- True if there exists a pair of numbers that sum up to the target value, False otherwise\"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False\ndef g(nums=[2, 4, 6, 8, 10], target=12):\n    return nums, target\nassert f(g()[0], g()[1])\n",
        "idx_generation": 429,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, find the longest increasing subsequence.\"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    longest_subsequence = []\n    for i in range(n - 1, -1, -1):\n        if dp[i] == max_length:\n            longest_subsequence.append(arr[i])\n            max_length -= 1\n    return longest_subsequence[::-1]\n\ndef g():\n    arr = [3, 4, -1, 0, 6, 2, 3]\n    return (arr,)\n\nassert f(*g()) == [-1, 0, 2, 3]\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Given two strings s1 and s2, determine if s2 is a rotation of s1.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    s1s1 = s1 + s1\n    if s2 in s1s1:\n        return True\n    return False\n\ndef g() -> Tuple[str, str]:\n    \"\"\"Generate two strings.\"\"\"\n    return \"rotation\", \"ionrotat\"\n\nassert f(*g()) == True\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to find the index of the target number.\n    Return the index if the target number is found, otherwise return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [-5, -2, 0, 3, 6, 9, 12, 15, 18, 21]\n\nassert f(g(), 9) == 5\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in a given list of integers.\nArgs:\n- nums: A list of integers\nReturns:\n- The maximum subarray sum\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\nassert f(g()) == 6\n",
        "idx_generation": 429,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"Given an integer n, calculate the nth Fibonacci number.\nReturns the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\ndef g():\n    return 7\nassert f(g()) == 13\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome ignoring spaces and case sensitivity.\n    \"\"\"\n    s = s.lower().replace(\" \", \"\")\n    return s == s[::-1]\n\ndef g():\n    return \"A man a plan a canal Panama\"\n\nassert f(g())\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a pair of numbers whose sum is equal to the target value.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    nums.sort()  # Sort the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(target=10):\n    return [2, 4, 6, 8, 10, 12]\n\nassert f(g())\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the missing number in the given list of consecutive integers.\"\"\"\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return total_sum - actual_sum\ndef g(nums=[1, 2, 3, 4, 6, 7, 8, 9, 10]):\n    return nums\nassert f(g()) == 5\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of integers, find the maximum sum of elements that can be obtained by starting at the top-left corner and moving to the bottom-right corner, only moving down or right.\n    Additionally, each element can be multiplied by a power of 2, but can only be multiplied once.\n    Return the maximum sum.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = max(dp[i-1][0] + grid[i][0], grid[i][0])\n    for j in range(1, cols):\n        dp[0][j] = max(dp[0][j-1] + grid[0][j], grid[0][j])\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\ndef g(grid: List[List[int]]):\n    return grid\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(grid)) == 29\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Given a string 's' and an integer 'k', return True if there exists a substring of length 'k' in 's'\n    that contains exactly 'k' unique characters. Otherwise, return False.\"\"\"\n    if len(s) < k:\n        return False\n    for i in range(len(s) - k + 1):\n        substring = s[i:i + k]\n        if len(set(substring)) == k:\n            return True\n    return False\n\ndef g() -> Tuple[str, int]:\n    \"\"\"Generate a string and an integer that have a valid solution.\n    Return the generated string and the integer as a tuple.\n    \"\"\"\n    s = \"aabbcdefg\"\n    k = 3\n    return (s, k)\n\nassert f(*g()) == True\n",
        "idx_generation": 430,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"Given an array nums of distinct integers and a target integer, return a list of all unique triplets [nums[i], nums[j], nums[k]] such that i != j != k and nums[i] + nums[j] + nums[k] == target.\n    You may return the triplets in any order.\"\"\"\n    n = len(nums)\n    nums.sort()\n    result = []\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left, right = i + 1, n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum < target:\n                left += 1\n            elif curr_sum > target:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result\ndef g():\n    return ([-1, 0, 1, 2, -1, -4], 0)\nassert f(*g()) == [[-1, -1, 2], [-1, 0, 1]]\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given an array of integers arr and a target integer, determine if there exist two distinct indices i and j in the array, such that arr[i] + arr[j] = target.\"\"\"\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g())\n",
        "idx_generation": 433,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given an array of integers, find the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g() -> List[int]:\n    \"\"\"\n    Generate a random array of integers.\n    \"\"\"\n    import random\n    n = random.randint(5, 10)\n    nums = [random.randint(0, 10) for _ in range(n)]\n    return nums\nassert f(g()) > 0\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"Find all words in the given list that start with the given prefix.\"\"\"\n    return [word for word in words if word.startswith(prefix)]\n\ndef g(words=[\"apple\", \"banana\", \"apricot\", \"orange\", \"avocado\"], prefix=\"ap\"):\n    return words, prefix\n\nassert f(*g()) == [\"apple\", \"apricot\"]\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Given a sorted array of integers, find if there exists two numbers in the array such that their sum equals to the target.\n    Return True if such pair exists, otherwise return False.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(target=10):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g())\n",
        "idx_generation": 289,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the sum of all the multiples of 3 or 5 below n.\"\"\"\n    return sum(i for i in range(n) if i % 3 == 0 or i % 5 == 0)\ndef g(n: int):\n    return n\nassert f(g(10)) == 23\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of a path in the given grid, starting from the top-left corner and ending at the bottom-right corner.\n    The allowed movements are right and down.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [[1, 3, 2], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Remove all occurrences of the words in the list from the given string, \n    and return the remaining words in a list.\n    \"\"\"\n    for word in words:\n        s = s.replace(word, '')\n    return s.split()\n\ndef g():\n    return ('The quick brown fox jumps over the lazy dog', ['quick', 'jumps', 'over'])\n\nassert f(g()[0], g()[1]) == ['The', 'brown', 'fox', 'the', 'lazy', 'dog']\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, remove any duplicate strings and sort them in alphabetical order.\n\n    Args:\n    - strings: A list of strings.\n\n    Returns:\n    - A list of strings with duplicates removed and sorted in alphabetical order.\n\n    Example:\n    f(['apple', 'banana', 'cherry', 'banana', 'date', 'apple']) -> \n    ['apple', 'banana', 'cherry', 'date']\n    \"\"\"\n    return sorted(list(set(strings)))\n\ndef g() -> List[str]:\n    return ['apple', 'banana', 'cherry', 'banana', 'date', 'apple']\n\nassert f(g()) == ['apple', 'banana', 'cherry', 'date']\n",
        "idx_generation": 290,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"Find if a target number exists in the grid by adding up the numbers in the rows and columns\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    return target in row_sums or target in col_sums\n\ndef g(grid: List[List[int]], target: int) -> Tuple[List[List[int]], int]:\n    return grid, target\n\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\ntarget = 15\nassert f(*g(grid, target))\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the shortest path from the top-left corner to the bottom-right corner of the grid.\n    Each cell in the grid represents the cost to move to that cell. The path can only move right or down.\n    Sample Input:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Sample Output:\n    7\"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(grid: List[List[int]]):\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return grid\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid)) == 7\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given sorted list that sum up to the target value.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert f(g(), 12)\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a matrix of integers and a target value, return True if the target value is present in the matrix, otherwise False.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    i = 0\n    j = n - 1\n    while i < m and j >= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n            \ndef g():\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]\n    target = 16\n    return (matrix, target)\n\nassert f(*g())\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, calculate the sum of the first n natural numbers using a recursive function.\"\"\"\n    if n == 0:\n        return 0\n    return n + f(n - 1)\n\n\ndef g():\n    \"\"\"\n    Returns the input for the function f.\n    \"\"\"\n    return 5\n\n\nassert f(g()) == 15\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the list that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Return a list of integers and a target value.\"\"\"\n    return [2, 4, 1, 7, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n\n    if n == 0 or n == 1:\n        return True\n\n    left = 0\n    right = n\n\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> int:\n    \"\"\"\n    Find the smallest perfect square greater than 100.\n    \"\"\"\n    n = 11\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g())\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"Given a positive integer n, find the number of distinct ways to climb to the top of a staircase\n    with n steps. You can climb either 1 or 2 steps at a time.\"\"\"\n    memo = {}\n    \n    def dfs(steps):\n        if steps == n:\n            return 1\n        if steps > n:\n            return 0\n        if steps in memo:\n            return memo[steps]\n        memo[steps] = dfs(steps + 1) + dfs(steps + 2)\n        return memo[steps]\n    \n    return dfs(0)\n\ndef g(n: int):\n    return n\n\nassert f(g(4)) == 5\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='ytpmurtseD') -> bool:\n    \"\"\"Check if the reverse of a string is equal to the target string\"\"\"\n    return s[::-1] == target\ndef g(target='ytpmurtseD'):\n    return target[::-1]\nassert f(g())\n",
        "idx_generation": 436,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target number.\nSample Input:\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nSample Output:\nTrue\nExplanation: The pair (2, 5) sums up to 7, hence the output is True.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in the given string while preserving the order of the words.\"\"\"\n    words = s.split()\n    reversed_words = deque()\n    for word in words:\n        reversed_words.appendleft(word)\n    return ' '.join(reversed_words)\ndef g(s='Hello World'):\n    return s\nassert f(g()) == 'World Hello'\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Given an array of integers, find the maximum sum of any contiguous subarray.\nReturn the maximum sum.\"\"\"\n    def max_subarray_sum(arr):\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n    return max_subarray_sum(arr)\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g()) == 6\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Reverse the order of words in a given string.\n    Each word should remain unchanged, but the order should be reversed.\n    \"\"\"\n    words = string.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)\n\ndef g():\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the indices of two numbers such that they add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    return ([2, 7, 11, 15], 9)\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 295,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'arr' and a target integer 'target', find two distinct numbers in 'arr' that sum up to 'target'.\n    Return a list containing the indices of these two numbers in 'arr'.\"\"\"\n    \n    num_set = set()\n    \n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_set:\n            return [arr.index(complement), i]\n        num_set.add(num)\n    \n    return []\n    \ndef g(arr=[2, 7, 11, 15], target=9):\n    return (arr, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 444,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    def fibonacci(n, memo):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 455,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Given a string s, return the length of the longest substring without repeating characters.\"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    for end in range(len(s)):\n        if s[end] in seen and start <= seen[s[end]]:\n            start = seen[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n        seen[s[end]] = end\n    return max_length\ndef g(s=\"abcabcbb\"):\n    return s\nassert f(g()) == 3\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, rearrange the array such that all zeros are moved to the end, while the non-zero elements remain in the same order. \n    You must do this in-place without making a copy of the array and minimizing the total number of operations.\n    \"\"\"\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[i], nums[non_zero_index] = nums[non_zero_index], nums[i]\n            non_zero_index += 1\n    return nums\ndef g():\n    return ([0, 1, 0, 3, 12],)\nassert f(*g()) == [1, 3, 12, 0, 0]\n",
        "idx_generation": 295,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n    def isPerfectSquare(num):\n        if num == 0 or num == 1:\n            return True\n        left, right = 1, num\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n    \n    return isPerfectSquare(n)\n\ndef g(n: int):\n    return n\n\nassert f(g(16))\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Given a grid of size n x m, find the minimum number of steps required to reach the bottom-right cell (n-1, m-1) from the top-left cell (0, 0).\n    You can only move down or right. Each cell in the grid represents the cost to reach that cell.\n    Args:\n        n: The number of rows in the grid.\n        m: The number of columns in the grid.\n        grid: The grid of size n x m.\n    Returns:\n        The minimum number of steps required to reach the bottom-right cell.\n    \"\"\"\n    dp = [[float('inf')] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[n-1][m-1]\n\ndef g():\n    \"\"\"\n    Returns the input for the function f.\n    \"\"\"\n    n = 3\n    m = 3\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 7\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\n    - s is a string of lowercase letters\"\"\"\n    def is_palindrome(s):\n        if len(s) <= 1:\n            return True\n        elif s[0] != s[-1]:\n            return False\n        else:\n            return is_palindrome(s[1:-1])\n    return is_palindrome(s)\ndef g():\n    return \"racecar\"\nassert f(g()) == True\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of three numbers in a list.\"\"\"\n    nums.sort(reverse=True)\n    return nums[0] * nums[1] * nums[2]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n",
        "idx_generation": 296,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, x: int) -> bool:\n    \"\"\"Given an integer n, determine if it is a power of x.\"\"\"\n    if n < 1 or x < 2:\n        return False\n    while n % x == 0:\n        n /= x\n    return n == 1\ndef g(n: int=16, x: int=2):\n    return (n, x)\nassert f(*g()) == True\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in a string.\n    - s is a string containing words separated by spaces\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\ndef g():\n    return \"Hello World\"\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in the sorted list using binary search iteratively.\"\"\"\n    start = 0\n    end = len(nums) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1\ndef g():\n    return [3, 6, 9, 12, 15, 18, 21, 24]\nassert f(g(), 15) == 4\n",
        "idx_generation": 297,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a matrix of integers 'matrix', return a list containing the elements of the matrix in spiral order.\nSpiral order starts at the top-left corner of the matrix and moves in a clockwise direction.\nExample:\nInput:\n[[1, 2, 3],\n [4, 5, 6],\n [7, 8, 9]]\nOutput:\n[1, 2, 3, 6, 9, 8, 7, 4, 5]\nNote: The input matrix will always be a non-empty 2D matrix.\n\"\"\"\n    result = []\n    if not matrix:\n        return result\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    return result\ndef g() -> List[List[int]]:\n    \"\"\"Generate a matrix of integers that has a valid solution.\n    Return the generated matrix.\n    \"\"\"\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a matrix of integers, return True if there exists a path from the top-left corner to the bottom-right corner such that the sum of the numbers along the path is the largest among all possible paths. You can only move down or right.\n    Sample input:\n    [[1,3,1],[1,5,1],[4,2,1]]\n    Sample output:\n    True\n    (Sample output hidden because showing sample output would give away too much information.)\"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    return dp[m - 1][n - 1] == max(dp[m - 1][n - 1], dp[m - 2][n - 1], dp[m - 1][n - 2])\n\ndef g():\n    return [[1,3,1],[1,5,1],[4,2,1]]\nassert f(g())\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels (a, e, i, o, u) in the given string.\"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count\ndef g():\n    return \"Python programming is fun!\"\nassert f(g()) == 6\n",
        "idx_generation": 442,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that sum up to the target.\nYou must solve this problem using a binary search approach.\"\"\"\n    def binary_search(arr, target, low, high):\n        if low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                return binary_search(arr, target, mid + 1, high)\n            else:\n                return binary_search(arr, target, low, mid - 1)\n        return False\n\n    for i in range(len(arr) - 1):\n        complement = target - arr[i]\n        if binary_search(arr, complement, i + 1, len(arr) - 1):\n            return True\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9], 12)\n\nassert f(*g())\n",
        "idx_generation": 299,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers nums and a target integer, find the number of subarrays whose sum is equal to the target.\"\"\"\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = {0: 1}\n    for num in nums:\n        prefix_sum += num\n        count += prefix_sum_count.get(prefix_sum - target, 0)\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n    return count\n\ndef g(nums=[1, 2, 3, 4], target=5):\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Given a directed graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end in the graph.\n\"\"\"\n\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g(graph: List[List[int]], start: int, end: int):\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, and two nodes start and end.\n    \"\"\"\n\n    return (graph, start, end)\n\ngraph = [[1, 2], [2], [3], []]\nstart = 0\nend = 3\n\nassert f(*g(graph, start, end))\n",
        "idx_generation": 459,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"Given a string, find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n    Sample Input:\n    s = \"abcabcbb\"\n    Sample Output:\n    3\"\"\"\n    seen = set()\n    left = 0\n    right = 0\n    max_length = 0\n    while right < len(s):\n        if s[right] not in seen:\n            seen.add(s[right])\n            right += 1\n            max_length = max(max_length, right - left)\n        else:\n            seen.remove(s[left])\n            left += 1\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' and a target integer 'target',\n    find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [2, 4, 6, 8, 10, 12]\n    target = 8\n    return (nums, target)\n\nassert f(*g()) == 3\n",
        "idx_generation": 299,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"Given a string s and an integer k, return the lexicographically smallest substring of length k that can be formed from the characters of s.\"\"\"\n    substrings = [s[i:i+k] for i in range(len(s)-k+1)]\n    return min(substrings)\ndef g():\n    s = \"programming\"\n    k = 3\n    return (s, k)\nassert f(*g()) == \"amm\"\n",
        "idx_generation": 459,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Given a grid containing non-negative numbers, find the minimum path sum from the top-left to the bottom-right corner by only moving right or down.\"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\ndef g(grid: List[List[int]]):\n    return grid\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid)) == 7\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(s: str) -> bool:\n    \"\"\"Given a string, check if it is a palindrome after removing all non-alphanumeric characters and ignoring case sensitivity.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    Return True if the string is a palindrome, and False otherwise.\"\"\"\n    clean_s = ''.join(char.lower() for char in s if char.isalnum())\n    return clean_s == clean_s[::-1]\ndef g(s: str) -> str:\n    return s\ns = \"A man, a plan, a canal: Panama\"\nassert f(g(s)) == True\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the target value is present in the sorted array using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g(arr: List[int], target: int):\n    \"\"\"Sort the array and return it along with the target value.\"\"\"\n    arr.sort()\n    return arr, target\n\nassert f(*g([5, 2, 1, 8, 4], 8))\n",
        "idx_generation": 299,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list of integers.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 463,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum subarray sum.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g()) == 6\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalnum())\n    return s == s[::-1]\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 452,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Given a list of integers and a target k, determine if there exists a subarray with a sum equal to k.\"\"\"\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n    for i in range(len(prefix_sum)):\n        for j in range(i + 1, len(prefix_sum)):\n            if prefix_sum[j] - prefix_sum[i] == k:\n                return True\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6], 11)\n\nassert f(*g())\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return 'racecar'\n\nassert f(g())\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target_sum=10) -> bool:\n    \"\"\"Find if there exists a subset of the given list such that the sum of all elements in the subset is equal to the target sum.\"\"\"\n    def helper(nums, index, curr_sum):\n        if curr_sum == target_sum:\n            return True\n        if index == len(nums):\n            return False\n        return helper(nums, index + 1, curr_sum + nums[index]) or helper(nums, index + 1, curr_sum)\n    return helper(nums, 0, 0)\ndef g(nums: List[int], target_sum=10):\n    return nums\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums), target_sum=10)\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"Given a string, check if it is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization. Return True if the string is a palindrome, and False otherwise.\"\"\"\n    def is_palindrome(s):\n        s = ''.join(filter(str.isalnum, s.lower()))\n        return s == s[::-1]\n    return is_palindrome(string)\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\nassert f(g()) == True\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exists a pair of numbers in the list that add up to the target value.\n    Return True if such pair exists, and False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\nassert f(*g())\n",
        "idx_generation": 305,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to a power of 2.\"\"\"\n    powers_of_two = set(2**i for i in range(32))\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] in powers_of_two:\n                return True\n    return False\ndef g(arr: List[int]):\n    return arr\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target_sum=20) -> bool:\n    \"\"\"Find if there exists a subset of the given list such that the sum of all elements in the subset is less than or equal to the target sum.\"\"\"\n    def helper(nums, index, curr_sum):\n        if curr_sum <= target_sum:\n            return True\n        if index == len(nums):\n            return False\n        return helper(nums, index + 1, curr_sum + nums[index]) or helper(nums, index + 1, curr_sum)\n    return helper(nums, 0, 0)\ndef g(nums: List[int], target_sum=20):\n    return nums\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums), target_sum=20)\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if the given string s can be rearranged to form k distinct strings with equal length and same number of vowels.\"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    s_vowels = sum(1 for c in s if c in vowels)\n    if s_vowels % k != 0:\n        return False\n    substring_vowels = s_vowels // k\n    substring_length = len(s) // k\n    for i in range(0, len(s), substring_length):\n        substring = s[i:i + substring_length]\n        if sum(1 for c in substring if c in vowels) != substring_vowels:\n            return False\n    return True\n\ndef g():\n    return ('aeiouaeiouaeiou', 3)\n\nassert f(*g())\n",
        "idx_generation": 458,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Find the index of the target value in the given sorted list using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return arr, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if there exists a subarray in the given array where the sum of the elements is equal to the length of the subarray multiplied by the maximum element in the subarray.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        subarray_sum = 0\n        subarray_max = float('-inf')\n        for j in range(i, n):\n            subarray_sum += arr[j]\n            subarray_max = max(subarray_max, arr[j])\n            if subarray_sum == (j - i + 1) * subarray_max:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Compute the nth Fibonacci number.\"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\ndef g() -> int:\n    return 6\nassert f(g()) == 8\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome when considering alphanumeric characters only and ignoring case.\"\"\"\n    clean_s = ''.join(char.lower() for char in s if char.isalnum())\n    return clean_s == clean_s[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g())\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"Given a matrix, return the matrix rotated 90 degrees clockwise\"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-i-1] = matrix[i][j]\n            \n    return rotated\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\n\nassert f(*g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"Given a matrix of integers, find the sum of all elements in the matrix that are divisible by 3.\"\"\"\n    total = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0:\n                total += num\n    return total\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the matrix of integers.\n    \"\"\"\n    return matrix\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) == 18\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Given a list of words and a target string, determine if it is possible to form the target string by concatenating the words in the list in any order. Each word can be used multiple times.\"\"\"\n    memo = {}\n\n    def canForm(target):\n        if target == \"\":\n            return True\n\n        if target in memo:\n            return memo[target]\n\n        for word in words:\n            if target.startswith(word):\n                remaining = target[len(word):]\n                if canForm(remaining):\n                    memo[target] = True\n                    return True\n\n        memo[target] = False\n        return False\n\n    return canForm(target)\n\ndef g(words: List[str], target: str):\n    return (words, target)\n\nassert f(*g([\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"], \"pineapple\"))\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"Given two strings s and t, determine if they are isomorphic.\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n    All occurrences of a character must be replaced with another character while preserving the order of characters.\n    No two characters may map to the same character but a character may map to itself.\nArgs:\n    s: The first string.\n    t: The second string.\nReturns:\n    True if s and t are isomorphic, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n    mapping = {}\n    used_chars = set()\n    for i in range(len(s)):\n        if s[i] not in mapping:\n            if t[i] in used_chars:\n                return False\n            mapping[s[i]] = t[i]\n            used_chars.add(t[i])\n        elif mapping[s[i]] != t[i]:\n            return False\n    return True\n\ndef g():\n    \"\"\"\n    Returns two strings s and t for testing.\n    \"\"\"\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if a given list is sorted in non-decreasing order.\"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            return False\n    return True\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"Sort a given list of integers in non-decreasing order.\"\"\"\n    return sorted(nums)\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of numbers, determine if there exists a pair of numbers in the list whose sum is equal to the target value.\nArgs:\n    nums: The list of numbers.\n    target: The target value to be achieved by summing up a pair of numbers in the list.\nReturns:\n    True if there exists a pair of numbers in the list whose sum is equal to the target value, False otherwise.\"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\ndef g():\n    \"\"\"\n    Returns a sample list of numbers.\n    \"\"\"\n    return [2, 4, 7, 11, 15]\nassert f(g(), 9)\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum sum of a subarray in the given list.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\ndef g():\n    arr = [1, -2, 3, 4, -5, 6, -7]\n    return arr\nassert f(g()) == 8\n",
        "idx_generation": 484,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"Rotate each character in a string by n positions to the right.\"\"\"\n    result = \"\"\n\n    for char in s:\n        if char.isalpha():\n            ascii_shift = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_shift + n) % 26 + ascii_shift)\n        else:\n            result += char\n\n    return result\n\ndef g() -> Tuple[str, int]:\n    return (\"Hello, World!\", 3)\n\nassert f(*g()) == \"Khoor, Zruog!\"\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return ([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 13)\n\nassert f(*g()) == 6\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given grid is a valid Sudoku solution.\"\"\"\n    def is_valid_row(grid, row):\n        return len(set(grid[row])) == 9\n\n    def is_valid_column(grid, col):\n        column = [grid[row][col] for row in range(9)]\n        return len(set(column)) == 9\n\n    def is_valid_subgrid(grid, start_row, start_col):\n        subgrid = []\n        for row in range(start_row, start_row + 3):\n            for col in range(start_col, start_col + 3):\n                subgrid.append(grid[row][col])\n        return len(set(subgrid)) == 9\n\n    for i in range(9):\n        if not is_valid_row(grid, i) or not is_valid_column(grid, i):\n            return False\n\n    for row in range(0, 9, 3):\n        for col in range(0, 9, 3):\n            if not is_valid_subgrid(grid, row, col):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a valid Sudoku solution grid.\"\"\"\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g())\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there exists a path in the grid from the top-left corner to the bottom-right corner, only moving right or down. The grid contains 0s and 1s, where 0 represents an obstacle and 1 represents a clear path.\"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] and grid[i][0] == 1\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] and grid[0][j] == 1\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] or dp[i][j-1]) and grid[i][j] == 1\n    return dp[-1][-1]\ndef g():\n    return [[1, 0, 0], [1, 1, 0], [0, 1, 1]]\nassert f(g())\n",
        "idx_generation": 485,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome after removing all non-alphanumeric characters and ignoring cases.\n    Return True if it is a palindrome, otherwise return False.\n    \"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g(s: str = 'A man, a plan, a canal: Panama'):\n    \"\"\"\n    Generate a string with special characters, spaces, and alphanumeric characters.\n    \"\"\"\n    return s\n\n# Test the puzzle\nassert f(g()) == True\nassert f(g('Hello World!')) == False\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the maximum subarray sum.\n    A subarray is a contiguous portion of the array.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    \n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a symmetric matrix\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g(n: int):\n    \"\"\"Generate a symmetric matrix of size n x n\"\"\"\n    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            matrix[j][i] = matrix[i][j]\n    return matrix\n\nassert f(g(3))\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a subset of numbers that add up to the target using recursion.\nArgs:\n    nums: A list of integers.\n    target: The target value.\nReturns:\n    True if there exists a subset of numbers that add up to the target, False otherwise.\"\"\"\n    def helper(nums, target, curr_sum, idx):\n        if curr_sum == target:\n            return True\n        if curr_sum > target or idx >= len(nums):\n            return False\n        return helper(nums, target, curr_sum + nums[idx], idx + 1) or helper(nums, target, curr_sum, idx + 1)\n    \n    return helper(nums, target, 0, 0)\n    \ndef g():\n    \"\"\"\n    Returns a sample list of integers and a target value.\n    \"\"\"\n    return ([2, 3, 7, 8, 10], 11)\nassert f(*g()) == True\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the order of words in a given string.\"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)\ndef g() -> str:\n    return \"Python is fun\"\nassert f(g()) == \"fun is Python\"\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element in the list using binary search.\n    Args:\n        nums: The sorted list of integers.\n        target: The target element to search for.\n    Returns:\n        The index of the target element if found, -1 otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    \"\"\"\n    Returns a sorted list of integers and the target element.\n    \"\"\"\n    return ([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 11)\n\nassert f(*g()) == 5\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers, find the number of subarrays whose sum is equal to the target.\n    A subarray is a contiguous part of the array.\"\"\"\n    prefix_sum = 0\n    count = 0\n    prefix_sums = {0: 1}\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sums:\n            count += prefix_sums[prefix_sum - target]\n        prefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n    \n    return count\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g()) == 2\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using dynamic programming\"\"\"\n    dp = [0] * (n+1)\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n    \ndef g():\n    \"\"\"\n    Returns the value of n\n    \"\"\"\n    return 6\nassert f(g()) == 8\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g())\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a 2D list, find the maximum area of a rectangle composed of 1's in the grid.\n    Args:\n        grid: The grid represented as a 2D list where 0 represents an empty space and 1 represents a filled space.\n    Returns:\n        The maximum area of a rectangle composed of 1's in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    heights = [0] * cols\n    max_area = 0\n    for row in grid:\n        for i in range(cols):\n            if row[i] == 0:\n                heights[i] = 0\n            else:\n                heights[i] += 1\n        max_area = max(max_area, largest_rectangle_area(heights))\n    return max_area\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    \"\"\"\n    Helper function to find the largest area of a rectangle given the heights of the bars.\n    Args:\n        heights: The heights of the bars represented as a list of integers.\n    Returns:\n        The largest area of a rectangle.\n    \"\"\"\n    stack = []\n    max_area = 0\n    i = 0\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i - stack[-1] - 1 if stack else i)\n        max_area = max(max_area, area)\n    return max_area\n\ndef g():\n    \"\"\"\n    Returns a sample grid represented as a 2D list.\n    \"\"\"\n    return [[0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 1, 1, 0], [0, 1, 1, 1, 1]]\n\nassert f(g()) == 6\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> float:\n    \"\"\"\n    Given a list of integers, find the average of all the odd numbers in the list.\n    Return the average as a float rounded to two decimal places.\n    \"\"\"\n    odd_nums = [num for num in nums if num % 2 != 0]\n    if len(odd_nums) == 0:\n        return 0.00\n    else:\n        return round(sum(odd_nums) / len(odd_nums), 2)\n\ndef g():\n    return [2, 5, 8, 3, 9, 6, 4]\n\nassert f(g()) == 5.67\n",
        "idx_generation": 489,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"Check if there is a path from start to end in the given graph\"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"Return a graph representing a maze\"\"\"\n    return [\n        [1, 3],  # Node 0\n        [0, 2],  # Node 1\n        [1, 5],  # Node 2\n        [0, 4],  # Node 3\n        [3, 5],  # Node 4\n        [2, 4],  # Node 5\n    ]\n\nassert f(g(), 0, 5)\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string contains a valid email address\"\"\"\n    import re\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, s))\ndef g():\n    return \"example@example.com\"\nassert f(g())\n",
        "idx_generation": 473,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists two numbers in the given list that sum up to the target.\nReturn True if such numbers exist, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[3, 1, 5, 7, 9], target=8):\n    return nums, target\nassert f(*g()) == True\n",
        "idx_generation": 314,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> bool:\n    \"\"\"\n    Given an integer, determine if it is a power of four.\n    Return True if it is a power of four, otherwise return False.\n    \"\"\"\n    if num < 1:\n        return False\n    while num % 4 == 0:\n        num //= 4\n    return num == 1\n\ndef g():\n    return 64\n\nassert f(g()) == True\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the length of the longest increasing subsequence in the given list of integers\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\nassert f(g()) == 4\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Given a string, determine if it is a palindrome after removing all non-alphanumeric characters and ignoring case.\"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama!\"\n\nassert f(g())\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number n is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return (17,)\n\nassert f(*g()) == True\n",
        "idx_generation": 314,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> bool:\n    \"\"\"Given a number n, return True if it is a prime number, and False otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\ndef g():\n    return 17\nassert f(g())\n",
        "idx_generation": 494,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"Given a maze represented as a 2D grid, determine if it is possible to reach the bottom-right corner of the maze from the top-left corner.\n    You can only move down or right. 1 represents a blocked path and 0 represents an open path.\"\"\"\n    m = len(maze)\n    n = len(maze[0])\n    \n    def dfs(row, col):\n        if row == m - 1 and col == n - 1:\n            return True\n        \n        if row >= m or col >= n or maze[row][col] == 1:\n            return False\n        \n        return dfs(row + 1, col) or dfs(row, col + 1)\n    \n    return dfs(0, 0)\n\ndef g():\n    maze = [[0, 0, 1, 0], \n            [0, 0, 0, 0], \n            [1, 1, 0, 0], \n            [1, 1, 1, 0]]\n    return maze\n\nassert f(g()) == True\n",
        "idx_generation": 493,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome or can be rearranged into a palindrome.\"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\ndef g():\n    s = \"level\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if there are two elements in the list that sum up to a target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    target = 10\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [1, 4, 5, 6, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n    left = 1\n    right = n // 2\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> int:\n    \"\"\"Given a grid of non-negative integers, count the number of unique paths from the top-left corner to the bottom-right corner. You can only move down or right.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = 1\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] if grid[i][0] != 1 else 0\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] if grid[0][j] != 1 else 0\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] if grid[i][j] != 1 else 0\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]], target: int) -> Tuple[List[List[int]], int]:\n    return (grid, target)\n\ngrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\ntarget = 2\n\nassert f(*g(grid, target)) == 2\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"\n    Return the string.\n    \"\"\"\n    return s\nassert f(g(\"racecar\")) == True\n",
        "idx_generation": 475,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if the target number is the sum of any two numbers in the given list, after sorting the list in ascending order.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 5, 8, 10, 13, 17, 21]\n\nassert f(g(), 15)\n",
        "idx_generation": 319,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of any contiguous subarray.\n    The subarray must contain at least one element.\"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, c: str) -> str:\n    \"\"\"Replace all occurrences of a character 'c' in a string 's' with '*'. Return the modified string.\"\"\"\n    return s.replace(c, '*')\ndef g():\n    return ('abracadabra', 'a')\nassert f(*g()) == '*br*c*d*br*'\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the index of the target number in a sorted list. If the target is not found, return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9, 11, 13], target=7):\n    return (nums, target)\n\nassert f(*g()) != -1\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum sum of a subsequence with the constraint that no two numbers in the \n    sequence should be adjacent to each other.\n    The function should return the maximum sum.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[n-1]\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([1, 2, 3, 4, 5])) == 9\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return 'madam'\nassert f(g())\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, find if there are two numbers in the list that add up to the target.\n    Sample input:\n    [1, 2, 3, 4, 5], 7\n    Sample output:\n    True\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g())\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the length of the longest increasing subsequence.\n    The function should return the length of the longest increasing subsequence.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    \n    return max(dp)\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"Return the string with the highest sum of ASCII values for each substring of length n.\"\"\"\n    max_sum = 0\n    max_string = \"\"\n    for i in range(len(s)-n+1):\n        substring = s[i:i+n]\n        current_sum = sum(ord(c) for c in substring)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_string = substring\n    return max_string\n\ndef g(n: int):\n    return \"abcde\"\n\nassert f(g(2), 2) == \"de\"\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a sorted matrix of integers, determine if the target value is present using binary search.\n    The matrix is sorted in ascending order from left to right in each row, and from top to bottom in each column.\n    Return True if the target value is present, False otherwise.\"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n\n    def binary_search_row(row, target, left, right):\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if row[mid] == target:\n            return True\n        elif row[mid] < target:\n            return binary_search_row(row, target, mid + 1, right)\n        else:\n            return binary_search_row(row, target, left, mid - 1)\n\n    def binary_search_matrix(matrix, target, top, bottom):\n        if top > bottom:\n            return False\n        mid = (top + bottom) // 2\n        if matrix[mid][0] <= target <= matrix[mid][-1]:\n            return binary_search_row(matrix[mid], target, 0, m - 1)\n        elif matrix[mid][0] > target:\n            return binary_search_matrix(matrix, target, top, mid - 1)\n        else:\n            return binary_search_matrix(matrix, target, mid + 1, bottom)\n\n    return binary_search_matrix(matrix, target, 0, n - 1)\n\ndef g():\n    matrix = [\n        [1, 3, 5, 7],\n        [10, 11, 16, 20],\n        [23, 30, 34, 60]\n    ]\n    target = 16\n    return (matrix, target)\n\nassert f(*g())\n",
        "idx_generation": 323,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Given a string, reverse the order of words in the string.\"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g(s: str=\"Hello World\"):\n    return (s,)\n\nassert f(*g()) == \"World Hello\"\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list that adds up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 3, 5, 7, 9, 11], 16)\n\nassert f(*g())\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    s = \"racecar\"\n    return s\nassert f(g())\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the index of the target number if it exists in the list. Using binary search algorithm.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return ([1, 3, 5, 7, 9, 11], 7)\n\nassert f(*g()) == 3\n",
        "idx_generation": 323,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g():\n    return 9\nassert f(g())\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find two numbers in the list that add up to the target value\"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return True\n    return False\n\ndef g(target=0):\n    nums = [1, 7, 3, 9, 2, 5]\n    return nums\n\nassert f(g(), target=10)\n",
        "idx_generation": 324,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"Reverse the words in the given string while maintaining the order of the words.\"\"\"\n    words = s.split()\n    return ' '.join(words[::-1])\ndef g():\n    return ('Hello World', )\nassert f(*g()) == 'World Hello'\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exist two elements that sum up to the target value.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"Return the sorted list and the target value.\"\"\"\n    return sorted(arr), target\n\nassert f(*g([1, 2, 3, 4, 5], 9)) == True\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[str]) -> str:\n    \"\"\"Given a list of strings, find the longest common prefix among them.\nThe solution should return the longest common prefix string.\"\"\"\n    if not arr:\n        return \"\"\n    prefix = arr[0]\n    for word in arr[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:len(prefix)-1]\n            if prefix == \"\":\n                return \"\"\n    return prefix\ndef g():\n    return [\"flower\", \"flow\", \"flight\"]\nassert f(g()) == \"fl\"\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a permutation of the sequence from 0 to n, where n is the length of the list.\nSample Input:\nnums = [1, 2, 3, 0]\nSample Output:\nTrue\nExplanation: The given list is a permutation of the sequence from 0 to 3, hence the output is True.\"\"\"\n    nums.sort()\n    for i, num in enumerate(nums):\n        if i != num:\n            return False\n    return True\ndef g(nums=[1, 2, 3, 0]):\n    return nums\nassert f(g())\n",
        "idx_generation": 326,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target_length=10) -> bool:\n    \"\"\"Find a string that has a specific length and contains only 0s and 1s, with an equal number of 0s and 1s\"\"\"\n    return len(s) == target_length and s.count('0') == s.count('1')\ndef g(target_length=10):\n    return '0' * (target_length // 2) + '1' * (target_length // 2)\nassert f(g())\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a sorted matrix of integers, determine if a target number is present in the matrix.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n\ndef g():\n    return [[1, 4, 7], [2, 5, 8], [3, 6, 9]], 5\n\nassert f(*g())\n",
        "idx_generation": 330,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"Given a list of strings, find the longest common prefix among all strings.\"\"\"\n    def common_prefix(s1, s2):\n        i = 0\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]:\n            i += 1\n        return s1[:i]\n    if not arr:\n        return \"\"\n    prefix = arr[0]\n    for i in range(1, len(arr)):\n        prefix = common_prefix(prefix, arr[i])\n    return prefix\ndef g(arr=['apple', 'app', 'application']):\n    return arr\nassert f(g()) == 'app'\n",
        "idx_generation": 496,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if there exists three elements such that their sum is equal to zero.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [1, -2, 3, 0, -1, 2]\n\nassert f(g())\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if one string is a rotation of the other.\"\"\"\n    if len(s1) != len(s2):\n        return False\n    s1 += s1\n    return s2 in s1\n\ndef g(s1: str, s2: str):\n    return (s1, s2)\n\nassert f(*g('hello', 'ohell'))\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value exists in the list.\n    Use binary search to find the target value in O(log n) time complexity.\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 9) == True\n",
        "idx_generation": 332,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"Rotate each character in the string by n positions to the right.\"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_val = ord(char)\n            if char.islower():\n                ascii_val = (ascii_val - 97 + n) % 26 + 97\n            else:\n                ascii_val = (ascii_val - 65 + n) % 26 + 65\n            result += chr(ascii_val)\n        else:\n            result += char\n    return result\n\ndef g(s: str, n: int):\n    return (s, n)\n\nassert f(*g('abcXYZ', 3)) == 'defABC'\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Args:\n        nums: The sorted list of integers.\n        target: The target value.\n\n    Returns:\n        True if there are two numbers in the list that add up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Returns a sample sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 7)\n",
        "idx_generation": 333,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"Generate the nth term of the look-and-say sequence.\"\"\"\n    if n == 1:\n        return \"1\"\n    \n    sequence = \"1\"\n    for _ in range(n-1):\n        count = 1\n        current = sequence[0]\n        next_sequence = \"\"\n        \n        for i in range(1, len(sequence)):\n            if sequence[i] == current:\n                count += 1\n            else:\n                next_sequence += str(count) + current\n                count = 1\n                current = sequence[i]\n        \n        next_sequence += str(count) + current\n        sequence = next_sequence\n    \n    return sequence\n\ndef g():\n    return 6\n\nassert f(g()) == \"312211\"\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, return True if the target value is present in the list, False otherwise.\n    Implement the binary search algorithm to solve this problem.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=3):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers sorted in ascending order, check if there exists two numbers whose sum is equal to the given target.\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    Sample Output:\n    True\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nassert f(*g([2, 4, 6, 8, 10], 14))\n",
        "idx_generation": 338,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g())\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, return True if there exists a pair of integers\nin the list that sum up to the target, and False otherwise.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"Given a sorted list of integers and a target integer, return the pair of integers that sum up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return (nums[left], nums[right])\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return (-1, -1)\n\n# Example usage:\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(g(nums, target), target)\n",
        "idx_generation": 339,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum equals the target.\"\"\"\n    nums.sort()  # sorting the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6], 9)\n\nassert f(*g())\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value,\n    find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 6\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists a pair of numbers that add up to the target value\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 346,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the median of a list of integers\"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\ndef g():\n    return [4, 2, 1, 5, 3]\n\nassert f(g()) == 3\n",
        "idx_generation": 346,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, check if the list is sorted in non-decreasing order and contains only unique elements.\"\"\"\n    return arr == sorted(list(set(arr)))\n\ndef g(arr: List[int]=[1, 2, 3, 4, 5]):\n    return arr\n\nassert f(g())\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    left, right = 0, len(arr)-1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int]=[1, 2, 3, 4, 5], target: int=8):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target number, find the index of the target number in the list using binary search.\n    If the target number is not present in the list, return -1.\"\"\"\n    left, right = 0, len(arr)-1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(arr: List[int]=[1, 2, 3, 4, 5], target: int=3):\n    return arr, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Find the elements in the matrix that appear more than once and return them in sorted order.\"\"\"\n    elements = []\n    seen = set()\n    for row in matrix:\n        for element in row:\n            if element in seen and element not in elements:\n                elements.append(element)\n            seen.add(element)\n    elements.sort()\n    return elements\n\ndef g():\n    matrix = [[1, 2, 3], [4, 2, 6], [7, 8, 9], [1, 2, 3]]\n    return matrix\n\nassert f(g()) == [1, 2, 3]\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Return the square of each number in the list, sorted in descending order.\"\"\"\n    squares = [num**2 for num in nums]\n    return sorted(squares, reverse=True)\ndef g():\n    return ([3, 1, 5, 2, 4],)\nassert f(*g()) == [25, 16, 9, 4, 1]\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13], 16\n\nassert f(*g()) == True\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there is a pair of numbers in the array that adds up to the target. \n    The array is sorted in ascending order.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low < high:\n        if arr[low] + arr[high] == target:\n            return True\n        elif arr[low] + arr[high] < target:\n            low += 1\n        else:\n            high -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 349,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exists a pair of numbers in the array that sum up to the target value. You can assume that the array is sorted in non-decreasing order.\n    Sample Input:\n    arr = [1, 3, 5, 7, 9]\n    target = 12\n    Sample Output:\n    True\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(arr: List[int], target: int) -> None:\n    \"\"\"\n    Generate a sorted array of integers and the target sum.\n    \"\"\"\n    return (arr, target)\n\nassert f(*g([1, 3, 5, 7, 9], 12))\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1.\n    Sample Input:\n    n = 5\n    Sample Output:\n    5\n    \"\"\"\n    if n <= 1:\n        return n\n\n    a, b = 0, 1\n\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n\ndef g(n: int) -> None:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return n\n\nassert f(g(5)) == 5\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=5):\n    return (nums, target)\nassert f(*g()) == 4\n",
        "idx_generation": 356,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order, check if the target value exists in the list using binary search.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    return arr\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 5\nassert f(g(arr, target), target)\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers 'arr', find if there exists a pair of numbers that sum up to 'n'.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == n:\n            return True\n        elif current_sum < n:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(10, g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of elements in the list that sums up to the target value.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([2, 7, 11, 15], 9))\n",
        "idx_generation": 361,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int]) -> bool:\n    \"\"\"Check if the list of numbers is sorted in strictly increasing order.\"\"\"\n    return all(numbers[i] < numbers[i+1] for i in range(len(numbers)-1))\n    \ndef g(numbers: List[int]):\n    return sorted(numbers)\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 364,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Determine if there exists a pair of numbers in the given list that sum up to the target.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 364,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a list of integers and a target value, find the index of the target value in the list.\nIf the target value is not found in the list, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g():\n    return ([1, 2, 3, 4, 5], 3)\nassert f(*g()) == 2\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Given a sorted array of integers and a target value, return the index of the target value in the array. If the target value is not found, return -1.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    target = 4\n    return arr, target\nassert f(*g()) == 3\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is sorted in ascending order.\"\"\"\n\n    return arr == sorted(arr)\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g())\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exist three elements whose sum is equal to the target.\n    Return True if such elements exist, otherwise return False.\"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 18)\n",
        "idx_generation": 367,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, return the next permutation of the numbers in the list in lexicographic order.\nIf the input is the last permutation, return the first permutation.\"\"\"\n    def next_permutation(nums):\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        return nums\n    return next_permutation(nums)\ndef g():\n    nums = [1, 2, 3]\n    return (nums,)\nassert f(*g()) == [1, 3, 2]\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists two numbers whose sum is equal to the target.\n    Return True if such a pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 3, 5, 7, 9], 12))\n",
        "idx_generation": 370,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers, find two numbers whose sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7], 9\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 371,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, check if there exists a pair of numbers whose sum is equal to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n            \n    return False\n\ndef g(nums: List[int], target: int):\n    return nums\n\nnums = [1, 4, 2, 7, 5, 3]\ntarget = 8\nassert f(g(nums, target), target)\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str]) -> bool:\n    \"\"\"Check if the given list of words is in alphabetical order, ignoring case.\"\"\"\n    return all(words[i].lower() <= words[i+1].lower() for i in range(len(words)-1))\n    \ndef g():\n    return ['apple', 'banana', 'cherry', 'Date', 'elderberry']\n\nassert f(g())\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Sort an array of integers using the bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g(nums=[9, 5, 2, 8, 1]):\n    return nums\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the product of the two largest numbers in the list.\"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\ndef g():\n    nums = [5, 2, 7, 1, 9, 3]\n    return nums\nassert f(g()) == 63\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order, find if there exists two numbers in the list such that their sum is equal to the target number.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return sorted(nums)\nassert f(g(), target=7)\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of the list whose sum is equal to 0.\"\"\"\n    prefix_sum = 0\n    seen = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == 0 or prefix_sum in seen:\n            return True\n        seen.add(prefix_sum)\n    return False\n\ndef g():\n    nums = [4, -2, 1, -3, 2, -1, 5, -4]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 11\n    return nums, target\n\nassert f(*g()) == 5\n",
        "idx_generation": 379,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 380,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums=[1, 3, 5, 7, 9], target=5):\n    \"\"\"\n    Return the sorted list of integers and the target value.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Given a list of integers, find the maximum product of any two numbers in the list.\"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2] > nums[0] * nums[1]\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\nassert f(g())\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists a pair of numbers that sum up to the target value.\nReturn True if such a pair exists, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr: List[int], target: int):\n    return (arr, target)\nassert f(*g([1, 3, 5, 7, 9], 12))\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, return the indices of two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left, right]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 382,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the median of a list of integers\"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        median = (nums[n // 2] + nums[n // 2 - 1]) / 2\n    else:\n        median = nums[n // 2]\n    return median\ndef g(nums=[9, 4, 2, 7, 1, 5, 3]):\n    return nums\nassert f(g()) == 4.0\n",
        "idx_generation": 382,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target element using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return (nums, target)\nassert f(g()[0], g()[1]) == 2\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there exists a pair of numbers whose sum is equal to the target value.\n    The list is sorted in ascending order.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 4, 5, 7, 9]\n\nassert f(g(), 10)\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"Count the number of pairs in the given list that sum up to the target value.\"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == target:\n                count += 1\n    return count\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5, 6], 7)\nassert f(*g()) == 3\n",
        "idx_generation": 385,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 4, 7, 3, 9, 2], 11\n\nassert f(*g())\n",
        "idx_generation": 386,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target integer, determine if there are two integers in the list that add up to the target.\nArgs:\n    arr: The sorted list of integers.\n    target: The target sum.\nReturns:\n    True if there exist two integers that add up to the target, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\narr = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(*g(arr, target))\n",
        "idx_generation": 387,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"Given a list of integers and a positive integer k, find the kth largest element in the list.\nArgs:\n    nums: The list of integers.\n    k: The target position.\nReturns:\n    The kth largest element in the list.\"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n\ndef g(nums: List[int], k: int):\n    return (nums, k)\n\nnums = [3, 1, 5, 2, 4]\nk = 3\nassert f(*g(nums, k)) == 3\n",
        "idx_generation": 387,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there exists two numbers that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return (nums, target)\n\nnums = [1, 2, 3, 5, 8, 13]\ntarget = 10\nassert f(*g(nums, target))\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(target: int):\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  # Assuming the list is already sorted\n\nassert f(g(target=11), target=11)\n",
        "idx_generation": 388,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], x: int) -> bool:\n    \"\"\"Check if a given number exists in a sorted list using binary search.\"\"\"\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 6)\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum equals the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int):\n    return nums\n\nassert f(g([2, 4, 7, 11, 15], 9), 9)\n",
        "idx_generation": 391,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list such that their sum is equal to the target.\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    Sample Output:\n    True\"\"\"\n    num_set = set()\n    for num in nums:\n        if target - num in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g():\n    return ([2, 4, 6, 8, 10], 14)\n\nassert f(*g())\n",
        "idx_generation": 392,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom functools import reduce\n\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of three distinct elements in the given list of integers.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    \"\"\"Return a list of random integers.\"\"\"\n    return [2, 7, 4, 1, -5, 3]\n\nassert f(g()) == 84\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int]) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the first occurrence of a target number in the list. If the target number is not found, return -1.\"\"\"\n    target = 5\n    start = 0\n    end = len(arr) - 1\n    index = -1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            index = mid\n            end = mid - 1\n        elif arr[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return index\ndef g():\n    return [1, 3, 5, 5, 7, 9, 11, 11]\nassert f(g()) == 2\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort the given array in ascending order using the insertion sort algorithm.\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndef g():\n    arr = [5, 2, 8, 1, 9]\n    return arr\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 396,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers in ascending order and a target value, return whether the target value exists in the list using binary search.\n\n    Args:\n        nums: A list of integers in ascending order.\n        target: The target value to search for.\n\n    Returns:\n        True if the target value exists in the list, False otherwise.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"\n    Returns a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n\nassert f(g(target=7), target=7)\n",
        "idx_generation": 396,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to obtain the target sum by adding any three elements from the given list of numbers.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"Given a list of integers, find a pair of numbers that sum up to the target value.\nReturn True if such a pair exists, False otherwise.\"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] == target:\n                return True\n    return False\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return nums\nassert f(g())\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given list is sorted in non-decreasing order.\"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True\n\ndef g(arr: List[int]):\n    return sorted(arr)\n\nassert f(g([1, 2, 3, 4, 5]))\n",
        "idx_generation": 400,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"Given a sorted list of integers 'arr', find if there exists a pair of numbers whose sum is equal to 'n'.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == n:\n            return True\n        elif arr[left] + arr[right] > n:\n            right -= 1\n        else:\n            left += 1\n    return False\n\ndef g(arr: List[int]):\n    return arr\n\nassert f(10, g([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n",
        "idx_generation": 402,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order and return the sorted list.\n    \"\"\"\n    return sorted(nums)\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return (nums,)\n\nnums = [4, 2, 5, 1, 3]\nassert f(*g(nums)) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Given a square matrix, check if it is symmetric.\n    Return True if it is symmetric, False otherwise.\"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True\n\ndef g():\n    return [[1, 2, 3], [2, 4, 5], [3, 5, 6]]\n\nassert f(g())\n",
        "idx_generation": 405,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a given 2D grid is a valid sudoku solution.\n    The grid is represented by a 9x9 list of integers, where each integer is in the range 1-9.\n    Return True if the grid is a valid sudoku solution, False otherwise.\"\"\"\n    # Check rows\n    for row in grid:\n        if sorted(row) != list(range(1, 10)):\n            return False\n    \n    # Check columns\n    for col in range(9):\n        column = [grid[row][col] for row in range(9)]\n        if sorted(column) != list(range(1, 10)):\n            return False\n    \n    # Check subgrids\n    for i in range(3):\n        for j in range(3):\n            subgrid = [grid[row][col] for row in range(i*3, (i+1)*3) for col in range(j*3, (j+1)*3)]\n            if sorted(subgrid) != list(range(1, 10)):\n                return False\n    \n    return True\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g())\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order, find the number of distinct elements in the list.\n    Args:\n        arr: A sorted list of integers.\n    Returns:\n        The number of distinct elements in the list.\n    \"\"\"\n    distinct_count = 1\n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            distinct_count += 1\n    return distinct_count\n\ndef g():\n    \"\"\"\n    Returns a sorted list of integers with duplicate elements.\n    \"\"\"\n    return [1, 2, 2, 3, 4, 4, 4, 5, 6, 6, 6]\n\nassert f(g()) == 6\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list whose sum is equal to the target.\"\"\"\n    nums.sort() # Sorting the list in ascending order\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g())\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there are any three numbers whose sum is equal to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return ([2, 3, 5, 8, 11, 15], 21)\n\nassert f(*g())\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target integer, return the index of the target in the list.\n    If the target is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(target=5):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return (nums, target)\n\nassert f(*g()) == 4\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 4, 7, 11, 15], 9\n\nassert f(g()[0], g()[1]) == True\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target number, return the index of the target number in the list. If the target number is not found, return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14, 16, 18], 10\n\nassert f(g()[0], g()[1]) == 4\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=10) -> bool:\n    \"\"\"Find if there exists a pair of elements in the list that sum up to a given target value.\"\"\"\n    arr.sort()\n    start = 0\n    end = len(arr) - 1\n    while start < end:\n        curr_sum = arr[start] + arr[end]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            start += 1\n        else:\n            end -= 1\n    return False\n\ndef g(target=10):\n    return [2, 4, 6, 8]\n\nassert f(g())\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[2, 4, 6, 8, 10], target=12):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"Split the string into k-sized chunks.\"\"\"\n    return [s[i:i+k] for i in range(0, len(s), k)]\n\ndef g(s='abcdefghij', k=3):\n    return s, k\n\nassert f(*g()) == ['abc', 'def', 'ghi', 'j']\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there are three numbers in the list that add up to the target number.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return True\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find three numbers from the list that add up to the target number.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            if arr[i] + arr[left] + arr[right] == target:\n                return [arr[i], arr[left], arr[right]]\n            elif arr[i] + arr[left] + arr[right] < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n\narr = [1, 2, 3, 4, 5]\ntarget = 10\nassert f(g(arr, target), target)\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there are four numbers in the list that add up to the target number.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 3):\n        for j in range(i + 1, n - 2):\n            left = j + 1\n            right = n - 1\n            while left < right:\n                if arr[i] + arr[j] + arr[left] + arr[right] == target:\n                    return True\n                elif arr[i] + arr[j] + arr[left] + arr[right] < target:\n                    left += 1\n                else:\n                    right -= 1\n    return False\n\ndef g(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find four numbers from the list that add up to the target number.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 3):\n        for j in range(i + 1, n - 2):\n            left = j + 1\n            right = n - 1\n            while left < right:\n                if arr[i] + arr[j] + arr[left] + arr[right] == target:\n                    return [arr[i], arr[j], arr[left], arr[right]]\n                elif arr[i] + arr[j] + arr[left] + arr[right] < target:\n                    left += 1\n                else:\n                    right -= 1\n    return []\n\narr = [1, 2, 3, 4, 5]\ntarget = 12\nassert f(g(arr, target), target)\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers 'nums', find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\nassert f(*g()) == 20\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that add up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), target=9) == True\n",
        "idx_generation": 420,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target number,\n    determine if there exists a pair of numbers in the array\n    whose sum is equal to the target.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 422,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find three numbers in the given list that sum up to the target value\"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g():\n    return [1, 4, 2, 7, 10, 3]\n\nassert f(g(), 15)\n",
        "idx_generation": 422,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to the target value.\n    The solution should return True if such pair exists, and False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([1, 2, 3, 4, 5], 8)\nassert f(*g()) == True\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums: List[int], target: int):\n    return sorted(nums)\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Given a sorted two-dimensional matrix of integers and a target value, determine if the target value exists in the matrix.\"\"\"\n    if not matrix or not matrix[0]:\n        return False\n        \n    m, n = len(matrix), len(matrix[0])\n    row, col = 0, n-1\n    while row < m and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n    \ndef g(matrix=[[1, 3, 5], [7, 9, 11], [13, 15, 17]], target=9):\n    return (matrix, target)\n    \nassert f(*g())\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\nArgs:\n    nums: A sorted list of integers.\n    target: The target number to find.\nReturns:\n    The index of the target number if found, otherwise -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g():\n    \"\"\"\n    Returns a sorted list of integers.\n    \"\"\"\n    return [2, 5, 7, 9, 12, 15, 18, 20]\nassert f(g(), 9) == 3\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, find the index of the target value in the list using binary search. If the target value is not found, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\ndef g(nums: List[int], target: int):\n    return (nums, target)\nassert f(*g([1, 2, 3, 4, 5], 3)) == 2\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists three numbers in the list such that their sum is equal to the target number.\n    You can use each number in the list only once.\"\"\"\n    n = len(nums)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9], target=15):\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', determine if there exists a pair of numbers in the list\n    such that their sum is equal to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return ([-2, 1, 3, 5, 6, 8, 9], 7)\n\nassert f(*g())\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sum up to the target value.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 4, 2, 7, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers in non-decreasing order, with even numbers before odd numbers.\"\"\"\n    evens = [num for num in arr if num % 2 == 0]\n    odds = [num for num in arr if num % 2 != 0]\n    evens.sort()\n    odds.sort()\n    return evens + odds\n\ndef g(arr=[3, 2, 1, 4, 5]):\n    return arr\n\nassert f(g()) == [2, 4, 1, 3, 5]\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list that sum up to the target value.\"\"\"\n    arr.sort()\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 12) == True\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list contains any duplicates.\"\"\"\n    nums.sort()\n    for i in range(len(nums) - 1):\n        if nums[i] == nums[i+1]:\n            return True\n    return False\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10]\nassert f(g())\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target.\n    Return True if such pair exists, else False.\"\"\"\n    nums.sort()  # Sorting the list\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 436,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'numbers', check if two numbers exist in the list such that their sum is equal to 'target'.\"\"\"\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        total = numbers[left] + numbers[right]\n        if total == target:\n            return True\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return numbers, target\n\nassert f(*g()) == True\n",
        "idx_generation": 436,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers nums and a target integer, determine if there exists a pair of numbers in nums that add up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums=[2, 7, 11, 15], target=9):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Given a list of integers nums and an integer k, find the kth largest element in the list.\"\"\"\n    nums.sort(reverse=True)\n    return nums[k - 1]\ndef g(nums=[3, 2, 1, 5, 6, 4], k=2):\n    return (nums, k)\nassert f(*g()) == 5\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a sorted list of integers and a target value, find the two numbers such that they add up to the target.\n    Implement the solution using a binary search approach.\"\"\"\n    n = len(nums)\n    left = 0\n    right = n - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 11\n    return (nums, target)\n\nassert f(*g()) == [2, 9]\n",
        "idx_generation": 438,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the given list whose sum is equal to the target value.\n    - nums: A list of integers\n    - target: The target sum\n    \n    Returns True if a pair of numbers exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"Return the list of numbers and the target sum.\"\"\"\n    return (nums, target)\n\nassert f(*g([1, 2, 3, 4, 5, 6], 10))\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in a sorted list that add up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g() -> Tuple[List[int], int]:\n    return ([-2, 0, 3, 5, 7, 9, 11], 8)\nassert f(*g())\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"Given a sorted list of integers, find if there exists a pair of numbers whose difference is equal to k.\"\"\"\n    n = len(arr)\n    low = 0\n    high = 1\n    while low < n and high < n:\n        diff = arr[high] - arr[low]\n        if diff == k:\n            return True\n        elif diff < k or low == high:\n            high += 1\n        else:\n            low += 1\n    return False\n\ndef g():\n    arr = [1, 3, 5, 7, 9]\n    k = 4\n    return (arr, k)\n\nassert f(*g())\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    Sample Output:\n    True\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return ([1, 3, 5, 7, 9], 10)\n\nassert f(*g())\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if the sum of any two numbers in the array is equal to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([1, 5, 2, 9, 3, 7], 10)\nassert f(*g())\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are three numbers in the list nums that can sum up to the target.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\ndef g(nums: List[int], target: int):\n    return nums\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(g(nums, target), target)\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, return the index of the target element. If the target is not found, return -1.\"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\ndef g(nums: List[int], target: int) -> Tuple:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    return (sorted(nums), target)\nnums = [1, 3, 5, 7, 9]\ntarget = 5\nassert f(*g(nums, target)) == 2\n",
        "idx_generation": 450,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return ([2, 7, 11, 15], 9)\nassert f(*g()) == True\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers nums and a target number, return True if the target is present in the list, False otherwise.\n    Use binary search algorithm to solve the problem.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers nums and a target number.\n    \"\"\"\n    return (nums, target)\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ntarget = 5\nassert f(*g(nums, target)) == True\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given a list of integers 'nums' and a target integer 'target', find two distinct numbers in the list\nthat sum up to the target. Return the pair of numbers as a list.\nIf no such pair exists, return an empty list.\nNote: Each input list will have exactly one valid solution.\n\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target value that has a valid solution.\n    Return the generated list of integers and the target value as a tuple.\n    \"\"\"\n    nums = [1, 4, 2, 7, 3]\n    target = 9\n    return (nums, target)\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers 'arr' and a target value 'target', find the two numbers in the list that sum up to the target value. Return True if such numbers exist, False otherwise.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 9))\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target value.\n    Sample Input:\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n    Sample Output:\n    True\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n    return (arr, target)\nassert f(*g())\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, return True if there exists a pair of numbers that sum up to the target value. Otherwise, return False.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    \"\"\"Returns a sorted list of integers.\"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers is a valid mountain sequence.\"\"\"\n    n = len(nums)\n    if n < 3:\n        return False\n    i = 0\n    while i < n - 1 and nums[i] < nums[i + 1]:\n        i += 1\n    if i == 0 or i == n - 1:\n        return False\n    while i < n - 1 and nums[i] > nums[i + 1]:\n        i += 1\n    return i == n - 1\ndef g():\n    nums = [1, 2, 3, 4, 5, 4, 3, 2, 1]\n    return nums\nassert f(g())\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of integers contains any duplicate numbers.\"\"\"\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n    return False\ndef g():\n    nums = [4, 2, 6, 1, 3, 6, 8]\n    return nums\nassert f(g())\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Given an array of integers nums sorted in ascending order, and an integer target, return indices of the two numbers such that they add up to target.\n    Sample input:\n    [2,7,11,15], 9\n    Sample output:\n    [0, 1]\n    (Sample output hidden because showing sample output would give away too much information.)\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return [2,7,11,15], 9\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"Find the kth smallest element in an unsorted array of non-negative integers.\n    Sample input:\n    [3,2,1,5,6,4], 2\n    Sample output:\n    2\n    (Sample output hidden because showing sample output would give away too much information.)\"\"\"\n    return sorted(nums)[k - 1]\n\ndef g():\n    return [3,2,1,5,6,4], 2\nassert f(*g()) == 2\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two elements in the list that sum up to the target.\n    Return True if such elements exist, False otherwise.\"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers nums and a target value, find the index of the target in the list using binary search.\"\"\"\n    start = 0\n    end = len(nums) - 1\n\n    while start <= end:\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return -1\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers nums and a target value.\n    \"\"\"\n    return (sorted(nums), target)\n\nnums = [1, 3, 5, 7, 9, 11, 13, 15]\ntarget = 7\nassert f(*g(nums, target)) == 3\n",
        "idx_generation": 458,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted array of integers and a target value, determine if there exist two numbers in the array whose sum is equal to the target value.\"\"\"\n    n = len(arr)\n    left = 0\n    right = n - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(arr: List[int], target: int):\n    return (arr, target)\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 10\nassert f(*g(arr, target))\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if the target value\n    is present in the list using binary search.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 3, 5, 7, 9, 11, 13]\n    target = 7\n    return (arr, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target element using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\ndef g(nums=[1, 3, 5, 7, 9, 11, 13], target=7):\n    return nums, target\nassert f(*g()) == 3\n",
        "idx_generation": 463,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order and return the sorted list.\"\"\"\n    nums.sort()\n    return nums\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nnums = [5, 2, 8, 1, 9]\nassert f(g(nums)) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers and a target value, return the index of the target if it exists in the list, otherwise return -1.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int], target: int):\n    \"\"\"Generate a sorted list of integers and a target value.\"\"\"\n    return (sorted(nums), target)\n\nnums = [1, 2, 3, 4, 5, 6]\ntarget = 4\nassert f(*g(nums, target)) == 3\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list that add up to the target.\n    Args:\n        nums: A list of integers in ascending order.\n        target: The target sum.\n    Returns:\n        True if there exists two numbers that add up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Returns the two numbers that add up to the target.\n    Args:\n        nums: A list of integers in ascending order.\n        target: The target sum.\n    Returns:\n        A list containing the two numbers that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\n# Sample input\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 10\n\nassert f(g(nums, target), target)\n",
        "idx_generation": 466,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in non-decreasing order using the Bubble Sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g():\n    return [4, 2, 7, 1, 3]\n\nassert f(g()) == [1, 2, 3, 4, 7]\n",
        "idx_generation": 466,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, sort the numbers in ascending order using the bubble sort algorithm.\n    Return the sorted list of numbers.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 8, 1, 9]\n\nassert f(g()) == [1, 2, 5, 8, 9]\n",
        "idx_generation": 466,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target number, determine whether there exist two elements in the list whose sum is equal to the target.\"\"\"\n    nums.sort()  # Sorting the list in ascending order\n    left, right = 0, len(nums) - 1  # Initialize two pointers at the start and end of the list\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:  # If the sum is equal to the target, return True\n            return True\n        elif curr_sum < target:  # If the sum is less than the target, move the left pointer to the right\n            left += 1\n        else:  # If the sum is greater than the target, move the right pointer to the left\n            right -= 1\n    return False  # If no such pair is found, return False\n\ndef g():\n    return [1, 5, 7, 10, 12, 15, 18]  # Example input list\n\nassert f(g(), 17) == True  # There exist two elements (7 and 10) whose sum is equal to the target (17)\n",
        "idx_generation": 468,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there exist two numbers in the list such that their sum is equal to the target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> None:\n    \"\"\"\n    Generate a sorted list of integers and the target sum.\n    \"\"\"\n    return (sorted(nums), target)\n\nnums = [1, 2, 3, 4, 5]\ntarget = 8\nassert f(*g(nums, target))\n",
        "idx_generation": 470,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in a sorted list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 3, 5, 7, 9, 11, 13], 7)\n\nassert f(*g()) == 3\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"Given a positive integer n, find the number of distinct prime factors of n that are less than or equal to k.\"\"\"\n    # Sieve of Eratosthenes to generate primes up to k\n    primes = [True] * (k + 1)\n    primes[0] = primes[1] = False\n    count = 0\n    for i in range(2, int(k ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, k + 1, i):\n                primes[j] = False\n    \n    # Count distinct prime factors of n\n    factors = set()\n    for i in range(2, k + 1):\n        if primes[i] and n % i == 0:\n            factors.add(i)\n    \n    return len(factors)\n\ndef g(n=100, k=10):\n    return (n, k)\n\nassert f(*g()) == 2\n",
        "idx_generation": 472,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that add up to the given target.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 473,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Given a list of integers, find the maximum XOR value between any two numbers in the list.\"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 15\n",
        "idx_generation": 473,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if a matrix is sorted in non-decreasing order row-wise and column-wise.\"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols-1):\n            if matrix[i][j] > matrix[i][j+1]:\n                return False\n    for j in range(cols):\n        for i in range(rows-1):\n            if matrix[i][j] > matrix[i+1][j]:\n                return False\n    return True\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers and a target value, determine if there are three numbers in the list that add up to the target.\n    Return True if such a triplet exists, False otherwise.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(arr: List[int], target: int):\n    return (arr, target)\n\narr = [1, 4, 45, 6, 10, 8]\ntarget = 22\nassert f(*g(arr, target))\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Determine if there are two numbers in the list that sum up to the target.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 4, 2, 7, 3, 9]\n\nassert f(g(), 10)\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\"\"\"\n    i, j = 0, len(nums) - 1\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return True\n        elif nums[i] + nums[j] < target:\n            i += 1\n        else:\n            j -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums\n\nassert f(g(), target=7)\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"Given a list of integers, sort the list in ascending order using bubble sort algorithm.\"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g():\n    nums = [5, 2, 8, 1, 7]\n    return (nums,)\n\nassert f(*g()) == [1, 2, 5, 7, 8]\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if it is possible to find a pair of numbers in the list whose sum is equal to the target\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g():\n    return [1, 5, 2, 9, 8, 4], 12\nassert f(*g())\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, check if there are two numbers that sum up to the target.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    \"\"\"Generate a sorted list of integers.\"\"\"\n    return sorted([1, 4, 5, 6, 8, 10, 12, 15])\n\nassert f(g(), target=11)\n",
        "idx_generation": 482,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"Generate a sorted list of integers.\"\"\"\n    return sorted([2, 4, 6, 8, 10, 12, 14, 16])\n\nassert f(g(), target=10) == 4\n",
        "idx_generation": 482,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers nums and a target integer, determine if the target integer is present in the list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=7):\n    return (nums, target)\nassert f(*g())\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three numbers in a given list of integers.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\ndef g(nums=[-10, -5, 1, 2, 3, 4, 5, 6]):\n    return nums\nassert f(g()) == 300\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers from the given list that sum up to the target value.\"\"\"\n    num_map = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\ndef g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return (arr, target)\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 484,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list is a permutation of the first n natural numbers\"\"\"\n    n = len(nums)\n    return sorted(nums) == list(range(1, n+1))\n\ndef g(n: int):\n    \"\"\"Generate a permutation of the first n natural numbers\"\"\"\n    return random.sample(range(1, n+1), n)\n\nassert f(g(5))\n",
        "idx_generation": 485,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target=0) -> int:\n    \"\"\"Given a sorted array of distinct integers, find the index of the target element. If the target is not found, return -1.\nSample Input:\narr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\ntarget = 16\nSample Output:\n4\"\"\"\n    start = 0\n    end = len(arr) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1\ndef g(arr=[2, 5, 8, 12, 16, 23, 38, 56, 72, 91], target=16):\n    return arr, target\nassert f(g()[0], g()[1]) != -1\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there exists two numbers in the list that add up to the target number.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return sorted(nums)\n\nassert f(g(), target=7)\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers that sum up to the target value\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 13)\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(arr: List[int]) -> bool:\n    \"\"\"Given a list of integers, determine if there exists a subsequence of length 3 where the sum of the first two elements is equal to the third element.\nThe solution should return True if such a subsequence exists, and False otherwise.\"\"\"\n    arr.sort()\n    for i in range(len(arr)-2):\n        if arr[i] + arr[i+1] == arr[i+2]:\n            return True\n    return False\ndef g():\n    return [1, 2, 3, 4, 5]\nassert f(g()) == True\n",
        "idx_generation": 492,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target value.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value k, determine if there are two numbers in the array that\n    add up to k. Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == k:\n            return True\n        elif curr_sum < k:\n            low += 1\n        else:\n            high -= 1\n\n    return False\n\n\ndef g(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value k such that there are two numbers in the array that\n    add up to k.\n    \"\"\"\n    # Generate a sorted array of integers\n    arr = sorted(arr)\n\n    # Generate a target value k such that there are two numbers in the array that add up to k\n    k = arr[0] + arr[1]\n\n    return arr, k\n\n\nassert f(*g([1, 2, 3, 4, 5], 7))\n",
        "idx_generation": 494,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not present in the list, return the index where it would be inserted\n    to maintain the sorted order.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Return the input list and the target number.\n    \"\"\"\n    return (nums, target)\nnums = [2, 4, 6, 8, 10]\ntarget = 7\nassert f(g(nums, target)[0], g(nums, target)[1]) == 3\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there are three numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=18):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 496,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exist three numbers in the given array that sum up to the target.\"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(target: int) -> List[int]:\n    \"\"\"Generate a list of 10 random integers between 1 and 10.\"\"\"\n    import random\n    return [random.randint(1, 10) for _ in range(10)]\n\nassert f(g(15), 15)\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the given list that sum up to the target number.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), target=9) == True\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"Find the index of the target number in the given sorted list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), target=5) == 4\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\ndef f(coordinates: List[Tuple[int, int]]) -> int:\n    \"\"\"Find the minimum number of steps required to move from (0, 0) to the last coordinate in the list.\n    The moves are allowed in 4 directions: up, down, left, and right.\"\"\"\n    x, y = 0, 0\n    steps = 0\n    for cx, cy in coordinates:\n        steps += abs(cx - x) + abs(cy - y)\n        x, y = cx, cy\n    return steps\ndef g(coordinates=[(0, 0), (1, 1), (3, 2), (5, 4)]):\n    \"\"\"Generate a list of coordinates such that the minimum number of steps required to move from (0, 0) to the last coordinate is non-zero.\"\"\"\n    return coordinates\nassert f(g()) > 0\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"Find two numbers in the list that sum up to the target value.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef g():\n    return [2, 7, 11, 15]\nassert f(g(), 9) == [2, 7]\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three elements in a list.\"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\ndef g():\n    return [1, 2, 3, 4]\nassert f(g()) == 24\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    }
]
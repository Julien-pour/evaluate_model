[
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next permutation in lexicographic order.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The next permutation is [1, 3, 2].\n\n    Therefore, the function should return [1, 3, 2].\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n    \n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    \n    if i >= 0:\n        j = n - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    \n    left = i + 1\n    right = n - 1\n    \n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    \n    return nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 407,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of jumps required to reach the last index. Each element in the list represents the maximum number of steps that can be jumped from that position.\n\n    Example:\n    Input: [2, 3, 1, 1, 4]\n    Output: 2 (The minimum number of jumps required is 2: 2 -> 3 -> 4)\n\n    Hint: This problem can be solved using dynamic programming and greedy algorithm.\n    \"\"\"\n    if len(nums) <= 1:\n        return 0\n\n    jumps = 1\n    cur_max = nums[0]\n    next_max = nums[0]\n\n    for i in range(1, len(nums)):\n        if i > cur_max:\n            cur_max = next_max\n            jumps += 1\n        next_max = max(next_max, i + nums[i])\n\n    return jumps\n\ndef g():\n    return [2, 3, 1, 1, 4]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    stack = [(0, 0)]\n    \n    while stack:\n        x, y = stack.pop()\n        \n        if x == m-1 and y == n-1:\n            return True\n        \n        if x+1 < m and grid[x+1][y] == 0:\n            stack.append((x+1, y))\n        \n        if y+1 < n and grid[x][y+1] == 0:\n            stack.append((x, y+1))\n    \n    return False\n\n\ndef g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 47,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"Check if a given word exists in the grid.\n\n    Sample Input:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Sample Output:\n    True\n    \"\"\"\n    def dfs(i, j, k):\n        if not 0 <= i < len(grid) or not 0 <= j < len(grid[0]) or grid[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n        temp, grid[i][j] = grid[i][j], '/'\n        res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n        grid[i][j] = temp\n        return res\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g(grid=[\n    ['A', 'B', 'C', 'E'],\n    ['S', 'F', 'C', 'S'],\n    ['A', 'D', 'E', 'E']\n], word=\"ABCCED\"):\n    return grid, word\n\nassert f(*g())\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s and an integer k, return the length of the longest substring in s that contains at most k distinct characters.\n\n    Sample Input:\n    s = \"abcba\"\n    k = 2\n\n    Sample Output:\n    3\n    Explanation: The longest substring with at most 2 distinct characters is \"bcb\".\n\n    Sample Input:\n    s = \"abacabadabacaba\"\n    k = 3\n\n    Sample Output:\n    7\n    Explanation: The longest substring with at most 3 distinct characters is \"dabacab\".\n    \"\"\"\n    if k == 0:\n        return 0\n    max_length = 0\n    start = 0\n    char_count = {}\n    for end in range(len(s)):\n        char_count[s[end]] = char_count.get(s[end], 0) + 1\n        while len(char_count) > k:\n            char_count[s[start]] -= 1\n            if char_count[s[start]] == 0:\n                del char_count[s[start]]\n            start += 1\n        max_length = max(max_length, end - start + 1)\n    return max_length\n\ndef g(s: str = \"abcba\", k: int = 2):\n    return s, k\n\nassert f(*g()) == 3\n",
        "idx_generation": 166,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    stack = deque()\n    for c in s:\n        stack.append(c)\n    reversed_s = \"\"\n    while stack:\n        reversed_s += stack.pop()\n    return s == reversed_s\n\ndef g():\n    return \"madam\"\n\nassert f(g()) == True\n",
        "idx_generation": 0,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of characters, determine if it is possible to form a word by connecting adjacent letters horizontally or vertically.\n    Return True if a word can be formed, False otherwise.\n\n    Example:\n    grid = [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\n    f(grid) => True\n    Explanation: The word \"ABCDEF\" can be formed by connecting adjacent letters in the grid.\n    \"\"\"\n\n    word = \"\".join([\"\".join(row) for row in grid])\n    return \"ABCDEF\" in word\n\ndef g():\n    return [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\nassert f(g()) == True\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a string s and a grid of characters, determine if it is possible to form the string s by traversing the grid horizontally or vertically in a continuous path.\n    Return True if the string can be formed, False otherwise.\n\n    Example:\n    s = \"HELLO\"\n    grid = [['H', 'E', 'L'],\n            ['L', 'O', 'L']]\n\n    f(s, grid) => True\n    Explanation: The string \"HELLO\" can be formed by traversing the grid horizontally and vertically.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row, col, index):\n        if index == len(s):\n            return True\n        if row < 0 or row >= rows or col < 0 or col >= cols or s[index] != grid[row][col]:\n            return False\n\n        temp = grid[row][col]\n        grid[row][col] = '#'\n\n        result = dfs(row + 1, col, index + 1) or dfs(row - 1, col, index + 1) or dfs(row, col + 1, index + 1) or dfs(row, col - 1, index + 1)\n\n        grid[row][col] = temp\n\n        return result\n\n    for row in range(rows):\n        for col in range(cols):\n            if dfs(row, col, 0):\n                return True\n\n    return False\n\ndef g():\n    return \"HELLO\", [['H', 'E', 'L'],\n                     ['L', 'O', 'L']]\n\nassert f(*g()) == True\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    Input: n = 11\n    Output: 3\n    Explanation: The binary representation of 11 is \"1011\", which contains 3 1 bits.\n\n    Hint: Use bitwise operations to count the number of 1 bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int = 11) -> int:\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subsequence of the list such that the bitwise XOR\n    of the elements in the subsequence is equal to 0, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    subset_count = 2 ** n\n    for i in range(subset_count):\n        subset_xor = 0\n        for j in range(n):\n            if (i >> j) & 1:\n                subset_xor ^= nums[j]\n        if subset_xor == 0:\n            return True\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return (nums,)\n\nassert f(g()) == True\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, check if there exists a pair of numbers in the list\n    whose bitwise OR is equal to the target.\n    \"\"\"\n    stack = []\n    for num in arr:\n        complement = target ^ num\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers in the list whose bitwise AND is equal to the target value.\n\n    Example:\n    Input: nums = [2, 5, 3, 8, 6, 4], target = 4\n    Output: True\n\n    Explanation: The bitwise AND of 2 and 6 is 4.\n    \"\"\"\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == target:\n                return True\n\n    return False\n\ndef g():\n    nums = [2, 5, 3, 8, 6, 4]\n    target = 4\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits in the binary representation of all numbers from 1 to n (inclusive).\n    \"\"\"\n    def count_set_bits(n: int) -> int:\n        if n <= 0:\n            return 0\n        power = 0\n        while (1 << power) <= n:\n            power += 1\n        power -= 1\n        return (power * (1 << (power-1))) + (n - (1 << power) + 1) + count_set_bits(n - (1 << power))\n    \n    return count_set_bits(n)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an integer n such that n is greater than 0.\n    \"\"\"\n    return [10]\n\nassert f(*g()) == 17\n\n",
        "idx_generation": 48,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, nums=[10, 15, 20, 25]) -> bool:\n    \"\"\"Check if there exists a subset of nums whose bitwise XOR of all elements is equal to n.\"\"\"\n    def subset_xor(nums, n):\n        if n == 0:\n            return True\n        if not nums:\n            return False\n        include = subset_xor(nums[1:], n ^ nums[0])\n        exclude = subset_xor(nums[1:], n)\n        return include or exclude\n    return subset_xor(nums, n)\n\ndef g(nums=[10, 15, 20, 25]) -> int:\n    \"\"\"Find a value n such that there exists a subset of nums whose bitwise XOR of all elements is equal to n.\"\"\"\n    return 5\n\nassert f(g()) == True\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(n):\n            for i in range(col+1, n):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == 15\n",
        "idx_generation": 129,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, b: int) -> bool:\n    \"\"\"\n    Given two integers n and b, determine if the binary representation of n contains a consecutive sequence of b ones.\n\n    Sample Input:\n    n = 11\n    b = 2\n\n    Sample Output:\n    True\n    Explanation: The binary representation of 11 is '1011', which contains a consecutive sequence of 2 ones.\n\n    Sample Input:\n    n = 7\n    b = 3\n\n    Sample Output:\n    False\n    Explanation: The binary representation of 7 is '111', but it does not contain a consecutive sequence of 3 ones.\n    \"\"\"\n    binary = bin(n)[2:]\n    return '1' * b in binary\ndef g(n = 11, b = 2):\n    return n, b\nassert f(*g())\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Check if a string s can be rearranged such that every pair of adjacent characters have at most k bits difference.\n    \"\"\"\n    for i in range(len(s)-1):\n        if abs(ord(s[i]) - ord(s[i+1])) > k:\n            return False\n    return True\n\ndef g(s: str, k: int):\n    return s\n\ns = \"abcd\"\nk = 2\nassert f(g(s, k), k)\n",
        "idx_generation": 338,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, return True if the matrix is a magic square, and False otherwise.\n    A magic square is a square matrix in which the sums of the elements in each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[2, 9, 4],\n              [7, 5, 3],\n              [6, 1, 8]]\n    Output: True\n\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output: False\n    \"\"\"\n\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n\n        # Check rows\n        for row in matrix:\n            if sum(row) != target_sum:\n                return False\n\n        # Check columns\n        for j in range(n):\n            column_sum = 0\n            for i in range(n):\n                column_sum += matrix[i][j]\n            if column_sum != target_sum:\n                return False\n\n        # Check main diagonal\n        diagonal_sum = 0\n        for i in range(n):\n            diagonal_sum += matrix[i][i]\n        if diagonal_sum != target_sum:\n            return False\n\n        # Check secondary diagonal\n        diagonal_sum = 0\n        for i in range(n):\n            diagonal_sum += matrix[i][n - 1 - i]\n        if diagonal_sum != target_sum:\n            return False\n\n        return True\n\n    return is_magic_square(matrix)\n\ndef g() -> List[List[int]]:\n    return [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\n\nassert f(g()) == True\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if it is possible to obtain the target by performing a series of mathematical operations on the elements of the array.\n    Each element in the array can be used multiple times, and the operations allowed are addition, subtraction, multiplication, and division.\n    \"\"\"\n    stack = []\n    stack.append(arr[0])\n    for num in arr[1:]:\n        temp_stack = []\n        while stack:\n            temp = stack.pop()\n            temp_stack.append(temp + num)\n            temp_stack.append(temp - num)\n            temp_stack.append(temp * num)\n            if num != 0:\n                temp_stack.append(temp / num)\n        stack = temp_stack\n    return target in stack\n\ndef g(arr = [1, 2, 3, 4], target = 8):\n    return arr\n\nassert f(g(), 8)\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given list, such that the sum is less than or equal to the target number.\n    \"\"\"\n    dp = [0] * (target + 1)\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = max(dp[i], dp[i - num] + num)\n\n    return dp[-1]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == 10\n",
        "idx_generation": 64,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Sample Input:\n    n = 4\n\n    Sample Output:\n    5\n\n    Explanation: There are five ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 2 steps + 1 step + 1 step\n    3. 1 step + 2 steps + 1 step\n    4. 1 step + 1 step + 2 steps\n    5. 2 steps + 2 steps\n\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix where the sum of all elements is positive.\n\n    Sample Input:\n    matrix = [\n        [1, 2, -1],\n        [-2, 3, 4],\n        [5, -6, 7]\n    ]\n\n    Sample Output:\n    13\n\n    Explanation: The submatrix with the maximum sum is:\n    [\n        [2, -1],\n        [3, 4],\n        [-6, 7]\n    ] which has a sum of 13.\n\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a prefix sum matrix\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + matrix[i - 1][j - 1]\n\n    max_sum = float('-inf')\n\n    # Iterate over all possible submatrices\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i + 1, rows + 1):\n                for l in range(j + 1, cols + 1):\n                    submatrix_sum = prefix_sum[k][l] - prefix_sum[i][l] - prefix_sum[k][j] + prefix_sum[i][j]\n                    max_sum = max(max_sum, submatrix_sum)\n\n    return max_sum\n\n\ndef g():\n    matrix = [\n        [1, 2, -1],\n        [-2, 3, 4],\n        [5, -6, 7]\n    ]\n    return matrix\n\n\nassert f(g()) == 13\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains an integer, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Return the minimum cost.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum cost to reach the bottom-right cell from the top-left cell is 7, following the path: 1 -> 3 -> 1 -> 1 -> 1.\n    Therefore, the function should return 7.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 156,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the XOR of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [1, 2, 3] has a sum of 6, which is equal to the XOR of its elements (1 ^ 2 ^ 3 = 6).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    xor_sum = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        xor_sum ^= num\n\n        if prefix_sum - xor_sum in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it can be expressed as a sum of powers of 2.\n    \"\"\"\n    if n == 0:\n        return True\n    if n < 0:\n        return False\n    if f(n - 1) or f(n - 2) or f(n - 4) or f(n - 8):\n        return True\n    return False\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that can be expressed as a sum of powers of 2.\n    \"\"\"\n    return 19\n\nassert f(g()) == True\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if the given string is a decimal representation of a binary number divisible by n.\"\"\"\n    decimal = int(s)\n    binary = bin(decimal)[2:]\n    return decimal % n == 0 and binary.count('1') % 2 == 0\n\ndef g(n: int):\n    return str(int('101010', 2) * n)\n\nassert f(g(3), 3)\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a graph, find the shortest path from the start node to the end node using breadth-first search.\n    Return the length of the shortest path.\n    If there is no path from the start node to the end node, return -1.\n    \"\"\"\n\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        node, distance = queue.pop(0)\n\n        if node == end:\n            return distance\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for neighbor, weight in enumerate(graph[node]):\n            if weight > 0:\n                queue.append((neighbor, distance + weight))\n\n    return -1\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0],\n        [0, 1, 1, 0, 1, 1],\n        [0, 0, 1, 1, 0, 1],\n        [0, 0, 0, 1, 1, 0]\n    ]\n\nassert f(g(), 0, 5) == 3\n\n",
        "idx_generation": 384,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every two nodes are connected to each other by a path.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The graph has 2 connected components:\n    - Component 1: Nodes 0, 1\n    - Component 2: Nodes 2, 3\n\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                for neighbor in range(len(matrix)):\n                    if matrix[curr][neighbor] == 1 and not visited[neighbor]:\n                        stack.append(neighbor)\n    \n    n = len(matrix)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n    \n    return count\n\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == 2\n",
        "idx_generation": 325,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(points: List[List[int]], threshold: int) -> bool:\n    \"\"\"\n    Given a list of points in a 2D grid, determine if there exists a rectangle such that the sum of the values of all points inside the rectangle is greater than or equal to the given threshold.\n    Each point is represented by a list [x, y, value], where x and y are the coordinates of the point in the grid, and value is the value at that point.\n\n    Sample Input:\n    points = [[1, 1, 1], [1, 2, 2], [2, 1, 3], [2, 2, 4]]\n    threshold = 10\n\n    Sample Output:\n    True\n    Explanation: The rectangle with points [(1,1), (1,2), (2,1), (2,2)] has a sum of 10, which is equal to the threshold.\n\n    Sample Input:\n    points = [[1, 1, 1], [1, 2, 2], [2, 1, 3], [2, 2, 4]]\n    threshold = 5\n\n    Sample Output:\n    False\n    Explanation: There is no rectangle with a sum greater than or equal to the threshold.\n    \"\"\"\n    x_values = set()\n    y_values = set()\n    for point in points:\n        x_values.add(point[0])\n        y_values.add(point[1])\n    for x1 in x_values:\n        for x2 in x_values:\n            if x2 > x1:\n                for y1 in y_values:\n                    for y2 in y_values:\n                        if y2 > y1:\n                            total = 0\n                            for point in points:\n                                if x1 <= point[0] <= x2 and y1 <= point[1] <= y2:\n                                    total += point[2]\n                            if total >= threshold:\n                                return True\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of points in a 2D grid with random values.\n    \"\"\"\n    return [[i, j, i+j] for i in range(1, 4) for j in range(1, 4)]\n\nassert f(g(), 10)\n",
        "idx_generation": 75,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Return the length of the shortest path.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    queue = [(0, 0, 0)]\n    \n    while queue:\n        x, y, steps = queue.pop(0)\n        \n        if x == m-1 and y == n-1:\n            return steps\n        \n        if x+1 < m and grid[x+1][y] == 0:\n            queue.append((x+1, y, steps+1))\n        \n        if y+1 < n and grid[x][y+1] == 0:\n            queue.append((x, y+1, steps+1))\n    \n    return -1\n\n\ndef g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 47,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n        \n        while queue:\n            row, col, steps = queue.pop(0)\n            if (row, col) == (rows-1, cols-1):\n                return steps\n            \n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            \n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:\n                    queue.append((new_row, new_col, steps+1))\n        \n        return -1\n    \n    return bfs(0, 0)\n\ndef g() -> List[List[int]]:\n    grid = [[1, 1, 1, 1, 1],\n            [0, 0, 1, 0, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 1],\n            [1, 1, 1, 1, 1]]\n    return grid\n\nassert f(g()) == 8\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of steps required to reach the target cell from the starting cell.\n    You can only move up, down, left, or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initialize the queue for BFS\n    queue = []\n    queue.append((0, 0, 0))\n    \n    # Initialize the visited array to keep track of visited cells\n    visited = [[False] * cols for _ in range(rows)]\n    visited[0][0] = True\n    \n    # Perform BFS\n    while queue:\n        row, col, steps = queue.pop(0)\n        \n        # Check if the target cell has been reached\n        if row == rows-1 and col == cols-1:\n            return steps\n        \n        # Check neighboring cells\n        neighbors = [(row+1, col), (row-1, col), (row, col+1), (row, col-1)]\n        for neighbor in neighbors:\n            n_row, n_col = neighbor\n            if 0 <= n_row < rows and 0 <= n_col < cols and not visited[n_row][n_col]:\n                visited[n_row][n_col] = True\n                queue.append((n_row, n_col, steps+1))\n    \n    # Return -1 if no path is found\n    return -1\n\ndef g():\n    grid = [\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 0, 0, 0, 1]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, target: str, keyword: str) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes (strings) and the values are lists of nodes\n    that can be reached from the key node, find if there exists a path from the start node to the target node\n    containing a specific keyword.\n\n    Sample input:\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    keyword = 'ACD'\n\n    Sample output:\n    True\n\n    In the given graph, there exists a path from node 'A' to node 'F' that contains the keyword 'ACD': 'A' -> 'C' -> 'D' -> 'F'.\n    \"\"\"\n    visited = set()\n    queue = [(start, '')]\n    while queue:\n        node, path = queue.pop(0)\n        if node == target and keyword in path:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, path + node))\n    return False\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D', 'E'], 'D': ['F'], 'E': ['F'], 'F': []}\n    start = 'A'\n    target = 'F'\n    keyword = 'ACD'\n    return graph, start, target, keyword\n\nassert f(*g()) == True\n",
        "idx_generation": 233,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of letters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of adjacent cells (horizontally or vertically),\n    but a cell can only be used once in the word.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Explanation:\n    The word \"ABCCED\" can be formed by starting at (0,0) and moving right -> down -> down.\n\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(i, j, k):\n        if k == len(word):\n            return True\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        for dx, dy in directions:\n            ni, nj = i + dx, j + dy\n            if dfs(ni, nj, k + 1):\n                return True\n        \n        grid[i][j] = temp\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n    return grid, word\n\nassert f(*g()) == True\n\n",
        "idx_generation": 73,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a grid of characters and a word, determine if the word can be formed by connecting adjacent letters horizontally or vertically in the grid.\n    Return True if the word can be formed, False otherwise.\n\n    Example:\n    grid = [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\n    word = \"ABC\"\n    f(grid, word) => True\n\n    Explanation: The word \"ABC\" can be formed by connecting adjacent letters in the grid.\n    \"\"\"\n\n    def dfs(row: int, col: int, word: str, index: int) -> bool:\n        if index == len(word):\n            return True\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or word[index] != grid[row][col]:\n            return False\n\n        temp = grid[row][col]\n        grid[row][col] = '#'\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if dfs(row + dr, col + dc, word, index + 1):\n                return True\n\n        grid[row][col] = temp\n\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == word[0] and dfs(i, j, word, 0):\n                return True\n\n    return False\n\ndef g():\n    return [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\nassert f(g(), \"ABC\")\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of characters representing a maze, where 'S' represents the starting point, 'E' represents the ending point,\n    '#' represents a wall, and '.' represents an empty space, find the minimum number of steps required to reach the ending point\n    from the starting point. You can only move up, down, left, or right, and you cannot pass through walls.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\n    The minimum number of steps required to reach the ending point from the starting point is 6, following the path: S -> right -> right -> down -> down -> down -> E.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n            if grid[row][col] == 'E':\n                return steps\n\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#':\n                    queue.append((new_row, new_col, steps+1))\n\n        return -1\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                return bfs(i, j)\n\n    return -1\n\ndef g() -> List[List[str]]:\n    return [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the maximum XOR value between any two nodes.\n\n    Return the maximum XOR value.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    The maximum XOR value between any two nodes in the graph is 3, which can be obtained by XORing the nodes 0 and 1.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(graph)):\n        for j in range(len(graph[0])):\n            if graph[i][j] == 1:\n                xor = i ^ j\n                max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph represented as an adjacency matrix for Puzzle 3.\n    \"\"\"\n    return [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 229,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value of any two numbers in the list.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n\n    Explanation: The maximum XOR value is achieved by combining 5 (binary: 101) and 25 (binary: 11001), which results in 28 (binary: 11100).\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n    \n    def insert(num: int, root: TrieNode) -> None:\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n    \n    def find_max_xor(num: int, root: TrieNode) -> int:\n        xor = 0\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            opposite_bit = 1 - bit\n            if opposite_bit in node.children:\n                xor |= (1 << i)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(num, root)\n    \n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, find_max_xor(num, root))\n    \n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, m: int, pairs: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Given a list of pairs representing dependencies between tasks, return a valid order in which the tasks can be\n    completed. Each pair (a, b) represents that task a must be completed before task b. It is guaranteed that there\n    are no circular dependencies in the input.\n\n    Sample Input:\n    n = 4\n    m = 3\n    pairs = [(1, 2), (2, 3), (3, 4)]\n\n    Sample Output:\n    [1, 2, 3, 4]\n\n    Explanation: The valid order of tasks is [1, 2, 3, 4], where task 1 is completed first, followed by task 2, then\n    task 3, and finally task 4.\n\n    \"\"\"\n    graph = {i: [] for i in range(1, n + 1)}\n    in_degrees = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in pairs:\n        graph[a].append(b)\n        in_degrees[b] += 1\n\n    queue = [i for i in range(1, n + 1) if in_degrees[i] == 0]\n    order = []\n\n    while queue:\n        task = queue.pop(0)\n        order.append(task)\n\n        for neighbor in graph[task]:\n            in_degrees[neighbor] -= 1\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order\n\ndef g():\n    n = 4\n    m = 3\n    pairs = [(1, 2), (2, 3), (3, 4)]\n    return n, m, pairs\n\nassert f(*g()) == [1, 2, 3, 4]\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target=8) -> bool:\n    \"\"\"Find a path from the top-left corner to the bottom-right corner of the matrix, where the sum of the numbers along the path equals to target\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, path_sum):\n        if i >= m or j >= n:\n            return False\n        if path_sum + matrix[i][j] == target:\n            return True\n        return dfs(i+1, j, path_sum + matrix[i][j]) or dfs(i, j+1, path_sum + matrix[i][j])\n    \n    return dfs(0, 0, 0)\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 8):\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, find a path from the top-left corner to the bottom-right corner with the maximum sum. At\n    each step, you can only move right or down.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\nassert f(g()) == 12\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\n\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])\n\n\nassert f(g(), 10) == True\n",
        "idx_generation": 48,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target value, find the number of unique combinations\n    of numbers in the list that add up to the target. Each number in the list may be used\n    multiple times in each combination.\n\n    Example:\n    nums = [1, 2, 3], target = 4\n    Output: 7\n\n    nums = [2, 5, 9], target = 12\n    Output: 4\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g(), 4) == 7\n",
        "idx_generation": 258,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a given word in the grid.\n    The word can be found in horizontal, vertical, or diagonal directions.\n    Return the count.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def search(word: str, row: int, col: int, dr: int, dc: int) -> bool:\n        for char in word:\n            if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != char:\n                return False\n            row += dr\n            col += dc\n        return True\n    \n    count = 0\n    directions = [(0, 1), (1, 0), (1, 1), (-1, 1)]\n    \n    for row in range(rows):\n        for col in range(cols):\n            for dr, dc in directions:\n                count += search(\"word\", row, col, dr, dc)\n    \n    return count\n\n\ndef g():\n    grid = [\n        [\"a\", \"b\", \"c\", \"d\"],\n        [\"e\", \"f\", \"g\", \"h\"],\n        [\"i\", \"j\", \"k\", \"l\"],\n        [\"m\", \"n\", \"o\", \"p\"]\n    ]\n    return grid\n\nassert f(g()) == 0\n",
        "idx_generation": 390,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [3, 10, 5, 8, 2]\n\nassert f(g()) == 15\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Find whether there are k numbers in the given list whose sum is divisible by k\n    \"\"\"\n    from itertools import combinations\n    for c in combinations(nums, k):\n        if sum(c) % k == 0:\n            return True\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6], k = 3):\n    return nums\n\nassert f(g(), 3)\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Return the index if the target is found, -1 otherwise.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int], target: int) -> int:\n    \"\"\"\n    Generate a sorted list of integers and a target element.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 6\nassert f(*g(nums, target)) == 5\n\n",
        "idx_generation": 71,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a sorted matrix of integers in ascending order from left to right and top to bottom, and a target value,\n    return True if the target value is present in the matrix, otherwise return False. Implement the solution using\n    optimized search.\n\n    Sample Input:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n\n    Sample Output:\n    True\n\n    \"\"\"\n    if not matrix:\n        return False\n    \n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    \n    return False\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n",
        "idx_generation": 30,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there exists a combination of numbers in the list that adds up to the target.\n    The combination should have the maximum sum of elements.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The combination [3, 7] adds up to 10, which has the maximum sum of elements.\n    \"\"\"\n\n    def backtrack(nums, start, target, path, result, max_sum):\n        if target == 0:\n            if sum(path) > max_sum[0]:\n                max_sum[0] = sum(path)\n                result[0] = path[:]\n            return\n\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(nums, i, target - nums[i], path, result, max_sum)\n            path.pop()\n\n    result = [None]\n    max_sum = [float('-inf')]\n    nums.sort()\n    backtrack(nums, 0, target, [], result, max_sum)\n    return result[0] is not None\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 3, 5, 7]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 272,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\nfrom collections import deque\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find the maximum element in each sliding window of size k in the given list of integers.\n    \"\"\"\n    result = []\n    window = deque()\n    \n    for i, num in enumerate(nums):\n        while window and nums[window[-1]] <= num:\n            window.pop()\n        \n        window.append(i)\n        \n        if window[0] == i - k:\n            window.popleft()\n        \n        if i >= k - 1:\n            result.append(nums[window[0]])\n    \n    return result\n\ndef g(k: int) -> List[int]:\n    nums = [1, 3, -1, -3, 5, 3, 6, 7]\n    return nums, k\n\nassert f(*g(3)) == [3, 3, 5, 5, 6, 7]\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exist three elements in the list that form a geometric progression,\n    and False otherwise. A geometric progression is a sequence of numbers where each term after the first is found by multiplying the previous term by a fixed, non-zero number called the common ratio.\n    \"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if nums[i + 1] / nums[i] == nums[i + 2] / nums[i + 1]:\n            return True\n    return False\n\n\ndef g(nums: List[int]) -> bool:\n    \"\"\"\n    Generate a list of integers such that there exist three elements in the list that form a geometric progression.\n    \"\"\"\n    nums.sort()\n    return nums\n\n# Test case\nnums = [2, 4, 8, 16, 32]\nassert f(g(nums))\n",
        "idx_generation": 10,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s consisting of parentheses, square brackets, and curly braces,\n    determine if the input string is balanced.\n\n    A string is considered balanced if every opening bracket has a corresponding closing bracket of the same type,\n    and the brackets are properly nested.\n\n    Example:\n    Input: s = \"({[]})\"\n    Output: True\n\n    Explanation: The input string is balanced because every opening bracket has a corresponding closing bracket\n    of the same type, and the brackets are properly nested.\n\n    Input: s = \"([)]\"\n    Output: False\n\n    Explanation: The input string is not balanced because the opening square bracket does not have a corresponding\n    closing square bracket.\n\n    Hint: Use a stack to keep track of opening brackets and check if the closing bracket matches the top of the stack.\n    \"\"\"\n\n    stack = []\n    mapping = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    }\n\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return len(stack) == 0\n\ndef g():\n    s = \"({[]})\"\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 396,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\n    \"\"\"\n    def search(matrix: List[List[int]], target: int, row: int, col: int) -> bool:\n        if row >= len(matrix) or col < 0:\n            return False\n        if matrix[row][col] == target:\n            return True\n        if matrix[row][col] > target:\n            return search(matrix, target, row, col-1)\n        return search(matrix, target, row+1, col)\n\n    if not matrix or not matrix[0]:\n        return False\n    return search(matrix, target, 0, len(matrix[0])-1)\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a matrix and a target value.\n    \"\"\"\n    matrix = [[1, 3, 5], [7, 9, 11], [13, 15, 17]]\n    target = 9\n    return matrix, target\n\nassert f(*g()) == True\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an n x m matrix, return the elements of the matrix in spiral order.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The elements of the matrix in spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n    row_begin = 0\n    row_end = len(matrix) - 1\n    col_begin = 0\n    col_end = len(matrix[0]) - 1\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end + 1):\n            result.append(matrix[row_begin][i])\n        row_begin += 1\n        for i in range(row_begin, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n        if row_begin <= row_end:\n            for i in range(col_end, col_begin - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n        if col_begin <= col_end:\n            for i in range(row_end, row_begin - 1, -1):\n                result.append(matrix[i][col_begin])\n            col_begin += 1\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 217,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers, find the length of the shortest subarray whose sum is greater than or equal to the target.\n    If no such subarray exists, return 0.\n    \"\"\"\n    n = len(arr)\n    min_len = float('inf')\n    start = 0\n    curr_sum = 0\n\n    for end in range(n):\n        if arr[end] >= target:\n            return 1\n        \n        curr_sum += arr[end]\n\n        while curr_sum >= target:\n            min_len = min(min_len, end - start + 1)\n            curr_sum -= arr[start]\n            start += 1\n\n    return 0 if min_len == float('inf') else min_len\n\ndef g(arr=[2, 3, 1, 2, 4, 3], target=7):\n    return arr, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 150,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, check if the target number exists in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\n\ndef g(target=3):\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g(), target=3) == True\n\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, rotate it 90 degrees clockwise.\n\n    Return the rotated grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The rotated grid should be:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Therefore, the function should return:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    rotated_grid = [[0] * rows for _ in range(cols)]\n\n    for i in range(rows):\n        for j in range(cols):\n            rotated_grid[j][rows - 1 - i] = grid[i][j]\n\n    return rotated_grid\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int, n: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of elements whose XOR is equal to the target.\n    The list has n elements.\n    \"\"\"\n    left, right = 0, n - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr: List[int], target: int, n: int):\n    return arr\n\narr = [1, 2, 3, 4, 5, 6]\ntarget = 7\nn = len(arr)\nassert f(g(arr, target, n), target, n)\n",
        "idx_generation": 25,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a power of 2.\"\"\"\n    return n & (n - 1) == 0\ndef g():\n    power_of_2 = 1\n    while True:\n        if f(power_of_2):\n            return power_of_2\n        power_of_2 += 1\nassert f(g()) == True\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that AND to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that AND to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        and_value = numbers[left] & numbers[right]\n        if and_value == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif and_value < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 0\n    substring = \"28\"\n    return numbers, target, substring\n\nassert f(*g()) == True\n",
        "idx_generation": 409,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers arr and a target integer, find the index of the target using binary search.\n    Return -1 if the target is not in the list.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n\ndef g():\n    arr = [2, 4, 6, 8, 10, 12, 14, 16]\n    target = 10\n    return arr, target\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 158,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Generate the first n numbers in the Fibonacci sequence.\n    Return the list of generated numbers.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return [fibonacci(i) for i in range(n)]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == [0, 1, 1, 2, 3]\n",
        "idx_generation": 318,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n    Explanation: The maximum sum of a path is 12 (1 -> 3 -> 5 -> 2 -> 1).\n\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n    Explanation: The maximum sum of a path is 29 (1 -> 2 -> 3 -> 6 -> 9).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n\n    The function should return 20 since the maximum product is 4 * 5 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(num: int, target: int) -> bool:\n    \"\"\"\n    Given a number num, determine if it is possible to obtain the target number by performing a series of mathematical operations on the digits of the number.\n    The operations allowed are addition, subtraction, multiplication, and division.\n    The order of the digits cannot be changed.\n    \"\"\"\n    num_str = str(num)\n    stack = []\n    stack.append(int(num_str[0]))\n    for digit in num_str[1:]:\n        temp_stack = []\n        while stack:\n            temp = stack.pop()\n            temp_stack.append(temp + int(digit))\n            temp_stack.append(temp - int(digit))\n            temp_stack.append(temp * int(digit))\n            if int(digit) != 0:\n                temp_stack.append(temp / int(digit))\n        stack = temp_stack\n    return target in stack\n\ndef g(num = 1234, target = 5):\n    return num\n\nassert f(g(), 5)\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the corresponding element.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n\n    Explanation: The product of all the elements in the original list except the first element is 2*3*4*5 = 120. The product of all the elements except the second element is 1*3*4*5 = 60, and so on.\n    \"\"\"\n\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = nums[i-1] * left_products[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_products[i] = nums[i+1] * right_products[i+1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number is a palindrome in base 2, base 8, and base 10.\n    \"\"\"\n    binary = bin(n)[2:]\n    octal = oct(n)[2:]\n    decimal = str(n)\n    \n    return binary == binary[::-1] and octal == octal[::-1] and decimal == decimal[::-1]\n\ndef g():\n    \"\"\"\n    Generate a number that is a palindrome in base 2, base 8, and base 10.\n    \"\"\"\n    return 585\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if a given grid forms a valid sudoku solution.\n    \"\"\"\n    def is_valid_row(grid, row):\n        seen = set()\n        for num in grid[row]:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    def is_valid_column(grid, col):\n        seen = set()\n        for row in range(9):\n            num = grid[row][col]\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    def is_valid_box(grid, start_row, start_col):\n        seen = set()\n        for row in range(start_row, start_row+3):\n            for col in range(start_col, start_col+3):\n                num = grid[row][col]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        return True\n    \n    for i in range(9):\n        if not is_valid_row(grid, i) or not is_valid_column(grid, i):\n            return False\n    \n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_box(grid, i, j):\n                return False\n    \n    return True\n\ndef g():\n    grid = [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 14,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise in-place.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    After rotating the matrix 90 degrees clockwise, the resulting matrix is:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Therefore, the function should return the rotated matrix:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n\n",
        "idx_generation": 269,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Spiral Matrix\n\n    Given a matrix of integers, traverse the matrix in a spiral order (starting from the top-left element)\n    and return a list of the visited elements.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    def traverse(matrix, row_start, row_end, col_start, col_end):\n        result = []\n        if row_start <= row_end and col_start <= col_end:\n            # Traverse top row\n            for col in range(col_start, col_end + 1):\n                result.append(matrix[row_start][col])\n            row_start += 1\n\n            # Traverse right column\n            for row in range(row_start, row_end + 1):\n                result.append(matrix[row][col_end])\n            col_end -= 1\n\n            # Traverse bottom row\n            if row_start <= row_end:\n                for col in range(col_end, col_start - 1, -1):\n                    result.append(matrix[row_end][col])\n                row_end -= 1\n\n            # Traverse left column\n            if col_start <= col_end:\n                for row in range(row_end, row_start - 1, -1):\n                    result.append(matrix[row][col_start])\n                col_start += 1\n\n            result += traverse(matrix, row_start, row_end, col_start, col_end)\n\n        return result\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    return traverse(matrix, 0, rows - 1, 0, cols - 1)\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 77,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of positive integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by taking XOR of 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n    \n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n    \n    def find_max_xor(num, root):\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor_val |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        \n        return xor_val\n    \n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(num, root)\n        max_xor = max(max_xor, find_max_xor(num, root))\n    \n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 113,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there exist two numbers in the list that sum up to the target.\"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums = [1, 5, 3, 9, 2], target = 8):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of letters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of adjacent cells (horizontally, vertically, or diagonally),\n    but a cell can only be used once in the word.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"SEE\"\n\n    Output:\n    True\n\n    Explanation:\n    The word \"SEE\" can be formed by starting at (0,1) and moving diagonally -> down -> diagonally.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    def dfs(i, j, k):\n        if k == len(word):\n            return True\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        for dx, dy in directions:\n            ni, nj = i + dx, j + dy\n            if dfs(ni, nj, k + 1):\n                return True\n        \n        grid[i][j] = temp\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"SEE\"\n    return grid, word\n\nassert f(*g()) == True\n",
        "idx_generation": 231,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the spiral order of the matrix.\n\n    Sample input:\n    [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, m - 1, 0, n - 1\n    direction = 0\n    result = []\n\n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        direction = (direction + 1) % 4\n\n    return result\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 137,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is obtained by taking the XOR of 5 and 25, which equals 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the maximum XOR value of any two elements in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n\n            node = node.children[bit]\n\n    def find_max_xor(num, root):\n        node = root\n        xor_value = 0\n\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            opposite_bit = 1 - bit\n\n            if opposite_bit in node.children:\n                xor_value |= (1 << i)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[bit]\n\n        return xor_value\n\n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(num, root)\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> int:\n    \"\"\"\n    Given a 2D grid of integers where each cell contains a positive integer, find the number of pairs of cells in the grid whose bitwise XOR is equal to the target number.\n\n    Example:\n    Input: grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 14\n    Output: 1\n\n    Explanation:\n    6 ^ 8 = 14, which is equal to the target number.\n    Therefore, there is one pair of cells whose bitwise XOR is equal to the target number.\n    \"\"\"\n    count = 0\n    rows, cols = len(grid), len(grid[0])\n    nums = sorted(grid[i][j] for i in range(rows) for j in range(cols))\n    left, right = 0, rows * cols - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a 2D grid of integers and a target number, where there exists pairs of cells in the grid whose bitwise XOR is equal to the target number.\n    \"\"\"\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 14)\n\nassert f(*g()) == 1\n",
        "idx_generation": 280,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output: 29\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 29\n",
        "idx_generation": 347,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find two numbers such that they add up to the target and return their indices.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] = 2 and nums[1] = 7 is 9, so the indices [0, 1] are returned.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any subgrid with dimensions 2x2.\n    \"\"\"\n    max_sum = float('-inf')\n    \n    for i in range(len(grid) - 1):\n        for j in range(len(grid[0]) - 1):\n            subgrid_sum = grid[i][j] + grid[i][j+1] + grid[i+1][j] + grid[i+1][j+1]\n            max_sum = max(max_sum, subgrid_sum)\n    \n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n    return grid\n\nassert f(g()) == 38\n",
        "idx_generation": 255,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Given a list of integers, find if there exists a pair of numbers such that their sum equals the target number.\n    Return True if such a pair exists, otherwise return False.\"\"\"\n    nums_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in nums_set:\n            return True\n    return False\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 12)\n",
        "idx_generation": 78,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given grid is a valid Sudoku solution.\n    Each row, column, and 3x3 sub-grid should contain all numbers from 1 to 9 without repetition.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if not is_valid(row):\n            return False\n    \n    # Check columns\n    for col in range(n):\n        column = [grid[row][col] for row in range(n)]\n        if not is_valid(column):\n            return False\n    \n    # Check 3x3 sub-grids\n    for i in range(0, n, 3):\n        for j in range(0, n, 3):\n            sub_grid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid(sub_grid):\n                return False\n    \n    return True\n\ndef is_valid(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of numbers is valid, i.e., contains all numbers from 1 to 9 without repetition.\n    \"\"\"\n    num_set = set(nums)\n    return len(num_set) == 9 and all(num in num_set for num in range(1, 10))\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given list whose sum is equal to the target.\n    \"\"\"\n    num_set = set()\n    \n    for num in nums:\n        complement = target - num\n        \n        if complement in num_set:\n            return True\n        \n        num_set.add(num)\n    \n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(num, root):\n        curr = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not curr.children[bit]:\n                curr.children[bit] = TrieNode()\n            curr = curr.children[bit]\n\n    def findMaxXOR(nums):\n        root = TrieNode()\n        for num in nums:\n            insert(num, root)\n\n        max_xor = float('-inf')\n        for num in nums:\n            curr = root\n            xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if curr.children[1 - bit]:\n                    xor |= 1 << i\n                    curr = curr.children[1 - bit]\n                else:\n                    curr = curr.children[bit]\n            max_xor = max(max_xor, xor)\n\n        return max_xor\n\n    return findMaxXOR(nums)\n\ndef g(nums):\n    return nums\n\nassert f(g([3, 10, 5, 25, 2, 8])) == 28\n\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"Find the maximum sum of elements in a rectangular subgrid of the given grid, where each element has only\n    one bit set to 1.\"\"\"\n    max_sum = 0\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k+1):\n                        for n in range(j, l+1):\n                            if bin(grid[m][n]).count('1') == 1:\n                                subgrid_sum += grid[m][n]\n                    max_sum = max(max_sum, subgrid_sum)\n    return max_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n",
        "idx_generation": 30,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Sample input:\n    nums = [2, 3, 4, 5, 6]\n\n    Sample output:\n    30\n\n    Explanation:\n    The maximum product is obtained by multiplying 5 and 6, which gives 30.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    nums = [2, 3, 4, 5, 6]\n    return [nums]\n\nassert f(*g()) == 30\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int, div=3, mod=2) -> bool:\n    \"\"\"Check if a number is divisible by div and leaves a remainder of mod\"\"\"\n    return num % div == mod\ndef g(div=3, mod=2):\n    num = 0\n    while True:\n        if f(num):\n            return num\n        num += 1\nassert f(g()) == True\n",
        "idx_generation": 49,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subarray in nums that sums up to the target.\n    \"\"\"\n    prefix_sum = 0\n    seen_sum = set()\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == target or prefix_sum - target in seen_sum:\n            return True\n        \n        seen_sum.add(prefix_sum)\n    \n    return False\n\ndef g():\n    nums = [4, -3, 2, 1, 8, -6]\n    target = 3\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and an integer k, return True if there exists a subarray of arr with length k,\n    such that the sum of its elements is divisible by k, and False otherwise.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = deque()\n    \n    for num in arr:\n        prefix_sum += num\n        prefix_sums.append(prefix_sum)\n        \n        if len(prefix_sums) > k:\n            prefix_sum -= prefix_sums.popleft()\n        \n        if len(prefix_sums) == k and prefix_sum % k == 0:\n            return True\n    \n    return False\n\ndef g(arr: List[int], k: int):\n    return arr\n\nassert f(g([1, 2, 3, 4, 5], 3), 3)\n",
        "idx_generation": 27,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list that sums up to zero.\n    \"\"\"\n    prefix_sum = 0\n    seen_sum = set()\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == 0 or prefix_sum in seen_sum:\n            return True\n        \n        seen_sum.add(prefix_sum)\n    \n    return False\n\ndef g():\n    nums = [4, -3, 2, 1, 8, -6]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 88,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the maximum sum of numbers in a rectangle subgrid within the grid.\n\n    Example:\n    Input: grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n\n    Explanation: The maximum sum can be obtained by selecting the subgrid [4, 5, 6], [7, 8, 9].\n\n    Constraints:\n    - The input grid is a rectangular grid containing at most 10^3 rows and columns.\n    - Each element in the grid is an integer.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = sum(grid[x][y] for x in range(i, k+1) for y in range(j, l+1))\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 45\n\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"Check if the given matrix is a magic square.\"\"\"\n    n = len(matrix)\n    target_sum = n * (n**2 + 1) // 2  # The sum of each row, column, and diagonal in a magic square\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(row[col] for row in matrix) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [[8, 1, 6], [3, 5, 7], [4, 9, 2]]  # Example of a 3x3 magic square\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a submatrix such that:\n        - The sum of all the elements in the submatrix is even.\n        - The number of even elements in the submatrix is greater than the number of odd elements.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    submatrix_sum = 0\n                    count_even = 0\n                    count_odd = 0\n                    for r in range(i, x + 1):\n                        for c in range(j, y + 1):\n                            submatrix_sum += matrix[r][c]\n                            if matrix[r][c] % 2 == 0:\n                                count_even += 1\n                            else:\n                                count_odd += 1\n                    if submatrix_sum % 2 == 0 and count_even > count_odd:\n                        return True\n    return False\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    12\n    Explanation: The even numbers in the list are 2, 4, and 6. Their sum is 12.\n\n    Sample Input:\n    nums = [3, 6, 9, 12, 15]\n\n    Sample Output:\n    18\n    Explanation: The even numbers in the list are 6 and 12. Their sum is 18.\n\n    \"\"\"\n\n    sum_even = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            sum_even += num\n\n    return sum_even\n\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return (nums,)\n\n\nassert f(*g()) == 12\n\n",
        "idx_generation": 380,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, generate a list of size n where each element is a multiple of k.\n\n    Example:\n    Input:\n    n = 5\n    k = 3\n\n    Output:\n    [0, 3, 6, 9, 12]\n\n    Explanation:\n    The list contains 5 elements, each of which is a multiple of 3.\n    \"\"\"\n\n    # Generate a list of size n where each element is a multiple of k\n    return [i * k for i in range(n)]\n\ndef g():\n    n = 5\n    k = 3\n    return [n, k]\n\nassert f(*g()) == [0, 3, 6, 9, 12]\n",
        "idx_generation": 207,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Example:\n    n = 3\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    The possible XOR values for the pairs of elements are: 1 ^ 2 = 3, 1 ^ 3 = 2, 2 ^ 3 = 1, 4 ^ 5 = 1, 4 ^ 6 = 2, 5 ^ 6 = 3, 7 ^ 8 = 15, 7 ^ 9 = 14, 8 ^ 9 = 1\n\n    The maximum XOR value is 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n\n    max_xor = 0\n    for row in grid:\n        for col in range(n):\n            for i in range(col+1, n):\n                max_xor = max(max_xor, row[col] ^ row[i])\n\n    return max_xor\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == 15\n\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a binary representation of a palindrome number.\"\"\"\n    return s == s[::-1] and int(s, 2) % 2 == 1\n\ndef g():\n    return bin(21)[2:]\n\nassert f(g()) == True\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return its binary representation as a string.\n\n    Example:\n    Input: 7\n    Output: \"111\"\n    \"\"\"\n\n    if n == 0:\n        return \"0\"\n\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n //= 2\n\n    return binary\n\ndef g():\n    n = 7\n    return n\n\nassert f(g()) == \"111\"\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid.\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a subgrid is 45, which corresponds to the entire grid.\n\n    Therefore, the function should return 45.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a prefix sum grid\n    prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    # Compute the prefix sum grid\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            prefix_sum[i][j] = prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1]\n\n    # Find the maximum sum of a subgrid\n    max_sum = float('-inf')\n\n    for r1 in range(rows):\n        for c1 in range(cols):\n            for r2 in range(r1, rows):\n                for c2 in range(c1, cols):\n                    subgrid_sum = prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r2 + 1][c1] - prefix_sum[r1][c2 + 1] + prefix_sum[r1][c1]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(points: List[List[int]], k: int) -> bool:\n    \"\"\"\n    Given a list of 2D points and an integer k, determine if there exists a line that divides the points into two groups,\n    such that the difference between the number of points in the two groups is at most k.\n\n    Example:\n    points = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    k = 1\n    output: True\n\n    Explanation: There exists a line that can divide the points into two groups such that the difference between the\n    number of points in the two groups is at most 1. One possible line is x = 5.\n\n    Note: The line does not necessarily need to pass through any of the points.\n    \"\"\"\n\n    x_coords = [point[0] for point in points]\n    x_mean = sum(x_coords) / len(x_coords)\n\n    num_points_left = sum(1 for point in points if point[0] < x_mean)\n    num_points_right = len(points) - num_points_left\n\n    return abs(num_points_left - num_points_right) <= k\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a list of 2D points and an integer k.\n    \"\"\"\n    points = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    k = 1\n\n    return points, k\n\nassert f(*g()) == True\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to place n non-attacking rooks on the grid,\n    where a rook can attack any other rook if they are in the same row or column.\n\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    rows = [0] * n\n    cols = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n                cols[j] += 1\n    return all(r <= 1 and c <= 1 for r, c in zip(rows, cols))\n\ndef g(n = 4):\n    grid = [[1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]]\n    return n, grid\n\nassert f(*g())\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to place n non-attacking rooks on the grid,\n    where a rook can attack any other rook if they are in the same row or column.\n\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    rows = [0] * n\n    cols = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n                cols[j] += 1\n    return all(r <= 1 and c <= 1 for r, c in zip(rows, cols))\ndef g(n = 4):\n    grid = [[1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]]\n    return n, grid\nassert f(*g())\n",
        "idx_generation": 32,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two distinct numbers in the array.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation:\n    - The maximum XOR value can be obtained by taking XOR of 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(num, root):\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor_val |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n\n        return xor_val\n\n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(num, root)\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any hourglass shape within the grid.\n    An hourglass shape is defined by a set of 7 cells in the following pattern:\n\n        a b c\n          d\n        e f g\n\n    Example:\n    grid = [\n        [-9, -9, -9, 1, 1, 1],\n        [0, -9, 0, 4, 3, 2],\n        [-9, -9, -9, 1, 2, 3],\n        [0, 0, 8, 6, 6, 0],\n        [0, 0, 0, -2, 0, 0],\n        [0, 0, 1, 2, 4, 0]\n    ]\n\n    The maximum sum of any hourglass shape is 28, which is obtained from the hourglass shape [-9, -9, -9, -9, -9, -9, 1].\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_sum = float('-inf')\n\n    for i in range(len(grid)-2):\n        for j in range(len(grid[0])-2):\n            hourglass_sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\n            max_sum = max(max_sum, hourglass_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [-9, -9, -9, 1, 1, 1],\n        [0, -9, 0, 4, 3, 2],\n        [-9, -9, -9, 1, 2, 3],\n        [0, 0, 8, 6, 6, 0],\n        [0, 0, 0, -2, 0, 0],\n        [0, 0, 1, 2, 4, 0]\n    ]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth number in the Fibonacci sequence.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n - 1) + f(n - 2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n to calculate the nth number in the Fibonacci sequence.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find the minimum number of steps required to reach the end of nums, where each element represents the maximum number of steps that can be jumped.\"\"\"\n    if not nums:\n        return False\n    n = len(nums)\n    if n == 1:\n        return True\n    steps = [float('inf')] * n\n    steps[0] = 0\n    for i in range(n):\n        for j in range(1, nums[i]+1):\n            if i+j < n:\n                steps[i+j] = min(steps[i+j], steps[i]+1)\n    return steps[n-1]\ndef g():\n    return [2, 3, 1, 1, 4]\nassert f(g()) == 2\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner,\n    where the sum of the values along the path is a perfect square.\n    You can only move down or right, and you can start and end at any cell.\n    Return True if such a path exists, otherwise return False.\n    \"\"\"\n    def is_perfect_square(num: int) -> bool:\n        \"\"\"\n        Check if a number is a perfect square.\n        \"\"\"\n        root = int(num ** 0.5)\n        return root * root == num\n\n    def find_path(matrix: List[List[int]], i: int, j: int, curr_sum: int) -> bool:\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return is_perfect_square(curr_sum + matrix[i][j])\n\n        if i < len(matrix) - 1 and find_path(matrix, i + 1, j, curr_sum + matrix[i][j]):\n            return True\n\n        if j < len(matrix[0]) - 1 and find_path(matrix, i, j + 1, curr_sum + matrix[i][j]):\n            return True\n\n        return False\n\n    return find_path(matrix, 0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 318,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if the given grid represents a valid Sudoku solution.\n    \"\"\"\n    def is_valid_row(grid, row):\n        seen = set()\n        for num in grid[row]:\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    \n    def is_valid_column(grid, col):\n        seen = set()\n        for row in range(len(grid)):\n            num = grid[row][col]\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    \n    def is_valid_box(grid, start_row, start_col):\n        seen = set()\n        for row in range(start_row, start_row+3):\n            for col in range(start_col, start_col+3):\n                num = grid[row][col]\n                if num != 0 and num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    for row in range(len(grid)):\n        if not is_valid_row(grid, row):\n            return False\n    \n    for col in range(len(grid[0])):\n        if not is_valid_column(grid, col):\n            return False\n    \n    for start_row in range(0, len(grid), 3):\n        for start_col in range(0, len(grid[0]), 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n    \n    return True\n\ndef g(grid=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    \"\"\"\n    Solve the Sudoku puzzle and return the grid.\n    \"\"\"\n    def solve_sudoku(grid, row, col):\n        if col == len(grid[0]):\n            col = 0\n            row += 1\n        \n        if row == len(grid):\n            return grid\n        \n        if grid[row][col] != 0:\n            return solve_sudoku(grid, row, col+1)\n        \n        for num in range(1, 10):\n            if is_valid(grid, row, col, num):\n                grid[row][col] = num\n                if solve_sudoku(grid, row, col+1):\n                    return grid\n                grid[row][col] = 0\n        \n        return None\n    \n    def is_valid(grid, row, col, num):\n        for i in range(len(grid)):\n            if grid[i][col] == num:\n                return False\n        \n        for j in range(len(grid[0])):\n            if grid[row][j] == num:\n                return False\n        \n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(3):\n            for j in range(3):\n                if grid[start_row+i][start_col+j] == num:\n                    return False\n        \n        return True\n    \n    return solve_sudoku(grid, 0, 0)\n\nassert f(g()) == True\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a subgrid within the grid.\n    A subgrid is defined as a contiguous block of cells within the grid.\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The function should return 45 since the maximum sum is obtained from the entire grid.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    current_sum = 0\n                    for row in range(i, k + 1):\n                        for col in range(j, l + 1):\n                            current_sum += grid[row][col]\n                    max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    Input: matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to 9, which is the target.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    return [[2, 7, 11, 15], 9]\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only '(' and ')', determine if the string is balanced,\n    i.e., for every '(' there is a corresponding ')'.\n    \"\"\"\n    stack = deque()\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    \"\"\"\n    Generate a string containing only '(' and ')' such that the string is balanced.\n    \"\"\"\n    return '()' * 10\n\nassert f(g()) == True\n",
        "idx_generation": 5,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return a string representation of its binary form.\n\n    Example:\n    Input: 10\n    Output: \"1010\"\n\n    Hint: Use recursion to convert the decimal number to binary.\n    If n is 0, return an empty string.\n    Otherwise, recursively calculate the binary representation of n // 2 and append the remainder n % 2 as a string.\n    Finally, return the binary representation.\n    \"\"\"\n\n    if n == 0:\n        return \"\"\n    else:\n        return f(n // 2) + str(n % 2)\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == \"1010\"\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the maximum sum of a subsequence with the constraint that no two\n    numbers in the subsequence should be adjacent.\n\n    Sample Input:\n    nums = [1, 2, 3, 1]\n\n    Sample Output:\n    4\n\n    Explanation: The maximum sum subsequence is [2, 2], where the sum is 4.\n\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[n - 1]\n\ndef g():\n    nums = [1, 2, 3, 1]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 197,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes, determine if there exists a path\n    from the start node to the end node.\n    \"\"\"\n    stack = [start]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g(graph = {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"E\"], \"D\": [], \"E\": []}, start = \"A\", end = \"E\"):\n    return graph, start, end\nassert f(*g())\n",
        "idx_generation": 21,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of characters representing a maze, where 'S' represents the starting point, 'E' represents the ending point,\n    '#' represents a wall, and '.' represents an empty space, find the minimum number of steps required to reach the ending point\n    from the starting point. You can only move up, down, left, or right, and you cannot pass through walls.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\n    The minimum number of steps required to reach the ending point from the starting point is 6, following the path: S -> right -> right -> down -> down -> down -> E.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D table to store the minimum steps required to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # Find the starting and ending points\n    start = None\n    end = None\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'E':\n                end = (i, j)\n\n    # The minimum number of steps required to reach the starting point is 0\n    dp[start[0]][start[1]] = 0\n\n    # Define the possible directions to move\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Create a queue to perform breadth-first search\n    queue = [(start[0], start[1])]\n\n    # Perform breadth-first search\n    while queue:\n        x, y = queue.pop(0)\n\n        # Check each possible direction to move\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n\n            # Check if the new position is within the grid boundaries\n            if 0 <= new_x < rows and 0 <= new_y < cols:\n                # Check if the new position is not a wall and has not been visited yet\n                if grid[new_x][new_y] != '#' and dp[new_x][new_y] == float('inf'):\n                    # Update the minimum steps required to reach the new position\n                    dp[new_x][new_y] = dp[x][y] + 1\n                    # Add the new position to the queue for further exploration\n                    queue.append((new_x, new_y))\n\n    # Return the minimum steps required to reach the ending point\n    return dp[end[0]][end[1]]\n\ndef g():\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 65,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of values along a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 12,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of non-negative integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation:\n    The shortest path is 1 -> 3 -> 1 -> 1 -> 1, with a total sum of 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that start with the given prefix.\n    \"\"\"\n    result = []\n    for word in words:\n        if word.startswith(prefix):\n            result.append(word)\n    return result\n\ndef g():\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\"]\n\nassert f(g(), \"b\") == [\"banana\"]\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: int, n=10) -> bool:\n    \"\"\"Check if a number is a palindrome.\"\"\"\n    if x < 0:\n        return False\n    reverse = 0\n    temp = x\n    while temp != 0:\n        reverse = reverse * 10 + temp % 10\n        temp = temp // 10\n    return x == reverse\ndef g(n = 10):\n    return int(str(n) + str(n)[::-1])\nassert f(g())\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome, ignoring all non-alphabetic characters.\n    \"\"\"\n    s = ''.join(c for c in s if c.isalpha()).lower()\n    queue = deque(s)\n    stack = []\n    while queue:\n        stack.append(queue.popleft())\n    reversed_s = ''.join(stack)\n    return s == reversed_s\n\ndef g():\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 6,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"Check if string s can be transformed into string t using the given operations.\"\"\"\n\n    def transform(s, t, operations):\n        if s == t:\n            return True\n        if len(s) != len(t):\n            return False\n        \n        queue = deque([(s, operations)])\n        visited = set()\n        \n        while queue:\n            current, ops = queue.popleft()\n            if current == t:\n                return True\n            \n            if current in visited:\n                continue\n            visited.add(current)\n            \n            for op in ops:\n                if op == \"reverse\":\n                    temp = current[::-1]\n                    queue.append((temp, ops))\n                elif op == \"rotate\":\n                    temp = current[1:] + current[0]\n                    queue.append((temp, ops))\n                elif op == \"swap\":\n                    for i in range(1, len(current)):\n                        temp = current[:i-1] + current[i] + current[i-1] + current[i+1:]\n                        queue.append((temp, ops))\n        \n        return False\n    \n    return transform(s, t, [\"reverse\", \"rotate\", \"swap\"])\n\ndef g(s = \"abcd\", t = \"dcba\"):\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of characters, check if it contains a valid word.\n    A valid word is defined as a sequence of characters that can be formed\n    by traversing adjacent cells (up, down, left, right) in the grid.\n    \"\"\"\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(grid, i, j, \"\"):\n                return True\n    return False\n\ndef dfs(grid: List[List[str]], row: int, col: int, word: str) -> bool:\n    if word == \"\":\n        return True\n\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != word[0]:\n        return False\n\n    visited = set()\n    visited.add((row, col))\n\n    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n        new_row = row + dx\n        new_col = col + dy\n\n        if (new_row, new_col) not in visited and dfs(grid, new_row, new_col, word[1:]):\n            return True\n\n    return False\n\ndef g():\n    grid = [\n        ['A', 'B', 'C', 'D'],\n        ['E', 'F', 'G', 'H'],\n        ['I', 'J', 'K', 'L'],\n        ['M', 'N', 'O', 'P']\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 212,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements in the array.\n\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        \n        potential_max = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ potential_max) in prefixes:\n                max_xor = potential_max\n                break\n    \n    return max_xor\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([3, 10, 5, 25, 2, 8])) == 28\n",
        "idx_generation": 482,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list whose bitwise AND is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: True\n\n    Explanation:\n    2 & 7 = 2, which is not a perfect square.\n    2 & 9 = 0, which is a perfect square.\n    Therefore, there exists a pair whose bitwise AND is a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] & nums[j] in squares:\n                return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise AND of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 266,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, check if there exists a pair of numbers in the list\n    whose bitwise AND is equal to the target.\n    \"\"\"\n    stack = []\n    for num in arr:\n        complement = num & target\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 4\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if there exists a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= arr[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Find a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in arr:\n        if num ^ target in arr:\n            subset.append(num)\n    return subset\n\narr = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(g(arr, target), target) == True\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if there exists a subset of arr such that the bitwise AND of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= arr[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Find a subset of arr such that the bitwise AND of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in arr:\n        if num & target in arr:\n            subset.append(num)\n    return subset\n\narr = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(g(arr, target), target) == True\n\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, convert it to its binary representation as a string.\n\n    Return the binary representation of n.\n\n    Example:\n    n = 10\n\n    The binary representation of 10 is '1010'.\n\n    Therefore, the function should return '1010'.\n    \"\"\"\n    return bin(n)[2:]\n\ndef g():\n    return 10\n\nassert f(g()) == '1010'\n",
        "idx_generation": 143,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[str]) -> bool:\n    \"\"\"\n    Given a list of strings, return True if there exists a pair of strings in the list such that their bitwise OR is a palindrome, otherwise return False.\n\n    Example:\n    Input: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"]\n    Output: True\n\n    Explanation:\n    The bitwise OR of \"abc\" and \"mno\" is \"mno\", which is a palindrome.\n    Therefore, there exists a pair whose bitwise OR is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            bitwise_or = int(arr[i], 2) | int(arr[j], 2)\n            if is_palindrome(bin(bitwise_or)[2:]):\n                return True\n\n    return False\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of binary strings where there exists a pair whose bitwise OR is a palindrome.\n    \"\"\"\n    return [\"101\", \"1101\", \"1110\", \"10001\"]\n\nassert f(g()) == True\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a perfect square (4^2 = 16).\n    \"\"\"\n\n    # Use the mathematical property that the square root of a perfect square is an integer\n    return int(n ** 0.5) ** 2 == n\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target value, determine if it is possible to form the target\n    value using the numbers in the list. You can perform addition, subtraction, multiplication,\n    and division using any of the numbers in the list. Each number can be used multiple times.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    queue = [(num, num) for num in nums]\n\n    while queue:\n        current_sum, current_product = queue.pop(0)\n\n        if current_sum == target or current_product == target:\n            return True\n\n        for num in nums:\n            new_sum = current_sum + num\n            new_product = current_product * num\n\n            if new_sum <= target:\n                queue.append((new_sum, current_product))\n\n            if new_product <= target:\n                queue.append((current_sum, new_product))\n\n    return False\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n",
        "idx_generation": 258,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if it is possible to obtain a target number by performing the following operation on n:\n    - Multiply n by k\n    - Subtract k from n\n    \"\"\"\n    queue = []\n    queue.append(n)\n    while queue:\n        num = queue.pop(0)\n        if num == 0:\n            return True\n        elif num < 0:\n            continue\n        else:\n            queue.append(num * k)\n            queue.append(num - k)\n    return False\n\ndef g(n = 10, k = 3):\n    return n\n\nassert f(g(), 3)\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given matrix is a magic square, i.e., the sum of each row, column, and diagonal is the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n    \n    reverse_diagonal_sum = 0\n    for i in range(n):\n        reverse_diagonal_sum += matrix[i][n - 1 - i]\n    if reverse_diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], row: int, col: int) -> int:\n    \"\"\"\n    Given a 2D grid of integers and a starting position (row, col), find the number of unique paths to reach the bottom-right corner of the grid from the starting position. You can only move down or right.\n\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    row = 0\n    col = 0\n\n    Sample Output:\n    6\n\n    Explanation: The number of unique paths from position (0, 0) to the bottom-right corner is 6.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[row][col] = 1\n\n    for i in range(row + 1, rows):\n        dp[i][col] = dp[i - 1][col]\n\n    for j in range(col + 1, cols):\n        dp[row][j] = dp[row][j - 1]\n\n    for i in range(row + 1, rows):\n        for j in range(col + 1, cols):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[rows - 1][cols - 1]\n\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    row = 0\n    col = 0\n    return grid, row, col\n\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 66,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, compute the number of ways to reach the bottom-right corner of an n x m grid, starting from the top-left corner.\n    You can only move down or right.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = 1\n    \n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g():\n    n = 3\n    m = 3\n    return n, m\n\nassert f(*g()) == 6\n",
        "idx_generation": 190,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> int:\n    \"\"\"\n    Given a string s, count the number of occurrences of the substring \"th\" in s.\n    Then, return the sum of n and the count of occurrences.\n\n    Example:\n    Input: s = \"the truth is out there\", n = 5\n    Output: 8\n\n    Explanation: The substring \"th\" occurs 3 times in the string s.\n    The sum of n (5) and the count (3) is 8.\n    \"\"\"\n\n    count = s.count(\"th\")\n    return n + count\n\ndef g():\n    s = \"the truth is out there\"\n    n = 5\n    return s, n\n\nassert f(*g()) == 8\n",
        "idx_generation": 218,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, determine if n is divisible by any of its digits raised to the power of k.\n\n    Example:\n    n = 123, k = 2\n\n    The digits of n are 1, 2, and 3. The powers of k are 1^2, 2^2, and 3^2, which are 1, 4, and 9.\n    Since 123 is divisible by 1, the function should return True.\n\n    n = 456, k = 3\n\n    The digits of n are 4, 5, and 6. The powers of k are 4^3, 5^3, and 6^3, which are 64, 125, and 216.\n    Since 456 is not divisible by any of these powers, the function should return False.\n    \"\"\"\n\n    # Convert n to a string and split it into its digits\n    digits = list(str(n))\n\n    # Check if any digit raised to the power of k is a divisor of n\n    for digit in digits:\n        if int(digit)**k != 0 and n % (int(digit)**k) == 0:\n            return True\n\n    return False\n\ndef g():\n    return 123, 2\n\nassert f(*g()) == True\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1\n\ndef g(n: int):\n    \"\"\"\n    Find the largest power of two that is less than or equal to n.\n    \"\"\"\n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    return power\nassert f(g(16))\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers arr and a target integer, find the minimum number of operations needed to transform arr into a list where each element is equal to the target by performing bitwise XOR operation on a subset of the list.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr: int) -> int:\n        if curr == target:\n            return 0\n        if index == len(arr):\n            return float('inf')\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(arr, target, index + 1, curr ^ arr[index]) + 1\n\n        return min(exclude, include)\n\n    res = helper(arr, target, 0, 0)\n\n    if res == float('inf'):\n        return -1\n    return res\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 6) == 2\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 404,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, determine if there exists a path from the start cell\n    to the end cell. You can only move to adjacent cells (up, down, left, or right) that are not blocked (value 0).\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n\n    There exists a path from the start cell (0, 0) to the end cell (3, 3).\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def dfs(grid, curr_row, curr_col, end_row, end_col, visited):\n        if curr_row == end_row and curr_col == end_col:\n            return True\n\n        if curr_row < 0 or curr_row >= len(grid) or curr_col < 0 or curr_col >= len(grid[0]) or grid[curr_row][curr_col] == 0 or visited[curr_row][curr_col]:\n            return False\n\n        visited[curr_row][curr_col] = True\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for direction in directions:\n            next_row = curr_row + direction[0]\n            next_col = curr_col + direction[1]\n\n            if dfs(grid, next_row, next_col, end_row, end_col, visited):\n                return True\n\n        return False\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n\n    return dfs(grid, start[0], start[1], end[0], end[1], visited)\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return grid, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of characters representing a maze, where 'S' represents the starting point, 'E' represents the ending point,\n    '#' represents a wall, and '.' represents an empty space, find the minimum number of steps required to reach the ending point\n    from the starting point. You can only move up, down, left, or right, and you cannot pass through walls.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\n    The minimum number of steps required to reach the ending point from the starting point is 6, following the path: S -> right -> right -> down -> down -> down -> E.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D table to store the minimum steps required to reach each cell\n    dp = [[float('inf')] * cols for _ in range(rows)]\n\n    # Find the starting and ending points\n    start = None\n    end = None\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'E':\n                end = (i, j)\n\n    # The minimum number of steps required to reach the starting point is 0\n    dp[start[0]][start[1]] = 0\n\n    # Define the possible directions to move\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Create a queue to perform breadth-first search\n    queue = [(start[0], start[1])]\n\n    # Perform breadth-first search\n    while queue:\n        x, y = queue.pop(0)\n\n        # Check each possible direction to move\n        for dx, dy in directions:\n            new_x = x + dx\n            new_y = y + dy\n\n            # Check if the new position is within the grid boundaries\n            if 0 <= new_x < rows and 0 <= new_y < cols:\n                # Check if the new position is not a wall and has not been visited yet\n                if grid[new_x][new_y] != '#' and dp[new_x][new_y] == float('inf'):\n                    # Update the minimum steps required to reach the new position\n                    dp[new_x][new_y] = dp[x][y] + 1\n                    # Add the new position to the queue for further exploration\n                    queue.append((new_x, new_y))\n\n    # Return the minimum steps required to reach the ending point\n    return dp[end[0]][end[1]]\n\ndef g():\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 65,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine the number of islands in the grid.\n    An island is a group of connected 1s, where \"connected\" means sharing a side (not a corner).\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 islands in the grid: one with 4 1s, one with 1 1, and one with 2 1s.\n\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    count = 0\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or visited[i][j]:\n            return\n        visited[i][j] = True\n\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1 and not visited[i][j]:\n                dfs(i, j)\n                count += 1\n\n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a land and 0 represents water, count the number of islands. \n    An island is formed by connecting adjacent lands horizontally or vertically.\n    \"\"\"\n\n    def dfs(i: int, j: int, grid: List[List[int]]) -> None:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(i - 1, j, grid)\n        dfs(i + 1, j, grid)\n        dfs(i, j - 1, grid)\n        dfs(i, j + 1, grid)\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j, grid)\n                count += 1\n\n    return count\n\n\ndef g():\n    return [[1, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [0, 0, 0, 1, 1]]\n\n\nassert f(g()) == 3\n",
        "idx_generation": 388,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a grid of characters and a word, determine if the word can be formed by connecting adjacent letters horizontally, vertically, or diagonally in the grid.\n    Return True if the word can be formed, False otherwise.\n\n    Example:\n    grid = [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\n    word = \"AEI\"\n    f(grid, word) => True\n\n    Explanation: The word \"AEI\" can be formed by connecting adjacent letters in the grid diagonally.\n    \"\"\"\n\n    def dfs(row: int, col: int, word: str, index: int) -> bool:\n        if index == len(word):\n            return True\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or word[index] != grid[row][col]:\n            return False\n\n        temp = grid[row][col]\n        grid[row][col] = '#'\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\n            if dfs(row + dr, col + dc, word, index + 1):\n                return True\n\n        grid[row][col] = temp\n\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == word[0] and dfs(i, j, word, 0):\n                return True\n\n    return False\n\ndef g():\n    return [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\nassert f(g(), \"AEI\")\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path\n    from the start vertex to the target vertex where the sum of the weights along the path is a power of 2.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n\n    There is a path from vertex 0 to vertex 3 where the sum of the weights along the path is 2.\n\n    Therefore, the function should return True.\n    \"\"\"\n    return dfs(graph, start, target, 0, set())\n\ndef dfs(graph: List[List[int]], node: int, target: int, weight: int, visited: set) -> bool:\n    if node == target and weight > 0 and is_power_of_2(weight):\n        return True\n    \n    visited.add(node)\n    \n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] != 0 and neighbor not in visited:\n            if dfs(graph, neighbor, target, weight + graph[node][neighbor], visited):\n                return True\n    \n    visited.remove(node)\n    return False\n\ndef is_power_of_2(n: int) -> bool:\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    return graph, start, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 407,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=10, k=3) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', find if there exists a combination of 'k' numbers that sum up to 'target'.\n\n    Return True if such a combination exists, False otherwise.\n\n    Additionally, optimize the solution to minimize the number of recursive calls.\n    \"\"\"\n    def backtrack(start, curr_sum, count):\n        if curr_sum == target and count == k:\n            return True\n        if curr_sum > target or count > k:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i], count + 1):\n                return True\n        return False\n    \n    return backtrack(0, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=10, k=3):\n    \"\"\"\n    Generate a list of 'k' numbers from 'nums' that sum up to 'target'.\n\n    Optimize the solution to minimize the number of recursive calls.\n    \"\"\"\n    from itertools import combinations\n    \n    for combo in combinations(nums, k):\n        if sum(combo) == target:\n            return list(combo)\n    return []\n\nassert f(g()) == True\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation: There are 6 unique paths from the top-left corner to the bottom-right corner of a 3x3 grid.\n\n    Note:\n    - The number of unique paths is the same as the number of combinations of (n-1) down movements and (n-1) right movements.\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[n-1][n-1] % (10**9 + 7)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the \n    sum of the numbers equals to the target. Each number in nums may only be used once in the combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation: The solution set must not contain duplicate combinations. \n    \"\"\"\n\n    def backtrack(comb: List[int], remain: int, start: int):\n        if remain == 0:\n            result.append(list(comb))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            comb.append(nums[i])\n            backtrack(comb, remain - nums[i], i + 1)\n            comb.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], target, 0)\n    return result\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nnums = [10, 1, 2, 7, 6, 1, 5]\ntarget = 8\nassert f(*g(nums, target)) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of numbers, calculate the sum of all the even numbers in the string.\n\n    Sample Input:\n    s = \"3,4,5,6,7,8\"\n\n    Sample Output:\n    18\n    Explanation: The even numbers in the string are 4, 6, and 8. Their sum is 18.\n\n    Sample Input:\n    s = \"1,2,3,4,5\"\n\n    Sample Output:\n    6\n    Explanation: The even numbers in the string are 2 and 4. Their sum is 6.\n\n    \"\"\"\n    numbers = s.split(\",\")\n    even_numbers = [int(num) for num in numbers if int(num) % 2 == 0]\n    return sum(even_numbers)\n\ndef g(s=\"3,4,5,6,7,8\"):\n    return s\n\nassert f(g()) == 18\n",
        "idx_generation": 144,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int, steps: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return float('inf')\n\n        if (row, col) == (rows-1, cols-1):\n            return steps\n\n        grid[row][col] = 0\n\n        min_steps = float('inf')\n\n        min_steps = min(min_steps, dfs(row-1, col, steps+1))\n        min_steps = min(min_steps, dfs(row+1, col, steps+1))\n        min_steps = min(min_steps, dfs(row, col-1, steps+1))\n        min_steps = min(min_steps, dfs(row, col+1, steps+1))\n\n        grid[row][col] = 1\n\n        return min_steps\n\n    return dfs(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]\n\nassert f(g()) == 8\n\n",
        "idx_generation": 384,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number.\n    If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the squares of all the elements in nums in non-decreasing order.\n\n    Sample Input:\n    nums = [-4, -2, 0, 2, 4]\n\n    Sample Output:\n    [0, 4, 4, 16, 16]\n\n    Explanation:\n    The squares of the elements in nums are [16, 4, 0, 4, 16]. After sorting the list in non-decreasing order, we get [0, 4, 4, 16, 16].\n    \"\"\"\n    return sorted([num**2 for num in nums])\n\ndef g():\n    return [-4, -2, 0, 2, 4]\n\nassert f(g()) == [0, 4, 4, 16, 16]\n\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers and two integers n and m, determine the maximum sum of a subsequence of length n,\n    where the sum is less than or equal to m.\n\n    Return True if a valid subsequence exists, False otherwise.\n    \"\"\"\n    if len(arr) < n:\n        return False\n\n    # Sort the array in non-decreasing order\n    arr.sort()\n\n    # Initialize a stack to store the current subsequence\n    stack = []\n    curr_sum = 0\n\n    for i in range(len(arr)):\n        if len(stack) < n:\n            stack.append(arr[i])\n            curr_sum += arr[i]\n        elif len(stack) == n:\n            if curr_sum <= m:\n                return True\n            curr_sum -= stack.pop(0)\n            stack.append(arr[i])\n            curr_sum += arr[i]\n\n    return curr_sum <= m\n\ndef g(n = 3, m = 10, arr = [1, 2, 3, 4, 5, 6]):\n    return n, m, arr\n\nassert f(*g())\n",
        "idx_generation": 34,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in ascending order.\n\n    Example:\n    Input: [4, 2, 7, 1, 5]\n    Output: [1, 2, 4, 5, 7]\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[0]\n    lesser = [x for x in nums[1:] if x <= pivot]\n    greater = [x for x in nums[1:] if x > pivot]\n\n    return f(lesser) + [pivot] + f(greater)\n\ndef g() -> List[int]:\n    return [4, 2, 7, 1, 5]\n\nassert f(g()) == [1, 2, 4, 5, 7]\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=50) -> bool:\n    \"\"\"\n    Find a combination of numbers from the given list that adds up to the target sum,\n    using the fewest number of elements\n    \"\"\"\n    nums.sort(reverse=True)\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        total, index = stack.pop()\n        if total == target:\n            return True\n        if index >= len(nums):\n            continue\n        if total + nums[index] <= target:\n            stack.append((total + nums[index], index + 1))\n        stack.append((total, index + 1))\n    return False\n\ndef g(nums=[10, 20, 30, 40, 50]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2 since nums[2] = 5.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), 5) == 2\n",
        "idx_generation": 463,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"\n    Determine if it is possible to form a grid of size n x n where each row and column contains exactly one occurrence of each character in the string s.\n    \"\"\"\n    if len(s) != n * n:\n        return False\n    rows = [set() for _ in range(n)]\n    cols = [set() for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            ch = s[i * n + j]\n            if ch in rows[i] or ch in cols[j]:\n                return False\n            rows[i].add(ch)\n            cols[j].add(ch)\n    return True\n\ndef g(n: int, s: str):\n    \"\"\"\n    Generate a string of length n x n that can form a grid where each row and column contains exactly one occurrence of each character.\n    \"\"\"\n    if n * n > len(s):\n        return \"\"\n    grid = [[\"\"] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            ch = s[i * n + j]\n            grid[i][j] = ch\n    return \"\".join([\"\".join(row) for row in grid])\n\nassert f(n=3, s=g(n=3, s=\"abcdefghijklmnopqrstuvwxyz\")) == True\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers representing the heights of buildings, determine\n    the maximum amount of water that can be trapped between the buildings.\n\n    Example:\n    nums = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    The maximum amount of trapped water is 6 units.\n    Therefore, the function should return 6.\n    \"\"\"\n    n = len(nums)\n    left_max = [0] * n\n    right_max = [0] * n\n\n    left_max[0] = nums[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], nums[i])\n\n    right_max[n-1] = nums[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], nums[i])\n\n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - nums[i]\n\n    return water\n\ndef g():\n    nums = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return (nums,)\n\nassert f(*g()) == 6\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an m x n matrix, return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only '0' and '1', determine if it represents a valid binary number.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '0' or char == '1':\n            stack.append(char)\n        else:\n            return False\n    return True\n\ndef g():\n    \"\"\"\n    Generate a string that represents a valid binary number.\n    \"\"\"\n    return '101010'\n\nassert f(g()) == True\n",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with the words sorted by their length in descending order. If multiple words have the same length, sort them lexicographically.\n\n    Example:\n    Input: [\"cat\", \"apple\", \"banana\", \"dog\"]\n    Output: [\"banana\", \"apple\", \"cat\", \"dog\"]\n    \"\"\"\n    def merge_sort(words: List[str]) -> List[str]:\n        if len(words) <= 1:\n            return words\n        \n        mid = len(words) // 2\n        left = merge_sort(words[:mid])\n        right = merge_sort(words[mid:])\n        \n        return merge(left, right)\n    \n    def merge(left: List[str], right: List[str]) -> List[str]:\n        merged = []\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if len(left[i]) > len(right[j]):\n                merged.append(left[i])\n                i += 1\n            elif len(left[i]) < len(right[j]):\n                merged.append(right[j])\n                j += 1\n            else:\n                if left[i] < right[j]:\n                    merged.append(left[i])\n                    i += 1\n                else:\n                    merged.append(right[j])\n                    j += 1\n        \n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n        \n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n        \n        return merged\n\n    return merge_sort(words)\n\ndef g() -> List[str]:\n    return [\"cat\", \"apple\", \"banana\", \"dog\"]\n\nassert f(g()) == [\"banana\", \"apple\", \"cat\", \"dog\"]\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list of elements in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    \"\"\"\n    if not matrix:\n        return []\n    row_start, row_end = 0, len(matrix) - 1\n    col_start, col_end = 0, len(matrix[0]) - 1\n    result = []\n    while row_start <= row_end and col_start <= col_end:\n        # Traverse right\n        for i in range(col_start, col_end + 1):\n            result.append(matrix[row_start][i])\n        row_start += 1\n\n        # Traverse down\n        for i in range(row_start, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n\n        if row_start <= row_end:\n            # Traverse left\n            for i in range(col_end, col_start - 1, -1):\n                result.append(matrix[row_end][i])\n            row_end -= 1\n\n        if col_start <= col_end:\n            # Traverse up\n            for i in range(row_end, row_start - 1, -1):\n                result.append(matrix[i][col_start])\n            col_start += 1\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, rotate the grid by 90 degrees clockwise.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    rotated_grid = [[0] * m for _ in range(n)]\n\n    for i in range(m):\n        for j in range(n):\n            rotated_grid[j][m - i - 1] = grid[i][j]\n\n    return rotated_grid\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers whose bitwise AND is equal to zero.\n\n    Sample Input:\n    nums = [2, 4, 6, 8]\n\n    Sample Output:\n    True\n    Explanation: The bitwise AND of 2 and 6 is 0.\n\n    Sample Input:\n    nums = [1, 3, 5, 7]\n\n    Sample Output:\n    False\n    Explanation: There is no pair of numbers whose bitwise AND is equal to zero.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                return True\n    return False\n\ndef g():\n    return [2, 4, 6, 8]\n\nassert f(g()) == True\n",
        "idx_generation": 100,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists two numbers in the list that sum up to the target number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 368,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of subarrays whose sum is equal to or greater than the target.\n    \"\"\"\n    n = len(nums)\n    count = float('inf')\n    left = 0\n    curr_sum = 0\n\n    for right in range(n):\n        curr_sum += nums[right]\n\n        while curr_sum >= target:\n            count = min(count, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n    \n    return count\n\ndef g():\n    nums = [2, 3, 1, 2, 4, 3]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it clockwise by 90 degrees in place.\n\n    Example:\n    Input: matrix = [[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]\n    Output: [[7, 4, 1],\n             [8, 5, 2],\n             [9, 6, 3]]\n\n    Explanation: The matrix is rotated clockwise by 90 degrees.\n\n    Note: You must perform the rotation in place, without using any extra space.\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n\n",
        "idx_generation": 327,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    Each step can be either a move down or a move right. The cost of each step is equal to the absolute difference\n    between the current cell and the target cell. Return True if the minimum cost is less than or equal to 20, otherwise False.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 0\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + abs(grid[i][0] - grid[i-1][0])\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + abs(grid[0][j] - grid[0][j-1])\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j] + abs(grid[i][j] - grid[i-1][j]), dp[i][j-1] + abs(grid[i][j] - grid[i][j-1]))\n    return dp[n-1][m-1] <= 20\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 72,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(points: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a list of 2D points, determine if there exist three points that form a right-angled triangle.\n\n    Example:\n    points = [(1, 1), (3, 3), (1, 3), (3, 1), (2, 2)]\n\n    There exist three points (1, 1), (3, 3), and (1, 3) that form a right-angled triangle.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def is_right_angle(p1, p2, p3):\n        \"\"\"\n        Check if three points form a right-angled triangle.\n        \"\"\"\n        distances = []\n        distances.append((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n        distances.append((p1[0] - p3[0]) ** 2 + (p1[1] - p3[1]) ** 2)\n        distances.append((p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2)\n        distances.sort()\n\n        return distances[0] + distances[1] == distances[2]\n\n    n = len(points)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if is_right_angle(points[i], points[j], points[k]):\n                    return True\n\n    return False\n\ndef g() -> List[Tuple[int, int]]:\n    points = [(1, 1), (3, 3), (1, 3), (3, 1), (2, 2)]\n    return points\n\nassert f(g()) == True\n",
        "idx_generation": 113,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(grid: Tuple[Tuple[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n\n    You can move up, down, left, or right from each cell. The path can start from any cell and follow the adjacent cells\n    in the grid.\n\n    Example:\n    grid = (\n        (9, 9, 4),\n        (6, 6, 8),\n        (2, 1, 1)\n    )\n\n    The longest increasing path in the grid is [1, 2, 6, 9], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def longestIncreasingPath(matrix):\n        if not matrix:\n            return 0\n\n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]\n\n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n\n            val = matrix[i][j]\n            dp[i][j] = 1 + max(\n                dfs(i-1, j) if i > 0 and val < matrix[i-1][j] else 0,\n                dfs(i+1, j) if i < rows-1 and val < matrix[i+1][j] else 0,\n                dfs(i, j-1) if j > 0 and val < matrix[i][j-1] else 0,\n                dfs(i, j+1) if j < cols-1 and val < matrix[i][j+1] else 0\n            )\n\n            return dp[i][j]\n\n        maxPath = 0\n        for i in range(rows):\n            for j in range(cols):\n                maxPath = max(maxPath, dfs(i, j))\n\n        return maxPath\n\n    return longestIncreasingPath(grid)\n\ndef g():\n    grid = (\n        (9, 9, 4),\n        (6, 6, 8),\n        (2, 1, 1)\n    )\n    return grid\n\nassert f(g()) == 4\n\n",
        "idx_generation": 382,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall, find the length of the shortest\n    path from the top-left corner to the bottom-right corner. You can only move horizontally or vertically and cannot\n    pass through walls.\n\n    Example:\n    grid = [[0, 1, 0, 0, 0],\n            [0, 0, 0, 1, 0],\n            [1, 1, 0, 1, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 1, 0]]\n\n    output: 8\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    queue = [(0, 0, 0)]\n    visited = set()\n    \n    while queue:\n        row, col, steps = queue.pop(0)\n        if row == rows - 1 and col == cols - 1:\n            return steps\n        if (row, col) in visited:\n            continue\n        visited.add((row, col))\n        \n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_row = row + dr\n            new_col = col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0:\n                queue.append((new_row, new_col, steps + 1))\n    \n    return -1\n\ndef g() -> List[List[int]]:\n    grid = [[0, 1, 0, 0, 0],\n            [0, 0, 0, 1, 0],\n            [1, 1, 0, 1, 0],\n            [1, 1, 0, 0, 0],\n            [0, 0, 1, 1, 0]]\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 100,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], nodes: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and a list of nodes, return a subgraph that includes only the nodes in the list.\n\n    Return the subgraph as an adjacency matrix.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    nodes = [0, 2, 3]\n\n    The subgraph with nodes 0, 2, and 3 is represented by the adjacency matrix:\n    [\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ]\n\n    Therefore, the function should return [[0, 1, 0], [1, 0, 1], [0, 1, 0]].\n    \"\"\"\n    subgraph = []\n\n    for i in nodes:\n        row = []\n        for j in nodes:\n            row.append(graph[i][j])\n        subgraph.append(row)\n\n    return subgraph\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph represented as an adjacency matrix for Puzzle 5.\n    \"\"\"\n    return [\n        [0, 1, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\nassert f(g(), [0, 2, 3]) == [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n\n",
        "idx_generation": 263,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, check if the target number exists in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\n\ndef g(target=8):\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g(), target=8) == True\n\n",
        "idx_generation": 98,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"Count the number of unique paths from (0,0) to (n-1, m-1) in a grid\"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n    for j in range(m):\n        dp[0][j] = 1\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g(n = 5, m = 5):\n    return (n, m)\n\nassert f(*g()) == 70\n",
        "idx_generation": 8,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list containing the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n    spiral_order = []\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for j in range(left, right + 1):\n            spiral_order.append(matrix[top][j])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        # Check if there is still a valid bottom row\n        if top <= bottom:\n            # Traverse bottom row\n            for j in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][j])\n            bottom -= 1\n\n        # Check if there is still a valid left column\n        if left <= right:\n            # Traverse left column\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid Sudoku solution.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if len(set(row)) != n:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column = [grid[i][j] for i in range(n)]\n        if len(set(column)) != n:\n            return False\n    \n    # Check subgrids\n    subgrid_size = int(n ** 0.5)\n    for i in range(0, n, subgrid_size):\n        for j in range(0, n, subgrid_size):\n            subgrid = []\n            for x in range(subgrid_size):\n                for y in range(subgrid_size):\n                    subgrid.append(grid[i + x][j + y])\n            if len(set(subgrid)) != n:\n                return False\n    \n    return True\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 13,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Sample input:\n    nums = [2, 7, 11, 15], target = 9\n\n    Sample output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 are 2 and 7, and their sum is 9.\n    \"\"\"\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        num_indices[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 108,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a sublist whose sum is equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    There exists a sublist [2, 3, 4] whose sum is equal to the target value.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def find_sublist(nums, target):\n        \"\"\"\n        Find a sublist whose sum is equal to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n+1):\n                sublist = nums[i:j]\n                if sum(sublist) == target:\n                    return True\n\n        return False\n\n    return find_sublist(nums, target)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum product of any two distinct numbers in the array.\n\n    Example:\n    nums = [1, 5, 4, 2]\n\n    The maximum product is between 5 and 4, which gives a result of 20.\n\n    Therefore, the function should return 20.\n\n    Note:\n    - The length of the array will be at least 2 and at most 500.\n    - The range of integers in the array is -10^3 <= nums[i] <= 10^3.\n    \"\"\"\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [1, 5, 4, 2]\n\nassert f(g()) == 20\n",
        "idx_generation": 319,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subset whose XOR is equal to the bitwise AND of all the numbers in the list.\n    \"\"\"\n    total_and = nums[0]\n    for num in nums[1:]:\n        total_and &= num\n    n = len(nums)\n    for i in range(1, 2 ** n):\n        subset_xor = 0\n        subset_and = total_and\n        for j in range(n):\n            if i & (1 << j):\n                subset_xor ^= nums[j]\n                subset_and &= nums[j]\n        if subset_xor == subset_and:\n            return True\n    return False\n\ndef g():\n    return [3, 6, 9, 12, 15]\nassert f(g()) == True\n",
        "idx_generation": 66,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list that can be XORed to the target value.\n    \"\"\"\n    def subset_xor(nums: List[int], target: int, index: int, xor_result: int) -> bool:\n        if xor_result == target:\n            return True\n        if index >= len(nums):\n            return False\n        return subset_xor(nums, target, index+1, xor_result ^ nums[index]) or subset_xor(nums, target, index+1, xor_result)\n    \n    return subset_xor(nums, target, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == True\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the unique elements in the original list, in the same order.\n\n    Example:\n    nums = [1, 2, 3, 2, 4, 3, 5, 6, 5]\n\n    The unique elements in nums are [1, 2, 3, 4, 5, 6].\n\n    Therefore, the function should return [1, 2, 3, 4, 5, 6].\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in nums:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 2, 4, 3, 5, 6, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given an array of integers and an integer k, determine if there are any two distinct indices i and j in the array\n    such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n\n    Example 1:\n    nums = [1, 2, 3, 1], k = 3\n    Output: True\n    Explanation: There are two 1's in the array, and the absolute difference between their indices is 3.\n\n    Example 2:\n    nums = [1, 0, 1, 1], k = 1\n    Output: True\n    Explanation: There are two 1's in the array, and the absolute difference between their indices is 1.\n\n    Example 3:\n    nums = [1, 2, 3, 1, 2, 3], k = 2\n    Output: False\n    Explanation: The absolute difference between any two indices is greater than 2.\n\n    Return True if such indices exist, otherwise return False.\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        if num in num_dict and i - num_dict[num] <= k:\n            return True\n        num_dict[num] = i\n    \n    return False\n\ndef g(nums=[1, 2, 3, 1], k=3):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums, k\n\nassert f(*g()) == True\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if it is possible to obtain the target by performing a series of mathematical operations on the elements of the array.\n    Each element in the array can be used only once, and the operations allowed are addition, subtraction, multiplication, and division.\n    \"\"\"\n    stack = []\n    stack.append(arr[0])\n    for num in arr[1:]:\n        temp_stack = []\n        while stack:\n            temp = stack.pop()\n            temp_stack.append(temp + num)\n            temp_stack.append(temp - num)\n            temp_stack.append(temp * num)\n            if num != 0:\n                temp_stack.append(temp / num)\n        stack = temp_stack\n    return target in stack\n\ndef g(arr = [1, 2, 3, 4], target = 24):\n    return arr\n\nassert f(g(), 24)\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray in nums is 6, which is the sum of the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a binary grid, find the maximum size of a square subgrid where all elements are 1s.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 0],\n        [0, 1, 1, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The maximum size of a square subgrid where all elements are 1s is 3, formed by the 1s at positions (1, 1), (1, 2), and (1, 3).\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_size = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 0],\n        [0, 1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal are all equal.\n    \"\"\"\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n        \n        # Check rows\n        for row in matrix:\n            if sum(row) != target_sum:\n                return False\n        \n        # Check columns\n        for col in range(n):\n            col_sum = 0\n            for row in range(n):\n                col_sum += matrix[row][col]\n            if col_sum != target_sum:\n                return False\n        \n        # Check diagonals\n        diag_sum1 = 0\n        diag_sum2 = 0\n        for i in range(n):\n            diag_sum1 += matrix[i][i]\n            diag_sum2 += matrix[i][n-i-1]\n        \n        if diag_sum1 != target_sum or diag_sum2 != target_sum:\n            return False\n        \n        return True\n    \n    return is_magic_square(matrix)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a magic square matrix.\n    \"\"\"\n    matrix = [[2, 7, 6],\n              [9, 5, 1],\n              [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 182,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\ndef g():\n    return \"racecar\"\nassert f(g()) == True\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all even numbers removed.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    Output: [1, 3, 5]\n\n    \"\"\"\n\n    return [num for num in nums if num % 2 != 0]\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == [1, 3, 5]\n\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of numbers in the array whose sum is equal to the target.\"\"\"\n    seen = set()\n    for num in arr:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    arr = [2, 4, 6, 8, 10]\n    target = 12\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a non-empty array of integers nums, every element appears twice except for one.\n    Find that single one. You must implement a solution with a linear runtime complexity\n    and use only constant extra space.\n    \"\"\"\n\n    result = 0\n    \n    for num in nums:\n        result ^= num\n    \n    return result\n\ndef g(nums=[4, 1, 2, 1, 2]):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 258,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid contains a valid sudoku solution.\"\"\"\n    def is_valid_row(row: List[int]) -> bool:\n        \"\"\"Check if a row in the grid is valid.\"\"\"\n        return len(set(row)) == 9\n\n    def is_valid_column(col: List[int]) -> bool:\n        \"\"\"Check if a column in the grid is valid.\"\"\"\n        return len(set(col)) == 9\n\n    def is_valid_box(box: List[int]) -> bool:\n        \"\"\"Check if a 3x3 box in the grid is valid.\"\"\"\n        return len(set(box)) == 9\n\n    # Check rows\n    for row in grid:\n        if not is_valid_row(row):\n            return False\n\n    # Check columns\n    for col in zip(*grid):\n        if not is_valid_column(col):\n            return False\n\n    # Check boxes\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            box = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid_box(box):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"Generate a valid sudoku grid.\"\"\"\n    return [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    def dfs(row, col, current_sum):\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\n            return current_sum + grid[row][col]\n        if row < len(grid) - 1 and col < len(grid[0]) - 1:\n            return max(dfs(row + 1, col, current_sum + grid[row][col]), dfs(row, col + 1, current_sum + grid[row][col]))\n        elif row < len(grid) - 1:\n            return dfs(row + 1, col, current_sum + grid[row][col])\n        elif col < len(grid[0]) - 1:\n            return dfs(row, col + 1, current_sum + grid[row][col])\n\n    return dfs(0, 0, 0)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum to reach the bottom-right cell from the top-left cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The function should return 7, as the minimum sum to reach the bottom-right cell is 7 (1 -> 3 -> 1 -> 1 -> 1).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 400,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    Each step can either move down or right.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if it is possible to flip a row or column such that all the rows and columns have an equal number of 1s.\n\n    Sample Input:\n    matrix = [[1, 0, 1],\n              [0, 0, 1],\n              [1, 1, 0]]\n\n    Sample Output:\n    True\n    Explanation: We can flip the second row to get [[1, 0, 1], [1, 1, 1], [1, 1, 0]], and now all the rows and columns have an equal number of 1s.\n\n    Sample Input:\n    matrix = [[1, 0, 1],\n              [0, 0, 1],\n              [1, 1, 1]]\n\n    Sample Output:\n    False\n    Explanation: It is not possible to flip a row or column to make all the rows and columns have an equal number of 1s.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    row_sum = [0] * n\n    col_sum = [0] * m\n\n    for i in range(n):\n        for j in range(m):\n            row_sum[i] += matrix[i][j]\n            col_sum[j] += matrix[i][j]\n\n    for i in range(n):\n        for j in range(m):\n            row_sum[i] -= matrix[i][j]\n            col_sum[j] -= matrix[i][j]\n            if row_sum[i] == col_sum[j]:\n                return True\n            row_sum[i] += matrix[i][j]\n            col_sum[j] += matrix[i][j]\n    return False\n\ndef g(matrix: List[List[int]]):\n    \"\"\"\n    Flip a row or column in the matrix such that all the rows and columns have an equal number of 1s.\n    \"\"\"\n    flipped_matrix = matrix.copy()\n    for i in range(len(flipped_matrix)):\n        for j in range(len(flipped_matrix[0])):\n            if flipped_matrix[i][j] == 1:\n                flipped_matrix[i][j] = 0\n            else:\n                flipped_matrix[i][j] = 1\n    return flipped_matrix\n\nmatrix = [[1, 0, 1],\n          [0, 0, 1],\n          [1, 1, 0]]\nassert f(g(matrix)) == True\n",
        "idx_generation": 201,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Determine if a given arithmetic expression has balanced parentheses.\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g(expression='(2 + 3) * (4 / 2)'):\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 13,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct substrings of s.\n\n    Example:\n    Input: \"abc\"\n    Output: 6\n\n    Explanation: The distinct substrings of \"abc\" are \"\", \"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\".\n\n    Hint: Use dynamic programming and recursion to calculate the distinct substrings.\n    Create a set to store the distinct substrings.\n    Iterate through each character in the string, and recursively find all substrings starting from that character.\n    Add each substring to the set.\n    Finally, return the size of the set.\n\n    Note: This solution has a time complexity of O(n^3), where n is the length of the string.\n    \"\"\"\n\n    def find_substrings(s: str, start: int, end: int, substrings: set):\n        if start > end:\n            return\n\n        substrings.add(s[start:end+1])\n\n        find_substrings(s, start+1, end, substrings)\n        find_substrings(s, start, end-1, substrings)\n\n    substrings = set()\n    find_substrings(s, 0, len(s)-1, substrings)\n\n    return len(substrings)\n\ndef g():\n    s = \"abc\"\n    return s\n\nassert f(g()) == 6\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth Fibonacci number using dynamic programming.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib[n]\n\ndef g():\n    n = 6\n    return (n,)\n\nassert f(*g()) == 8\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, determine if there exists a path from the start cell to the end cell.\n\n    You can only move in the four cardinal directions (up, down, left, and right) and you cannot visit the same cell twice.\n\n    Use a stack to perform depth-first search (DFS) on the grid.\n\n    Example:\n    Input:\n    grid = [\n        [0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n\n    Output: True\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    stack = [start]\n    visited = set()\n\n    while stack:\n        x, y = stack.pop()\n\n        if (x, y) == end:\n            return True\n\n        visited.add((x, y))\n\n        # Check the four cardinal directions\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n\n            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0:\n                stack.append((nx, ny))\n\n    return False\n\ndef g():\n    grid = [\n        [0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    return grid, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of values along a path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally right-down.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [2, 6, 2],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 13\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Find if a given substring appears in the string s\"\"\"\n    return substr in s\ndef g(substr = 'abc'):\n    return 'abcdefg'\nassert f(g())\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n    Return True if the string is a palindrome, False otherwise.\n    \"\"\"\n    stack = deque()\n    for char in s:\n        stack.append(char)\n    reversed_s = ''\n    while stack:\n        reversed_s += stack.pop()\n    return s == reversed_s\n\ndef g():\n    return 'racecar'\n\nassert f(g()) == True\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if the given string is a palindrome after removing exactly one character.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return s[i+1:j+1] == s[i+1:j+1][::-1] or s[i:j] == s[i:j][::-1]\n        i += 1\n        j -= 1\n    return True\n\ndef g():\n    \"\"\"\n    Generate a random palindrome string with length between 5 and 10.\n    \"\"\"\n    import random\n    import string\n    length = random.randint(5, 10)\n    s = ''.join(random.choices(string.ascii_lowercase, k=length))\n    return s + s[::-1]\n\nassert f(g()) == True\n",
        "idx_generation": 168,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    The XOR value is the result of applying the XOR operation (^) to two numbers.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by taking the XOR of 5 and 25, which gives a result of 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum bitwise XOR value of any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28 (The maximum XOR value is obtained by 5 XOR 25 = 28)\n\n    Hint: Use a Trie data structure to store the binary representation of the numbers and find the XOR value.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root, num):\n        xor = 0\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given an array of integers and an integer k, determine if there exists a subset of the array\n    such that the bitwise XOR of all elements in the subset is equal to k.\n    \"\"\"\n    subset_sums = {0}\n    for num in arr:\n        subset_sums = {subset_sum ^ num for subset_sum in subset_sums} | subset_sums\n    return k in subset_sums\n\ndef g(arr=[2, 4, 6, 8, 10], k=12):\n    return arr\n\nassert f(g(), k=12)\n",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of positive integers and a target value, determine if it is possible to obtain the target value by performing bitwise OR operation on a subset of the list.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if index == len(arr):\n            return False\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(arr, target, index + 1, curr | arr[index])\n\n        return exclude or include\n\n    return helper(arr, target, 0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [3, 5, 7, 9, 11]\n\nassert f(g(), 13) == True\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 4.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if two strings are anagrams of each other.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    The output should be True since \"listen\" and \"silent\" are anagrams of each other.\n\n    Hint: Use bit manipulation and string manipulation techniques to solve this problem.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    s1_count = [0] * 26\n    s2_count = [0] * 26\n\n    for char in s1:\n        s1_count[ord(char) - ord('a')] += 1\n    for char in s2:\n        s2_count[ord(char) - ord('a')] += 1\n\n    for i in range(26):\n        if s1_count[i] != s2_count[i]:\n            return False\n\n    return True\n\ndef g():\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import Tuple\n\ndef f(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Given three positive integers a, b, and c, calculate the value of (a^b) % c, where ^ denotes exponentiation.\n\n    Sample Input:\n    a = 3\n    b = 4\n    c = 5\n\n    Sample Output:\n    1\n\n    Explanation: (3^4) % 5 = 81 % 5 = 1.\n    \"\"\"\n    return pow(a, b, c)\n\ndef g() -> Tuple[int, int, int]:\n    \"\"\"\n    Generate three positive integers a, b, and c with random values.\n    \"\"\"\n    a = 3\n    b = 4\n    c = 5\n    return a, b, c\n\nassert f(*g()) == 1\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the corresponding element.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [120, 60, 40, 30, 24]\n\n    Explanation: The first element is the product of (2 * 3 * 4 * 5), the second element is the product of (1 * 3 * 4 * 5), and so on.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    output = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n    \n    return output\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that the product of all elements in the list is not zero.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 210,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the n-th Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    \n    Output:\n    1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move right or down. Each cell has a cost associated with it.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Calculate the minimum cost path for the first column\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    # Calculate the minimum cost path for the first row\n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n\n    # Calculate the minimum cost path for the rest of the grid\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef g():\n    \"\"\"\n    Generate an integer that is a power of two.\n    \"\"\"\n    return 8\n\nassert f(g()) == True\n",
        "idx_generation": 11,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Find the minimum number of edges required to connect all nodes in a directed graph with n nodes and m edges.\n    \"\"\"\n    if n == 0:\n        return m == 0\n    return m >= n - 1\ndef g():\n    n = 5\n    m = 6\n    return n, m\nassert f(*g())\n",
        "idx_generation": 41,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of connected islands in the grid.\n    Two cells are considered connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g():\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 448,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid representing a maze, return the minimum number of steps required to reach the destination from the starting point.\n    You can only move in four directions: up, down, left, and right. The value 1 represents a valid path, while 0 represents a wall.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n            if (row, col) == (rows-1, cols-1):\n                return steps\n\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:\n                    queue.append((new_row, new_col, steps+1))\n\n        return -1\n\n    return bfs(0, 0)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 1],\n        [1, 1, 1, 1, 1]\n    ]\n\nassert f(g()) == 8\n\n",
        "idx_generation": 312,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the perimeter of the island with the most 1s.\n    An island is defined as a group of connected 1s.\n    Two 1s are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    8\n\n    Explanation:\n    The island with the most 1s is formed by the 1s at positions (0, 0), (0, 1), (1, 0), and (1, 1).\n    The perimeter of this island is 8.\n    \"\"\"\n\n    def dfs(row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return 0\n        if grid[row][col] == -1:\n            return 0\n        count = 0\n        if row == 0 or grid[row - 1][col] == 0:\n            count += 1\n        if row == len(grid) - 1 or grid[row + 1][col] == 0:\n            count += 1\n        if col == 0 or grid[row][col - 1] == 0:\n            count += 1\n        if col == len(grid[0]) - 1 or grid[row][col + 1] == 0:\n            count += 1\n        grid[row][col] = -1\n        return count + dfs(row - 1, col) + dfs(row + 1, col) + dfs(row, col - 1) + dfs(row, col + 1)\n\n    max_perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                perimeter = dfs(row, col)\n                max_perimeter = max(max_perimeter, perimeter)\n    return max_perimeter\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 8\n",
        "idx_generation": 108,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of islands.\n    An island is formed by connecting adjacent lands horizontally or vertically.\n    Assume all grid cells are either '0' (water) or '1' (land).\n\n    Example:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n\n    The grid represents the following islands:\n    1 1 0 0 0\n    1 1 0 0 0\n    0 0 1 0 0\n    0 0 0 1 1\n\n    Therefore, the function should return 3.\n    \"\"\"\n    def dfs(i, j, grid):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'\n        \n        dfs(i+1, j, grid)\n        dfs(i-1, j, grid)\n        dfs(i, j+1, grid)\n        dfs(i, j-1, grid)\n    \n    count = 0\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(i, j, grid)\n                count += 1\n    \n    return count\n\ndef g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[str]], word=\"PYTHON\") -> bool:\n    \"\"\"\n    Given a grid of characters and a word, determine if the word exists in the grid.\n    The word can be formed by connecting adjacent characters horizontally, vertically, or diagonally.\n\n    Sample Input:\n    grid = [\n        ['P', 'Y', 'T', 'H', 'O', 'N'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n    ]\n    word = \"PYTHON\"\n\n    Sample Output:\n    True\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(i, j, k):\n        if k == len(word):\n            return True\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != word[k]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = \"\"  # Mark the current character as visited\n\n        # Explore the neighboring cells\n        found = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1) \\\n                or dfs(i + 1, j + 1, k + 1) or dfs(i + 1, j - 1, k + 1) or dfs(i - 1, j + 1, k + 1) \\\n                or dfs(i - 1, j - 1, k + 1)\n\n        grid[i][j] = temp  # Restore the character\n\n        return found\n\n    # Iterate over each cell in the grid\n    for i in range(rows):\n        for j in range(cols):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\ndef g(word=\"PYTHON\"):\n    return [\n        ['P', 'Y', 'T', 'H', 'O', 'N'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n        ['X', 'X', 'X', 'X', 'X', 'X'],\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 223,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target, find all unique combinations in the list\n    that sum up to the target. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n    Output:\n    [[2, 2, 3], [7]]\n    \"\"\"\n    def backtrack(combination: List[int], remaining: int, start: int):\n        if remaining == 0:\n            result.append(combination[:])\n            return\n        if remaining < 0:\n            return\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            backtrack(combination, remaining - nums[i], i)\n            combination.pop()\n\n    result = []\n    backtrack([], target, 0)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 112,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if it is possible to transform the target word into any other word in the list by replacing one character at a time. Each transformation must result in a valid word that exists in the list.\n    \"\"\"\n    def is_valid_word(word: str, words: List[str]) -> bool:\n        return word in words\n    \n    def is_valid_transformation(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        diff_count = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff_count += 1\n                if diff_count > 1:\n                    return False\n        return diff_count == 1\n    \n    def transform_word(word: str, target: str, visited: set, words: List[str]) -> bool:\n        if word == target:\n            return True\n        visited.add(word)\n        for i in range(len(word)):\n            for j in range(26):\n                new_word = word[:i] + chr(ord('a')+j) + word[i+1:]\n                if new_word not in visited and is_valid_word(new_word, words) and is_valid_transformation(word, new_word):\n                    if transform_word(new_word, target, visited, words):\n                        return True\n        visited.remove(word)\n        return False\n    \n    visited = set()\n    return transform_word(target, target, visited, words)\n\ndef g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate a list of words and a target word.\n    \"\"\"\n    words = [\"cat\", \"bat\", \"hat\", \"hat\", \"hot\"]\n    target = \"hot\"\n    return words, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the sum of elements in the combination is equal to target.\n    Each number in nums may only be used once in the combination.\n    Note: The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    nums = [2, 5, 2, 1, 2], target = 5\n    Output: [[1, 2, 2], [5]]\n    \"\"\"\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            result.append(path[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path, curr_sum + nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g(nums: List[int] = [10, 1, 2, 7, 6, 1, 5], target: int = 8):\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Find the number of ways to place n non-attacking rooks on an m x m chessboard.\n    \"\"\"\n    def backtrack(row, rooks):\n        nonlocal count\n        if row == m:\n            count += 1\n            return\n        for col in range(m):\n            if not any(row == r or col == c for r, c in rooks):\n                backtrack(row + 1, rooks + [(row, col)])\n    count = 0\n    backtrack(0, [])\n    return count\ndef g(n=4, m=4):\n    return n, m\nassert f(*g()) == 24\n",
        "idx_generation": 0,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"\n    Given a list of integers, find if there exists a combination of numbers that sum up to the target.\n    Return True if such combination exists, False otherwise.\n    \"\"\"\n\n    def backtrack(start, curr_sum):\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\ndef g(nums=[2, 4, 6, 8]):\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 35,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the kth permutation sequence of the numbers from 1 to n.\n\n    Example:\n    n = 3, k = 3\n    Output: \"213\"\n\n    n = 4, k = 9\n    Output: \"2314\"\n    \"\"\"\n    nums = [str(i) for i in range(1, n+1)]\n    result = []\n    factorial = [1]\n    for i in range(1, n):\n        factorial.append(factorial[-1] * i)\n    \n    k -= 1\n    for i in range(n, 0, -1):\n        index = k // factorial[i-1]\n        k %= factorial[i-1]\n        result.append(nums.pop(index))\n    \n    return \"\".join(result)\n\ndef g(n: int = 3, k: int = 3):\n    return n, k\n\nassert f(*g()) == \"213\"\n",
        "idx_generation": 405,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 0 to n, where n is the length of the list.\n    \n    Example:\n    nums = [0, 1, 3, 4, 5]\n    \n    Output: 2\n    \"\"\"\n    nums.sort()\n    \n    for i in range(len(nums)):\n        if nums[i] != i:\n            return i\n    \n    return len(nums)\n\ndef g() -> List[int]:\n    nums = [0, 1, 3, 4, 5]\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"Find the maximum product of any three numbers in a list.\"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 720\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a pair of numbers in the array that add up to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [2, 7, 11, 15], target = 9\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 14)\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find all unique combinations of four elements in the array whose sum is equal to the target.\n    \"\"\"\n\n    def backtrack(combination: List[int], start: int, target: int) -> None:\n        if len(combination) == 4 and sum(combination) == target:\n            result.append(tuple(combination))\n            return\n\n        if len(combination) >= 4:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            combination.append(nums[i])\n            backtrack(combination, i+1, target)\n            combination.pop()\n\n    result = []\n    nums.sort()\n    backtrack([], 0, target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers nums and an integer target, where there are unique combinations of four elements in the array whose sum is equal to the target.\n    \"\"\"\n    return [1, 0, -1, 0, -2, 2], 0\n\nassert f(*g()) == [(-2, -1, 1, 2), (-2, 0, 0, 2), (-1, 0, 0, 1)]\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray within the list.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The maximum sum is achieved by adding the subarray [4, -1, 2, 1], which gives a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 122,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an m x n matrix, return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n\n    if not matrix:\n        return []\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 273,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle,\n    find the minimum number of steps required to navigate from the start cell to the end cell,\n    considering only horizontal and vertical movements. If a path from start to end is not possible,\n    return -1.\n    \n    Sample Input:\n    grid = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    \n    Sample Output:\n    8\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0\n    \n    queue = [(start[0], start[1], 0)]  # (row, col, steps)\n    visited = set()\n    \n    while queue:\n        row, col, steps = queue.pop(0)\n        if (row, col) == end:\n            return steps\n        \n        for d_row, d_col in directions:\n            new_row, new_col = row + d_row, col + d_col\n            if is_valid_move(new_row, new_col) and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, steps + 1))\n                visited.add((new_row, new_col))\n    \n    return -1\n\ndef g():\n    grid = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    return grid, start, end\n\nassert f(*g()) == 8\n\n",
        "idx_generation": 470,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid parentheses string. A valid parentheses string is one in which each\n    opening parenthesis '(' has a corresponding closing parenthesis ')'.\n    \"\"\"\n    # Function to check if a string is a valid parentheses string\n    def is_valid_parentheses_string(s):\n        # Create a stack to store the opening parentheses\n        stack = []\n        \n        # Loop through the string\n        for char in s:\n            # Check if the character is an opening parenthesis\n            if char == '(':\n                # Add the opening parenthesis to the stack\n                stack.append(char)\n            # Check if the character is a closing parenthesis\n            elif char == ')':\n                # Check if the stack is empty or the top of the stack is not an opening parenthesis\n                if not stack or stack[-1] != '(':\n                    return False\n                # Remove the corresponding opening parenthesis from the stack\n                stack.pop()\n        \n        # Check if the stack is empty (all opening parentheses have a corresponding closing parenthesis)\n        return not stack\n\n    # Check if the string is a valid parentheses string\n    return is_valid_parentheses_string(s)\n\ndef g():\n    # The string\n    s = '(()()())'\n    \n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 32,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest word that can be built one character at a time by other words in the list.\n\n    If there are multiple possible answers, return the longest word with the smallest lexicographical order.\n    If there is no possible word, return an empty string.\n\n    Example:\n    words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\n    Output: \"world\"\n\n    words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n    Output: \"apple\"\n    \"\"\"\n    def is_buildable(word, words):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            if prefix not in words:\n                return False\n        return True\n\n    words.sort(key=lambda x: (-len(x), x))\n\n    for word in words:\n        if is_buildable(word, set(words)):\n            return word\n\n    return \"\"\n\ndef g():\n    words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\n    return words\n\nassert f(g()) == \"world\"\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 199,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers 'matrix', return the spiral order of the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = []\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of size m x n, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    columns = len(matrix[0])\n    result = []\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = columns - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n\n        # Traverse right column\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n\n        if top <= bottom:\n            # Traverse bottom row\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n\n        if left <= right:\n            # Traverse left column\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n\n    return result\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 390,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in non-decreasing order based on the count of set bits in their binary representation.\n    If two numbers have the same count of set bits, sort them in non-decreasing order as usual.\n\n    Example:\n    Input: [3, 5, 1, 8, 6]\n    Output: [1, 8, 3, 5, 6]\n    Explanation:\n    - The binary representation of 3 is 0011, which has 2 set bits.\n    - The binary representation of 5 is 0101, which has 2 set bits.\n    - The binary representation of 1 is 0001, which has 1 set bit.\n    - The binary representation of 8 is 1000, which has 1 set bit.\n    - The binary representation of 6 is 0110, which has 2 set bits.\n    Therefore, the sorted array is [1, 8, 3, 5, 6].\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    arr.sort(key=lambda x: (count_set_bits(x), x))\n    return arr\n\ndef g():\n    arr = [3, 5, 1, 8, 6]\n    return arr\n\nassert f(g()) == [1, 8, 3, 5, 6]\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, generate the first n Fibonacci numbers.\n\n    Example:\n    n = 6\n    The first 6 Fibonacci numbers are [0, 1, 1, 2, 3, 5].\n    Return [0, 1, 1, 2, 3, 5].\n    \"\"\"\n    fibonacci = [0, 1]\n    for i in range(2, n):\n        fibonacci.append(fibonacci[i-1] + fibonacci[i-2])\n    return fibonacci[:n]\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == [0, 1, 1, 2, 3, 5]\n\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if there exists a subset whose sum is equal to the target sum.\n    \"\"\"\n    def subset_sum(arr: List[int], n: int, target: int) -> bool:\n        if target == 0:\n            return True\n        if n == 0 and target != 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, n-1, target)\n        return subset_sum(arr, n-1, target) or subset_sum(arr, n-1, target-arr[n-1])\n\n    return subset_sum(arr, len(arr), target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target sum.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 70,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [3, 7, 10, 5]\n    Output: 15 (The maximum XOR value is obtained by XORing 7 and 10)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)\n\n\ndef g() -> List[int]:\n    return [3, 7, 10, 5]\n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 409,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, determine the minimum number of steps required to reach the bottom-right cell from the top-left cell.\n    You can only move down, right, or diagonally (down-right).\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1]\n    ]\n\n    The minimum number of steps required is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 4\n\n",
        "idx_generation": 77,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [3],\n        3: [4],\n        4: []\n    }\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 110,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n    \n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    Sample Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    direction = 0\n    result = []\n    \n    while top <= bottom and left <= right:\n        if direction == 0:\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n        elif direction == 1:\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n        elif direction == 2:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        elif direction == 3:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        \n        direction = (direction + 1) % 4\n    \n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the longest common prefix among them.\n    Return the length of the longest common prefix.\n    \"\"\"\n    if not words:\n        return 0\n    \n    prefix = \"\"\n    for i in range(len(words[0])):\n        char = words[0][i]\n        for word in words[1:]:\n            if i >= len(word) or word[i] != char:\n                return len(prefix)\n        prefix += char\n    \n    return len(prefix)\n\n\ndef g():\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words\n\nassert f(g()) == 2\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, perform a clockwise rotation of the matrix by 90 degrees.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the values of the elements in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements visited in a clockwise spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    result = []\n\n    while top <= bottom and left <= right:\n        # Traverse the top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        # Traverse the right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse the bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse the left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string consisting of parentheses, determine if the parentheses are balanced.\n    Return True if the parentheses are balanced, otherwise return False.\n    \"\"\"\n    stack = deque()\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    s = \"((()))()\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 1,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid Sudoku solution.\n    \"\"\"\n    def is_valid_row(row: List[int]) -> bool:\n        return len(set(row)) == 9\n    \n    def is_valid_column(grid, col_index: int) -> bool:\n        column = [row[col_index] for row in grid]\n        return len(set(column)) == 9\n    \n    def is_valid_subgrid(grid, start_row: int, start_col: int) -> bool:\n        subgrid = []\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                subgrid.append(grid[i][j])\n        return len(set(subgrid)) == 9\n    \n    # Check rows\n    for row in grid:\n        if not is_valid_row(row):\n            return False\n    \n    # Check columns\n    for col_index in range(9):\n        if not is_valid_column(grid, col_index):\n            return False\n    \n    # Check subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_subgrid(grid, i, j):\n                return False\n    \n    return True\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(board: List[List[str]]) -> bool:\n    \"\"\"\n    Given a 9x9 Sudoku board, determine if it is valid.\n    The board is valid if each row, each column, and each 3x3 sub-grid contains the digits 1-9 without repetition.\n\n    Example:\n    board = [\n        [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n        [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n        [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n        [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n        [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n        [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n        [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n        [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n        [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The Sudoku board is valid.\n\n    \"\"\"\n\n    # Check rows\n    for row in board:\n        if not is_valid(row):\n            return False\n\n    # Check columns\n    for col in range(9):\n        column = [board[i][col] for i in range(9)]\n        if not is_valid(column):\n            return False\n\n    # Check sub-grids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            sub_grid = [board[row][col] for row in range(i, i + 3) for col in range(j, j + 3)]\n            if not is_valid(sub_grid):\n                return False\n\n    return True\n\n\ndef is_valid(lst: List[str]) -> bool:\n    \"\"\"\n    Helper function to check if a list of strings is valid.\n    A valid list contains the digits 1-9 without repetition.\n\n    \"\"\"\n    digits = set()\n    for val in lst:\n        if val != '.':\n            if val in digits:\n                return False\n            digits.add(val)\n    return True\n\n\ndef g():\n    board = [\n        [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n        [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n        [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n        [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n        [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n        [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n        [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n        [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n        [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n    ]\n    return board\n\n\nassert f(g()) == True\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the two numbers in the list that sum up to the target.\n    Return the product of the two numbers.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    The two numbers that sum up to 12 are 2 and 10.\n    The product of 2 and 10 is 20.\n\n    Therefore, the function should return 20.\n    \"\"\"\n    num_set = set(nums)\n    \n    for num in nums:\n        complement = target - num\n        \n        if complement in num_set:\n            return num * complement\n    \n    return 0\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return (nums, target)\n\nassert f(*g()) == 20\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        curr_xor = max_xor | (1 << i)\n\n        for num in nums:\n            prefix_set.add(num & mask)\n            if curr_xor ^ (num & mask) in prefix_set:\n                max_xor = curr_xor\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the numbers that appear an odd number of times in the list.\n    Return a list containing these numbers.\n\n    Example:\n    Input: nums = [2, 3, 2, 5, 6, 7, 6, 7, 5]\n    Output: [3]\n    \"\"\"\n\n    odd_occurrences = []\n\n    for num in nums:\n        if nums.count(num) % 2 != 0 and num not in odd_occurrences:\n            odd_occurrences.append(num)\n\n    return odd_occurrences\n\ndef g() -> List[int]:\n    nums = [2, 3, 2, 5, 6, 7, 6, 7, 5]\n    return nums\n\nassert f(g()) == [3]\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer n, determine if there exists a subset of nums that sums up to n.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    n = 9\n\n    There exists a subset [2, 3, 4] that sums up to 9.\n\n    Therefore, the function should return True.\n    \"\"\"\n    dp = [[False] * (n+1) for _ in range(len(nums)+1)]\n\n    for i in range(len(nums)+1):\n        dp[i][0] = True\n\n    for i in range(1, len(nums)+1):\n        for j in range(1, n+1):\n            if nums[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n\n    return dp[len(nums)][n]\n\ndef g() -> Tuple[int, List[int]]:\n    n = 9\n    nums = [1, 2, 3, 4, 5]\n    return n, nums\n\nassert f(*g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray is 6, which corresponds to the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 495,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, determine if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[4, 9, 2],\n              [3, 5, 7],\n              [8, 1, 6]]\n    f(matrix) => True\n    Explanation: The sums of each row, each column, and both diagonals are all 15.\n\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[4, 9, 2],\n            [3, 5, 7],\n            [8, 1, 6]]\n\nassert f(g()) == True\n\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the sum of the squares of the even numbers in the given list.\n    Return the sum.\n    \"\"\"\n    even_nums = [num for num in nums if num % 2 == 0]\n    even_squares = [num**2 for num in even_nums]\n    return sum(even_squares)\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 56\n",
        "idx_generation": 351,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [0,1]\n    Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if target - num in complement:\n            return [complement[target - num], i]\n        complement[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and a target sum 'target',\n    find two numbers in the array that add up to the target sum.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target sum 9, so the function should return [0, 1].\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum length of a sequence of 1s in the grid that forms a straight line.\n    The line can be horizontal, vertical, or diagonal.\n\n    Example:\n    grid = [\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest straight line of 1s in the grid is the diagonal line from (0, 0) to (2, 2) with a length of 4.\n\n    \"\"\"\n\n    def get_longest_sequence(grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        max_length = 0\n\n        # Check horizontal lines\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check vertical lines\n        for j in range(cols):\n            length = 0\n            for i in range(rows):\n                if grid[i][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check diagonal lines (top-left to bottom-right)\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if i + j < rows and grid[i + j][j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        # Check diagonal lines (top-right to bottom-left)\n        for i in range(rows):\n            length = 0\n            for j in range(cols):\n                if i + j < rows and grid[i + j][cols - 1 - j] == 1:\n                    length += 1\n                else:\n                    length = 0\n                max_length = max(max_length, length)\n\n        return max_length\n\n    return get_longest_sequence(grid)\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the degree of each node in the graph.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n\n    The degree of each node in the graph is [2, 2, 2, 2].\n\n    Therefore, the function should return [2, 2, 2, 2].\n    \"\"\"\n\n    degrees = []\n\n    for node in range(len(graph)):\n        degree = sum(graph[node])\n        degrees.append(degree)\n\n    return degrees\n\ndef g() -> List[List[int]]:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    return graph\n\nassert f(g()) == [2, 2, 2, 2]\n",
        "idx_generation": 202,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given matrix is a magic square, i.e., the sum of each row, column, and diagonal is the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column_sum = 0\n        for i in range(n):\n            column_sum += matrix[i][j]\n        if column_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n    \n    reverse_diagonal_sum = 0\n    for i in range(n):\n        reverse_diagonal_sum += matrix[i][n - 1 - i]\n    if reverse_diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    matrix = [[4, 9, 2], [3, 5, 7], [8, 1, 6]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using the Kadane's algorithm and return the maximum sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6, -7]\n\nassert f(g()) == 8\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(equation: str) -> bool:\n    \"\"\"\n    Determine if a given equation is balanced by checking if the number of opening and closing parentheses are equal.\n    Return True if the equation is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    \n    for char in equation:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n\ndef g():\n    equation = \"((2 + 3) * (4 - 1))\"\n    return equation\n\nassert f(g()) == True\n",
        "idx_generation": 16,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of n using recursion.\n    Return the factorial.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n to calculate its factorial.\n    \"\"\"\n    return 6\n\nassert f(g()) == 720\n\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    \"\"\"\n    if not arr:\n        return 0\n\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + arr[i])\n\n    return dp[n - 1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n",
        "idx_generation": 97,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum area of a rectangle that can be formed by 1s in the grid.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    heights = [0] * cols\n    max_area = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n        \n        max_area = max(max_area, largest_rectangle_area(heights))\n    \n    return max_area\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    stack = []\n    max_area = 0\n    i = 0\n    \n    while i <= len(heights):\n        if not stack or (i < len(heights) and heights[i] >= heights[stack[-1]]):\n            stack.append(i)\n            i += 1\n        else:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n    \n    return max_area\n\ndef g():\n    grid = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return grid\n\nassert f(g()) == 6\n\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"Check if there exists a path in the given matrix that sums up to the target.\"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i: int, j: int, curr_sum: int) -> bool:\n        nonlocal target\n        if curr_sum == target:\n            return True\n        if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or curr_sum > target:\n            return False\n        visited[i][j] = True\n        if dfs(i + 1, j, curr_sum + matrix[i][j]) or dfs(i - 1, j, curr_sum + matrix[i][j]) or \\\n           dfs(i, j + 1, curr_sum + matrix[i][j]) or dfs(i, j - 1, curr_sum + matrix[i][j]):\n            return True\n        visited[i][j] = False\n        return False\n    \n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, matrix[i][j]):\n                return True\n    return False\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 15)\n",
        "idx_generation": 26,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string and return the count.\n    \"\"\"\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    for char in string:\n        if char.lower() in vowels:\n            count += 1\n\n    return count\n\ndef g() -> str:\n    return \"Hello, World!\"\n\nassert f(g()) == 3\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            if word:\n                stack.append(word)\n                word = \"\"\n        else:\n            word += char\n    if word:\n        stack.append(word)\n    reverse_words = []\n    while stack:\n        reverse_words.append(stack.pop())\n    return \" \".join(reverse_words)\n\ndef g():\n    \"\"\"\n    Generate a string with words in random order.\n    \"\"\"\n    return \"world hello my\"\n\nassert f(g()) == \"my hello world\"\n",
        "idx_generation": 33,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target string, check if it is possible to form the target string by concatenating the words in any order. Each word can only be used once.\n\n    Return True if it is possible to form the target string, False otherwise.\n\n    Sample input:\n    words = [\"hello\", \"world\", \"python\"]\n    target = \"helloworld\"\n\n    Sample output:\n    True\n    \"\"\"\n    def dfs(word, target):\n        if target == \"\":\n            return True\n\n        for i in range(len(words)):\n            if words[i] != \"\":\n                if target.startswith(words[i]):\n                    temp = words[i]\n                    words[i] = \"\"\n                    if dfs(words, target[len(temp):]):\n                        return True\n                    words[i] = temp\n\n        return False\n\n    return dfs(words, target)\n\ndef g():\n    words = [\"hello\", \"world\", \"python\"]\n    target = \"helloworld\"\n    return words, target\n\nassert f(*g()) == True\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise XOR value between any two numbers.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The function should return 28 since the maximum XOR value is between 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        current_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (current_xor ^ prefix) in prefixes:\n                max_xor = current_xor\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    # Create a set to store the complement of each number encountered\n    complements = set()\n\n    for num in nums:\n        # Check if the complement of the current number exists in the set\n        if num ^ target in complements:\n            return True\n\n        # Add the current number to the set\n        complements.add(num)\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 230,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose bitwise AND of all elements is equal to 0.\n    \"\"\"\n    def subset_and(nums, n):\n        if n == 0:\n            return True\n        if not nums:\n            return False\n        include = subset_and(nums[1:], n & nums[0])\n        exclude = subset_and(nums[1:], n)\n        return include or exclude\n    \n    return subset_and(nums, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there exists a subset whose bitwise AND of all elements is equal to 0.\n    \"\"\"\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 86,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if there exists a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if index == len(arr):\n            return False\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(arr, target, index + 1, curr ^ arr[index])\n\n        return exclude or include\n\n    return helper(arr, target, 0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [2, 4, 6, 8, 10]\n\nassert f(g(), 12) == True\n",
        "idx_generation": 234,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given a positive integer n, generate a list of all binary strings of length n.\n\n    Example:\n    n = 3\n    The binary strings of length 3 are ['000', '001', '010', '011', '100', '101', '110', '111'].\n    Return ['000', '001', '010', '011', '100', '101', '110', '111'].\n    \"\"\"\n    strings = []\n\n    for i in range(2 ** n):\n        binary = bin(i)[2:]\n        binary = '0' * (n - len(binary)) + binary\n        strings.append(binary)\n\n    return strings\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == ['000', '001', '010', '011', '100', '101', '110', '111']\n\n",
        "idx_generation": 472,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the squares of all the positive integers less than or equal to n.\n\n    Example:\n    n = 5\n    Output: 55\n    Explanation: The sum of the squares of numbers less than or equal to 5 is 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55.\n\n    Constraints:\n    - n will be a positive integer.\n    \"\"\"\n    return sum([i**2 for i in range(1, n+1)])\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 55\n",
        "idx_generation": 451,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, value):\n        self.stack.append(value)\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack.pop()\n    \n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to reach the target value using the following operations:\n    - Push a number from the list onto a stack\n    - Pop the top number from the stack\n    Return True if the target value can be reached, False otherwise.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n    Explanation: It is possible to reach the target value 6 by pushing 1 and 2 onto the stack, and then popping both numbers from the stack.\n    \"\"\"\n\n    stack = Stack()\n    for num in nums:\n        stack.push(num)\n        while not stack.is_empty() and stack.stack[-1] == target:\n            stack.pop()\n    \n    return not stack.is_empty()\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    55\n\n    \"\"\"\n    def fibonacci(n, memo):\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 299,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Return the number of paths.\n\n    Example:\n    n = 3\n\n    The grid is represented as follows:\n    1 1 1\n    1 1 1\n    1 1 1\n\n    There are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    paths = factorial(2 * (n - 1)) // (factorial(n - 1) ** 2)\n\n    return paths\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner\n    of a grid of size n x n. You can only move right and down.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: There are six unique paths from the top-left corner to the bottom-right corner:\n    1) Right -> Right -> Down\n    2) Right -> Down -> Right\n    3) Down -> Right -> Right\n    4) Down -> Down -> Right\n    5) Down -> Right -> Down\n    6) Right -> Down -> Down\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 192,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a perfect square.\"\"\"\n    return n & int(n ** 0.5) == 0\ndef g():\n    perfect_square = 1\n    while True:\n        if f(perfect_square):\n            return perfect_square\n        perfect_square += 1\nassert f(g()) == True\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(graph: List[List[int]], g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]) -> bool:\n    \"\"\"\n    Given a graph and two sets of edges, determine if the graph is a permutation of either set of edges.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(graph) == len(set(graph)) and {(i, j) for (i, j) in g1} == {(graph[i], graph[j]) for (i, j) in g2}\ndef g(g1 = [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2 = [[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):\n    # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\"\nassert f(g()) == True\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine if there exists a square subgrid with all 1s,\n    where the side length of the square is a power of 2.\n\n    Example:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 1, 1, 0],\n        [1, 1, 0, 0],\n        [1, 0, 0, 0]\n    ]\n\n    There exists a square subgrid with all 1s of side length 2.\n\n    Therefore, the function should return True.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    def is_square_subgrid(i, j, k):\n        for x in range(i, i + k):\n            for y in range(j, j + k):\n                if grid[x][y] != 1:\n                    return False\n        return True\n\n    for i in range(m):\n        for j in range(n):\n            for k in range(min(m - i, n - j)):\n                if is_square_subgrid(i, j, 2 ** k):\n                    return True\n    return False\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1, 1],\n        [1, 1, 1, 0],\n        [1, 1, 0, 0],\n        [1, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the number of unique k-digit numbers that can be formed using the digits of n.\n    \"\"\"\n\n    def factorial(num):\n        if num == 0:\n            return 1\n        return num * factorial(num - 1)\n\n    def count_unique_numbers(num, k):\n        count = [0] * 10\n        while num > 0:\n            digit = num % 10\n            count[digit] += 1\n            num //= 10\n        total = factorial(sum(count))\n        for c in count:\n            total //= factorial(c)\n        return total\n\n    return count_unique_numbers(n, k) > 0\ndef g(n=12345, k=3):\n    return n, k\nassert f(*g())\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of unique combinations of the integers that sum up to the target.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n        \n        for i in range(start, len(nums)):\n            backtrack(nums, target - nums[i], i, path + [nums[i]], result)\n    \n    result = []\n    backtrack(nums, target, 0, [], result)\n    return len(result)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == 2\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k=2) -> bool:\n    \"\"\"\n    Given a string 's', determine if it can be partitioned into 'k' non-empty substrings such that each substring\n    is a palindrome.\n\n    Return True if such a partition is possible, False otherwise.\n    \"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]\n\n    def backtrack(start, count):\n        if count == k:\n            return True\n        for end in range(start, len(s)):\n            substring = s[start:end + 1]\n            if is_palindrome(substring):\n                if backtrack(end + 1, count + 1):\n                    return True\n        return False\n    \n    return backtrack(0, 0)\n\ndef g(s=\"levelonemorelevel\", k=2):\n    \"\"\"\n    Partition the string 's' into 'k' non-empty substrings such that each substring is a palindrome.\n    \"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    if k == 1:\n        return [s]\n    \n    palindromes = []\n    for i in range(1, len(s)):\n        substring = s[:i]\n        if is_palindrome(substring):\n            remaining = g(s[i:], k - 1)\n            if remaining:\n                return [substring] + remaining\n    return []\n\nassert f(g()) == True\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return all possible combinations of numbers that add up to the target.\n    Each number in nums may only be used once in each combination.\n\n    Example:\n    Input: nums = [10,1,2,7,6,1,5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation:\n    1 + 1 + 6 = 8\n    1 + 2 + 5 = 8\n    1 + 7 = 8\n    2 + 6 = 8\n    \"\"\"\n\n    def backtrack(start, current_sum, current_combination):\n        if current_sum == target:\n            combinations.append(current_combination[:])\n            return\n        if current_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i], current_combination)\n            current_combination.pop()\n\n    nums.sort()\n    combinations = []\n    backtrack(0, 0, [])\n    return combinations\n\ndef g():\n    nums = [10,1,2,7,6,1,5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to represent n as a sum of positive integers, where the order of the addends doesn't matter.\n\n    Example:\n    Input: n = 5\n    Output: 7\n    Explanation: There are 7 ways to represent 5 as a sum of positive integers: 1+1+1+1+1, 1+1+1+2, 1+1+3, 1+2+2, 1+4, 2+3, 5.\n\n    Input: n = 10\n    Output: 42\n    Explanation: There are 42 ways to represent 10 as a sum of positive integers.\n\n    Input: n = 3\n    Output: 3\n    Explanation: There are 3 ways to represent 3 as a sum of positive integers.\n    \"\"\"\n    def count_partitions(n: int, k: int) -> int:\n        if n == 0:\n            return 1\n        if k == 0 or n < 0:\n            return 0\n        return count_partitions(n - k, k) + count_partitions(n, k - 1)\n\n    return count_partitions(n, n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 11\n",
        "idx_generation": 78,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return a list of all possible combinations of k numbers out of the range [1, n].\n\n    The combinations should be sorted in lexicographic order.\n\n    Example:\n    Input:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(start, combination):\n        # Base case: if the combination has k elements, add it to the result\n        if len(combination) == k:\n            result.append(combination[:])\n            return\n\n        # Try all possible numbers starting from 'start'\n        for i in range(start, n + 1):\n            combination.append(i)\n            # Recursively backtrack with the next number\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the position of the target element using binary search.\n\n    Return the index of the target element if found, otherwise return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=4):\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if it is sorted in non-decreasing order.\n    \"\"\"\n    for i in range(len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            return False\n    return True\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a subsequence of length k, where the sum of the subsequence is equal to the target.\n\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    if k > n or sum(nums[:k]) > target:\n        return False\n\n    # Initialize a stack to store the indices of the subsequence\n    stack = []\n    stack.append(0)\n    curr_sum = nums[0]\n    k -= 1\n\n    for i in range(1, n):\n        curr_sum += nums[i]\n\n        # If the current sum exceeds the target, remove elements from the start of the subsequence\n        while curr_sum > target:\n            curr_sum -= nums[stack.pop(0)]\n            k += 1\n\n        stack.append(i)\n        k -= 1\n\n        # If the subsequence length is equal to k and the current sum is equal to the target, return True\n        if k == 0 and curr_sum == target:\n            return True\n\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6], target = 12, k = 3):\n    return nums, target, k\n\nassert f(*g())\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in non-decreasing order using merge sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = f(arr[:mid])\n    right = f(arr[mid:])\n    \n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    \n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    \n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    \n    return arr\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers to be sorted.\n    \"\"\"\n    return [5, 2, 8, 1, 9, 3]\n\nassert f(g()) == [1, 2, 3, 5, 8, 9]\n\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to find the index of the target value in the list.\n    If the target value is not found, return -1.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2 (index of 5 in the list)\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return -1\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains a non-negative integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Args:\n    - grid: A 2D grid of size m x n, where each cell contains a non-negative integer.\n\n    Returns:\n    - The maximum XOR value that can be obtained.\n\n    Example:\n    f([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> 15\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    max_xor = 0\n    for col in range(n):\n        heap = []\n        for row in range(m):\n            heapq.heappush(heap, -grid[row][col])\n        xor = 0\n        while heap:\n            xor ^= -heapq.heappop(heap)\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of size m x n and a positive integer m and n.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix filled with integers, return the values of the matrix in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(matrix) => [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a palindrome.\"\"\"\n    stack = []\n    for num in arr:\n        stack.append(num)\n    reversed_arr = []\n    while stack:\n        reversed_arr.append(stack.pop())\n    return arr == reversed_arr\n\ndef g():\n    return [1, 2, 3, 2, 1]\n\nassert f(g()) == True\n",
        "idx_generation": 92,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    visited = {}\n\n    for i in range(len(s)):\n        if s[i] in visited and start <= visited[s[i]]:\n            start = visited[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        visited[s[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 122,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next greater element for each element in the list.\n\n    Example:\n    Input: nums = [3, 1, 4, 2, 8, 5, 7, 6]\n    Output: [4, 4, 8, 8, -1, 7, -1, -1]\n\n    Explanation:\n    For each element in the list, the next greater element is the smallest element that comes after it and is greater than it. If there is no such element, the result is -1.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums, where there exists the next greater element for each element in the list.\n    \"\"\"\n    return [3, 1, 4, 2, 8, 5, 7, 6]\n\nassert f(g()) == [4, 4, 8, 8, -1, 7, -1, -1]\n\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of integers in the list\n    whose XOR is equal to the target number.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    There exists a pair (2, 8) whose XOR is equal to the target number 10.\n\n    Therefore, the function should return True.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if target ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g() -> (List[int], int):\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"Check if the given array is a perfect square.\"\"\"\n    return len(arr) > 0 and all(a == arr[0] for a in arr) and int(arr[0] ** 0.5) ** 2 == arr[0]\n\ndef g():\n    return [4, 4, 4, 4]\n    \nassert f(g()) == True\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are three integers in nums such that the sum is equal to the target.\n    \"\"\"\n    def three_sum(nums: List[int], target: int, start: int, curr_sum: int, curr_nums: List[int]) -> bool:\n        if len(curr_nums) == 3 and curr_sum == target:\n            return True\n        if len(curr_nums) == 3:\n            return False\n        \n        for i in range(start, len(nums)):\n            if three_sum(nums, target, i + 1, curr_sum + nums[i], curr_nums + [nums[i]]):\n                return True\n        \n        return False\n\n    return three_sum(nums, target, 0, 0, [])\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([-2, -1, 0, 1, 2, 3], 0)\n\nassert f(*g()) == True\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid represented by a 2D list of integers, determine if there exists a path from the top-left corner to the bottom-right corner, only moving right or down, such that the sum of the values along the path is greater than or equal to a target value.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[rows - 1][cols - 1] >= 0\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid crossword solution.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if len(row) != n:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        column = [grid[i][j] for i in range(n)]\n        if len(column) != n:\n            return False\n    \n    # Check for intersections\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if (i > 0 and grid[i-1][j] == 1) or (i < n-1 and grid[i+1][j] == 1) or \\\n                   (j > 0 and grid[i][j-1] == 1) or (j < n-1 and grid[i][j+1] == 1):\n                    continue\n                else:\n                    return False\n    \n    return True\n\ndef g():\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == True\n\n",
        "idx_generation": 353,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a 2D matrix, rotate the matrix clockwise by 90 degrees.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(matrix) => [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix by 90 degrees (clockwise) in-place.\n\n    Example:\n    Input:\n    [[1,2,3],\n     [4,5,6],\n     [7,8,9]]\n\n    Output:\n    [[7,4,1],\n     [8,5,2],\n     [9,6,3]]\n    \"\"\"\n\n    n = len(matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row of the matrix\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n\n    return matrix\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n",
        "idx_generation": 93,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer target, determine if it is possible to obtain target by performing multiplication and division operations on the elements of nums.\n    \"\"\"\n    stack = [nums[0]]\n    for num in nums[1:]:\n        temp_stack = []\n        while stack:\n            temp = stack.pop()\n            temp_stack.append(temp * num)\n            if num != 0:\n                temp_stack.append(temp // num)\n        stack.extend(temp_stack)\n    return target in stack\n\ndef g(nums = [2, 3, 4], target = 24):\n    return nums\n\nassert f(g(), 24)\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, determine if it is possible to arrange n distinct numbers in a circle in such a way that the absolute difference between any two adjacent numbers is exactly k.\n\n    Example:\n    Input: n = 4, k = 2\n    Output: True\n\n    Explanation: One possible arrangement is [1, 3, 4, 2], where the absolute difference between any two adjacent numbers is 2.\n\n    Constraints:\n    - 1 <= n <= 10^9\n    - 1 <= k <= n\n    \"\"\"\n\n    if k == 0:\n        return n == 1\n    if n % 2 == 0 and k > n // 2:\n        return False\n    return n % k == 0\n\ndef g(n = 4, k = 2) -> Tuple[int, int]:\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 352,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers from the list that add up to the target value.\n    Return the indices of these two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to 9 are 2 and 7. Their indices in the list are 0 and 1, respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 306,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which is obtained by XORing 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n    \n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 238,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and a target integer, find two numbers such that they add up to the target.\n    Return the indices of the two numbers in the input array.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of numbers at indices 0 and 1 is equal to the target value 9.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray is [4, -1, 2, 1], which sums up to 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the product of all the even numbers.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num % 2 == 0:\n            stack.append(num)\n    product = 1\n    while stack:\n        product *= stack.pop()\n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == 3840\n",
        "idx_generation": 450,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string and an integer n, return True if the string can be divided into n equal parts,\n    otherwise return False.\n    \"\"\"\n    if len(s) % n != 0:\n        return False\n    part_length = len(s) // n\n    parts = [s[i:i+part_length] for i in range(0, len(s), part_length)]\n    if all(part == parts[0] for part in parts):\n        return True\n    return False\n\ndef g(n: int) -> str:\n    \"\"\"\n    Generate a string by repeating a pattern n times.\n    \"\"\"\n    pattern = \"AB\"\n    return pattern * n\n\nn = 3\nassert f(g(n), n)\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray within the list.\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers\n    such that they add up to target. You may assume that each input would have exactly one\n    solution, and you may not use the same element twice. You can return the answer in any order.\n    \"\"\"\n\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 258,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport numpy as np\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a square matrix of integers, find the maximum sum of a submatrix.\n\n    Sample Input:\n    matrix = [\n        [1, 2, -1],\n        [-2, 3, 4],\n        [5, -8, 9]\n    ]\n\n    Sample Output:\n    13\n\n    Explanation: The maximum sum submatrix is [[3, 4], [-8, 9]], which has a sum of 13.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n\n            current_sum = 0\n            max_temp_sum = float('-inf')\n\n            for i in range(rows):\n                current_sum = max(temp[i], current_sum + temp[i])\n                max_temp_sum = max(max_temp_sum, current_sum)\n\n            max_sum = max(max_sum, max_temp_sum)\n\n    return max_sum\n\ndef g():\n    matrix = [\n        [1, 2, -1],\n        [-2, 3, 4],\n        [5, -8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 13\n\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a spiral matrix of size n x n.\n\n    Example:\n    Input: n = 3\n    Output: [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n\n    Explanation:\n    The spiral matrix should look like this:\n    1 2 3\n    8 9 4\n    7 6 5\n\n    The numbers are filled in a clockwise spiral order starting from the top-left corner.\n    \"\"\"\n\n    def generate_spiral(matrix: List[List[int]], num: int, row: int, col: int, direction: int):\n        if num > n * n:\n            return\n\n        matrix[row][col] = num\n\n        if direction == 0:  # right\n            if col + 1 >= n or matrix[row][col + 1] != 0:\n                generate_spiral(matrix, num + 1, row + 1, col, 1)  # go down\n            else:\n                generate_spiral(matrix, num + 1, row, col + 1, 0)  # go right\n        elif direction == 1:  # down\n            if row + 1 >= n or matrix[row + 1][col] != 0:\n                generate_spiral(matrix, num + 1, row, col - 1, 2)  # go left\n            else:\n                generate_spiral(matrix, num + 1, row + 1, col, 1)  # go down\n        elif direction == 2:  # left\n            if col - 1 < 0 or matrix[row][col - 1] != 0:\n                generate_spiral(matrix, num + 1, row - 1, col, 3)  # go up\n            else:\n                generate_spiral(matrix, num + 1, row, col - 1, 2)  # go left\n        else:  # up\n            if row - 1 < 0 or matrix[row - 1][col] != 0:\n                generate_spiral(matrix, num + 1, row, col + 1, 0)  # go right\n            else:\n                generate_spiral(matrix, num + 1, row - 1, col, 3)  # go up\n\n    matrix = [[0] * n for _ in range(n)]\n    generate_spiral(matrix, 1, 0, 0, 0)\n    return matrix\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 19,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value between any two elements in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    Output: 1 (minimum XOR value is between 3 and 2)\n\n    Explanation:\n    The minimum XOR value between any two elements is 1.\n    \"\"\"\n    min_xor = float('inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor < min_xor:\n                min_xor = xor\n    return min_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 1\n\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    stack = []\n    for num in nums:\n        complement = target - num\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones,\n    usually starting with 0 and 1.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\".\n\n    Hint: Use dynamic programming and sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n    max_length = 0\n    start = 0\n    used_chars = {}\n    \n    for i, char in enumerate(s):\n        if char in used_chars and start <= used_chars[char]:\n            start = used_chars[char] + 1\n        max_length = max(max_length, i - start + 1)\n        used_chars[char] = i\n    \n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the area of the largest rectangle that can be formed with only 1s.\n    The rectangle must be aligned with the grid and can only be formed using adjacent 1s.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n\n    The largest rectangle that can be formed with only 1s is of area 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    heights = [0] * cols\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                heights[j] += 1\n            else:\n                heights[j] = 0\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    stack = [-1]\n    max_area = 0\n\n    for i, height in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] >= height:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area\n\ndef g():\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, check if there exists a path from the top-left corner to the bottom-right corner\n    by traversing only the cells with the value 1. You can move in any of the four cardinal directions (up, down,\n    left, right) but cannot visit cells with the value 0.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] != 1:\n            return False\n        grid[row][col] = -1\n        return dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1)\n    \n    return dfs(0, 0)\n    \ndef g():\n    return [[1, 1, 0, 0, 0],\n            [0, 1, 1, 0, 1],\n            [0, 0, 1, 1, 1],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 1]]\n    \nassert f(g()) == True\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(s: str, words: List[str]) -> List[int]:\n    \"\"\"\n    Given a string s and a list of words, find all the starting indices of the substrings in s that are a concatenation of all the words in the list.\n    The words in the list may appear in any order and multiple times.\n    \"\"\"\n\n    def is_concatenation(s: str, words: List[str], start: int) -> bool:\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        substring = s[start:start+total_len]\n        substring_words = [substring[i:i+word_len] for i in range(0, total_len, word_len)]\n\n        count = {}\n        for word in substring_words:\n            count[word] = count.get(word, 0) + 1\n\n        for word in words:\n            if count.get(word, 0) != words.count(word):\n                return False\n\n        return True\n\n    result = []\n    if not s or not words:\n        return result\n\n    word_len = len(words[0])\n    total_len = word_len * len(words)\n    n = len(s)\n\n    for i in range(n - total_len + 1):\n        if is_concatenation(s, words, i):\n            result.append(i)\n\n    return result\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words, where the starting indices of the substrings in s that are a concatenation of all the words in the list can be found.\n    \"\"\"\n    return \"barfoothefoobarman\", [\"foo\", \"bar\"]\n\nassert f(*g()) == [0, 9]\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    stack = deque()\n    queue = deque()\n    \n    for char in s:\n        stack.append(char)\n        queue.append(char)\n    \n    while stack and queue:\n        if stack.pop() != queue.popleft():\n            return False\n    \n    return True\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 221,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the minimum number of operations required to make s a palindrome.\n\n    Example:\n    Input: \"abcde\"\n    Output: 4 (The minimum number of operations required to make \"abcde\" a palindrome is 4: replace 'a' with 'e', replace 'b' with 'd', replace 'c' with 'c', and add 'e' at the end)\n\n    Hint: Use dynamic programming and recursion to find the minimum number of operations.\n    \"\"\"\n    def dp(i, j):\n        if i >= j:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        if s[i] == s[j]:\n            memo[i][j] = dp(i + 1, j - 1)\n        else:\n            memo[i][j] = 1 + min(dp(i + 1, j), dp(i, j - 1))\n        return memo[i][j]\n\n    memo = [[-1] * len(s) for _ in range(len(s))]\n    return dp(0, len(s) - 1)\n\ndef g():\n    return \"abcde\"\n\nassert f(g()) == 4\n",
        "idx_generation": 247,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    Input: 11\n    Output: 3\n    Explanation: The binary representation of 11 is \"1011\", which contains 3 ones.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n=11):\n    return n\n\nassert f(g()) == 3\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise XOR of each number with the previous number in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: [1, 3, 1, 7, 1] (1 ^ 2 = 3, 2 ^ 3 = 1, 3 ^ 4 = 7, 4 ^ 5 = 1)\n\n    Hint: Use bit manipulation to perform the XOR operation.\n    \"\"\"\n    xor_list = [nums[0]]\n    for i in range(1, len(nums)):\n        xor_list.append(nums[i] ^ nums[i-1])\n\n    return xor_list\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 1, 7, 1]\n",
        "idx_generation": 307,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if there exists a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= arr[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Find a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in arr:\n        if num ^ target in arr:\n            subset.append(num)\n    return subset\n\narr = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(g(arr, target), target) == True\n\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset of the list such that the bitwise XOR of\n    all the numbers in the subset is equal to 0.\n    \"\"\"\n    def helper(nums, target):\n        if target == 0:\n            return True\n        if not nums or target < 0:\n            return False\n        if helper(nums[1:], target ^ nums[0]):\n            return True\n        return helper(nums[1:], target)\n\n    return helper(nums, 0)\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all positive integers up to n.\n\n    Return the sum.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\n# Test case\nn = 10\nassert f(g(n)) == 55\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of unique binary strings of length n\n    that do not contain consecutive ones.\n\n    Example:\n    Input: 4\n    Output: 8\n    Explanation: The unique binary strings of length 4 that do not contain consecutive ones are:\n    0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010.\n    \"\"\"\n    if n == 0:\n        return 0\n    \n    ending_with_zero = 1\n    ending_with_one = 1\n    \n    for i in range(2, n + 1):\n        ending_with_zero, ending_with_one = ending_with_zero + ending_with_one, ending_with_zero\n    \n    return ending_with_zero + ending_with_one\n\ndef g():\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    return 4\n\nassert f(g()) == 8\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    f(grid) => 1 + 4 + 7 + 8 + 9 = 29\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 29\n\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a power of two.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Explanation:\n    16 is a power of two (2^4 = 16).\n    \"\"\"\n    if n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g():\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner\n    by only moving down, right, or diagonally. The path can only traverse cells with a value of 1.\n\n    Example:\n    matrix = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    There exists a path from (0, 0) to (3, 3): [(0, 0), (1, 1), (2, 2), (2, 3), (3, 3)].\n\n    Therefore, the function should return True.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        if i < m - 1 and matrix[i + 1][j] == 1:\n            if dfs(i + 1, j):\n                return True\n\n        if j < n - 1 and matrix[i][j + 1] == 1:\n            if dfs(i, j + 1):\n                return True\n\n        if i < m - 1 and j < n - 1 and matrix[i + 1][j + 1] == 1:\n            if dfs(i + 1, j + 1):\n                return True\n\n        return False\n\n    return dfs(0, 0)\n\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return matrix\n\n\nassert f(g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if there is a path from the top-left corner to the bottom-right corner of the grid.\"\"\"\n    stack = [(0, 0)]\n    while stack:\n        x, y = stack.pop()\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return True\n        if x + 1 < len(grid):\n            stack.append((x + 1, y))\n        if y + 1 < len(grid[0]):\n            stack.append((x, y + 1))\n    return False\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"Transpose the grid.\"\"\"\n    return [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))]\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n",
        "idx_generation": 3,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique islands.\n    An island is defined as a group of connected 1s.\n    Two 1s are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 unique islands in the grid.\n    \"\"\"\n\n    def dfs(row, col, island):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        island.append((row, col))\n        dfs(row - 1, col, island)\n        dfs(row + 1, col, island)\n        dfs(row, col - 1, island)\n        dfs(row, col + 1, island)\n\n    unique_islands = set()\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                island = []\n                dfs(row, col, island)\n                unique_islands.add(tuple(sorted(island)))\n\n    return len(unique_islands)\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 222,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a grid of characters and a word, determine if the word can be formed by connecting adjacent letters horizontally or vertically in the grid.\n    Return True if the word can be formed, False otherwise.\n\n    Example:\n    grid = [['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']]\n\n    f(grid, 'ABC') => True\n    Explanation: The word \"ABC\" can be formed by connecting adjacent letters in the grid.\n    \"\"\"\n\n    def dfs(i, j, word_idx):\n        if word_idx >= len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[word_idx]:\n            return False\n        temp = grid[i][j]\n        grid[i][j] = '#'\n        if dfs(i-1, j, word_idx+1) or dfs(i+1, j, word_idx+1) or dfs(i, j-1, word_idx+1) or dfs(i, j+1, word_idx+1):\n            return True\n        grid[i][j] = temp\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n    return False\n\ndef g():\n    return ([['A', 'B', 'C'],\n            ['D', 'E', 'F'],\n            ['G', 'H', 'I']], 'ABC')\n\nassert f(*g()) == True\n",
        "idx_generation": 137,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import Tuple\n\ndef f(n: int, k: int) -> Tuple[int, int]:\n    \"\"\"\n    Given two positive integers n and k, find the number of ways to choose k items from a set of n items.\n    Return the total number of combinations and permutations.\n\n    Example:\n    Input:\n    n = 5\n    k = 3\n\n    Output:\n    (10, 60)\n\n    Explanation:\n    There are 10 combinations (unordered) of choosing 3 items from a set of 5 items: (5 choose 3) = 10.\n    There are 60 permutations (ordered) of choosing 3 items from a set of 5 items: (5 permute 3) = 60.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    combinations = factorial(n) // (factorial(k) * factorial(n - k))\n    permutations = factorial(n) // factorial(n - k)\n\n    return (combinations, permutations)\n\ndef g():\n    n = 5\n    k = 3\n    return [n, k]\n\nassert f(*g()) == (10, 60)\n\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, return True if there are k numbers in the list whose sum is equal to the target,\n    otherwise return False. Implement the solution using a brute-force search algorithm.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    k = 3\n\n    Sample Output:\n    True\n\n    \"\"\"\n    def helper(nums, target, k, start, curr_sum):\n        if k == 0:\n            return curr_sum == target\n        if start == len(nums):\n            return False\n        \n        return helper(nums, target, k-1, start+1, curr_sum+nums[start]) or helper(nums, target, k, start+1, curr_sum)\n    \n    return helper(nums, target, k, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    k = 3\n    return nums, target, k\n\nassert f(*g()) == True\n",
        "idx_generation": 41,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of stock prices, find the maximum profit that can be obtained by buying and selling the stocks.\n    You can only make one transaction (buy and sell) and you cannot sell a stock before buying one.\n    \"\"\"\n    max_profit = 0\n    min_price = float('inf')\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit\n\n\ndef g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices\n\nassert f(g()) == 5\n\n",
        "idx_generation": 165,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string and a dictionary of words, determine if the string can be segmented into a space-separated\n    sequence of one or more dictionary words.\n    \"\"\"\n    word_set = set(wordDict)\n    memo = {}\n    return dfs(s, word_set, memo)\n\ndef dfs(s, word_set, memo):\n    if s in memo:\n        return memo[s]\n    if s in word_set:\n        return True\n    for i in range(1, len(s)):\n        prefix = s[:i]\n        suffix = s[i:]\n        if prefix in word_set and dfs(suffix, word_set, memo):\n            memo[s] = True\n            return True\n    memo[s] = False\n    return False\n\ndef g():\n    s = \"applepie\"\n    wordDict = [\"apple\", \"pie\"]\n    return s, wordDict\n\nassert f(*g())\n",
        "idx_generation": 69,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and two integers n and k, determine if it is possible to split the list into k non-empty subsets,\n    such that the sum of each subset is less than or equal to n.\n    \"\"\"\n    def can_partition(nums, k, target, current_sum, start):\n        if k == 1:\n            return True\n        if current_sum > target:\n            return False\n        if current_sum == target:\n            return can_partition(nums, k - 1, target, 0, 0)\n        for i in range(start, len(nums)):\n            if not used[i]:\n                used[i] = True\n                if can_partition(nums, k, target, current_sum + nums[i], i + 1):\n                    return True\n                used[i] = False\n        return False\n    \n    max_num = max(nums)\n    if max_num > n:\n        return False\n    target = n - max_num\n    used = [False] * len(nums)\n    return can_partition(nums, k, target, 0, 0)\ndef g(n = 10, k = 3, nums = [1, 2, 3, 4, 5, 6, 7]):\n    return n, k, nums\nassert f(*g())\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    The even numbers in the list are [2, 4, 6], and their sum is 12.\n    Return 12.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 413,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target value, determine if the target exists in the grid.\n    The grid is sorted in ascending order both row-wise and column-wise.\n    \n    Sample Input:\n    grid = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    \n    Sample Output:\n    True\n    \"\"\"\n    if not grid or not grid[0]:\n        return False\n    \n    rows, cols = len(grid), len(grid[0])\n    row, col = rows - 1, 0\n    \n    while row >= 0 and col < cols:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            col += 1\n        else:\n            row -= 1\n    \n    return False\n\ndef g():\n    grid = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g()) == True\n",
        "idx_generation": 134,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport heapq\n\ndef f(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Find the kth smallest element in the array arr using a heap.\n    \"\"\"\n    heap = []\n    for num in arr:\n        heapq.heappush(heap, num)\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap))\n    return res[-1]\n\ndef g(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Generate an array arr and an integer k to find the kth smallest element in the array.\n    \"\"\"\n    return arr, k\n\narr = [4, 2, 7, 1, 9, 5]\nk = 3\nassert f(*g(arr, k)) == 4\n",
        "idx_generation": 93,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, determine if it is possible to select k elements from the list\n    such that their sum is equal to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total == target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort(reverse=True)\n    return backtrack(0, 0, 0)\n\n\ndef g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and an integer k, such that it is possible to select k elements from the list\n    such that their sum is equal to the target.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums, target, k\n\n# Test case\nnums = [5, 4, 3, 2, 1]\ntarget = 10\nk = 3\nassert f(*g(nums, target, k))\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subarray (consecutive elements in increasing order).\n\n    Example:\n    Input: [1, 2, 3, 2, 5, 6, 7]\n    Output: 4 (The longest increasing subarray is [2, 5, 6, 7])\n\n    Hint: Use a stack to keep track of the current increasing subarray.\n    \"\"\"\n\n    max_length = 0\n    current_length = 0\n\n    for i in range(len(arr)):\n        if i == 0 or arr[i] > arr[i-1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    max_length = max(max_length, current_length)\n\n    return max_length\n\ndef g():\n    return [1, 2, 3, 2, 5, 6, 7]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 195,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses string.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(s=\"((())())\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 102,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"level\"\n    Output: True\n    Explanation: The string \"level\" is already a palindrome.\n\n    Input: \"racecar\"\n    Output: True\n    Explanation: The string \"racecar\" is already a palindrome.\n\n    Input: \"abccdba\"\n    Output: True\n    Explanation: The string \"abccdba\" is a palindrome after removing the character 'c' at index 3.\n    \"\"\"\n\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            # Try removing either the character at the left index or the character at the right index\n            return is_palindrome(s, left, right - 1) or is_palindrome(s, left + 1, right)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string with at most one character that can be removed.\n    \"\"\"\n    return \"abccdba\"\n\nassert f(g()) == True\n",
        "idx_generation": 274,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of numbers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g(), 22) == True\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n    \n    Sample Input:\n    nums = [1, 3, 5, 6]\n    target = 5\n    \n    Sample Output:\n    2\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n\ndef g():\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 31,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n    output: 8\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    return fib[n]\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 300,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a subset of the list that sums up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    Output: True\n    Explanation: There exists a subset [2, 3, 4] that sums up to the target number 9.\n\n    Note:\n    - The list can contain both positive and negative integers.\n    - You may assume that the list does not contain duplicate elements.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum of a path from the top-left corner to the bottom-right corner. You can only move down or right. Each cell can be visited only once.\n\n    Example:\n    Input: [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    Output: 7\n\n    Explanation: The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 7.\n    \"\"\"\n\n    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    def min_path(i: int, j: int) -> int:\n        if i < 0 or j < 0:\n            return float('inf')\n        if i == 0 and j == 0:\n            return grid[0][0]\n        return min(min_path(i-1, j), min_path(i, j-1)) + grid[i][j]\n\n    return min_path(m-1, n-1)\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether the given matrix is a magic square.\n    \"\"\"\n    n = len(matrix)\n    row_sum = [0] * n\n    col_sum = [0] * n\n    diag_sum = [0, 0]\n    \n    for i in range(n):\n        for j in range(n):\n            row_sum[i] += matrix[i][j]\n            col_sum[j] += matrix[i][j]\n            if i == j:\n                diag_sum[0] += matrix[i][j]\n            if i + j == n - 1:\n                diag_sum[1] += matrix[i][j]\n    \n    target_sum = row_sum[0]\n    \n    if any(sum != target_sum for sum in row_sum + col_sum + diag_sum):\n        return False\n    \n    return True\n\ndef g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g())\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the maximum area of a rectangle containing only 1s.\n\n    Example:\n    grid = [\n        [1, 0, 0, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 0, 1, 1, 1],\n        [1, 0, 1, 1, 0],\n        [1, 1, 0, 0, 0]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum area rectangle containing only 1s is formed by the 1s in the bottom left corner of the grid: \n    [\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n\n    \"\"\"\n\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    heights = [0] * cols\n    max_area = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                heights[j] = 0\n            else:\n                heights[j] += 1\n\n        max_area = max(max_area, largest_rectangle_area(heights))\n\n    return max_area\n\n\ndef largest_rectangle_area(heights: List[int]) -> int:\n    stack = []\n    max_area = 0\n    index = 0\n\n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (index if not stack else index - stack[-1] - 1)\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (index if not stack else index - stack[-1] - 1)\n        max_area = max(max_area, area)\n\n    return max_area\n\n\ndef g():\n    grid = [\n        [1, 0, 0, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 0, 1, 1, 1],\n        [1, 0, 1, 1, 0],\n        [1, 1, 0, 0, 0]\n    ]\n    return grid\n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid parentheses sequence.\n\n    A valid parentheses sequence is one that contains only pairs of opening and closing parentheses, \n    and for any closing parenthesis, there is a corresponding opening parenthesis before it.\n\n    Sample Input:\n    s = \"((()))\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"(()()\"\n\n    Sample Output:\n    False\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return len(stack) == 0\n\ndef g(s: str = \"((()))\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest consecutive subsequence.\n\n    A consecutive subsequence is a sequence of numbers where each number appears exactly once and the difference between\n    consecutive numbers is exactly 1.\n\n    Return the length of the longest consecutive subsequence.\n\n    Example:\n    Input: nums = [100, 4, 200, 1, 3, 2]\n    Output: 4\n    Explanation: The longest consecutive subsequence is [1, 2, 3, 4], which has a length of 4.\n    \"\"\"\n    num_set = set(nums)\n    longest_streak = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n\ndef g():\n    nums = [100, 4, 200, 1, 3, 2]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1, which are 2 and 7, add up to 9.\n    \"\"\"\n\n    n = len(nums)\n    num_dict = {}\n\n    for i in range(n):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 368,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"Check if there exists a subarray in nums with length k that contains both odd and even numbers\"\"\"\n    stack = deque()\n    stack.append((0, [], False, False))\n    while stack:\n        idx, subarray, has_odd, has_even = stack.pop()\n        if len(subarray) == k and has_odd and has_even:\n            return True\n        if idx < len(nums):\n            stack.append((idx + 1, subarray + [nums[idx]], has_odd or nums[idx] % 2 != 0, has_even or nums[idx] % 2 == 0))\n            stack.append((idx + 1, subarray, has_odd, has_even))\n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], k: int = 3) -> List[int]:\n    return nums\n\nassert f(g(), k=3)\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two numbers in the array.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the list.\n    \n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    \n    Explanation:\n    The sum of 2 and 7 is 9, which is the target. Therefore, the indices of 2 and 7 in the list are [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine if it is possible to reach the target\n    by performing arithmetic operations (+ or -) on the given numbers.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return False\n    subset_sum = (total_sum + target) // 2\n    return subset_sum_exists(nums, subset_sum)\n\ndef subset_sum_exists(nums, target):\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray with a sum equal to zero.\n\n    Sample Input:\n    nums = [4, -2, 3, -1, 0, 2, -3, 1]\n\n    Sample Output:\n    True\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    return [4, -2, 3, -1, 0, 2, -3, 1]\n\nassert f(g()) == True\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all even numbers from the list and return the updated list.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [1, 3, 5, 7, 9]\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, return True if s is a palindrome, considering only alphanumeric characters and ignoring cases.\n    Otherwise, return False.\n    \"\"\"\n    def is_alphanumeric(char: str) -> bool:\n        return char.isalpha() or char.isdigit()\n\n    s = ''.join(char.lower() for char in s if is_alphanumeric(char))\n    return s == s[::-1]\n\ndef g(s: str):\n    \"\"\"\n    Given a string s, find the longest palindromic substring in s.\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    start, max_len = 0, 0\n\n    for i in range(n):\n        dp[i][i] = True\n        max_len = 1\n\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][i+1] = True\n            start = i\n            max_len = 2\n\n    for k in range(3, n+1):\n        for i in range(n-k+1):\n            j = i + k - 1\n            if dp[i+1][j-1] and s[i] == s[j]:\n                dp[i][j] = True\n                start = i\n                max_len = k\n\n    return s[start:start+max_len]\n\nassert f(g(\"babad\"))\n",
        "idx_generation": 74,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a palindrome.\n    \"\"\"\n    if n < 0:\n        return False\n    temp = n\n    reverse = 0\n    while temp > 0:\n        reverse = reverse * 10 + temp % 10\n        temp //= 10\n    return reverse == n\n\ndef g():\n    \"\"\"\n    Generate a palindrome number.\n    \"\"\"\n    i = 0\n    while True:\n        s = str(i)\n        yield int(s + s[::-1])\n        i += 1\n\nassert f(next(g())) == True\n",
        "idx_generation": 120,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    \"\"\"\n    def max_product(nums: List[int]) -> int:\n        max_product = float('-inf')\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                product = nums[i] * nums[j]\n                max_product = max(max_product, product)\n        \n        return max_product\n    \n    return max_product(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Note:\n    - The subsequence does not have to be contiguous.\n    \"\"\"\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 245,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n    \ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all duplicates from the list and return a new list with the unique elements.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    The unique elements in the list are [1, 2, 3, 4, 5].\n    Return [1, 2, 3, 4, 5].\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the maximum area of a rectangle that can be formed using only the cells\n    with the value 1. The sides of the rectangle must be parallel to the sides of the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    max_area = 0\n    heights = [0] * cols\n    \n    for row in range(rows):\n        for col in range(cols):\n            heights[col] = heights[col] + 1 if grid[row][col] == 1 else 0\n        \n        stack = []\n        for i, height in enumerate(heights):\n            while stack and height < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n    \n    return max_area\n    \ndef g():\n    return [[1, 0, 1, 0, 1],\n            [1, 1, 1, 1, 0],\n            [1, 1, 1, 1, 1],\n            [0, 1, 1, 1, 1],\n            [0, 0, 1, 1, 1]]\n    \nassert f(g()) == 9\n",
        "idx_generation": 37,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string s and a list of words, find all valid word break combinations of s using the words in the list.\n    A valid word break combination is a list of words that, when concatenated together, form the string s.\n\n    Return a list of all valid word break combinations.\n\n    Example:\n    s = \"applepenapple\"\n    words = [\"apple\", \"pen\"]\n\n    f(s, words) => [\"apple pen apple\"]\n    Explanation: The string \"apple pen apple\" can be formed by concatenating the words \"apple\", \"pen\", and \"apple\".\n\n    \"\"\"\n\n    word_set = set(words)\n    word_dict = {}\n\n    def word_break(s):\n        if s in word_dict:\n            return word_dict[s]\n        if s in word_set:\n            return [s]\n\n        result = []\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix in word_set:\n                suffixes = word_break(s[i:])\n                for suffix in suffixes:\n                    result.append(prefix + \" \" + suffix)\n\n        word_dict[s] = result\n        return result\n\n    return word_break(s)\n\ndef g() -> List[str]:\n    return \"applepenapple\", [\"apple\", \"pen\"]\n\nassert f(*g()) == [\"apple pen apple\"]\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target=10):\n    \"\"\"Find the minimum number of elements from a list that sum to the target value.\"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 2\n",
        "idx_generation": 208,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, check if there is a path from the top-left corner to the bottom-right corner,\n    where the path consists of only 0s and each adjacent cell in the path shares a side (not a corner).\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from (0,0) to (3,3) consisting of only 0s: (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (3,2) -> (3,3)\n\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 1 or visited[i][j]:\n            return False\n        if i == m - 1 and j == n - 1:\n            return True\n        \n        visited[i][j] = True\n\n        return dfs(i - 1, j) or dfs(i + 1, j) or dfs(i, j - 1) or dfs(i, j + 1)\n\n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 1, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 73,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of values along a path from the top-left cell to the bottom-right cell in a grid.\n    You can only move down or right.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    def dfs(i: int, j: int) -> int:\n        nonlocal grid, dp\n\n        if i == rows - 1 and j == cols - 1:\n            return grid[i][j]\n\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        down = right = float('-inf')\n\n        if i + 1 < rows:\n            down = dfs(i + 1, j)\n\n        if j + 1 < cols:\n            right = dfs(i, j + 1)\n\n        dp[i][j] = grid[i][j] + max(down, right)\n        return dp[i][j]\n\n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 39,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing exactly one character.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: After removing the character 'e', the string becomes \"racar\", which is a palindrome.\n    \"\"\"\n\n    def is_palindrome(string: str, left: int, right: int, removed: bool) -> bool:\n        while left < right:\n            if string[left] != string[right]:\n                if removed:\n                    return False\n                # Try removing the character on the left or right side\n                return is_palindrome(string, left + 1, right, True) or is_palindrome(string, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g())\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(string: str, target: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be transformed into the target string by\n    performing a series of operations. Each operation involves removing a character\n    from the string.\n\n    Return True if the string can be transformed into the target string, False otherwise.\n    \"\"\"\n    stack = list(string)\n\n    for char in target:\n        if char not in stack:\n            return False\n        stack.remove(char)\n    \n    return True\n\ndef g():\n    string = \"abracadabra\"\n    target = \"acadabra\"\n    return string, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"Check if the string contains all characters of the target string in order.\"\"\"\n    if len(target) == 0:\n        return True\n    if len(s) == 0:\n        return False\n    if s[0] == target[0]:\n        return f(s[1:], target[1:])\n    else:\n        return f(s[1:], target)\n\ndef g(s: str) -> str:\n    \"\"\"Extract all uppercase letters from the given string and return them.\"\"\"\n    uppercase_letters = [char for char in s if char.isupper()]\n    return ''.join(uppercase_letters)\n\nassert f(g('HelloWorld'), 'HW') == True\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is achieved by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of pairs with a bitwise XOR equal to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: 2\n\n    Explanation:\n    The pairs (2, 4) and (3, 5) have a bitwise XOR equal to 6.\n    Hence, the output is 2.\n\n    Note: Each pair should only be counted once, i.e., (2, 4) and (4, 2) should be considered as the same pair.\n    \"\"\"\n\n    count = 0\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            count += 1\n            complements.remove(num ^ target)\n        else:\n            complements.add(num)\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, count the number of set bits in the binary representation of all numbers from 1 to n (inclusive) using dynamic programming.\n    \"\"\"\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i >> 1] + (i & 1)\n    return sum(dp)\n\ndef g() -> Tuple[int]:\n    \"\"\"\n    Generate an integer n such that n is greater than 0.\n    \"\"\"\n    return (10,)\n\nassert f(*g()) == 17\n\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    f(nums) => 28\n    Explanation: The maximum XOR value can be obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.is_end = True\n\n    def find_max_xor(num, root):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit ^ 1 in node.children:\n                xor |= (1 << i)\n                node = node.children[bit ^ 1]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(num, root)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, find_max_xor(num, root))\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the odd elements in the list.\n\n    Return the product.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The odd elements in the list are [1, 3, 5].\n    The product of these elements is 1 * 3 * 5 = 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    product = 1\n\n    for num in arr:\n        if num % 2 != 0:\n            product *= num\n\n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 945\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, num_list: List[int]) -> bool:\n    \"\"\"\n    Given a target number n and a list of positive integers, determine if it is possible to reach the target number by\n    combining the integers in the list using addition, subtraction, multiplication, and division.\n\n    Return True if it is possible to reach the target number, False otherwise.\n\n    Example:\n    n = 10\n    num_list = [1, 2, 3, 4]\n\n    Possible combinations:\n    1 + 2 + 3 + 4 = 10\n    1 * 2 * 3 + 4 = 10\n\n    So, f(n, num_list) should return True.\n    \"\"\"\n    def dfs(curr: int, idx: int) -> bool:\n        if curr == n:\n            return True\n        if idx == len(num_list):\n            return False\n\n        if dfs(curr + num_list[idx], idx + 1):\n            return True\n        if dfs(curr - num_list[idx], idx + 1):\n            return True\n        if dfs(curr * num_list[idx], idx + 1):\n            return True\n        if curr % num_list[idx] == 0 and dfs(curr // num_list[idx], idx + 1):\n            return True\n\n        return False\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a target number n and a list of positive integers.\n    \"\"\"\n    n = 10\n    num_list = [1, 2, 3, 4]\n    return n, num_list\n\nassert f(*g()) == True\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 266,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given positive integer n is a power of two.\n\n    Example:\n    n = 16\n\n    16 is a power of 2 since 2^4 = 16.\n\n    Therefore, the function should return True.\n\n    Hint: Use mathematical properties of powers of two.\n    \"\"\"\n    return n > 0 and (n & (n-1)) == 0\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start=0, target=3) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path from\n    the start node to the target node.\n\n    For example, if the adjacency matrix is [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]],\n    the graph can be represented as:\n        0 -> 1 -> 2 -> 3\n\n    There is a path from node 0 to node 3, so the function should return True.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n    return False\ndef g(graph=[[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, target=3):\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Find if there is a path from the start node to the target node in the given graph.\n\n    The graph is represented as a dictionary where the keys are the node numbers and the values\n    are lists of adjacent nodes.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [4],\n        3: [],\n        4: []\n    }\n    start = 0\n    target = 4\n    output: True\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g(graph = {0: [1, 2], 1: [3, 4], 2: [4], 3: [], 4: []}, start = 0, target = 4):\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n    In each step, you can only move down or right.\n\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum sum path from the top-left corner to the bottom-right corner is 7.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n    dp[rows][cols-1] = 0\n\n    for row in range(rows - 1, -1, -1):\n        for col in range(cols - 1, -1, -1):\n            dp[row][col] = min(dp[row+1][col], dp[row][col+1]) + grid[row][col]\n\n    return dp[0][0]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 7\n\n",
        "idx_generation": 257,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a string s, a positive integer n, and a grid of size n x n, check if it is possible to form the string s by concatenating the values of the cells in the grid.\n\n    The concatenation should be done by traversing the grid in a zigzag pattern, starting from the top-left cell and moving diagonally down to the bottom-right cell.\n\n    Return True if it is possible to form the string s, and False otherwise.\n\n    Example:\n    s = \"hello\"\n    n = 3\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    The grid traversal in a zigzag pattern would be: 1 -> 2 -> 4 -> 7 -> 5 -> 3 -> 6 -> 8 -> 9\n\n    The concatenation of the values of the cells is: \"124753689\"\n\n    Therefore, the function should return False, as it is not possible to form the string \"hello\" by concatenating the values of the cells in the grid.\n\n    Note:\n    - The string s will only contain lowercase letters.\n    - The grid will only contain positive integers.\n    \"\"\"\n\n    def dfs(row, col, path):\n        if row == n-1 and col == n-1:\n            return path + str(grid[row][col]) == s\n\n        if row >= n or col >= n:\n            return False\n\n        if (row + col) % 2 == 0:\n            return (path + str(grid[row][col]) == s) or \\\n                   dfs(row+1, col, path + str(grid[row][col])) or \\\n                   dfs(row, col+1, path + str(grid[row][col]))\n        else:\n            return dfs(row+1, col, path + str(grid[row][col])) or \\\n                   dfs(row, col+1, path + str(grid[row][col]))\n\n    return dfs(0, 0, \"\")\n\ndef g() -> Tuple[str, int, List[List[int]]]:\n    \"\"\"\n    Generate a string s, a positive integer n, and a grid of size n x n.\n    \"\"\"\n    return \"hello\", 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(*g()) == False\n\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find the number of distinct permutations of elements in nums that sum up to target.\"\"\"\n    def count_permutations(nums, target):\n        if target == 0:\n            return 1\n        if target < 0 or not nums:\n            return 0\n        count = 0\n        for i in range(len(nums)):\n            count += count_permutations(nums[:i] + nums[i+1:], target - nums[i])\n        return count\n    \n    return count_permutations(nums, target) > 0\n\ndef g(target=0):\n    nums = [1, 2, 3, 4, 5]\n    return nums, target\n\nassert f(g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if it is possible to construct a valid parentheses sequence of length n with k pairs of parentheses.\n    \"\"\"\n    def backtrack(seq, opens, closes):\n        if len(seq) == n:\n            return opens == closes\n        if opens < n//2:\n            seq.append('(')\n            if backtrack(seq, opens+1, closes):\n                return True\n            seq.pop()\n        if closes < opens:\n            seq.append(')')\n            if backtrack(seq, opens, closes+1):\n                return True\n            seq.pop()\n        return False\n    \n    return backtrack([], 0, 0)\n\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, find all possible permutations of its characters.\n\n    Sample Input:\n    s = \"abc\"\n\n    Sample Output:\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n    \"\"\"\n    def backtrack(curr, remaining):\n        if not remaining:\n            permutations.append(curr)\n            return\n        for i in range(len(remaining)):\n            backtrack(curr + remaining[i], remaining[:i] + remaining[i+1:])\n    \n    permutations = []\n    backtrack(\"\", s)\n    return permutations\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n",
        "idx_generation": 76,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if the number of combinations C(n, k) is even\"\"\"\n    from math import comb\n    return comb(n, k) % 2 == 0\ndef g(n=6, k=3):\n    return n, k\nassert f(g()[0], g()[1])\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, target_sum=100) -> bool:\n    \"\"\"Find n positive integers that add up to target_sum.\"\"\"\n    def count_combinations(total, k):\n        # Returns the number of combinations of k numbers that add up to the total\n        if k == 1:\n            return 1\n        elif k > total:\n            return 0\n        else:\n            return count_combinations(total-1, k-1) + count_combinations(total-k, k)\n\n    return count_combinations(target_sum, n) > 0\n\ndef g(target_sum=100):\n    n = 1\n    while True:\n        if f(n, target_sum):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the first occurrence of the target number.\n    If the target number does not exist in the list, return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums=[1, 2, 2, 3, 4, 5, 5, 5, 6, 7], target=5):\n    return nums\n\nassert f(g(), target=5) == 5\n",
        "idx_generation": 414,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers arr and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Note:\n    - You may assume that each input would have exactly one solution.\n    - You cannot use the same element twice.\n    \"\"\"\n\n    # Use two pointers approach\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return [left, right]\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 163,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a pair of numbers in the array that add up to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [2, 5, 7, 11, 15], target = 9\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 12)\n",
        "idx_generation": 108,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, determine if it is possible to select k elements from the list\n    such that their sum is less than or equal to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total <= target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort(reverse=True)\n    return backtrack(0, 0, 0)\n\n\ndef g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and an integer k, such that it is possible to select k elements from the list\n    such that their sum is less than or equal to the target.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums, target, k\n\n# Test case\nnums = [5, 4, 3, 2, 1]\ntarget = 10\nk = 3\nassert f(*g(nums, target, k))\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, find the next greater element for each element in the list.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n\n    for i in range(len(arr)):\n        while stack and arr[i] > arr[stack[-1]]:\n            index = stack.pop()\n            result[index] = arr[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 5.\n    \"\"\"\n    return [4, 2, 9, 5, 1]\n\nassert f(g()) == [9, 9, -1, -1, -1]\n\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, move all zeros to the end of the list while maintaining\n    the relative order of the non-zero elements. Modify the input list in-place and\n    return the modified list.\n\n    Example:\n    nums = [0, 2, 3, 0, 4, 5]\n    output: [2, 3, 4, 5, 0, 0]\n    \"\"\"\n\n    # Move all non-zero elements to the front of the list\n    non_zeros = [num for num in nums if num != 0]\n\n    # Append zeros to the end of the list\n    zeros = [0] * (len(nums) - len(non_zeros))\n\n    # Combine non-zero elements and zeros\n    nums[:] = non_zeros + zeros\n\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [0, 2, 0, 3, 0, 4, 5]\n\nassert f(g()) == [2, 3, 4, 5, 0, 0, 0]\n",
        "idx_generation": 127,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The function should return 3 since the longest substring without repeating characters is \"abc\".\n\n    Note: The substring \"abcabc\" is longer, but it has repeating characters.\n    \"\"\"\n\n    n = len(s)\n    char_dict = {}\n    max_length = 0\n    start = 0\n\n    for end in range(n):\n        if s[end] in char_dict:\n            start = max(start, char_dict[s[end]] + 1)\n        char_dict[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find all subarrays of length k with maximum sum.\n    Return the subarrays.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], k = 3\n    Output: [[3, 4, 5]]\n\n    Explanation: The subarray [3, 4, 5] has the maximum sum of 12.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    max_sum_subarrays = []\n\n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        subarray_sum = sum(subarray)\n\n        if subarray_sum > max_sum:\n            max_sum = subarray_sum\n            max_sum_subarrays = [subarray]\n        elif subarray_sum == max_sum:\n            max_sum_subarrays.append(subarray)\n\n    return max_sum_subarrays\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [[3, 4, 5]]\n",
        "idx_generation": 368,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum XOR value of two elements in the given list.\n    Return the maximum XOR value.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The maximum XOR value of two elements in the list is 7, which can be obtained by XORing 3 and 4.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    \n    return max_xor\n\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 7\n\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, nums: List[int]) -> bool:\n    \"\"\"Check if the numbers in the list are sorted in ascending order and their sum is equal to s\"\"\"\n    return sorted(nums) == nums and sum(nums) == s\ndef g(nums=[1, 2, 3, 4, 5], s=15):\n    return s, nums\nassert f(*g())\n",
        "idx_generation": 67,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 6, 7, 1, 2, 3, 4]\n\nassert f(g()) == 4\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach from the top-left corner to the bottom-right corner.\n    You can only move down or right, and the cost of each step is given by the value in the corresponding cell.\n    Return the minimum cost.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right, and you can only move to a cell if its value is positive.\n    Return the minimum path sum.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    f(grid) => 7\n    Explanation: The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Sample Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Sample Output:\n    7\n    Explanation: The minimum path sum from the top-left corner (1) to the bottom-right corner (1) is 7\n    (1 -> 3 -> 1 -> 1 -> 1).\n\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    21\n    Explanation: The minimum path sum from the top-left corner (1) to the bottom-right corner (9) is 21\n    (1 -> 2 -> 3 -> 6 -> 9).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[rows-1][cols-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 280,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it can be expressed as the sum of distinct powers of 2.\n    \"\"\"\n    def is_power_of_two(num: int) -> bool:\n        return (num & (num - 1)) == 0\n    \n    def can_sum_powers_of_two(n: int, powers: List[int]) -> bool:\n        if n == 0:\n            return True\n        if n < 0 or len(powers) == 0:\n            return False\n        with_curr = can_sum_powers_of_two(n - powers[0], powers[1:])\n        without_curr = can_sum_powers_of_two(n, powers[1:])\n        return with_curr or without_curr\n    \n    powers_of_two = [1 << i for i in range(n.bit_length())]\n    return can_sum_powers_of_two(n, powers_of_two)\n\ndef g(n=10) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 194,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses string.\n    A valid parentheses string is one in which each open parenthesis '(' is followed\n    by a corresponding closing parenthesis ')'.\n\n    Example:\n    s = \"((()))\"\n\n    The string is a valid parentheses string.\n\n    Therefore, the function should return True.\n    \"\"\"\n    stack = []\n    \n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    s = \"((()))\"\n    return s\n\nassert f(g())",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicates removed.\n\n    Sample input:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n\n    Sample output:\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n\n    return unique_nums\n\ndef g():\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 70,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 8, 2]\n    Output: 15\n\n    Explanation:\n    The maximum XOR value is achieved by the pair (10, 5), where 10 ^ 5 = 15.\n    Hence, the output is 15.\n\n    Note: The list can have duplicate elements, but each element should only be used once in a pair.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 8, 2]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 372,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return [num_map[complement], i]\n\n        num_map[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, check if there is a subset of the list that adds up to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        dp[i][0] = True\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g(target=9):\n    nums = [2, 7, 11, 15]\n    return nums\n\nassert f(g(), target=9) == True\n",
        "idx_generation": 138,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number n is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0 or n == 1:\n        return True\n\n    left = 0\n    right = n\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g(n: int):\n    \"\"\"\n    Find the square root of a given number n.\n    \"\"\"\n    if n < 0:\n        return None\n    if n == 0 or n == 1:\n        return n\n\n    left = 0\n    right = n\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if mid * mid == n:\n            return mid\n        elif mid * mid < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return None\n\nassert f(g(16))\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a Fibonacci sequence.\"\"\"\n    if len(nums) < 3:\n        return False\n    for i in range(2, len(nums)):\n        if nums[i] != nums[i-1] + nums[i-2]:\n            return False\n    return True\n\ndef g():\n    return [0, 1, 1, 2, 3, 5, 8, 13]\n    \nassert f(g()) == True\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum sum of a subarray of length k.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, -2, 5], k = 3\n\n    The subarrays of length 3 are [1, 2, 3], [2, 3, -2], [3, -2, 5].\n    The maximum sum is 6, which is the sum of [1, 2, 3].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    queue = []\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(len(nums)):\n        queue.append(nums[i])\n        current_sum += nums[i]\n\n        if len(queue) > k:\n            current_sum -= queue.pop(0)\n\n        if len(queue) == k:\n            max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, -2, 5]\n    return nums, 3\n\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 144,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) sum up to the target number 9.\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 316,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers, check if there exists a subgrid whose XOR is equal to the target.\n    The grid is represented as a 2D list of integers.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            xor = 0\n            for k in range(i, m):\n                for l in range(j, n):\n                    xor ^= grid[k][l]\n                    if xor == target:\n                        return True\n    return False\n\ndef g(grid: List[List[int]], target: int):\n    return grid\n\ngrid = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\ntarget = 7\n\nassert f(g(grid, target), target)\n",
        "idx_generation": 34,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the indices of two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] because nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 415,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there are two numbers in the array that add up to the target number.\"\"\"\n    stack = []\n    for num in arr:\n        complement = target - num\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    arr = [3, 5, 2, 8, 4]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 53,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, determine if there is a path from the start node to the end node.\n\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    start = 0\n    end = 3\n\n    There is a path from node 0 to node 3: 0 -> 1 -> 3\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph represented as an adjacency matrix for Puzzle 3.\n    \"\"\"\n    return [\n        [0, 1, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\nassert f(g(), 0, 3) == True\n\n",
        "idx_generation": 263,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, check if the target number exists in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\n\ndef g(target=6):\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g(), target=6) == True\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 46,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct characters in the string.\n    Return the count.\n    \"\"\"\n    distinct_chars = set(s)\n    return len(distinct_chars)\n\ndef g():\n    s = \"abracadabra\"\n    return s\n\nassert f(g()) == 5\n",
        "idx_generation": 429,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(queue: List[str], target: str) -> bool:\n    \"\"\"\n    Given a queue represented as a list of strings and a target string, check if the\n    target string can be generated by performing a series of operations on the queue.\n    Each operation involves removing the first element from the queue.\n\n    Return True if the target string can be generated, False otherwise.\n    \"\"\"\n    for char in target:\n        if not queue or queue[0] != char:\n            return False\n        queue.pop(0)\n    \n    return True\n\ndef g():\n    queue = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    target = \"abcde\"\n    return queue, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string s and a target string, determine if the target string can be formed by rearranging the characters of s.\n\n    Example:\n    s = \"listen\"\n    target = \"silent\"\n\n    Output:\n    True\n\n    Explanation:\n    The target string \"silent\" can be formed by rearranging the characters of s.\n    \"\"\"\n\n    def backtrack(s, target, path, result):\n        if len(path) == len(target):\n            result[0] = True\n            return\n\n        for i in range(len(s)):\n            if path + s[i] not in result:\n                path += s[i]\n                backtrack(s, target, path, result)\n                path = path[:-1]\n\n    result = [False]\n    backtrack(s, target, \"\", result)\n    return result[0]\n\ndef g() -> Tuple[str, str]:\n    s = \"listen\"\n    target = \"silent\"\n    return s, target\n\nassert f(*g()) == True\n",
        "idx_generation": 308,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the product of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [2, 3] has a sum of 5, which is equal to the product of its elements (2 * 3 = 5).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    product = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        product ^= num\n\n        if prefix_sum - product in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers arr and a target integer, find the maximum number of elements that can be included in a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(arr)\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= arr[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - arr[i - 1]] + 1)\n\n    return dp[n][target]\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Find the maximum number of elements that can be included in a subset of arr such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in arr:\n        if num ^ target in arr:\n            subset.append(num)\n    return subset\n\narr = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(g(arr, target), target) == 3\n\n",
        "idx_generation": 98,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list such that their XOR is equal to the target value.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Output:\n    [1, 3]\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target ^ num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 6\n\nassert f(*g()) == [1, 3]\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there is a path from the top-left corner to the bottom-right corner\n    such that the sum of numbers along the path is a prime number.\n\n    Return True if such a path exists, False otherwise.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Possible path: 1 -> 2 -> 3 -> 6 -> 9\n\n    So, f(matrix) should return True.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def dfs(row: int, col: int, curr_sum: int) -> bool:\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return is_prime(curr_sum + matrix[row][col])\n\n        if row < len(matrix) - 1 and dfs(row + 1, col, curr_sum + matrix[row][col]):\n            return True\n        if col < len(matrix[0]) - 1 and dfs(row, col + 1, curr_sum + matrix[row][col]):\n            return True\n\n        return False\n\n    return dfs(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left\n    corner to the bottom-right corner of an n x n grid.\n\n    Each step, you can either move down or to the right.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths from (0, 0) to (2, 2) in a 3 x 3 grid.\n\n    Input: n = 7\n    Output: 28\n    Explanation: There are 28 unique paths from (0, 0) to (6, 6) in a 7 x 7 grid.\n    \"\"\"\n\n    # Use dynamic programming to store the number of unique paths for each cell in the grid\n    dp = [[0] * n for _ in range(n)]\n\n    # Initialize the first row and first column with 1, as there is only one way to reach each cell in the first row and first column\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n\n    # Calculate the number of unique paths for each cell by summing the number of paths from the cell above and the cell to the left\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    # Return the number of unique paths for the bottom-right cell\n    return dp[n-1][n-1]\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR of any two elements in the array.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of size n x m, determine if there exists a path from the top-left corner to the bottom-right corner.\n    The path can only move down or right.\n\n    Return True if such a path exists, False otherwise.\n    \"\"\"\n    def dfs(i: int, j: int) -> bool:\n        if i == n - 1 and j == m - 1:\n            return True\n        if i >= n or j >= m:\n            return False\n        if grid[i][j] == 1:\n            return False\n        return dfs(i + 1, j) or dfs(i, j + 1)\n\n    return dfs(0, 0)\n\n\ndef g(n=3, m=3, grid=[[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    \"\"\"\n    Generate a grid of size n x m with obstacles.\n\n    The grid should have a path from the top-left corner to the bottom-right corner.\n    The path can only move down or right.\n    \"\"\"\n    grid[n-1][m-1] = 0\n    return grid\n\n\nassert f(3, 3, g()) == True\n\n",
        "idx_generation": 143,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(maze: List[List[int]]) -> bool:\n    \"\"\"\n    Check if it is possible to reach the bottom-right cell of the maze from the top-left cell.\n    1 represents a wall, 0 represents an open path.\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    queue = [(0, 0)]\n    visited = set()\n    \n    while queue:\n        x, y = queue.pop(0)\n        \n        if (x, y) == (rows - 1, cols - 1):\n            return True\n        \n        if (x, y) in visited:\n            continue\n        \n        visited.add((x, y))\n        \n        if maze[x][y] == 1:\n            continue\n        \n        if x > 0:\n            queue.append((x - 1, y))\n        if x < rows - 1:\n            queue.append((x + 1, y))\n        if y > 0:\n            queue.append((x, y - 1))\n        if y < cols - 1:\n            queue.append((x, y + 1))\n    \n    return False\n\n\ndef g():\n    maze = [\n        [0, 0, 0, 0, 1],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return maze\n\nassert f(g()) == True\n",
        "idx_generation": 10,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid filled with 0's and 1's, find the number of distinct islands. An island is considered to be\n    connected horizontally or vertically, and consists of all the 1's (and only the 1's) in the grid. Each island\n    is represented by a list of its cells, which are the indices of the 1's in the grid.\n\n    Return the number of distinct islands in the grid.\n    \"\"\"\n    def dfs(grid, i, j, di, dj, path):\n        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:\n            grid[i][j] = 0\n            path.append((di, dj))\n            dfs(grid, i + 1, j, di + 1, dj, path)\n            dfs(grid, i - 1, j, di - 1, dj, path)\n            dfs(grid, i, j + 1, di, dj + 1, path)\n            dfs(grid, i, j - 1, di, dj - 1, path)\n    \n    islands = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                path = []\n                dfs(grid, i, j, 0, 0, path)\n                islands.add(tuple(path))\n    \n    return len(islands)\ndef g(grid: List[List[int]]):\n    return grid\nassert f(g([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]))\n",
        "idx_generation": 15,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of distinct islands in the grid.\n    An island is defined as a group of connected 1s, where two 1s are considered connected if they are adjacent vertically or horizontally.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    distinct_islands = set()\n    \n    def dfs(i, j, r, c, shape):\n        if i < 0 or i >= r or j < 0 or j >= c or grid[i][j] == 0 or (i, j) in visited:\n            return\n        \n        visited.add((i, j))\n        shape.append((i, j))\n        \n        dfs(i-1, j, r, c, shape)  # up\n        dfs(i+1, j, r, c, shape)  # down\n        dfs(i, j-1, r, c, shape)  # left\n        dfs(i, j+1, r, c, shape)  # right\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and (i, j) not in visited:\n                shape = []\n                dfs(i, j, rows, cols, shape)\n                distinct_islands.add(tuple(shape))\n    \n    return len(distinct_islands)\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 2\n\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of characters, determine if it contains a valid word formed by connecting adjacent\n    letters horizontally or vertically. Each letter can only be used once.\n    \"\"\"\n    if not grid or not grid[0]:\n        return False\n\n    def dfs(row: int, col: int, word: str, visited: List[List[bool]]) -> bool:\n        \"\"\"\n        Perform depth-first search to check if a valid word can be formed starting from a specific position.\n        \"\"\"\n        if not word:\n            return True\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] != word[0]:\n            return False\n\n        visited[row][col] = True\n        result = dfs(row + 1, col, word[1:], visited) or dfs(row - 1, col, word[1:], visited) or dfs(row, col + 1, word[1:], visited) or dfs(row, col - 1, word[1:], visited)\n        visited[row][col] = False\n\n        return result\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, grid[i][j], [[False] * len(grid[0]) for _ in range(len(grid))]):\n                return True\n\n    return False\n\ndef g(grid: List[List[str]]) -> str:\n    \"\"\"\n    Find a valid word formed by connecting adjacent letters horizontally or vertically in the grid.\n    Each letter can only be used once.\n    \"\"\"\n    if not grid or not grid[0]:\n        return \"\"\n\n    def dfs(row: int, col: int, word: str, visited: List[List[bool]]) -> List[str]:\n        \"\"\"\n        Perform depth-first search to find a valid word starting from a specific position.\n        \"\"\"\n        if not word:\n            return [word]\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] != word[0]:\n            return []\n\n        visited[row][col] = True\n        result = []\n        for r, c in [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]:\n            temp = dfs(r, c, word[1:], visited)\n            if temp:\n                result.extend([grid[row][col] + t for t in temp])\n        visited[row][col] = False\n\n        return result\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            words = dfs(i, j, grid[i][j], [[False] * len(grid[0]) for _ in range(len(grid))])\n            if words:\n                return words[0]\n\n    return \"\"\n\nassert f(g([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]]))\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible subsets (power set) of the list.\n    \"\"\"\n    subsets = [[]]\n    \n    for num in nums:\n        new_subsets = []\n        for subset in subsets:\n            new_subset = subset + [num]\n            new_subsets.append(new_subset)\n        subsets += new_subsets\n    \n    return subsets\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n",
        "idx_generation": 224,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer,\n    find all unique combinations of numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    The unique combinations of numbers that add up to 7 are:\n    - [2, 2, 3]\n    - [7]\n\n    So the function should return [[2, 2, 3], [7]].\n\n    Hint: Use a stack and backtracking to explore all possible combinations.\n    \"\"\"\n\n    def backtrack(combination, start, remain):\n        if remain == 0:\n            result.append(combination[:])\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            backtrack(combination, i, remain - nums[i])\n            combination.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], 0, target)\n    return result\n\ndef g(nums = [2, 3, 6, 7], target = 7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 298,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: \"abc\" (The longest substring without repeating characters is \"abc\")\n\n    Hint: Use a sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n    start = 0\n    max_length = 0\n    used_chars = {}\n    max_substring = \"\"\n    \n    for i, char in enumerate(s):\n        if char in used_chars and start <= used_chars[char]:\n            start = used_chars[char] + 1\n        else:\n            if i - start + 1 > max_length:\n                max_length = i - start + 1\n                max_substring = s[start:i+1]\n        used_chars[char] = i\n    \n    return max_substring\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == \"abc\"\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, determine the number of combinations of k elements that can be selected from a set of n elements.\n    \"\"\"\n    factorial = lambda x: 1 if x == 0 else x * factorial(x - 1)\n    combinations = factorial(n) // (factorial(k) * factorial(n - k))\n    return combinations\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique BSTs (binary search trees) that can be formed\n    using the numbers from 1 to n.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    5\n\n    Sample Input:\n    n = 4\n\n    Sample Output:\n    14\n\n    \"\"\"\n    def count_bsts(n, memo):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return 1\n        count = 0\n        for i in range(1, n+1):\n            count += count_bsts(i-1, memo) * count_bsts(n-i, memo)\n        memo[n] = count\n        return count\n\n    memo = {}\n    return count_bsts(n, memo)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 299,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a matrix of characters, rotate it 90 degrees clockwise.\n    \"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    rotated_matrix = [['' for _ in range(rows)] for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_matrix[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated_matrix\n\ndef g():\n    \"\"\"\n    Generate a matrix of characters.\n    \"\"\"\n    return [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]\n\nassert f(g()) == [['g', 'd', 'a'], ['h', 'e', 'b'], ['i', 'f', 'c']]\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if the given grid is a valid Sudoku solution.\"\"\"\n    def check_rows(grid):\n        for row in grid:\n            if len(set(row)) != 9:\n                return False\n        return True\n    \n    def check_columns(grid):\n        for col in range(9):\n            column = [grid[row][col] for row in range(9)]\n            if len(set(column)) != 9:\n                return False\n        return True\n    \n    def check_subgrids(grid):\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [grid[row][col] for row in range(i, i+3) for col in range(j, j+3)]\n                if len(set(subgrid)) != 9:\n                    return False\n        return True\n    \n    return check_rows(grid) and check_columns(grid) and check_subgrids(grid)\n\ndef g():\n    valid_sudoku = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return valid_sudoku\n\nassert f(g()) == True\n",
        "idx_generation": 197,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a pair of numbers in the array that add up to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [2, 7, 11, 15, 16, 20, 21], target = 23\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n\nassert f(g(), 22)\n",
        "idx_generation": 108,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next greater element for each element in the list. The next greater element for an element is the first greater element to its right. If there is no greater element, return -1.\n\n    Example:\n    Input: [4, 5, 2, 25, 10]\n    Output: [5, 25, 25, -1, -1]\n\n    Hint: This problem can be solved using a stack.\n    \"\"\"\n\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n\n    for i in range(n):\n        while stack and nums[i] > nums[stack[-1]]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g():\n    return [4, 5, 2, 25, 10]\n\nassert f(g()) == [5, 25, 25, -1, -1]\n\n\n",
        "idx_generation": 264,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, coins: List[int]) -> int:\n    \"\"\"\n    Given a value n and a list of coin denominations, find the minimum number of coins required to make the value n.\n    You may assume that there is always a combination of coins that can be used to make the desired value.\n\n    Sample Input:\n    n = 10\n    coins = [1, 2, 5]\n\n    Sample Output:\n    2\n\n    Explanation:\n    The minimum number of coins required to make the value 10 is 2 (1 coin of denomination 2 and 1 coin of denomination 5).\n    \"\"\"\n    dp = [0] + [float('inf')] * n\n    for i in range(1, n + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[n]\n\ndef g():\n    n = 10\n    coins = [1, 2, 5]\n    return n, coins\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 217,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the smallest subarray length whose sum is greater than or equal to the target value.\n    Return the length of the smallest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [2, 3, 1, 2, 4, 3], target = 7\n    Output: 2\n\n    Hint: Use a sliding window approach to find the smallest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    min_length = float('inf')\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= arr[left]\n            left += 1\n\n        right += 1\n\n    return min_length if min_length != float('inf') else -1\n\ndef g():\n    return [2, 3, 1, 2, 4, 3], 7\n\nassert f(*g()) == 2\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], and the sum is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    current_sum = 0\n    max_sum = float('-inf')\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 415,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: True\n    Explanation: The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers such that there exists a pair of numbers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(*g(nums, target)) == True\n",
        "idx_generation": 235,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a subarray whose sum is equal to the target.\n\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    n = len(arr)\n    prefix_sum = 0\n    prefix_sums = {0}\n\n    for i in range(n):\n        prefix_sum += arr[i]\n\n        if prefix_sum - target in prefix_sums:\n            return True\n\n        prefix_sums.add(prefix_sum)\n\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5, 6], target = 9):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 80,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\n    def fibonacci(n: int, memo: Dict[int, int]) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 2:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)\n\ndef g() -> int:\n    \"\"\"Generate an integer\"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 317,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target value, determine if the target value exists in the grid.\n    The grid is sorted row-wise and column-wise in ascending order.\n\n    Return True if the target value exists in the grid, False otherwise.\n    \"\"\"\n    def search(grid: List[List[int]], target: int, row: int, col: int) -> bool:\n        if row >= len(grid) or col < 0:\n            return False\n        if grid[row][col] == target:\n            return True\n        if grid[row][col] > target:\n            return search(grid, target, row, col-1)\n        return search(grid, target, row+1, col)\n\n    if not grid or not grid[0]:\n        return False\n    return search(grid, target, 0, len(grid[0])-1)\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a grid and a target value.\n    \"\"\"\n    grid = [[1, 3, 5], [7, 9, 11], [13, 15, 17]]\n    target = 9\n    return grid, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 166,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left corner to the bottom-right corner.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum sum path from the top-left corner (1) to the bottom-right corner (1) is 7, which is obtained by following the path 1 -> 3 -> 1 -> 1.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n    dp[rows][cols-1] = 0\n    \n    for i in range(rows-1, -1, -1):\n        for j in range(cols-1, -1, -1):\n            dp[i][j] = grid[i][j] + min(dp[i+1][j], dp[i][j+1])\n    \n    return dp[0][0]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subsequence of the list where the product of all elements\n    is a perfect square, and False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subsequence [2, 4] has a product of 8, which is a perfect square, so the output is True.\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        sqrt = int(n ** 0.5)\n        return sqrt * sqrt == n\n\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 1 if is_perfect_square(nums[0]) else 0\n\n    for i in range(1, n):\n        dp[i] = dp[i-1] + (1 if is_perfect_square(nums[i]) else 0)\n        if dp[i] > 1:\n            return True\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if it is possible to construct a valid parentheses sequence of length n with k pairs of parentheses.\n    \"\"\"\n    stack = []\n    open_count = 0\n    close_count = 0\n    \n    def backtrack():\n        nonlocal open_count, close_count\n        if len(stack) == n:\n            return open_count == close_count\n        if open_count < k:\n            stack.append('(')\n            open_count += 1\n            if backtrack():\n                return True\n            stack.pop()\n            open_count -= 1\n        if close_count < open_count:\n            stack.append(')')\n            close_count += 1\n            if backtrack():\n                return True\n            stack.pop()\n            close_count -= 1\n        return False\n    \n    return backtrack()\n\n\ndef g(n=4, k=2):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 212,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1] (since nums[0] + nums[1] = 2 + 7 = 9)\n\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 83,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value of any two elements is required.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef g(n = 23):\n    return n\nassert f(g()) == True\n",
        "idx_generation": 21,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    The function should return [1, 2], since nums[1] + nums[2] = 4 + 6 = 10.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there is a subset of the list that adds up to the target.\n    Return True if such subset exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    \n    return dp[n][target]\n\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 165,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n    Return the maximum sum.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    output: 6\n\n    Explanation: The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, convert it into a new array where each element is the product of all the elements in the original array except itself.\n    The product of all the elements except the current element can be calculated by dividing the total product of all elements by the current element.\n    \"\"\"\n\n    n = len(nums)\n    result = [0] * n\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    for i in range(n):\n        result[i] = product // nums[i]\n\n    return result\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 329,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The sum of all the elements in the matrix is 45.\n    Therefore, the function should return 45.\n    \"\"\"\n    total_sum = 0\n\n    for row in matrix:\n        for num in row:\n            total_sum += num\n\n    return total_sum\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value k, find the length of the longest subarray with a sum equal to k.\n\n    Example:\n    arr = [1, -1, 5, -2, 3]\n    k = 3\n    output: 4\n    Explanation: The longest subarray with a sum equal to 3 is [1, -1, 5, -2].\n\n    Note: The subarray must be contiguous.\n    \"\"\"\n    prefix_sum = 0\n    sum_dict = {}\n    max_length = 0\n\n    for i, num in enumerate(arr):\n        prefix_sum += num\n\n        if prefix_sum == k:\n            max_length = i + 1\n\n        if prefix_sum - k in sum_dict:\n            max_length = max(max_length, i - sum_dict[prefix_sum - k])\n\n        if prefix_sum not in sum_dict:\n            sum_dict[prefix_sum] = i\n\n    return max_length\n\ndef g():\n    return [1, -1, 5, -2, 3], 3\n\nassert f(*g()) == 4\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Therefore, the function should return 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return the matrix elements in spiral order.\n    \"\"\"\n    if not matrix:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    spiral = []\n    \n    top = 0\n    bottom = m - 1\n    left = 0\n    right = n - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            spiral.append(matrix[top][i])\n        top += 1\n        \n        # Traverse right column\n        for i in range(top, bottom + 1):\n            spiral.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Traverse bottom row\n            for i in range(right, left - 1, -1):\n                spiral.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            # Traverse left column\n            for i in range(bottom, top - 1, -1):\n                spiral.append(matrix[i][left])\n            left += 1\n    \n    return spiral\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 52,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the largest subarray sum.\n    The subarray must contain consecutive elements and the sum should be maximized.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    The largest subarray sum is 9, which is obtained by the subarray [3, 4, -1, 2, 1].\n\n    Therefore, the function should return 9.\n\n    Note:\n    - The length of the list will be at least 1 and at most 10^5.\n    - The range of integers in the list is -10^4 <= nums[i] <= 10^4.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 9\n",
        "idx_generation": 419,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of vowels in a string using a stack.\"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    stack = []\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            stack.append(char)\n            count += 1\n    return count\n\ndef g():\n    return \"Hello, World!\"\n\nassert f(g()) == 3\n",
        "idx_generation": 53,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent to each other.\n\n    Example:\n    nums = [4, 1, 1, 9, 1]\n\n    Output:\n    13\n\n    Explanation:\n    The maximum sum subarray is [4, 9], with a sum of 13.\n    The subarray [4, 1, 1, 1] also has a sum of 13, but it contains adjacent numbers.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g():\n    return [4, 1, 1, 9, 1]\n\nassert f(g()) == 13\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8 (The 6th Fibonacci number is 8)\n\n    Hint: Use dynamic programming to optimize the calculation of Fibonacci numbers.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    fib = [0] * (n+1)\n    fib[1] = 1\n\n    for i in range(2, n+1):\n        fib[i] = fib[i-1] + fib[i-2]\n\n    return fib[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate the value of n.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 336,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target number, check if the target number exists in the grid.\n    The grid is represented as a list of lists, where each inner list represents a row in the grid.\n    Return True if the target number is found, otherwise return False.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    output: True\n\n    Explanation: The target number 5 is present in the grid.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n\n    return False\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a 2D grid of integers and a target number.\n    \"\"\"\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n\n    return grid, target\n\nassert f(*g()) == True\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell. You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 12\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of lowercase English letters, return the longest substring without repeating characters.\n    If there are multiple answers, return the substring with the smallest index.\n    \"\"\"\n    max_substring = \"\"\n    current_substring = \"\"\n    char_map = {}\n    start = 0\n    for i, char in enumerate(s):\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n            current_substring = s[start:i]\n        current_substring += char\n        char_map[char] = i\n        if len(current_substring) > len(max_substring):\n            max_substring = current_substring\n    return max_substring\n\ndef g(s = \"abcabcbb\"):\n    return s\n\nassert f(g()) == \"abc\"\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    \"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_s = \"\"\n    while stack:\n        reversed_s += stack.pop()\n    if s == reversed_s:\n        return True\n    else:\n        return False\n\ndef g(s=\"racecar\") -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after deleting at most one character.\n\n    Example:\n    Input: s = \"aba\"\n    Output: True\n    Explanation: The string is already a palindrome.\n\n    Input: s = \"abca\"\n    Output: True\n    Explanation: By deleting 'b', the resulting string is \"aca\", which is a palindrome.\n\n    Input: s = \"abcda\"\n    Output: False\n    Explanation: There is no way to make the string a palindrome by deleting at most one character.\n    \"\"\"\n    def is_palindrome(s: str, i: int, j: int) -> bool:\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n    \n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n    \n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcda\"\n\nassert f(g()) == False\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the bitwise OR of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [3, 4] has a sum of 7, which is equal to the bitwise OR of its elements (3 | 4 = 7).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    or_sum = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        or_sum |= num\n\n        if prefix_sum - or_sum in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28 (The maximum XOR value is obtained by XORing 5 and 25: 5 ^ 25 = 28)\n\n    Hint: This problem can be solved using bitwise manipulation and dynamic programming.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in arr:\n            prefixes.add(num & mask)\n\n        temp = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if (prefix ^ temp) in prefixes:\n                max_xor = temp\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 137,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n    Explanation: The new list is obtained by multiplying all the numbers in the original list except the one at each index.\n\n    Input: nums = [3, 2, 1]\n    Output: [2, 3, 6]\n    Explanation: The new list is obtained by multiplying all the numbers in the original list except the one at each index.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_products[i] = right_products[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n    \n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation: The minimum sum path from the top-left cell (1) to the bottom-right cell (1) is 1 + 3 + 1 + 1 + 1 = 7.\n\n    Hint: Use dynamic programming to calculate the minimum sum path for each cell in the grid.\n    Start by initializing a new grid with the same size as the input grid.\n    Then, iterate through each cell in the new grid, calculating the minimum sum path based on the adjacent cells.\n    Finally, return the value in the bottom-right cell of the new grid.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 402,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list whose bitwise OR is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: True\n\n    Explanation:\n    2 | 7 = 7, which is not a perfect square.\n    2 | 9 = 11, which is not a perfect square.\n    2 | 3 = 3, which is not a perfect square.\n    2 | 5 = 7, which is not a perfect square.\n    7 | 9 = 15, which is not a perfect square.\n    7 | 3 = 7, which is not a perfect square.\n    7 | 5 = 7, which is not a perfect square.\n    9 | 3 = 11, which is not a perfect square.\n    9 | 5 = 13, which is not a perfect square.\n    3 | 5 = 7, which is not a perfect square.\n    Therefore, there is no pair whose bitwise OR is a perfect square.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] | nums[j] in squares:\n                return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the bitwise OR of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]\n\nassert f(g()) == False\n",
        "idx_generation": 266,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine if it is possible to reach any cell in the bottom row\n    starting from any cell in the top row, where the path consists of only 1s.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    It is possible to reach any cell in the bottom row starting from any cell in the top row.\n\n    Therefore, the function should return True.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    def is_valid(i, j):\n        return 0 <= i < m and 0 <= j < n and grid[i][j] == 1\n\n    def dfs(i, j):\n        if i == m - 1:\n            return True\n        if is_valid(i, j):\n            grid[i][j] = 0\n            return dfs(i + 1, j - 1) or dfs(i + 1, j) or dfs(i + 1, j + 1)\n        return False\n\n    for j in range(n):\n        if dfs(0, j):\n            return True\n    return False\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 1, 1, 0],\n        [1, 0, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=0, end=4) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    Return True if a path exists, False otherwise.\n\n    Sample input:\n    {\n        0: [1, 2],\n        1: [2, 3],\n        2: [3],\n        3: [4],\n        4: []\n    }\n\n    Sample output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 4 in the given graph.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    return {\n        0: [1, 2],\n        1: [2, 3],\n        2: [3],\n        3: [4],\n        4: []\n    }\n\nassert f(g()) == True\n",
        "idx_generation": 17,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start_node=0, path_length=4) -> bool:\n    \"\"\"\n    Find if there exists a path of length path_length in the given graph starting from start_node.\n    \"\"\"\n    def dfs(node, length):\n        if length == 0:\n            return True\n        for neighbor in graph[node]:\n            if dfs(neighbor, length - 1):\n                return True\n        return False\n    \n    return dfs(start_node, path_length)\n    \ndef g(graph=[[1,2],[0,3],[0,3],[1,2]], start_node=0, path_length=4):\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 35,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes, find whether there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, node, end, visited):\n    visited.add(node)\n    if node == end:\n        return True\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\nassert f(*g())\n",
        "idx_generation": 11,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Determine the number of islands in a given grid.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != 1:\n            return\n        grid[i][j] = 0\n        dfs(i-1, j)\n        dfs(i+1, j)\n        dfs(i, j-1)\n        dfs(i, j+1)\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 353,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of letters and a word, determine if the word exists in the grid.\n    The word can be constructed from letters of adjacent cells (horizontally or vertically),\n    but a cell can only be used once in the word.\n\n    Example:\n    grid = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n    word = \"ABCCED\"\n\n    Output:\n    True\n\n    Explanation:\n    The word \"ABCCED\" can be formed by starting at (0,0) and moving right -> down -> down.\n\n    \"\"\"\n\n    def dfs(i: int, j: int, k: int) -> bool:\n        if k == len(word):\n            return True\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[k]:\n            return False\n\n        temp = grid[i][j]\n        grid[i][j] = '#'\n\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni = i + dx\n            nj = j + dy\n            if dfs(ni, nj, k + 1):\n                return True\n\n        grid[i][j] = temp\n        return False\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\ndef g() -> List[List[str]]:\n    return [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ]\n\nassert f(g(), \"ABCCED\") == True\n\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k=2) -> bool:\n    \"\"\"Check if there exists a permutation of the numbers from 1 to n such that the absolute difference between each adjacent pair is at least k\"\"\"\n    def helper(nums, k, path):\n        if not nums:\n            return True\n        for i in range(len(nums)):\n            if not path or abs(nums[i] - path[-1]) >= k:\n                if helper(nums[:i] + nums[i+1:], k, path + [nums[i]]):\n                    return True\n        return False\n    \n    return helper(list(range(1, n + 1)), k, [])\n\ndef g(k=2):\n    return 4\n\nassert f(g()) == True\n",
        "idx_generation": 2,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Generate all permutations of the given list of integers.\n    \"\"\"\n    def backtrack(nums, path, used, res):\n        if len(path) == len(nums):\n            res.append(path.copy())\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(nums, path, used, res)\n            path.pop()\n            used[i] = False\n\n    res = []\n    used = [False] * len(nums)\n    backtrack(nums, [], used, res)\n    return res\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, return True if it is possible to construct the string s by concatenating the words in the list, in any order, without any overlapping characters. Otherwise, return False.\n\n    Example:\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n\n    The string s can be formed by concatenating the words \"apple\" and \"pie\" without any overlapping characters, so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\")\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words.\n    \"\"\"\n    return \"applepie\", [\"apple\", \"pie\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string 's' and a list of words, check if 's' can be formed by concatenating the words in the list.\n    Each word can be used multiple times, and the order of the words can be rearranged.\n    Return True if 's' can be formed, False otherwise.\n    \"\"\"\n    def backtrack(s):\n        if len(s) == 0:\n            return True\n        for word in words:\n            if s.startswith(word):\n                if backtrack(s[len(word):]):\n                    return True\n        return False\n    \n    return backtrack(s)\n\ndef g():\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n    return s, words\n\nassert f(*g()) == True\n\n",
        "idx_generation": 149,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k items from a set of n items without repetition.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n\n    \"\"\"\n    if k > n:\n        return 0\n\n    numerator = 1\n    denominator = 1\n\n    for i in range(1, k + 1):\n        numerator *= n - i + 1\n        denominator *= i\n\n    return numerator // denominator\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two integers n and k such that there are at least k ways to choose k items from a set of n items.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 202,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median element.\n    The median is the middle element if the list is sorted.\n    If the list has an even number of elements, the median is the average of the two middle elements.\n    Return the median.\n\n    Example:\n    nums = [1, 5, 3, 9, 7, 2, 4, 6, 8]\n    The middle elements after sorting the list are [4, 5, 6].\n    Therefore, the function should return 5.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 1:\n        return nums[n // 2]\n    else:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n\ndef g():\n    nums = [1, 5, 3, 9, 7, 2, 4, 6, 8]\n    return nums\n\nassert f(g()) == 5\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    If the target value is not found in the array, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], target = 11\n    Output: 5\n\n    Hint: Use binary search to find the index of the target value.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    return binary_search(nums, target)\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 11\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of elements in the given array that sum up to the target value.\"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [2, 4, 1, 5, 9, 3, 7], 10\n\nassert f(*g())\n",
        "idx_generation": 118,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: [4, 10, 4, 3, 8, 9]\n    Output: 3\n    Explanation: The longest increasing subsequence is [4, 8, 9], therefore the length is 3.\n    \"\"\"\n\n    # Initialize an array to store the length of the LIS for each element in the input list\n    dp = [1] * len(nums)\n\n    # Iterate through the input list\n    for i in range(1, len(nums)):\n        # Check all previous elements to find the longest increasing subsequence\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Return the maximum length of the LIS\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    Input: [10, 22, 9, 33, 21, 50, 41, 60, 80]\n    Output: 6 (The longest increasing subsequence is [10, 22, 33, 50, 60, 80])\n\n    Hint: Use dynamic programming and a stack to solve this problem.\n    \"\"\"\n    dp = [1] * len(nums)\n    stack = []\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)\n\n    for i in range(len(nums) - 1, -1, -1):\n        if dp[i] == max_length:\n            stack.append(nums[i])\n            max_length -= 1\n\n    lis = []\n    while stack:\n        lis.append(stack.pop())\n\n    return len(lis)\n\ndef g():\n    return [10, 22, 9, 33, 21, 50, 41, 60, 80]\n\nassert f(g()) == 6\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target and return their indices.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The sum of nums[0] = 2 and nums[1] = 7 is equal to the target value of 9, so the indices [0, 1] are returned.\n\n    Input: nums = [3, 2, 4], target = 6\n    Output: [1, 2]\n    Explanation: The sum of nums[1] = 2 and nums[2] = 4 is equal to the target value of 6, so the indices [1, 2] are returned.\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix represented as a list of lists, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements of the matrix in spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    spiral = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            spiral.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral.append(matrix[i][left])\n            left += 1\n\n    return spiral\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose bitwise OR is equal to 0.\n    \"\"\"\n    arr.sort()  # Sorting the list in ascending order\n    for i in range(len(arr)-1):\n        if (arr[i] | arr[i+1]) == 0:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g()) == False\n\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target value 'target',\n    determine if there exists two elements in the list whose sum is equal to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    The elements 2 and 5 sum up to the target value 7.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g(), 7) == True\n",
        "idx_generation": 83,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid == n:\n            return True\n        elif mid * mid < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False\n\ndef g():\n    \"\"\"\n    Find a perfect square number.\n    \"\"\"\n    return 16\n\nassert f(g())\n",
        "idx_generation": 343,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum along a path from the top-left corner to the bottom-right corner.\n    You can only move either down or right at any point in time.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    \n    def max_path_sum(row: int, col: int) -> int:\n        if row == rows-1 and col == cols-1:\n            return grid[row][col]\n        if row >= rows or col >= cols:\n            return float('-inf')\n        if memo[row][col] != 0:\n            return memo[row][col]\n        \n        memo[row][col] = grid[row][col] + max(max_path_sum(row+1, col), max_path_sum(row, col+1))\n        return memo[row][col]\n    \n    return max_path_sum(0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1,3,1],[1,5,1],[4,2,1]])) == 12\n",
        "idx_generation": 167,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [2],\n        2: [3],\n        3: [4],\n        4: []\n    }\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n\n\n",
        "idx_generation": 232,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the elevation of a terrain, find the maximum amount of water that can be trapped between the bars.\n    Each bar has a width of 1 unit.\n\n    Sample Input:\n    heights = [0,1,0,2,1,0,1,3,2,1,2,1]\n\n    Sample Output:\n    6\n\n    Explanation: The figure below represents the elevation map where 'X' indicates water being trapped.\n                 The total amount of water trapped is 6 units.\n\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n                 X X X X X X X X X X X\n    \"\"\"\n\n    n = len(heights)\n    if n < 3:\n        return 0\n    \n    left_max = [0] * n\n    right_max = [0] * n\n\n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    water = 0\n    for i in range(1, n-1):\n        min_height = min(left_max[i], right_max[i])\n        water += max(0, min_height - heights[i])\n\n    return water\n\ndef g() -> List[int]:\n    heights = [0,1,0,2,1,0,1,3,2,1,2,1]\n    return heights\n\nassert f(g()) == 6\n\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if it is possible to arrange n distinct numbers such that\n    the absolute difference between any two adjacent numbers is at least k.\n\n    Return True if it is possible, False otherwise.\n    \"\"\"\n    if k == 0:\n        return False\n    if k > n:\n        return False\n    if k == 1:\n        return True\n    if k == 2:\n        if n % 2 == 0:\n            return False\n        return True\n    return True\ndef g(n = 5, k = 2):\n    return n, k\nassert f(*g())\n",
        "idx_generation": 32,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of non-empty subarrays that have a sum divisible by 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    f(nums) => 4\n\n    Explanation: The subarrays with a sum divisible by 5 are [1, 2], [2, 3], [3, 4], [4, 5].\n    \"\"\"\n\n    count = 0\n    prefix_sum = 0\n    remainder_counts = [0] * 5\n\n    for num in nums:\n        prefix_sum += num\n\n        # Calculate the remainder of the prefix sum when divided by 5\n        remainder = prefix_sum % 5\n\n        # Increment the count of subarrays with the same remainder\n        count += remainder_counts[remainder]\n\n        # Increment the count of subarrays with a sum divisible by 5\n        if remainder == 0:\n            count += 1\n\n        # Increment the count of the current remainder\n        remainder_counts[remainder] += 1\n\n    return count\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 4\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 84,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any three numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 31\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 25, 2, and 4, which is equal to 31.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                xor_val = nums[i] ^ nums[j] ^ nums[k]\n                if xor_val > max_xor:\n                    max_xor = xor_val\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 31\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine if there exists a perfect square between n and m (inclusive).\n    \"\"\"\n    def is_perfect_square(num):\n        if num < 0:\n            return False\n        root = int(num ** 0.5)\n        return root * root == num\n    \n    for i in range(n, m+1):\n        if is_perfect_square(i):\n            return True\n    return False\n\ndef g(n=10, m=20):\n    return n, m\n\nassert f(*g()) == True\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target=10) -> bool:\n    \"\"\"\n    Given a list of numbers, determine if there exists a subset of the numbers whose sum is equal to the target.\n\n    Sample input:\n    [2, 4, 6, 8]\n\n    Sample output:\n    True\n\n    In the given list, there exists a subset [2, 8] whose sum is equal to the target 10.\n    \"\"\"\n    n = len(numbers)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            if j >= numbers[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - numbers[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][target]\n\ndef g():\n    numbers = [2, 4, 6, 8]\n    return numbers\n\nassert f(g()) == True\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the elements in the original list except the corresponding element.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [14, 13, 12, 11, 10]\n\n    Explanation: The first element is the sum of (2 + 3 + 4 + 5), the second element is the sum of (1 + 3 + 4 + 5), and so on.\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    suffix_sum = [0] * (n + 1)\n    output = [0] * n\n\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i-1]\n    \n    for i in range(n-1, -1, -1):\n        suffix_sum[i] = suffix_sum[i+1] + nums[i]\n    \n    for i in range(n):\n        output[i] = prefix_sum[i] + suffix_sum[i+1]\n    \n    return output\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that the sum of all elements in the list is not zero.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [14, 13, 12, 11, 10]\n\n",
        "idx_generation": 286,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subarray with a sum equal to zero.\n    Return True if such a subarray exists, otherwise return False.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in prefix_sums or prefix_sum == 0:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g():\n    nums = [1, -2, 3, 4, -5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 160,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is a subsequence of s.\n\n    Args:\n    s (str): The input string.\n    t (str): The subsequence to check.\n\n    Returns:\n    bool: True if t is a subsequence of s, False otherwise.\n    \"\"\"\n    m = len(s)\n    n = len(t)\n  \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n  \n    for i in range(m + 1):\n        dp[i][0] = 1\n  \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i - 1][j]\n  \n    return dp[m][n]\n\ndef g():\n    s = \"abcde\"\n    t = \"ace\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'arr', check if there exists a subset of the array whose sum is divisible by 3.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    Output: True\n    Explanation: The subset [2, 4] has a sum of 6, which is divisible by 3.\n\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        if arr[i] % 3 == 0:\n            dp[i][i] = True\n\n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if (arr[i] + arr[j]) % 3 == 0:\n                dp[i][j] = True\n            elif (arr[i] + arr[j]) % 3 != 0:\n                for k in range(i+1, j):\n                    if dp[i][k-1] and dp[k][j]:\n                        dp[i][j] = True\n                        break\n\n    return dp[0][n-1]\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a grid of integers, return a list containing the sum of each row in the grid.\n    \"\"\"\n    sums = []\n    for row in grid:\n        row_sum = 0\n        for num in row:\n            row_sum += num\n        sums.append(row_sum)\n    return sums\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == [6, 15, 24]\n",
        "idx_generation": 54,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return the indices of two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] equals 9, so the function should return [0, 1].\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all the numbers in the grid.\n    \"\"\"\n    stack = []\n    for row in grid:\n        for num in row:\n            stack.append(num)\n    total_sum = 0\n    while stack:\n        total_sum += stack.pop()\n    return total_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 54,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the longest increasing path in the matrix.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path in the matrix is [1, 2, 6, 9], with a length of 4.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    longest_path = 1\n    cache = [[0] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        if cache[row][col]:\n            return cache[row][col]\n\n        path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] > matrix[row][col]:\n                path = max(path, 1 + dfs(new_row, new_col))\n\n        cache[row][col] = path\n        return path\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 424,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of characters and a word, return True if the word exists in the grid, and False otherwise.\n    The word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are horizontally or vertically neighboring.\n    The same letter cell may not be used more than once in a word.\n\n    Example:\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n    Output: True\n\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"SEE\"\n    Output: True\n\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCB\"\n    Output: False\n    \"\"\"\n\n    def exist(grid: List[List[str]], word: str) -> bool:\n        def dfs(i: int, j: int, k: int) -> bool:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            temp = grid[i][j]\n            grid[i][j] = ''\n            res = dfs(i - 1, j, k + 1) or dfs(i + 1, j, k + 1) or dfs(i, j - 1, k + 1) or dfs(i, j + 1, k + 1)\n            grid[i][j] = temp\n            return res\n\n        m = len(grid)\n        n = len(grid[0])\n\n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n\n        return False\n\n    return exist(grid, word)\n\ndef g() -> (List[List[str]], str):\n    return [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \"ABCCED\"\n\nassert f(*g()) == True\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all the elements in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    total = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            total += grid[i][j]\n\n    return total\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 150,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, return the number of unique paths from the top-left corner to the bottom-right\n    corner of a grid of size n x m. You can only move down or right.\n\n    Example:\n    n = 3\n    m = 3\n\n    f(n, m) => 6\n    Explanation: There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    n = 2\n    m = 4\n\n    f(n, m) => 4\n    Explanation: There are 4 unique paths from the top-left corner to the bottom-right corner of a 2 x 4 grid.\n    \"\"\"\n\n    dp = [[1] * m] * n\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][m - 1]\n\ndef g():\n    return 3, 3\n\nassert f(*g()) == 6\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome. A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring cases and non-alphanumeric characters.\n\n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    Explanation: \"amanaplanacanalpanama\" is a valid palindrome.\n\n    Constraints:\n    - 0 <= len(s) <= 2 * 10^5\n    - s consists only of printable ASCII characters.\n    \"\"\"\n\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n\n\n",
        "idx_generation": 430,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words and the characters within each word.\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            if word:\n                stack.append(word[::-1])\n                word = \"\"\n        else:\n            word += char\n    if word:\n        stack.append(word[::-1])\n    return \" \".join(stack[::-1])\n\ndef g():\n    \"\"\"\n    Generate a string with words in random order.\n    \"\"\"\n    return \"world hello my\"\n\nassert f(g()) == \"ym olleh dlrow\"\n",
        "idx_generation": 415,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome after deleting at most one character.\n\n    Example:\n    Input: \"raceacar\"\n    Output: True\n\n    Explanation: You can either delete the 'e' at index 3 or the 'a' at index 4 to make s a valid palindrome.\n    \"\"\"\n    def is_palindrome(s: str, i: int, j: int) -> bool:\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i += 1\n            j -= 1\n        return True\n\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return is_palindrome(s, i + 1, j) or is_palindrome(s, i, j - 1)\n        i += 1\n        j -= 1\n\n    return True\n\ndef g():\n    s = \"raceacar\"\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, return a new matrix where each element is the bitwise XOR of its row and column index.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    result = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            result[i][j] = i ^ j\n\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [[0, 1, 2], [1, 0, 3], [2, 3, 0]]\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits in a binary representation of a number.\n    \"\"\"\n    if n == 0:\n        return 0\n    return (n & 1) + f(n >> 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a number with a specific number of set bits in its binary representation.\n    \"\"\"\n    return 15\n\nassert f(g()) == 4\n",
        "idx_generation": 168,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there is a subset of the list that sums up to the target value.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    Output:\n    6\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = 1\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\n\ndef g():\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string of binary digits, determine if it represents a valid binary number divisible by 5.\n\n    Sample Input:\n    s = \"1010\"\n\n    Sample Output:\n    True\n    Explanation: The binary number 1010 is equal to the decimal number 10, which is divisible by 5.\n\n    Sample Input:\n    s = \"1101\"\n\n    Sample Output:\n    False\n    Explanation: The binary number 1101 is equal to the decimal number 13, which is not divisible by 5.\n    \"\"\"\n    decimal = int(s, 2)\n    return decimal % 5 == 0\n\ndef g():\n    return \"1010\"\n\nassert f(g()) == True\n",
        "idx_generation": 100,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, return True if it is a power of 2, otherwise return False.\n\n    Example:\n    n = 16\n\n    f(n) => True\n    Explanation: 16 is a power of 2 (2 ^ 4).\n\n    n = 12\n\n    f(n) => False\n    Explanation: 12 is not a power of 2.\n\n    \"\"\"\n\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g(n: int = 16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if it is connected.\n\n    Sample Input:\n    graph = [[1, 2], [0, 2], [0, 1]]\n\n    Sample Output:\n    True\n    Explanation: The graph is connected.\n\n    Sample Input:\n    graph = [[1, 2], [0], [0]]\n\n    Sample Output:\n    False\n    Explanation: The graph is not connected.\n    \"\"\"\n    visited = [False] * len(graph)\n    dfs(graph, 0, visited)\n    return all(visited)\n\ndef dfs(graph: List[List[int]], node: int, visited: List[bool]):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(graph, neighbor, visited)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph that is connected.\n    \"\"\"\n    return [[1, 2], [0, 2], [0, 1]]\n\nassert f(g()) == True\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(edges: List[Tuple[int, int]], n: int, start: int, end: int) -> List[int]:\n    \"\"\"\n    Given a list of edges representing a directed graph, find the shortest path from the start node to the end node.\n\n    Example:\n    edges = [(0, 1), (0, 2), (1, 2), (2, 3), (3, 4)]\n    n = 5\n    start = 0\n    end = 4\n    Output: [0, 2, 3, 4]\n    Explanation: The shortest path from node 0 to node 4 is [0, 2, 3, 4].\n\n    Note:\n    - You may assume that there is always a path from the start node to the end node.\n    \"\"\"\n\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u in graph:\n            graph[u].append(v)\n        else:\n            graph[u] = [v]\n\n    queue = [(start, [start])]\n    while queue:\n        node, path = queue.pop(0)\n        if node == end:\n            return path\n        if node in graph:\n            for neighbor in graph[node]:\n                queue.append((neighbor, path + [neighbor]))\n\ndef g(edges=[(0, 1), (0, 2), (1, 2), (2, 3), (3, 4)], n=5, start=0, end=4):\n    return edges, n, start, end\n\nassert f(*g()) == [0, 2, 3, 4]\n",
        "idx_generation": 29,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of values along a path from the top-left cell to the bottom-right cell in a grid.\n    You can only move down or right. Each cell in the grid can only be visited once.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return grid[i][j]\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        right_sum = float('-inf')\n        down_sum = float('-inf')\n\n        if i + 1 < rows:\n            down_sum = dfs(i + 1, j)\n        if j + 1 < cols:\n            right_sum = dfs(i, j + 1)\n\n        dp[i][j] = max(down_sum, right_sum) + grid[i][j]\n        return dp[i][j]\n\n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 36,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid representing a maze, find the shortest path from the top-left cell to the bottom-right cell.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    return dfs(grid, 0, 0, m, n, {})\n\ndef dfs(grid, i, j, m, n, memo):\n    if i == m - 1 and j == n - 1:\n        return True\n    if i >= m or j >= n or grid[i][j] == 1:\n        return False\n    if (i, j) in memo:\n        return memo[(i, j)]\n    memo[(i, j)] = dfs(grid, i + 1, j, m, n, memo) or dfs(grid, i, j + 1, m, n, memo)\n    return memo[(i, j)]\n\ndef g():\n    grid = [\n        [0, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 11,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine whether it is possible to reach the bottom-right cell of the grid from the top-left cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    \n    def dfs(i: int, j: int) -> bool:\n        if i == m - 1 and j == n - 1:\n            return True\n        if i >= m or j >= n or grid[i][j] == 1 or visited[i][j]:\n            return False\n        \n        visited[i][j] = True\n        return dfs(i + 1, j) or dfs(i, j + 1)\n    \n    return dfs(0, 0)\n\ndef g(grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Find the number of ways to choose k elements from a set of n elements, such that no two chosen elements are consecutive integers, and the sum of the chosen elements is divisible by m.\"\"\"\n    def count_ways(n, m, k):\n        if k == 0:\n            return 1\n        elif k == 1:\n            return n\n        elif k == 2:\n            return n * (n-1)\n        else:\n            dp = [0] * (k+1)\n            dp[0] = 1\n            dp[1] = n\n            dp[2] = n * (n-1)\n            for i in range(3, k+1):\n                dp[i] = (n-1) * dp[i-1] + (n-2) * dp[i-2]\n            return dp[k]\n\n    return count_ways(n, m, k) % m == 0\n\ndef g(n=10, m=5, k=3):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, find the number of distinct anagrams present in the list.\n\n    Example:\n    Input: words = [\"cat\", \"tac\", \"act\", \"dog\", \"god\"]\n    Output: 2\n    Explanation: There are 2 distinct anagrams present in the list: [\"cat\", \"tac\", \"act\"] and [\"dog\", \"god\"].\n\n    Input: words = [\"listen\", \"silent\", \"enlist\", \"tinsel\"]\n    Output: 2\n    Explanation: There are 2 distinct anagrams present in the list: [\"listen\", \"silent\", \"enlist\"] and [\"tinsel\"].\n\n    Input: words = [\"hello\", \"world\", \"hi\", \"bye\"]\n    Output: 4\n    Explanation: There are 4 distinct anagrams present in the list: [\"hello\"], [\"world\"], [\"hi\"] and [\"bye\"].\n    \"\"\"\n\n    def count_anagrams(word: str) -> str:\n        count = [0] * 26\n        for char in word:\n            count[ord(char) - ord('a')] += 1\n        return tuple(count)\n\n    anagram_count = len(set(count_anagrams(word) for word in words))\n    return anagram_count\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    return [\"cat\", \"tac\", \"act\", \"dog\", \"god\", \"mat\", \"tam\"]\n\nassert f(g()) == 3\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Find the number of ways to choose n objects from a set of r distinct objects, where order does not matter and repetitions are allowed.\n    \"\"\"\n    def factorial(x):\n        if x == 0:\n            return 1\n        else:\n            return x * factorial(x-1)\n    \n    return factorial(n+r-1) // (factorial(n) * factorial(r-1))\n\ndef g():\n    n = 4\n    r = 3\n    return n, r\n\nassert f(*g()) == 15\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the elements of nums in non-decreasing order, with all duplicates removed.\n\n    Example:\n    Input: nums = [3, 1, 2, 2, 1, 4, 5, 4]\n    Output: [1, 2, 3, 4, 5]\n\n    Explanation:\n    The input list contains duplicates and is not sorted. The output list is a sorted version of the input list with duplicates removed.\n\n    Note:\n    - The input list may contain negative numbers.\n    - The output list should not contain any duplicates.\n    - The output list should be in non-decreasing order.\n    \"\"\"\n\n    nums = sorted(set(nums))\n    return nums\n\ndef g():\n    return [3, 1, 2, 2, 1, 4, 5, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of two numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation:\n    - The maximum product of two numbers in the given list is 20, which corresponds to the pair (4, 5).\n    \"\"\"\n\n    def max_product(nums):\n        if len(nums) < 2:\n            return None\n\n        # Initialize variables to store the maximum and second maximum numbers\n        max_num = float('-inf')\n        second_max_num = float('-inf')\n\n        for num in nums:\n            if num > max_num:\n                second_max_num = max_num\n                max_num = num\n            elif num > second_max_num:\n                second_max_num = num\n\n        return max_num * second_max_num\n\n    return max_product(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, return a new list that contains all the elements from arr in sorted order.\n\n    Use a stack and a queue to implement a sorting algorithm.\n\n    Example:\n    Input: [4, 2, 7, 1, 9, 5]\n    Output: [1, 2, 4, 5, 7, 9]\n    \"\"\"\n    stack = []\n    queue = []\n\n    for num in arr:\n        queue.append(num)\n\n    while queue:\n        # Move the elements from the queue to the stack in descending order\n        # using a temporary queue\n        temp_queue = []\n        max_num = float('-inf')\n\n        while queue:\n            num = queue.pop(0)\n            if num > max_num:\n                max_num = num\n            temp_queue.append(num)\n\n        while temp_queue:\n            num = temp_queue.pop(0)\n            if num != max_num:\n                queue.append(num)\n            else:\n                stack.append(num)\n\n    # Move the elements from the stack to the result list in ascending order\n    result = []\n    while stack:\n        result.append(stack.pop())\n\n    return result\n\ndef g(arr=[4, 2, 7, 1, 9, 5]):\n    return [arr]\n\nassert f(*g()) == [1, 2, 4, 5, 7, 9]\n",
        "idx_generation": 164,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is located at index 2 in the list.\n\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, low, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, high)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if a given string is a valid parentheses expression.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"(())\"\n\nassert f(g()) == True\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid mathematical expression.\n    The expression can contain digits, operators (+, -, *, /), parentheses, and whitespace.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return not stack\n\ndef g():\n    return \"(3 * 4) + (5 / 2)\"\n\nassert f(g()) == True\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all duplicate elements such that each element appears only once.\n    The original list should be modified in-place, and the modified list should be sorted in non-decreasing order.\n\n    Example:\n    Input: [1, 1, 2, 2, 3, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n\n    Hint: Use a two-pointer technique to solve this problem efficiently.\n    \"\"\"\n    if len(nums) < 2:\n        return nums\n\n    left = 0\n    right = 1\n\n    while right < len(nums):\n        if nums[left] != nums[right]:\n            left += 1\n            nums[left] = nums[right]\n        \n        right += 1\n\n    return nums[:left + 1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 1, 2, 2, 3, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose bitwise XOR is equal to the target number.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: True\n\n    Explanation:\n    3 ^ 5 = 6, which is equal to the target number.\n    Therefore, there exists a pair whose bitwise XOR is equal to the target number.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number, where there exists a pair of numbers in the list whose bitwise XOR is equal to the target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 274,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    Return True if n is prime, False otherwise.\n\n    Sample input:\n    n = 7\n\n    Sample output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef g(n = 7):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 89,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum size of a subarray\n    that sums up to at least the target value.\n    \"\"\"\n    min_length = float('inf')\n    left = 0\n    current_sum = 0\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length\n\ndef g(nums: List[int], target: int) -> int:\n    return nums, target\n\nassert f(*g([2, 3, 1, 2, 4, 3], 7)) == 2\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation:\n    - The longest increasing subsequence in the given list is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    def longest_increasing_subsequence(arr):\n        n = len(arr)\n        dp = [1] * n\n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return longest_increasing_subsequence(arr)\n\ndef g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 186,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum spanning tree (MST) using Prim's algorithm.\n\n    Return the total weight of the MST.\n\n    Example:\n    graph = [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\n    Output:\n    16\n\n    Explanation:\n    The minimum spanning tree is formed by the edges (0, 1), (1, 2), (1, 4), and (2, 3), with a total weight of 16.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    key = [float('inf')] * n\n    key[0] = 0\n    mst = 0\n\n    for _ in range(n):\n        u = min_vertex(key, visited)\n        visited[u] = True\n        mst += key[u]\n\n        for v in range(n):\n            if graph[u][v] > 0 and not visited[v] and graph[u][v] < key[v]:\n                key[v] = graph[u][v]\n\n    return mst\n\ndef min_vertex(key, visited):\n    min_key = float('inf')\n    min_vertex = -1\n\n    for v in range(len(key)):\n        if not visited[v] and key[v] < min_key:\n            min_key = key[v]\n            min_vertex = v\n    \n    return min_vertex\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 2, 0, 6, 0],\n        [2, 0, 3, 8, 5],\n        [0, 3, 0, 0, 7],\n        [6, 8, 0, 0, 9],\n        [0, 5, 7, 9, 0]\n    ]\n\nassert f(g()) == 16\n",
        "idx_generation": 355,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Args:\n    matrix (List[List[int]]): The matrix of integers.\n\n    Returns:\n    List[List[int]]: The rotated matrix.\n    \"\"\"\n    n = len(matrix)\n    rotated = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            rotated[j][n-i-1] = matrix[i][j]\n    \n    return rotated\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -> List[List[int]]:\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 340,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of increasing subsequences of length 3 within the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 10\n    Explanation: The increasing subsequences of length 3 are: [1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5].\n\n    Input: nums = [3, 2, 1]\n    Output: 0\n    Explanation: There are no increasing subsequences of length 3 in the list.\n    \"\"\"\n\n    def count_increasing_subsequences(nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                if nums[j] > nums[i]:\n                    for k in range(j + 1, n):\n                        if nums[k] > nums[j]:\n                            count += 1\n\n        return count\n\n    return count_increasing_subsequences(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 10\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=20) -> bool:\n    \"\"\"Find the minimum number of coins required to make up the target amount\"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for coin in nums:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[target] if dp[target] != float('inf') else -1\ndef g(target=20):\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    return coins\nassert f(g()) == True\n",
        "idx_generation": 3,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 254,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nimport itertools\n\ndef f(arr: List[int], target: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    Given a list of integers and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a tuple, or None if no such numbers exist.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_map:\n            return num_map[complement], i\n        num_map[num] = i\n    return None\n\ndef g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == (0, 1)\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        max_xor_candidate = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ max_xor_candidate in prefixes:\n                max_xor = max_xor_candidate\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 488,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers in the list whose sum is a perfect square.\n\n    Example:\n    Input: [2, 7, 9, 3, 5]\n    Output: True\n\n    Explanation:\n    2 + 9 = 11, which is not a perfect square.\n    7 + 9 = 16, which is a perfect square.\n    Therefore, the output is True.\n    \"\"\"\n    squares = {i ** 2 for i in range(int(max(nums) ** 0.5) + 1)}\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] in squares:\n                return True\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers where the sum of any two numbers is a perfect square.\n    \"\"\"\n    return [2, 7, 9, 3, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, count the number of prime numbers less than or equal to num.\n\n    Return the count of prime numbers.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for i in range(2, num + 1):\n        if is_prime(i):\n            count += 1\n    \n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    num = 20\n    return num\n\nassert f(g()) == 8\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find if there exists a subset of the list whose sum is equal to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n    dp[0][0] = True\n\n    for i in range(1, n+1):\n        for j in range(target + 1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i-1]]\n    \n    return dp[n][target]\n\ndef g():\n    nums = [3, 2, 7, 1, 6]\n    target = 9\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all the multiples of 3 or 5 below n.\n    \"\"\"\n    multiples_sum = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            multiples_sum += i\n    return multiples_sum\n\ndef g():\n    return 100\n\nassert f(g()) == 2318\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Given two positive integers m and n, find the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid.\n\n    You can only move either down or right at any point in time.\n\n    Return the number of unique paths.\n\n    Example:\n    Input: m = 3, n = 7\n    Output: 28\n    Explanation: There are 28 unique paths from the top-left corner to the bottom-right corner of a 3 x 7 grid.\n\n    Constraints:\n    - 1 <= m, n <= 100\n    \"\"\"\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\ndef g(m = 3, n = 7):\n    return m, n\n\nassert f(*g()) == 28\n\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given grid is a magic square.\n    A magic square is a square grid of numbers, where the sum of each row, each column,\n    and both diagonals is the same.\n    \"\"\"\n    n = len(grid)\n    target_sum = sum(grid[0])\n\n    # Check rows\n    if not all(sum(row) == target_sum for row in grid):\n        return False\n\n    # Check columns\n    if not all(sum(col) == target_sum for col in zip(*grid)):\n        return False\n\n    # Check diagonals\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return False\n    if sum(grid[i][n - i - 1] for i in range(n)) != target_sum:\n        return False\n\n    return True\ndef g():\n    grid = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\n    return grid\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of indices of two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int, start: int, end: int) -> List[int]:\n        num_set = set()\n        for i in range(start, end + 1):\n            complement = target - nums[i]\n            if complement in num_set:\n                return [nums.index(complement), i]\n            num_set.add(nums[i])\n        return []\n    \n    return two_sum(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 420,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, reverse the order of elements using a stack.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    reversed_nums = []\n    while stack:\n        reversed_nums.append(stack.pop())\n    return reversed_nums\n\ndef g():\n    # The list of integers\n    nums = [1, 2, 3, 4, 5]\n    \n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 59,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a combination of numbers that sum up to the target.\n    Return True if such combination exists, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    There is a combination that sums up to 10: [2, 4, 4].\n\n    Therefore, the function should return True.\n    \"\"\"\n    return dp(nums, target, 0, {})\n\ndef dp(nums: List[int], target: int, index: int, memo: dict) -> bool:\n    if target == 0:\n        return True\n    if target < 0 or index >= len(nums):\n        return False\n    if (target, index) in memo:\n        return memo[(target, index)]\n    \n    if dp(nums, target - nums[index], index, memo) or dp(nums, target, index + 1, memo):\n        memo[(target, index)] = True\n        return True\n    \n    memo[(target, index)] = False\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 426,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible balanced parentheses combinations of length n.\n    \"\"\"\n    result = []\n    \n    def backtrack(s: str, open_count: int, close_count: int):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        \n        if open_count < n:\n            backtrack(s + '(', open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(s + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n\ndef g(n: int):\n    return n\n\nn = 3\nassert f(g(n)) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a grid of integers, rotate the grid clockwise by 90 degrees in-place.\n    Return the rotated grid.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The rotated grid is:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    Therefore, the function should return the grid:\n    [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Transpose the grid\n    for i in range(rows):\n        for j in range(i, cols):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n\n    # Reverse each row of the grid\n    for i in range(rows):\n        grid[i] = grid[i][::-1]\n\n    return grid\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, return the number of unique paths from the top-left corner to the bottom-right\n    corner of a grid of size n x m. You can only move down or right.\n\n    Example:\n    n = 3\n    m = 2\n\n    f(n, m) => 3\n    Explanation: There are 3 unique paths from the top-left corner to the bottom-right corner of a 3 x 2 grid.\n\n    n = 4\n    m = 3\n\n    f(n, m) => 10\n    Explanation: There are 10 unique paths from the top-left corner to the bottom-right corner of a 4 x 3 grid.\n    \"\"\"\n\n    def count_unique_paths(i: int, j: int) -> int:\n        if i == n - 1 and j == m - 1:\n            return 1\n        if i >= n or j >= m:\n            return 0\n        return count_unique_paths(i + 1, j) + count_unique_paths(i, j + 1)\n\n    return count_unique_paths(0, 0)\n\ndef g():\n    return 3, 2\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 65,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s: str) -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s + s[::-1]\n\nassert f(g(\"abcba\")) == True\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(expression: str) -> int:\n    \"\"\"\n    Evaluate the given arithmetic expression written in Reverse Polish Notation (RPN).\n    \"\"\"\n    stack = []\n    operators = {\n        \"+\": lambda a, b: a + b,\n        \"-\": lambda a, b: a - b,\n        \"*\": lambda a, b: a * b,\n        \"/\": lambda a, b: int(a / b)\n    }\n\n    for token in expression.split():\n        if token in operators:\n            b = stack.pop()\n            a = stack.pop()\n            result = operators[token](a, b)\n            stack.append(result)\n        else:\n            stack.append(int(token))\n\n    return stack[0]\n\ndef g():\n    expression = \"5 4 + 3 *\"\n    return expression\n\nassert f(g()) == 27\n",
        "idx_generation": 12,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a subarray in nums such that the bitwise AND of all its elements is equal to 0.\n    \"\"\"\n    prefix_and = 0\n    and_set = {0}\n    for num in nums:\n        prefix_and &= num\n        and_set.add(prefix_and)\n    return any(prefix_and & a == 0 for a in and_set)\n\ndef g():\n    return [1, 2, 3, 4, 5]\nassert f(g()) == True\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target integer, determine if it is possible to obtain the target value by performing bitwise XOR operation on a subset of the matrix elements. The XOR operation is performed on the elements in the same row or same column.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def helper(row: int, col: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if row == rows or col == cols:\n            return False\n\n        # Exclude the current element\n        exclude = helper(row + 1, col, curr) or helper(row, col + 1, curr)\n\n        # Include the current element\n        include = helper(row + 1, col, curr ^ matrix[row][col]) or helper(row, col + 1, curr ^ matrix[row][col])\n\n        return exclude or include\n\n    return helper(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 5.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 14) == True\n",
        "idx_generation": 234,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there is a subset of nums that adds up to the target.\n\n    \"\"\"\n    def subset_sum(nums, target, index, memo):\n        # Base cases\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        \n        # Check if subset sum has already been computed\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        # Recursive case: include current number or exclude it\n        include = subset_sum(nums, target - nums[index], index + 1, memo)\n        exclude = subset_sum(nums, target, index + 1, memo)\n        \n        # Store result in memoization table\n        memo[(index, target)] = include or exclude\n        \n        return include or exclude\n    \n    memo = {}\n    return subset_sum(nums, target, 0, memo)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome after removing n characters.\n\n    Args:\n    s (str): The input string.\n    n (int): The number of characters to remove.\n\n    Returns:\n    bool: True if the string is a palindrome after removing n characters, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"\n        Check if a string is a palindrome.\n\n        Args:\n        s (str): The string to check.\n\n        Returns:\n        bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    return is_palindrome(s[:n] + s[n+1:])\n\ndef g():\n    return (\"level\", 1)\n\nassert f(*g()) == False\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 15\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes start and end,\n    return True if there is a path from start to end, and False otherwise.\n    \n    Sample Input:\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n    \n    Sample Output:\n    True\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph: List[List[int]], start: int, end: int, visited: List[bool]) -> bool:\n    if start == end:\n        return True\n    \n    visited[start] = True\n    \n    for i in range(len(graph)):\n        if graph[start][i] == 1 and not visited[i]:\n            if dfs(graph, i, end, visited):\n                return True\n    \n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n# Importing the necessary library\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, check if the graph represented by the edges\n    is a complete binary tree. A complete binary tree is a tree in which each level, except possibly the last,\n    is completely filled, and all nodes are as far left as possible.\n    \"\"\"\n    # Function to check if the graph is a complete binary tree\n    def is_complete_binary_tree(n, edges):\n        # Create a set to store the nodes that have been visited\n        visited = set()\n        \n        # Create a list to store the nodes that need to be visited\n        queue = [1]\n        \n        # Loop through the queue until it is empty\n        while queue:\n            # Get the current node\n            node = queue.pop(0)\n            \n            # Add the current node to the visited set\n            visited.add(node)\n            \n            # Loop through the edges\n            for edge in edges:\n                # Check if the current node is in the edge\n                if node in edge:\n                    # Get the other node in the edge\n                    other_node = edge[0] if edge[0] != node else edge[1]\n                    \n                    # Check if the other node has not been visited\n                    if other_node not in visited:\n                        # Add the other node to the queue\n                        queue.append(other_node)\n        \n        # Check if all nodes have been visited\n        return len(visited) == n\n\n    # Check if the graph is a complete binary tree\n    return is_complete_binary_tree(n, edges)\n\ndef g():\n    # The number of nodes\n    n = 5\n    \n    # The list of edges connecting the nodes\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5]]\n    \n    return (n, edges)\n\nassert f(*g())\n",
        "idx_generation": 32,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges in a graph, determine if there exists a cycle in the graph.\n    Return True if a cycle exists, False otherwise.\n    \"\"\"\n    def has_cycle(graph, visited, current):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if visited[neighbor] or has_cycle(graph, visited, neighbor):\n                return True\n        visited[current] = False\n        return False\n    \n    n = len(edges)\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    \n    visited = [False] * n\n    for i in range(n):\n        if has_cycle(graph, visited, i):\n            return True\n    \n    return False\n\ndef g(edges: List[List[int]]):\n    return edges\n\nassert f(g([[0, 1], [1, 2], [2, 0]]))\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from \n    the start node to the end node with at most k edges.\n    \"\"\"\n    visited = set()\n    return dfs(graph, start, end, k, visited)\n\ndef dfs(graph, node, end, k, visited):\n    if node == end:\n        return True\n    if k == 0:\n        return False\n    visited.add(node)\n    for neighbor in range(len(graph[node])):\n        if graph[node][neighbor] == 1 and neighbor not in visited:\n            if dfs(graph, neighbor, end, k-1, visited):\n                return True\n    visited.remove(node)\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n    k = 3\n    return graph, start, end, k\n\nassert f(*g()) == True\n",
        "idx_generation": 18,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Given three integers n, m, and k, determine the number of ways to choose k numbers from the range 1 to n,\n    such that the sum of the chosen numbers is divisible by m.\n\n    Return True if the number of ways is greater than 0, False otherwise.\n    \"\"\"\n    # Initialize a dynamic programming table to store the number of ways\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            dp[i][(j + i) % m] += dp[i - 1][j]\n\n    return dp[n][0] > 0\n\ndef g(n = 5, m = 3, k = 2):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 34,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers and a target value, find all unique combinations in the array where the sum of the combination is equal to the target.\n\n    Each number in the array can be used unlimited times.\n\n    Return a list of all unique combinations.\n\n    Example:\n    arr = [2, 3, 6, 7]\n    target = 7\n    Output: [[2, 2, 3], [7]]\n\n    arr = [2, 3, 5]\n    target = 8\n    Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    \"\"\"\n    result = []\n    arr.sort()\n    dfs(arr, target, 0, [], result)\n    return result\n\ndef dfs(arr: List[int], target: int, index: int, path: List[int], result: List[List[int]]):\n    if target == 0:\n        result.append(path)\n        return\n    for i in range(index, len(arr)):\n        if arr[i] > target:\n            break\n        dfs(arr, target - arr[i], i, path + [arr[i]], result)\n\ndef g(arr: List[int] = [2, 3, 6, 7], target: int = 7):\n    return arr, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 190,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique permutations of the digits of n.\n\n    Sample Input:\n    n = 123\n\n    Sample Output:\n    6\n    Explanation: The digits of 123 can be rearranged to form the following unique permutations: 123, 132, 213, 231, 312, 321.\n\n    Sample Input:\n    n = 1122\n\n    Sample Output:\n    6\n    Explanation: The digits of 1122 can be rearranged to form the following unique permutations: 1122, 1212, 1221, 2112, 2121, 2211.\n\n    \"\"\"\n    from math import factorial\n    digit_counts = [0] * 10\n    while n > 0:\n        digit_counts[n % 10] += 1\n        n //= 10\n    total_permutations = factorial(sum(digit_counts))\n    for count in digit_counts:\n        total_permutations //= factorial(count)\n    return total_permutations\n\ndef g(n=123):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of two numbers from nums that add up to the target. \n    If there are multiple pairs that add up to the target, return any one of them.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [2, 7]\n\n    Explanation:\n    The input list contains the pair (2, 7) which adds up to the target 9.\n\n    Note:\n    - The input list may contain negative numbers.\n    - There will always be a solution in the input list.\n    \"\"\"\n\n    num_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return [num, complement]\n\ndef g():\n    return [3, 1, 5, 2, 7, 4, 6], 10\n\nassert f(*g()) == [3, 7]\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product can be obtained by multiplying 4 and 5.\n\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g(nums = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 247,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, return True if there exists a pair of numbers in the list that add up to the target,\n    and False otherwise. You may not use the same element twice.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there exists a pair of numbers that add up to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 4, 7, 3, 9, 2]\ntarget = 6\nassert f(*g(nums, target))\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums\n\nassert f(g(), g()[1] + g()[-1]) == True\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the numbers in non-decreasing order.\n\n    Example:\n    nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]\n\n    The sorted list is [1, 1, 2, 3, 4, 5, 5, 6, 9].\n\n    Therefore, the function should return [1, 1, 2, 3, 4, 5, 5, 6, 9].\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[0]\n    less_than_pivot = [num for num in nums[1:] if num <= pivot]\n    greater_than_pivot = [num for num in nums[1:] if num > pivot]\n\n    return f(less_than_pivot) + [pivot] + f(greater_than_pivot)\n\ndef g() -> List[int]:\n    nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]\n    return nums\n\nassert f(g()) == [1, 1, 2, 3, 4, 5, 5, 6, 9]\n\n",
        "idx_generation": 288,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation:\n    - The maximum product of any two distinct numbers in the given list is 5 * 4 = 20.\n    \"\"\"\n\n    def max_product(arr):\n        n = len(arr)\n        if n < 2:\n            return 0\n        \n        max_product = float('-inf')\n        for i in range(n-1):\n            for j in range(i+1, n):\n                product = arr[i] * arr[j]\n                max_product = max(max_product, product)\n                \n        return max_product\n\n    return max_product(arr)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 20\n",
        "idx_generation": 324,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the number of pairs of numbers in the list whose bitwise XOR is equal to the target number.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: 1\n\n    Explanation:\n    3 ^ 5 = 6, which is equal to the target number.\n    Therefore, there is one pair whose bitwise XOR is equal to the target number.\n    \"\"\"\n    count = 0\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number, where there exists pairs of numbers in the list whose bitwise XOR is equal to the target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == 1\n\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return -1.\n    \n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    \n    Sample Output:\n    2\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Initialize the first row\n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    \n    # Initialize the first column\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    \n    # Calculate the rest of the grid\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n    \n    return grid[-1][-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 191,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1)\n    where the path consists of only 0s and the neighboring cells are connected horizontally or vertically.\n\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    There exists a path from the top-left corner to the bottom-right corner consisting only of 0s.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def dfs(matrix, row, col, visited):\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return True\n\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]) or matrix[row][col] != 0 or visited[row][col]:\n            return False\n\n        visited[row][col] = True\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for direction in directions:\n            next_row = row + direction[0]\n            next_col = col + direction[1]\n\n            if dfs(matrix, next_row, next_col, visited):\n                return True\n\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n\n    return dfs(matrix, 0, 0, visited)\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0]\n    ]\n    return matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 420,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the maximum number of consecutive 1s in any row or column.\n    Return the maximum number of consecutive 1s.\n    \"\"\"\n    max_consecutive = 0\n    for row in grid:\n        consecutive = 0\n        for num in row:\n            if num == 1:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n    for col in range(len(grid[0])):\n        consecutive = 0\n        for row in range(len(grid)):\n            if grid[row][col] == 1:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n    return max_consecutive\n\n\ndef g():\n    grid = [[1, 1, 0, 1, 1],\n            [0, 1, 1, 1, 0],\n            [1, 1, 1, 0, 0],\n            [0, 0, 1, 1, 1]]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find whether there are 4 numbers in the given list whose sum is equal to the target.\n    \"\"\"\n    from itertools import combinations\n    for c in combinations(nums, 4):\n        if sum(c) == target:\n            return True\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8], target = 18):\n    return nums\n\nassert f(g(), 18)\n\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, k: int, n: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, a number of elements to select (k), and a sum (n),\n    return True if there exist k elements in the list that sum up to n, and False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total == n\n        if index == len(nums):\n            return False\n        if total + nums[index] <= n and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort()\n    return backtrack(0, 0, 0)\n\n\ndef g(nums: List[int], target: int, k: int, n: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, a number of elements to select (k), and a sum (n),\n    such that there exist k elements in the list that sum up to n.\n    \"\"\"\n    nums.sort()\n    return nums, target, k, n\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 10\nk = 3\nn = 6\nassert f(*g(nums, target, k, n))\n",
        "idx_generation": 10,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the majority element (appears more than n/2 times, where n is the length of the list).\n    Return the majority element.\n    \"\"\"\n    majority_count = 0\n    majority_element = 0\n    for num in nums:\n        if majority_count == 0:\n            majority_element = num\n        if num == majority_element:\n            majority_count += 1\n        else:\n            majority_count -= 1\n    return majority_element\n\ndef g(nums = [2, 2, 1, 1, 1, 2, 2]):\n    return nums\n\nassert f(g()) == 2\n",
        "idx_generation": 254,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target number, find two numbers in nums such that they add up to the target. Return their indices as a list.\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 104,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of every row, column, and diagonal is the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n    A subarray is a contiguous part of the array.\n    Return the maximum subarray sum.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, -2, 3, -4, 5]\n    return nums\n\nassert f(g()) == 5\n\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the sum of all the even numbers in the list.\n    \"\"\"\n    def helper(nums, index):\n        if index < 0:\n            return 0\n        if nums[index] % 2 == 0:\n            return nums[index] + helper(nums, index - 1)\n        else:\n            return helper(nums, index - 1)\n    \n    return helper(numbers, len(numbers) - 1)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers to find the sum of all the even numbers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n    \"\"\"\n    return sum([num for num in arr if num % 2 == 0])\n\ndef g(arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    return arr\n\nassert f(g()) == 30\n\n",
        "idx_generation": 280,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29 (1 -> 4 -> 7 -> 8 -> 9)\n\n    matrix = [\n        [-1, 2, 3],\n        [4, -5, 6],\n        [7, 8, 9]\n    ]\n    Output: 17 (-1 -> 4 -> -5 -> 6 -> 9)\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 29\n\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given matrix is a magic square.\n    A matrix is a magic square if the sum of every row, column, and diagonal is the same.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != target_sum:\n            return False\n    \n    # Check diagonal\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != target_sum:\n        return False\n    \n    # Check anti-diagonal\n    anti_diagonal_sum = 0\n    for i in range(n):\n        anti_diagonal_sum += matrix[i][n-i-1]\n    if anti_diagonal_sum != target_sum:\n        return False\n    \n    return True\n\ndef g():\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a subgrid where the subgrid is a rectangle.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a subgrid is 45, which can be obtained by selecting the entire grid.\n\n    Therefore, the function should return 45.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            subgrid_sum += grid[x][y]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of positive integers for Puzzle 5.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer target, determine if it is possible to obtain target by performing addition and subtraction operations on the elements of nums.\n    \"\"\"\n    queue = deque([nums[0], -nums[0]])\n    for num in nums[1:]:\n        temp_queue = deque()\n        while queue:\n            temp = queue.popleft()\n            temp_queue.append(temp + num)\n            temp_queue.append(temp - num)\n        queue = temp_queue\n    return target in queue\n\ndef g(nums = [1, 2, 3, 4], target = 8):\n    return nums\n\nassert f(g(), 8)\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input: matrix = [[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]\n    Output: 29\n\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    Note: The matrix will have at least one cell.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]\n\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\n\nassert f(g()) == 29\n\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if it is possible to arrange n points on a grid such that no two points are k or less units apart.\n    \"\"\"\n    if k <= 0:\n        return n <= 1\n    if k == 1:\n        return n <= 4\n    if n <= (k+1)**2:\n        return True\n    return False\n\ndef g(n = 5, k = 2):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, determine if there is a path from the top-left corner to the bottom-right corner.\n    You can only move down or right, and you can only move to a cell if its value is positive.\n    \"\"\"\n    def dfs(row: int, col: int) -> bool:\n        if row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= 0:\n            return False\n        if row == len(grid)-1 and col == len(grid[0])-1:\n            return True\n        return dfs(row+1, col) or dfs(row, col+1)\n    \n    if not grid:\n        return False\n    return dfs(0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    grid = [[1, -2, 3], [4, 5, -6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 73,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the reversed string.\n\n    Sample Input:\n    s = \"hello\"\n\n    Sample Output:\n    \"olleh\"\n    \"\"\"\n\n    return s[::-1]\n\ndef g():\n    return \"hello\"\n\nassert f(g()) == \"olleh\"\n\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"Find the number of ways to form the target word using the given list of words, where each word can be used multiple times.\"\"\"\n    dp = [0] * (len(target) + 1)\n    dp[0] = 1\n\n    for i in range(1, len(target) + 1):\n        for word in words:\n            if len(word) <= i and target[i - len(word):i] == word:\n                dp[i] += dp[i - len(word)]\n\n    return dp[-1]\n\ndef g():\n    words = [\"apple\", \"pen\", \"applepen\"]\n    target = \"applepenapple\"\n    return words, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"abca\"\n    Output: True\n    Explanation: By removing the character 'b', the string becomes \"aca\", which is a palindrome.\n\n    Hint: Use a two-pointer approach to check if the string is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g() -> str:\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of set bits (1's) in its binary representation.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    2\n\n    Explanation: The binary representation of 10 is '1010' which contains 2 set bits.\n\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\n\ndef g() -> int:\n    n = 10\n    return n\n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 66,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a subset of nums that XORs to 0.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: True (subset [1, 4, 5] XORs to 0)\n\n    Hint: Use bit manipulation and dynamic programming to find the subset with XOR 0.\n    \"\"\"\n    total_xor = 0\n    for num in nums:\n        total_xor ^= num\n\n    if total_xor == 0:\n        return True\n\n    n = len(nums)\n    dp = [[False] * (total_xor + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(total_xor + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][total_xor]\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    dp = [0] * (n+1)\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that can be used to find the nth Fibonacci number.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n\n",
        "idx_generation": 453,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the sum of the ASCII values of all characters in the string.\n\n    Sample Input:\n    s = \"abc\"\n\n    Sample Output:\n    294\n    \"\"\"\n\n    total_sum = 0\n\n    for char in s:\n        total_sum += ord(char)\n\n    return total_sum\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == 294\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, return the transpose of the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ]\n    output: [\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ]\n    Explanation: The transpose of the graph is the same as the original graph.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    transpose = []\n    for i in range(len(graph)):\n        row = []\n        for j in range(len(graph[0])):\n            row.append(graph[j][i])\n        transpose.append(row)\n    return transpose\n\ndef g():\n    graph = [\n        [0, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == [\n    [0, 1, 0],\n    [1, 0, 1],\n    [0, 1, 0]\n]\n",
        "idx_generation": 218,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the shortest path from the start cell to the end cell.\n    You can only move up, down, left, or right in the matrix.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    queue = [(start[0], start[1], 0)]\n    visited = set([(start[0], start[1])])\n    \n    while queue:\n        i, j, steps = queue.pop(0)\n        \n        if (i, j) == end:\n            return steps\n        \n        neighbors = [\n            (i - 1, j),  # up\n            (i + 1, j),  # down\n            (i, j - 1),  # left\n            (i, j + 1)   # right\n        ]\n        \n        for ni, nj in neighbors:\n            if 0 <= ni < rows and 0 <= nj < cols and matrix[ni][nj] != 0 and (ni, nj) not in visited:\n                queue.append((ni, nj, steps + 1))\n                visited.add((ni, nj))\n    \n    return -1\n\ndef g():\n    matrix = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1],\n        [1, 0, 1, 1]\n    ]\n    start = (0, 0)\n    end = (3, 3)\n    return matrix, start, end\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list, determine if there exists a path from a given start node to a given end node using depth-first search (DFS).\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g():\n    graph = {\n        1: [2, 3],\n        2: [4],\n        3: [4, 5],\n        4: [],\n        5: [6],\n        6: []\n    }\n    start = 1\n    end = 6\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 46,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes start and end, return True if there is a path from\n    start to end in the graph, otherwise return False.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g(start: str, end: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Generate a graph as a dictionary with nodes and their adjacent nodes.\n    \"\"\"\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    return graph\n\nstart = \"A\"\nend = \"F\"\nassert f(g(start, end), start, end)\n",
        "idx_generation": 30,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', find if there exists a combination of 'k' numbers that add up to 'target'.\n\n    Return True if such a combination exists, False otherwise.\n\n    You can use each element in 'nums' an unlimited number of times.\n    \"\"\"\n    def backtrack(curr_sum, count, start):\n        if curr_sum == target and count == k:\n            return True\n        if curr_sum > target or count > k:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(curr_sum + nums[i], count + 1, i):\n                return True\n        return False\n\n    return backtrack(0, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], k=3, target=5):\n    \"\"\"\n    Generate a list of 'k' numbers from 'nums' that add up to 'target'.\n\n    You can use each element in 'nums' an unlimited number of times.\n    \"\"\"\n    return nums\n\nassert f(g(), 3, 5) == True\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, word_list: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to form the string s using the words from the list.\n    Each word can be used multiple times.\n\n    Example:\n    s = \"leetcode\"\n    word_list = [\"leet\", \"code\"]\n\n    It is possible to form the string \"leetcode\" using the words \"leet\" and \"code\".\n\n    Returns True if it is possible to form the string, False otherwise.\n    \"\"\"\n\n    def can_form_string(s: str, word_list: List[str]) -> bool:\n        \"\"\"\n        Checks if it is possible to form the string s using the words from the list.\n        \"\"\"\n        if not s:\n            # Base case: an empty string can always be formed\n            return True\n\n        for word in word_list:\n            if s.startswith(word):\n                # Recursively check if the remaining string can be formed using the remaining words\n                if can_form_string(s[len(word):], word_list):\n                    return True\n\n        return False\n\n    return can_form_string(s, word_list)\n\n\ndef g():\n    s = \"leetcode\"\n    word_list = [\"leet\", \"code\"]\n    return s, word_list\n\nassert f(*g()) == True\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of combinations of n items taken k at a time.\n\n    Example:\n    Input:\n    n = 5\n    k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 10 different combinations of 5 items taken 3 at a time.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g():\n    n = 5\n    k = 3\n    return [n, k]\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the elements of nums in non-decreasing order,\n    with all duplicates removed and all odd numbers removed.\n\n    Example:\n    Input: nums = [3, 1, 2, 2, 1, 4, 5, 4]\n    Output: [2, 4]\n\n    Explanation:\n    The input list contains duplicates and odd numbers. The output list is a sorted version of the input list\n    with duplicates and odd numbers removed.\n\n    Note:\n    - The input list may contain negative numbers.\n    - The output list should not contain any duplicates.\n    - The output list should only contain even numbers.\n    - The output list should be in non-decreasing order.\n    \"\"\"\n\n    nums = sorted(set(nums))\n    nums = [num for num in nums if num % 2 == 0]\n    return nums\n\ndef g():\n    return [3, 1, 2, 2, 1, 4, 5, 4]\n\nassert f(g()) == [2, 4]\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find the two numbers in the list that add up to the target value.\n    Return their indices in ascending order.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14\n    Output: [1, 4]\n\n    Explanation: The numbers at indices 1 and 4 ([4, 10]) add up to 14.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g()) == [1, 4]\n",
        "idx_generation": 258,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next smaller element for each element in the list.\n\n    Example:\n    Input: nums = [4, 8, 3, 2, 9, 1, 6, 5]\n    Output: [3, 3, 2, 1, 1, -1, 5, -1]\n\n    Explanation:\n    For each element in the list, the next smaller element is the smallest element that comes after it and is smaller than it. If there is no such element, the result is -1.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] > nums[i]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    return [4, 8, 3, 2, 9, 1, 6, 5]\n\nassert f(g()) == [3, 3, 2, 1, 1, -1, 5, -1]\n",
        "idx_generation": 176,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n\n    Output:\n    3\n    Explanation:\n    Inversions: (2, 1), (4, 1), (4, 3)\n    \"\"\"\n    count = 0\n    \n    def merge_sort(nums):\n        nonlocal count\n        if len(nums) <= 1:\n            return nums\n        \n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        \n        i = j = 0\n        merged = []\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                count += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged\n    \n    merge_sort(nums)\n    \n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 1, 3, 5]\n\nassert f(g()) == 3\n",
        "idx_generation": 438,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to find the index of the target value in the list.\n    If the target value is not found, return -1.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2 (index of 5 in the list)\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return -1\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 296,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be achieved by XORing 25 and 5: 25 ^ 5 = 28.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, num):\n            node = self.root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if bit not in node.children:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n            node.is_end = True\n\n        def find_max_xor(self, num):\n            node = self.root\n            xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if 1 - bit in node.children:\n                    xor |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor\n\n    trie = Trie()\n    for num in nums:\n        trie.insert(num)\n\n    max_xor = 0\n    for num in nums:\n        max_xor = max(max_xor, trie.find_max_xor(num))\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers where each cell contains a positive integer, determine if there exists a pair of cells in the grid whose bitwise XOR is equal to the target number.\n\n    Example:\n    Input: grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], target = 14\n    Output: True\n\n    Explanation:\n    6 ^ 8 = 14, which is equal to the target number.\n    Therefore, there exists a pair of cells whose bitwise XOR is equal to the target number.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    nums = sorted(grid[i][j] for i in range(rows) for j in range(cols))\n    left, right = 0, rows * cols - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a 2D grid of integers and a target number, where there exists a pair of cells whose bitwise XOR is equal to the target number.\n    \"\"\"\n    return ([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 14)\n\nassert f(*g()) == True\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any three numbers in the list.\n    \n    Sample Input:\n    nums = [1, 2, 3, 4]\n    \n    Sample Output:\n    24\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [[1,3,1],\n            [1,5,1],\n            [4,2,1]]\n    Output: 7\n    Explanation: The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n\n    grid = [[1,2,3],\n            [4,5,6]]\n    Output: 12\n    Explanation: The minimum path sum is 1 + 2 + 3 + 6 = 12.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 203,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, return a list of the degrees of each node in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    The degrees of the nodes in the graph are [2, 2, 2, 2].\n\n    Therefore, the function should return [2, 2, 2, 2].\n    \"\"\"\n    degrees = []\n\n    for node in range(len(graph)):\n        degree = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                degree += 1\n        degrees.append(degree)\n\n    return degrees\n\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == [2, 2, 2, 2]\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of combinations of three elements in the list that add up to zero.\n    Return the count of such combinations.\n\n    Sample Input:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Sample Output:\n    2\n\n    Explanation:\n    The two combinations that add up to zero are [-1, 0, 1] and [-1, -1, 2].\n    \"\"\"\n\n    count = 0\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                count += 1\n\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return count\n\ndef g():\n    nums = [-1, 0, 1, 2, -1, -4]\n    return (nums,)\n\nassert f(*g()) == 2\n",
        "idx_generation": 169,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list can be split into two non-empty subarrays such that the sum of the\n    elements in both subarrays is equal, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    total_sum = sum(nums)\n\n    # Check if total sum is even\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target_sum]\n\ndef g():\n    \"\"\"\n    Generate a list of integers that can be split into two non-empty subarrays with equal sum.\n    \"\"\"\n    return [1, 5, 11, 5]\n\nnums = g()\nassert f(g()) == True\n",
        "idx_generation": 21,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of consecutive subarrays whose sum is equal to the target.\n    Return the count of such subarrays.\n\n    Sample input:\n    nums = [1, 1, 1], target = 2\n\n    Sample output:\n    2\n\n    Explanation:\n    There are 2 subarrays with sum equal to 2: [1, 1] and [1, 1].\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_counts = {0: 1}  # Store the count of prefix sums\n\n    for num in nums:\n        prefix_sum += num\n        complement = prefix_sum - target\n        if complement in sum_counts:\n            count += sum_counts[complement]\n        sum_counts[prefix_sum] = sum_counts.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g():\n    nums = [1, 1, 1]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 326,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k=3) -> bool:\n    \"\"\"Check if it is possible to rearrange the characters in the string to form a palindrome with at most k characters swapped\"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def helper(s, k):\n        if len(s) < 2:\n            return True\n        if s[0] == s[-1]:\n            return helper(s[1:-1], k)\n        elif k > 0:\n            return helper(s[1:-1], k - 1)\n        else:\n            return False\n        \n    return helper(s, k)\n\ndef g(k=3):\n    return \"abca\"\n\nassert f(g()) == True\n",
        "idx_generation": 2,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subarray.\n    An increasing subarray is a contiguous subarray where the elements are in strictly\n    increasing order.\n\n    Example:\n    nums = [1, 2, 3, 2, 4, 5, 6, 7]\n    output: 5\n\n    Explanation: The longest increasing subarray is [2, 4, 5, 6, 7] with a length of 5.\n    \"\"\"\n\n    max_length = 0\n    length = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            length += 1\n        else:\n            max_length = max(max_length, length)\n            length = 1\n\n    max_length = max(max_length, length)\n\n    return max_length\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 2, 4, 5, 6, 7]\n\nassert f(g()) == 5\n",
        "idx_generation": 127,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the sum of all the prime numbers in the list.\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in numbers:\n        if is_prime(num):\n            prime_sum += num\n    \n    return prime_sum\n\ndef g():\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return numbers\n\nassert f(g()) == 17\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if n is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 219,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    output = [1] * n\n    \n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output[i] = left_product[i] * right_product[i]\n    \n    return output\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the smallest subarray that has a sum greater than or equal to the target value.\n    Return the length of the subarray.\n\n    Example:\n    Input: nums = [1, 4, 3, 2, 6, 5], target = 10\n    Output: 2\n\n    Explanation:\n    The subarray [4, 3] has a sum of 7, which is the smallest subarray that has a sum greater than or equal to 10.\n    \"\"\"\n\n    left = 0\n    right = 0\n    min_len = float('inf')\n    curr_sum = 0\n\n    while right < len(nums):\n        curr_sum += nums[right]\n        right += 1\n\n        while curr_sum >= target:\n            min_len = min(min_len, right - left)\n            curr_sum -= nums[left]\n            left += 1\n\n    return min_len if min_len != float('inf') else 0\n\ndef g() -> List[int]:\n    return [1, 4, 3, 2, 6, 5], 10\n\nassert f(*g()) == 2\n",
        "idx_generation": 330,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g(arr = [1, -2, 3, 4, -5, 6, 7]):\n    return arr\n\nassert f(g()) == 15\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n\n    Return a list with the indices of the two numbers.\n\n    It is guaranteed that there are exactly two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        complement_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in complement_map:\n                return [complement_map[complement], i]\n            complement_map[num] = i\n        \n    return two_sum(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Reverse the words in the given string using a stack.\n    \"\"\"\n    words = s.split()\n    stack = []\n    for word in words:\n        stack.append(word)\n    reversed_words = []\n    while stack:\n        reversed_words.append(stack.pop())\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return (s,)\n\nassert f(*g()) == \"World Hello\"\n",
        "idx_generation": 67,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (LIS).\n    \"\"\"\n    if not arr:\n        return 0\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 2, 1, 20]\n\nassert f(g()) == 3\n",
        "idx_generation": 431,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Given three integers n, m, and k, determine if it is possible to arrange n points on a grid of size m x m such that no two points are k or less units apart.\n    \"\"\"\n    if k <= 0:\n        return n <= 1\n    if k == 1:\n        return n <= 4\n    if n <= (k+1)**2 and m >= k+1:\n        return True\n    return False\n\ndef g(n = 5, m = 4, k = 2):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]], target_sum=10) -> bool:\n    \"\"\"Determine if there exists a path in the grid that sums up to the target sum\"\"\"\n    def dfs(i, j, curr_sum):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return False\n        curr_sum += grid[i][j]\n        if curr_sum == target_sum:\n            return True\n        return dfs(i+1, j, curr_sum) or dfs(i, j+1, curr_sum)\n    \n    return dfs(0, 0, 0)\n    \n    \ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], target_sum=10):\n    return grid\n\n\nassert f(g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string s, shift each character in the string by n positions in the alphabet.\n    Wrap around from 'z' to 'a' and from 'Z' to 'A' if necessary.\n\n    Example:\n    Input: s = \"abcXYZ\", n = 2\n    Output: \"cdeZAB\"\n\n    Explanation: Shifting each character in the string \"abcXYZ\" by 2 positions gives \"cdeZAB\".\n    \"\"\"\n\n    shifted_string = \"\"\n\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                shift = (ord(char) - ord('a') + n) % 26\n                shifted_char = chr(ord('a') + shift)\n            else:\n                shift = (ord(char) - ord('A') + n) % 26\n                shifted_char = chr(ord('A') + shift)\n        else:\n            shifted_char = char\n\n        shifted_string += shifted_char\n\n    return shifted_string\n\ndef g():\n    s = \"abcXYZ\"\n    n = 2\n    return s, n\n\nassert f(*g()) == \"cdeZAB\"\n\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Word Transformation\n\n    Given a list of words and a target word, determine if it is possible to transform the target word\n    into any word from the list by performing a series of transformations. Each transformation involves changing\n    exactly one character in the word.\n\n    Example:\n    words = ['cat', 'bat', 'hat', 'mat', 'pat']\n    target = 'car'\n    output: True\n    \"\"\"\n    def transform(word1, word2):\n        count = 0\n        for c1, c2 in zip(word1, word2):\n            if c1 != c2:\n                count += 1\n        return count == 1\n\n    def dfs(word, visited, target):\n        if word == target:\n            return True\n        visited.add(word)\n        for w in words:\n            if w not in visited and transform(word, w):\n                if dfs(w, visited, target):\n                    return True\n        visited.remove(word)\n        return False\n    \n    return dfs(target, set(), target)\n    \ndef g(words=['cat', 'bat', 'hat', 'mat', 'pat'], target='car'):\n    return words, target\n\nassert f(*g())\n",
        "idx_generation": 35,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, return a string representation of its binary form.\n    \"\"\"\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n //= 2\n    return binary\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == '1010'\n",
        "idx_generation": 85,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target integer, determine if it is possible to obtain the target value by performing bitwise XOR operation on a subset of the matrix elements. The XOR operation is performed on the elements in the same row or same column.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def helper(row: int, col: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if row == rows or col == cols:\n            return False\n\n        # Exclude the current element\n        exclude = helper(row + 1, col, curr) or helper(row, col + 1, curr)\n\n        # Include the current element\n        include = helper(row + 1, col, curr ^ matrix[row][col]) or helper(row, col + 1, curr ^ matrix[row][col])\n\n        return exclude or include\n\n    return helper(0, 0, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers for Puzzle 3.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g(), 14) == True\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if it is possible to obtain the target sum by selecting a subset of the integers.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 4, 8] sums up to 14, so it is possible to obtain the target sum.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n\n    for i in range(n+1):\n        dp[i][0] = True\n\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n\n    return dp[n][target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 14\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, rotate the string to the right by k positions.\n\n    Sample Input:\n    s = \"abcdef\"\n    k = 3\n\n    Sample Output:\n    \"defabc\"\n    \"\"\"\n\n    n = len(s)\n    k = k % n\n\n    rotated_string = s[-k:] + s[:-k]\n\n    return rotated_string\n\ndef g():\n    return \"abcdef\", 3\n\nassert f(*g()) == \"defabc\"\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and two nodes start and end,\n    determine if there is a path from start to end in the graph.\n\n    Example:\n    graph = [[1, 2], [0, 3], [0, 4], [1], [2]]\n    start = 0\n    end = 3\n\n    The graph can be visualized as follows:\n    0 -- 1 -- 3\n    |    |\n    2    4\n\n    The function should return True, as there is a path from node 0 to node 3.\n\n    Hint: Use depth-first search (DFS) algorithm to traverse the graph and check for connectivity.\n    \"\"\"\n\n    def dfs(node, visited):\n        visited[node] = True\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)\n\ndef g():\n    graph = [[1, 2], [0, 3], [0, 4], [1], [2]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 229,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes and a list of edges, determine if it is possible to visit all nodes starting from node 0 and return to node 0.\n    The edges list contains pairs of nodes that are connected by an edge.\n    Example: n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    In this case, it is possible to visit all nodes starting from node 0 and return to node 0, so the function should return True.\n    \"\"\"\n    visited = [False] * n\n    visited[0] = True\n    stack = [0]\n    \n    while stack:\n        node = stack.pop()\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                stack.append(neighbor)\n    \n    return all(visited)\n\ndef g(n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]):\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 115,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two nodes start and end, determine if there exists a path from start to end.\n    Use depth-first search (DFS) to explore the graph and check for a path.\n    \"\"\"\n    def dfs(graph: List[List[int]], start: int, end: int, visited: List[bool]) -> bool:\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in range(len(graph[start])):\n            if graph[start][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return True\n        return False\n    \n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix, and two nodes start and end.\n    \"\"\"\n    graph = [[0, 1, 0, 0, 0],\n             [0, 0, 1, 1, 0],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 1],\n             [0, 0, 0, 0, 0]]\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 51,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes 'n' and a list of directed edges represented as tuples (u, v),\n    determine if there is a path from node 0 to node n-1.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    def dfs(node):\n        if node == n - 1:\n            return True\n\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n\n        return False\n\n    return dfs(0)\n\ndef g(n=4):\n    \"\"\"\n    Generate a graph with 'n' nodes and some directed edges.\n    \"\"\"\n    edges = [(0, 1), (1, 2), (2, 3)]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find the combination of numbers from the given list that add up to the target number with the minimum number of elements.\n    \"\"\"\n    dp = [[float('inf')] * (target + 1) for _ in range(len(nums) + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, len(nums) + 1):\n        dp[i][0] = 0\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    combination = []\n    i, j = len(nums), target\n    while i > 0 and j > 0:\n        if dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        else:\n            combination.append(nums[i - 1])\n            j -= nums[i - 1]\n\n    return combination[::-1]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [4, 5]\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, generate all possible permutations of the characters in the string.\n\n    Sample Input:\n    s = \"abc\"\n\n    Sample Output:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n    Sample Input:\n    s = \"123\"\n\n    Sample Output:\n    [\"123\", \"132\", \"213\", \"231\", \"312\", \"321\"]\n\n    \"\"\"\n    def backtrack(string, path, visited):\n        if len(path) == len(string):\n            result.append(\"\".join(path))\n            return\n        \n        for i in range(len(string)):\n            if not visited[i]:\n                visited[i] = True\n                path.append(string[i])\n                backtrack(string, path, visited)\n                path.pop()\n                visited[i] = False\n    \n    result = []\n    path = []\n    visited = [False] * len(s)\n    backtrack(s, path, visited)\n    \n    return result\n\ndef g(s=\"abc\"):\n    return s\n\nassert f(g()) == [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of permutations of n items taken k at a time.\n\n    Example:\n    Input:\n    n = 5\n    k = 3\n\n    Output:\n    60\n\n    Explanation:\n    There are 60 different permutations of 5 items taken 3 at a time.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    return factorial(n) // factorial(n - k)\n\ndef g():\n    n = 5\n    k = 3\n    return [n, k]\n\nassert f(*g()) == 60\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if the target number is present in the list using binary search.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted in increasing order from left to right and from top to bottom.\n\n    Example:\n    matrix = [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    target = 5\n    output: True\n    Explanation: The target value 5 is present in the matrix.\n\n    Note: The matrix will be a square matrix of size n x n.\n\n    Hint: Use the properties of a sorted matrix to optimize the search algorithm.\n    \"\"\"\n\n    n = len(matrix)\n    row = 0\n    col = n - 1\n\n    while row < n and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g(matrix=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return matrix, target\n\nassert f(*g()) == True\n",
        "idx_generation": 268,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum number of operations required to transform the list such that the sum of all elements in the list is equal to the target value.\n    Each operation involves either adding or subtracting a value from an element in the list.\n\n    Return the minimum number of operations.\n\n    Example:\n    Input:\n    arr = [1, 2, 3, 4, 5]\n    target = 10\n\n    Output:\n    2\n    Explanation:\n    We can transform the list as follows:\n    - Subtract 1 from the first element: [0, 2, 3, 4, 5]\n    - Subtract 1 from the first element: [-1, 2, 3, 4, 5]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 6]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 7]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 8]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 9]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 10]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 11]\n    - Add 1 to the fifth element: [-1, 2, 3, 4, 12]\n    - Subtract 2 from the second element: [-1, 0, 3, 4, 12]\n    - Subtract 3 from the third element: [-1, 0, 0, 4, 12]\n\n    The sum of all elements in the transformed list is equal to the target value 10, and the minimum number of operations required is 2.\n    \"\"\"\n\n    # Create a queue to store the possible target values and the number of operations required to reach them\n    queue = [(0, 0)]\n\n    while queue:\n        current_sum, operations = queue.pop(0)\n\n        if current_sum == target:\n            return operations\n\n        for num in arr:\n            new_sum = current_sum + num\n            new_operations = operations + 1\n            queue.append((new_sum, new_operations))\n\n            new_sum = current_sum - num\n            new_operations = operations + 1\n            queue.append((new_sum, new_operations))\n\n    return -1\n\ndef g(arr=[1, 2, 3, 4, 5], target=10):\n    return [arr, target]\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that add up to the target using a recursive binary search.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list of two numbers that add up to the target sum.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 6\n    Output: [1, 5]\n\n    Explanation:\n    The numbers 1 and 5 from the list [1, 2, 3, 4, 5] add up to the target sum of 6.\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            return binary_search(arr, mid + 1, end, target)\n        else:\n            return binary_search(arr, start, mid - 1, target)\n\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        result = binary_search(arr, i + 1, len(arr) - 1, complement)\n        if result is not None:\n            return [arr[i], result]\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers 'arr' and a target integer 'target'.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == [1, 5]\n\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The function should return [[7, 4, 1],\n                              [8, 5, 2],\n                              [9, 6, 3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n\n",
        "idx_generation": 394,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find two numbers in the list that sum up to the target.\n    Return a list containing these two numbers.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 12\n    Output: [2, 10]\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\nassert f(*g()) == [2, 10]\n\n",
        "idx_generation": 384,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value of any two elements in the array.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value can be obtained by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ possible_xor) in prefixes:\n                max_xor = possible_xor\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value of any two elements is required to solve the puzzle.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subarray of length 3 that forms an arithmetic progression.\n    \"\"\"\n    arr.sort()\n    for i in range(len(arr) - 2):\n        if arr[i + 1] - arr[i] == arr[i + 2] - arr[i + 1]:\n            return True\n    return False\n\ndef g(arr = [1, 2, 3, 5, 7, 9, 11]):\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 131,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right\n    corner. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    7\n\n    Explanation:\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 7\n",
        "idx_generation": 204,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the maximum sum of any contiguous subarray of size k.\n\n    Example:\n    Input: nums = [2, 1, 5, 1, 3, 2], k = 3\n    Output: 9\n\n    Explanation: The maximum sum of a subarray of size 3 is obtained by adding the numbers at indices 2, 3, and 4, which gives 9.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n    left = 0\n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        if right - left + 1 == k:\n            max_sum = max(max_sum, curr_sum)\n            curr_sum -= nums[left]\n            left += 1\n\n    return max_sum\n\ndef g():\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 9\n\n",
        "idx_generation": 374,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is a permutation of the numbers from 1 to n,\n    where n is the length of the list.\n\n    Example:\n    arr = [3, 1, 2]\n    Output: True\n\n    arr = [3, 1, 4]\n    Output: False\n    \"\"\"\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n\n    for i in range(n):\n        if sorted_arr[i] != i + 1:\n            return False\n\n    return True\n\ndef g():\n    return [1, 3, 2]\n\nassert f(g()) == True\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, count: int) -> bool:\n    \"\"\"Find count numbers from the given list that sum up to target\"\"\"\n    def helper(nums, target, count):\n        if target == 0 and count == 0:\n            return True\n        if target < 0 or count <= 0:\n            return False\n        for i in range(len(nums)):\n            if helper(nums[:i] + nums[i+1:], target - nums[i], count - 1):\n                return True\n        return False\n\n    return helper(nums, target, count)\n\ndef g(nums = [2, 4, 6, 8, 10], target = 18, count = 3):\n    return [num for num in nums if num <= target]\n\nassert f(g(), target=18, count=3)\n",
        "idx_generation": 40,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a list containing the product of all the numbers except the current number at each index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The function should return [24, 12, 8, 6], since:\n    - The product of all the numbers except 1 is 24\n    - The product of all the numbers except 2 is 12\n    - The product of all the numbers except 3 is 8\n    - The product of all the numbers except 4 is 6\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n",
        "idx_generation": 371,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Determine if a string can be constructed by repeating a substring exactly n times.\"\"\"\n    if len(s) % n != 0:\n        return False\n    substring = s[:len(s) // n]\n    return s == substring * n\n\ndef g(n: int) -> str:\n    \"\"\"Generate a string by repeating a substring exactly n times.\"\"\"\n    substring = \"abc\"\n    return substring * n\n\nassert f(g(3), 3)\n",
        "idx_generation": 86,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(target=9):\n    nums = [2, 7, 11, 15]\n    return nums\n\nassert f(g(), target=9) == [0, 1]\n",
        "idx_generation": 138,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a subarray of length k whose sum is equal to the target value.\n    You may assume that each input would have exactly one solution.\n\n    Sample input:\n    arr = [1, 2, 3, 4, 5, 6, 7], target = 9, k = 3\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, k - 1\n    subarray_sum = sum(arr[left:right+1])\n\n    while right < len(arr):\n        if subarray_sum == target:\n            return True\n        subarray_sum -= arr[left]\n        left += 1\n        right += 1\n        if right < len(arr):\n            subarray_sum += arr[right]\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g(), 9, 3)\n",
        "idx_generation": 159,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if it can be split into two subsets with equal sum.\n    \"\"\"\n    total_sum = sum(nums)\n\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    n = len(nums)\n\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target_sum]\n\n\ndef g(nums=[1, 5, 11, 5]):\n    \"\"\"\n    Generate a list of integers that can be split into two subsets with equal sum.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 234,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n    Return the maximum sum.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 384,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers at indices 0 and 1, i.e., 2 and 7, add up to the target value 9.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 149,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Given three positive integers n, m, and k, determine if it is possible to construct a rectangle with dimensions n x m\n    using exactly k squares. Return True if possible, False otherwise.\n    \"\"\"\n    if k > n * m:\n        return False\n    if k % n == 0 or k % m == 0:\n        return True\n    return False\n\ndef g(n=4, m=5, k=12):\n    \"\"\"\n    Construct a rectangle with dimensions n x m using exactly k squares.\n    \"\"\"\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 422,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=100) -> bool:\n    \"\"\"\n    Find a combination of numbers from the given list that adds up to the target sum\n    \"\"\"\n    stack = []\n    stack.append((0, 0))\n    while stack:\n        total, index = stack.pop()\n        if total == target:\n            return True\n        if index >= len(nums):\n            continue\n        stack.append((total + nums[index], index + 1))\n        stack.append((total, index + 1))\n    return False\n\ndef g(nums=[15, 25, 10, 30, 5, 40]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 69,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray.\n    \"\"\"\n    if not arr:\n        return 0\n\n    current_sum = max_sum = arr[0]\n\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, find the sum of the numbers in the grid by traversing the grid in a zigzag pattern.\n\n    The zigzag pattern starts at the top-left corner and follows the path: right, down, left, down, right, down, left, down, and so on.\n\n    Return the sum of the numbers in the zigzag pattern.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    i, j = 0, 0\n    direction = 1\n    total_sum = 0\n\n    while i < m and j < n:\n        total_sum += grid[i][j]\n\n        if direction == 1:\n            if j == n - 1:\n                i += 1\n                direction = -1\n            else:\n                j += 1\n        else:\n            if j == 0:\n                i += 1\n                direction = 1\n            else:\n                j -= 1\n\n    return total_sum\n\ndef g(grid: List[List[int]]) -> int:\n    \"\"\"\n    Generate a 2D grid of integers to find the sum of the numbers in the grid using a zigzag pattern.\n    \"\"\"\n    return grid\n\ngrid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(grid)) == 45\n\n",
        "idx_generation": 173,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left corner\n    to the bottom-right corner. You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 7\n",
        "idx_generation": 92,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string.\n    \"\"\"\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n\n    return count\n\ndef g(s='Hello, World!'):\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"\n    Given a string s and an integer n, check if there exists a substring of s that is a palindrome and has length greater than or equal to n.\n\n    Sample Input:\n    n = 3\n    s = \"racecar\"\n\n    Sample Output:\n    True\n\n    Explanation:\n    The substring \"racecar\" is a palindrome and has a length of 7, which is greater than or equal to n (3).\n    \"\"\"\n    for i in range(len(s)):\n        for j in range(i + n, len(s) + 1):\n            if s[i:j] == s[i:j][::-1]:\n                return True\n    return False\n\ndef g():\n    return 3, \"racecar\"\n\nassert f(*g())\n",
        "idx_generation": 76,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 13\n\n    Output:\n    3\n\n    Explanation:\n    The binary representation of 13 is 1101, which has 3 bits set to 1.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g():\n    n = 13\n    return n\n\nassert f(g()) == 3\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find a subset of nums such that the XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    subset = []\n    for num in nums:\n        if num ^ target in nums:\n            subset.append(num)\n    return subset\n\nnums = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(g(nums, target), target) == True\n",
        "idx_generation": 397,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, find the number of paths from the top-left corner to the bottom-right corner,\n    moving only right or down. The sum of the integers along each path must be greater than or equal to a target value.\n    Return True if there exists at least one path satisfying the condition, False otherwise.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    target = sum(sum(row) for row in grid) // 2\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1] >= target\n\n\ndef g():\n    grid = [\n        [1, 3, 2],\n        [4, 2, 1],\n        [2, 1, 3],\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the sum of the ASCII values of all the characters in the string.\n\n    Example:\n    Input: s = \"hello\"\n    Output: 532\n\n    Explanation: The ASCII values of the characters 'h', 'e', 'l', 'l', and 'o' are 104, 101, 108, 108, and 111, respectively.\n    The sum of these ASCII values is 532.\n    \"\"\"\n\n    total_sum = 0\n\n    for char in s:\n        total_sum += ord(char)\n\n    return total_sum\n\ndef g():\n    s = \"hello\"\n    return s\n\nassert f(g()) == 532\n\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix graph representation, return the number of nodes in the graph.\n\n    Sample Input:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 0],\n        [0, 1, 0, 0]\n    ]\n\n    Sample Output:\n    4\n    \"\"\"\n    return len(graph)\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 0],\n        [0, 1, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == 4\n",
        "idx_generation": 237,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges, check if there is a path from node 0 to node N-1 in a directed graph.\n    \"\"\"\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n    \n    stack = [0]\n    visited = set()\n    while stack:\n        node = stack.pop()\n        if node == len(edges) - 1:\n            return True\n        if node in visited:\n            continue\n        visited.add(node)\n        if node in graph:\n            stack.extend(graph[node])\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a list of directed edges.\n    \"\"\"\n    return [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]]\n\nassert f(g()) == True\n",
        "idx_generation": 118,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there exists a cycle in the graph.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(graph, node, visited, stack):\n                return True\n\n    return False\n\ndef dfs(graph: List[List[int]], node: int, visited: List[bool], stack: List[bool]) -> bool:\n    visited[node] = True\n    stack[node] = True\n\n    for neighbor in range(len(graph[node])):\n        if graph[node][neighbor] == 1:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n    stack[node] = False\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph with a cycle.\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 55,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if there exists a path that visits all the nodes exactly once.\n\n    Example:\n    graph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n    There exists a path that visits all the nodes exactly once: 0 -> 1 -> 2 -> 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def dfs(graph, node, visited):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited)\n\n    n = len(graph)\n    visited = [False] * n\n\n    dfs(graph, 0, visited)\n\n    return all(visited)\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 84,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a Pascal's Triangle with n rows. Each row is represented as a list of integers.\n    \"\"\"\n    triangle = []\n\n    for i in range(n):\n        row = [1] * (i + 1)\n\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n\n        triangle.append(row)\n\n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    Return the length.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has length 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    \n    for i, char in enumerate(s):\n        if char in seen and start <= seen[char]:\n            start = seen[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        seen[char] = i\n        \n    return max_length\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of possible combinations of k elements from a set of n elements.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n\n    Explanation:\n    There are 5 elements in the set: {1, 2, 3, 4, 5}.\n    We need to select 3 elements from the set.\n    The possible combinations are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    Hence, the output is 10.\n\n    Note: The order of the elements in a combination does not matter.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        \"\"\"\n        Helper function to calculate the factorial of a number.\n        \"\"\"\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    # Calculate the number of combinations using the formula C(n, k) = n! / (k! * (n-k)!)\n    num_combinations = factorial(n) // (factorial(k) * factorial(n - k))\n\n    return num_combinations\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 372,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers is 60 (4 * 5 * 3).\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid-1)\n        else:\n            return binary_search(nums, target, mid+1, right)\n    \n    return binary_search(nums, target, 0, len(nums)-1)\n\ndef g(nums=[1, 2, 3, 4, 5], target=3):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there exists a pair of integers in the list whose sum is equal to the target value.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums=[-2, 0, 3, 5, 9, 12], target=9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of distinct integers 'arr' and a target integer 'target', find the index of the target using binary search.\n\n    Args:\n    - arr: A sorted list of distinct integers.\n    - target: The target integer.\n\n    Returns:\n    - The index of the target integer in the list, or -1 if it is not found.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target integer 5 is found at index 2 in the list [1, 3, 5, 7, 9].\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, mid + 1, end, target)\n        else:\n            return binary_search(arr, start, mid - 1, target)\n\n    return binary_search(arr, 0, len(arr) - 1, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers 'arr' and a target integer 'target'.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers representing the heights of bars in a histogram, calculate the area of the largest rectangle that can be formed within the histogram.\n\n    Example:\n    Input: heights = [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The largest rectangle can be formed by bars with heights [5, 6, 2, 3] and has an area of 10.\n\n    Constraints:\n    - 1 <= len(heights) <= 10^4\n    - 0 <= heights[i] <= 10^6\n    \"\"\"\n\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a positive integer k, rotate the list to the right by k steps.\n    \"\"\"\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 2\n    return [nums, k]\n\nassert f(*g()) == [4, 5, 1, 2, 3]\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 25 and 5, which gives 28.\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value between any two numbers is 28.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any three numbers in the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 5, 3, 2, 4]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    1 + 3 + 1 + 1 + 1 = 7\n\n    Explanation:\n    The minimum path sum is 1 -> 3 -> 1 -> 1 -> 1, which gives a sum of 7.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[rows-1][cols-1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 7\n\n",
        "idx_generation": 234,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation: The elements of the matrix are [1, 2, 3, 4, 5, 6, 7, 8, 9] in spiral order.\n\n    Constraints:\n    - m == matrix.length\n    - n == matrix[i].length\n    - 1 <= m, n <= 10\n    - -100 <= matrix[i][j] <= 100\n    \"\"\"\n\n    spiral_order = []\n\n    if not matrix:\n        return spiral_order\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Sample Output:\n    [0, 1]\n    Explanation: The numbers at indices 0 and 1, [2, 7], add up to the target value 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=10, k=3) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', find if there exists a combination of 'k' numbers that sum up to 'target'.\n\n    Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start, curr_sum, count):\n        if curr_sum == target and count == k:\n            return True\n        if curr_sum > target or count > k:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i], count + 1):\n                return True\n        return False\n    \n    return backtrack(0, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target=10, k=3):\n    \"\"\"\n    Generate a list of 'k' numbers from 'nums' that sum up to 'target'.\n    \"\"\"\n    from itertools import combinations\n    \n    for combo in combinations(nums, k):\n        if sum(combo) == target:\n            return list(combo)\n    return []\n\nassert f(g()) == True\n",
        "idx_generation": 49,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, n=3) -> bool:\n    \"\"\"\n    Determine if a given string can be divided into n equal parts, where each part is a palindrome.\n    \"\"\"\n    length = len(string)\n    if length % n != 0:\n        return False\n    \n    part_length = length // n\n    \n    for i in range(n):\n        start = i * part_length\n        end = start + part_length\n        part = string[start:end]\n        \n        if part != part[::-1]:\n            return False\n    \n    return True\n\ndef g(string='abcdeedcbaabcdeedcbaabcdeedcba'):\n    \"\"\"\n    Divide a given string into n equal parts, where each part is a palindrome.\n    \"\"\"\n    n = 3\n    length = len(string)\n    \n    if length % n != 0:\n        return \"\"\n    \n    part_length = length // n\n    \n    parts = []\n    for i in range(n):\n        start = i * part_length\n        end = start + part_length\n        part = string[start:end]\n        parts.append(part)\n    \n    return parts\n\nassert f(g()) == True\n",
        "idx_generation": 93,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and an integer k, return True if there are two distinct indices i and j in the list\n    such that nums[i] = nums[j] and abs(i - j) <= k, otherwise return False.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        if num in seen and abs(i - seen[num]) <= k:\n            return True\n        seen[num] = i\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers and an integer k.\n    \"\"\"\n    nums = [1, 2, 3, 1]\n    k = 3\n    return nums, k\n\nassert f(*g()) == True\n\n",
        "idx_generation": 158,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence such that the sum of the subsequence is equal to zero.\n    Return True if such subsequence exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    prefix_sum = [0] * (n+1)\n    prefix_sum[0] = 0\n    \n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + nums[i-1]\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            if prefix_sum[j] - prefix_sum[i] == 0:\n                return True\n    \n    return False\n\ndef g() -> List[int]:\n    nums = [1, -2, 3, 0, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 164,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given an array of integers arr and a target integer k, determine if there exists a subset of arr that adds up to k.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][k]\n\ndef g(arr: List[int], k: int):\n    \"\"\"\n    Find a subset of arr that adds up to k.\n    \"\"\"\n    n = len(arr)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    subset = []\n    i = n\n    j = k\n    while i > 0 and j > 0:\n        if dp[i - 1][j]:\n            i -= 1\n        else:\n            subset.append(arr[i - 1])\n            j -= arr[i - 1]\n            i -= 1\n\n    return subset[::-1]\n\nassert f(g([1, 2, 3, 4, 5], 9), 9)\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list is\n    the product of all the numbers in the original list except the one at i.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: [120, 60, 40, 30, 24]\n\n    nums = [3, 2, 1]\n    Output: [2, 3, 6]\n    \"\"\"\n\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find a contiguous subarray that sums up to the target.\n    Return the starting and ending indices of the subarray, or an empty list if no such subarray exists.\n\n    Sample Input:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n\n    Sample Output:\n    [2, 4]\n\n    Explanation: The subarray [20, 3, 10] sums up to the target 33, and its starting and ending indices are 2 and 4 respectively.\n    \"\"\"\n\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if prefix_sum[j] - prefix_sum[i] == target:\n                return [i, j - 1]\n\n    return []\n\ndef g() -> List[int]:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n    return arr, target\n\nassert f(*g()) == [2, 4]\n",
        "idx_generation": 350,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target sum k, find the length of the shortest subarray with sum at least k.\n    Return the length of the shortest subarray.\n    \"\"\"\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n    shortest_length = float('inf')\n    left = 0\n    for right in range(1, n + 1):\n        while prefix_sum[right] - prefix_sum[left] >= k:\n            shortest_length = min(shortest_length, right - left)\n            left += 1\n    return shortest_length\n\ndef g():\n    arr = [2, 3, 1, 2, 4, 3]\n    k = 7\n    return (arr, k)\n\nassert f(*g()) == 2\n",
        "idx_generation": 165,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    4\n    Explanation: The prime numbers less than or equal to 10 are 2, 3, 5, and 7.\n\n    Sample Input:\n    n = 20\n\n    Sample Output:\n    8\n    Explanation: The prime numbers less than or equal to 20 are 2, 3, 5, 7, 11, 13, 17, and 19.\n    \"\"\"\n    prime_count = 0\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_count += 1\n    return prime_count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 4\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a palindrome.\n\n    Sample input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample output:\n    True\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reverse_nums = []\n    while stack:\n        reverse_nums.append(stack.pop())\n    \n    return nums == reverse_nums\n\ndef g(nums = [1, 2, 3, 2, 1]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 72,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 433,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, return True if there exists a rectangle in the grid where the sum of its elements is divisible\n    by 10, otherwise return False.\n    \"\"\"\n    def sum_rectangle(top_row: int, left_col: int, bottom_row: int, right_col: int) -> int:\n        \"\"\"\n        Helper function to calculate the sum of elements in a rectangle of the grid.\n        \"\"\"\n        total = 0\n        for i in range(top_row, bottom_row+1):\n            for j in range(left_col, right_col+1):\n                total += grid[i][j]\n        return total\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for top_row in range(rows):\n        for left_col in range(cols):\n            for bottom_row in range(top_row, rows):\n                for right_col in range(left_col, cols):\n                    rectangle_sum = sum_rectangle(top_row, left_col, bottom_row, right_col)\n                    if rectangle_sum % 10 == 0:\n                        return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(g()) == False\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of unique paths from the top-left\n    corner to the bottom-right corner of an n x n grid. You can only move down or right.\n\n    Example:\n    Input: 3\n    Output: 6\n\n    Explanation: From the top-left corner, there are a total of 6 ways to reach the bottom-right corner:\n    1. Right -> Right -> Down\n    2. Right -> Down -> Right\n    3. Down -> Right -> Right\n    4. Down -> Down -> Right\n    5. Down -> Right -> Down\n    6. Right -> Down -> Down\n    \"\"\"\n\n    # Using dynamic programming to solve the problem\n    dp = [[1] * n for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[n - 1][n - 1]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 93,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation:\n    The string \"Hello World\" is reversed word by word, resulting in \"olleH dlroW\".\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n",
        "idx_generation": 440,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(word: str, dictionary: List[str]) -> bool:\n    \"\"\"\n    Word Break\n\n    Given a string and a dictionary of words, determine if the string can be segmented into a space-separated\n    sequence of one or more dictionary words.\n\n    Example:\n    word = \"applepie\"\n    dictionary = [\"apple\", \"pie\"]\n    output: True\n    \"\"\"\n    def word_break(word, dictionary, memo):\n        if word in dictionary:\n            return True\n        if word in memo:\n            return memo[word]\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            if prefix in dictionary and word_break(word[i:], dictionary, memo):\n                memo[word] = True\n                return True\n        memo[word] = False\n        return False\n\n    return word_break(word, dictionary, {})\n\ndef g(word = \"applepie\", dictionary = [\"apple\", \"pie\"]):\n    return (word, dictionary)\n\nassert f(*g())\n",
        "idx_generation": 77,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Find the maximum XOR value of two elements in the given list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    \n    return max_xor\n\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 7\n\n",
        "idx_generation": 96,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, determine the length of the longest increasing subarray\n    where the bitwise OR of all elements in the subarray is zero.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        if arr[i] | arr[i - 1] == 0:\n            dp[i] = dp[i - 1] + 1\n    return max(dp)\n\ndef g():\n    arr = [1, 2, 4, 8, 16, 32, 64]\n    return arr\n\nassert f(g())\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number is a power of 4.\n    \"\"\"\n    if n == 0:\n        return False\n    if n == 1:\n        return True\n    if n % 4 == 0:\n        return f(n // 4)\n    return False\n\ndef g() -> int:\n    \"\"\"\n    Generate a number that is a power of 4.\n    \"\"\"\n    return 64\n\nassert f(g()) == True\n",
        "idx_generation": 56,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each character is replaced by its corresponding ASCII value.\n\n    Example:\n    string = \"hello\"\n\n    The ASCII values of the characters in the string are 104, 101, 108, 108, 111.\n    Therefore, the function should return \"104101108108111\".\n    \"\"\"\n    ascii_string = \"\"\n\n    for char in string:\n        ascii_string += str(ord(char))\n\n    return ascii_string\n\ndef g():\n    string = \"hello\"\n    return string\n\nassert f(g()) == \"104101108108111\"\n",
        "idx_generation": 467,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given the number of nodes n and a list of edges, check if it is possible to form a binary tree from the given edges.\n\n    Each edge in the list represents a connection between two nodes.\n\n    Return True if it is possible to form a binary tree, and False otherwise.\n\n    Example:\n    n = 4\n    edges = [[1, 2], [1, 3], [2, 4]]\n\n    The edges represent the following connections:\n    1 -> 2\n    1 -> 3\n    2 -> 4\n\n    It is possible to form a binary tree with these edges:\n        1\n       / \\\n      2   3\n     /\n    4\n\n    Therefore, the function should return True.\n\n    Note:\n    - The nodes are labeled from 1 to n.\n    - Each node can have at most 2 children.\n    - The list of edges will not contain any duplicate connections.\n    \"\"\"\n\n    # Create an adjacency list to represent the connections between nodes\n    adj_list = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Use depth-first search (DFS) to check if it is possible to form a binary tree\n    def dfs(node, parent):\n        if len(adj_list[node]) > 2:\n            return False\n\n        for neighbor in adj_list[node]:\n            if neighbor == parent:\n                continue\n            if not dfs(neighbor, node):\n                return False\n\n        return True\n\n    # Start the DFS from the root node (node 1)\n    return dfs(1, -1)\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes n and a list of edges.\n    \"\"\"\n    return 4, [[1, 2], [1, 3], [2, 4]]\n\nassert f(*g()) == True\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Find the shortest path from the start node to the target node in the given graph.\n\n    The graph is represented as a dictionary where the keys are the node numbers and the values\n    are lists of adjacent nodes.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        node, distance = queue.pop(0)\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                queue.append((neighbor, distance + 1))\n    \n    return False\n\ndef g(graph={0: [1, 2], 1: [3, 4], 2: [4], 3: [], 4: []}, start=0, target=4):\n    return graph, start, target\n\nassert f(*g())\n",
        "idx_generation": 130,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes 'n' and a list of directed edges represented as tuples (u, v),\n    determine if there is a cycle in the graph.\n\n    Return True if a cycle exists, False otherwise.\n    \"\"\"\n    visited = [False] * n\n    recursion_stack = [False] * n\n\n    def dfs(node):\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False\n\ndef g(n=5):\n    \"\"\"\n    Generate a graph with 'n' nodes and some directed edges.\n    \"\"\"\n    edges = [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 2)]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there exists a path from the top-left corner to the bottom-right corner\n    by only moving down or right. The path can only traverse cells with a value of 1.\n\n    Example:\n    matrix = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    There exists a path from (0, 0) to (3, 3): [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)].\n\n    Therefore, the function should return True.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        if i < m - 1 and matrix[i + 1][j] == 1:\n            if dfs(i + 1, j):\n                return True\n\n        if j < n - 1 and matrix[i][j + 1] == 1:\n            if dfs(i, j + 1):\n                return True\n\n        return False\n\n    return dfs(0, 0)\n\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return matrix\n\n\nassert f(g()) == True\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, target_sum=100) -> bool:\n    \"\"\"\n    Given a positive integer n, find a combination of n positive integers that sum up to target_sum.\n    \"\"\"\n    def find_combination(n, target_sum):\n        if n == 1:\n            return [target_sum]\n        combination = []\n        for i in range(1, target_sum - n + 2):\n            remaining_combination = find_combination(n - 1, target_sum - i)\n            if remaining_combination:\n                combination = [i] + remaining_combination\n                break\n        return combination\n\n    return sum(find_combination(n, target_sum)) == target_sum\n\ndef g(n=5, target_sum=100):\n    return n, target_sum\n\nassert f(*g())\n",
        "idx_generation": 71,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be segmented into a space-separated sequence of dictionary words.\n\n    Sample input:\n    s = \"leetcode\"\n\n    Sample output:\n    False\n\n    Explanation: The string \"leetcode\" cannot be segmented into valid dictionary words.\n    \"\"\"\n    def word_break(s, word_dict, memo):\n        if s in memo:\n            return memo[s]\n        if not s:\n            return True\n        for i in range(1, len(s) + 1):\n            if s[:i] in word_dict and word_break(s[i:], word_dict, memo):\n                memo[s] = True\n                return True\n        memo[s] = False\n        return False\n    \n    word_dict = [\"leet\", \"code\"]\n    return word_break(s, word_dict, {})\n\ndef g(s=\"leetcode\"):\n    return s\n\nassert f(g())\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the number of ways to arrange n items in a row if there are k groups of identical items.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n <= 1:\n            return 1\n        return n * factorial(n-1)\n    \n    def count_arrangements(n: int, groups: List[int]) -> int:\n        total = factorial(n)\n        for group in groups:\n            total //= factorial(group)\n        return total\n    \n    return count_arrangements(n, [2, 3])\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 10\n\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to the target are 2 and 7.\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n\n    Explanation:\n    The maximum product is obtained by multiplying 2, 3, and 4, which gives 24.\n    Therefore, the function should return 24.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum product of any three numbers is 24.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n",
        "idx_generation": 295,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and an integer k, find the kth largest element in the array.\n\n    Example:\n    Input: nums = [3, 1, 5, 2, 7, 4, 6], k = 3\n    Output: 5 (The 3rd largest element in the array is 5)\n\n    Hint: Use a min-heap to efficiently find the kth largest element.\n    \"\"\"\n\n    import heapq\n\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heapq.heappop(heap)\n\ndef g():\n    return [3, 1, 5, 2, 7, 4, 6], 3\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 199,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The maximum subarray sum is [4, -1, 2, 1] which sums to 6.\n    \"\"\"\n\n    def max_subarray_sum(nums: List[int], left: int, right: int) -> int:\n        if left == right:\n            return nums[left]\n        \n        mid = (left + right) // 2\n        \n        left_sum = max_subarray_sum(nums, left, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, right)\n        \n        cross_sum = cross_subarray_sum(nums, left, mid, right)\n        \n        return max(left_sum, right_sum, cross_sum)\n    \n    def cross_subarray_sum(nums: List[int], left: int, mid: int, right: int) -> int:\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, left - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, right + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return max_subarray_sum(nums, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [2, -3, 5, -1, 6, -4, 2, 3]\n\nassert f(g()) == 11\n",
        "idx_generation": 404,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle that can be formed by connecting adjacent buildings.\n    \n    Example:\n    heights = [2, 4, 1, 3, 5, 6, 2, 1]\n    \n    Output:\n    10\n    \"\"\"\n    n = len(heights)\n    stack = []\n    max_area = 0\n    \n    for i in range(n):\n        while stack and heights[stack[-1]] >= heights[i]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area\n\ndef g():\n    heights = [2, 4, 1, 3, 5, 6, 2, 1]\n    return heights\n\nassert f(g()) == 10\n",
        "idx_generation": 488,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    Output: 28 (maximum XOR value is between 25 and 5)\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask = mask | (1 << i)\n        prefix_set = set()\n        for num in arr:\n            prefix = num & mask\n            prefix_set.add(prefix)\n        \n        candidate = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if candidate ^ prefix in prefix_set:\n                max_xor = candidate\n                break\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 296,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list is a sorted list of prime numbers.\n\n    Args:\n    arr (List[int]): The list of numbers to check.\n\n    Returns:\n    bool: True if the list is sorted and contains only prime numbers, False otherwise.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"\n        Check if a number is prime.\n\n        Args:\n        num (int): The number to check.\n\n        Returns:\n        bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    return sorted(arr) == arr and all(is_prime(num) for num in arr)\n\ndef g():\n    return [2, 3, 5, 7, 11]\n\nassert f(g()) == True\n",
        "idx_generation": 156,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the largest island (connected component) of 1s in the grid.\n    Return the size of the largest island.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n\n    The largest island in the grid has a size of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_island_size = 0\n\n    def dfs(row, col, island_size):\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return\n\n        grid[row][col] = -1\n        island_size[0] += 1\n\n        dfs(row + 1, col, island_size)\n        dfs(row - 1, col, island_size)\n        dfs(row, col + 1, island_size)\n        dfs(row, col - 1, island_size)\n\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row][col] == 1:\n                island_size = [0]\n                dfs(row, col, island_size)\n                max_island_size = max(max_island_size, island_size[0])\n\n    return max_island_size\n\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 4\n\n",
        "idx_generation": 257,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    nums[0] + nums[1] equals 2 + 7 = 9, so the answer is [0, 1].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        if target - num in num_dict:\n            return [num_dict[target - num], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, check if it is a valid Sudoku board.\n    The grid is considered valid if each row, each column, and each of the\n    nine 3x3 sub-grids contains all the digits from 1 to 9 without repetition.\n    \"\"\"\n    def is_valid(nums: List[int]) -> bool:\n        count = [0] * 10\n        for num in nums:\n            if num != 0:\n                count[num] += 1\n                if count[num] > 1:\n                    return False\n        return True\n\n    for i in range(9):\n        if not is_valid(grid[i]):\n            return False\n\n    for j in range(9):\n        if not is_valid([grid[i][j] for i in range(9)]):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid([grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]):\n                return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers that represents a valid Sudoku board.\n    \"\"\"\n    return [\n        [5, 3, 0, 0, 7, 0, 0, 0, 0],\n        [6, 0, 0, 1, 9, 5, 0, 0, 0],\n        [0, 9, 8, 0, 0, 0, 0, 6, 0],\n        [8, 0, 0, 0, 6, 0, 0, 0, 3],\n        [4, 0, 0, 8, 0, 3, 0, 0, 1],\n        [7, 0, 0, 0, 2, 0, 0, 0, 6],\n        [0, 6, 0, 0, 0, 0, 2, 8, 0],\n        [0, 0, 0, 4, 1, 9, 0, 0, 5],\n        [0, 0, 0, 0, 8, 0, 0, 7, 9],\n    ]\n\nassert f(g()) == True\n",
        "idx_generation": 58,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct subsequences that form the string \"abc\".\n    \"\"\"\n    count = [0] * 3\n    for char in s:\n        if char == 'a':\n            count[0] += 1\n        elif char == 'b':\n            count[1] += count[0]\n        elif char == 'c':\n            count[2] += count[1]\n    return count[2]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string containing only the characters 'a', 'b', and 'c'.\n    \"\"\"\n    return 'aabbcc'\n\nassert f(g()) == 8\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target sum, find a contiguous subarray whose sum is equal to the target. Return the indices of the subarray.\n\n    Args:\n    - nums: the list of integers\n    - target: the target sum\n\n    Returns:\n    - A list of two integers representing the starting and ending indices (inclusive) of the subarray, or an empty list if no such subarray exists.\n    \"\"\"\n    def find_subarray(nums, target):\n        prefix_sum = 0\n        sum_map = {}\n        for i in range(len(nums)):\n            prefix_sum += nums[i]\n            if prefix_sum == target:\n                return [0, i]\n            if prefix_sum - target in sum_map:\n                return [sum_map[prefix_sum - target] + 1, i]\n            sum_map[prefix_sum] = i\n        \n        return []\n    \n    return find_subarray(nums, target)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    return nums, target\n\nassert f(*g()) == [0, 4]\n\n",
        "idx_generation": 181,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the prime numbers in the list.\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\ndef g():\n    return [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\nassert f(g()) == 28\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Sample input:\n    n = 5\n\n    Sample output:\n    120\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 290,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, check if there exists a pair of numbers in the list\n    such that their sum is equal to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: The pair of numbers (2, 5) has a sum of 7.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int) -> bool:\n        seen = set()\n        for num in nums:\n            complement = target - num\n            if complement in seen:\n                return True\n            seen.add(num)\n        return False\n\n    return two_sum(nums, target)\n\ndef g(nums: List[int], target: int):\n    return nums, target\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(*g(nums, target)) == True\n",
        "idx_generation": 402,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each number is multiplied by 2.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [2, 4, 6, 8, 10]\n    \"\"\"\n\n    def multiply_by_two(nums):\n        return [num * 2 for num in nums]\n\n    return multiply_by_two(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [2, 4, 6, 8, 10]\n",
        "idx_generation": 367,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, rotate the string k times to the right.\n    \"\"\"\n    k = k % len(s)  # handle cases where k is greater than the length of the string\n    rotated = s[-k:] + s[:-k]\n    return rotated\n\ndef g():\n    s = \"hello\"\n    k = 3\n    return (s, k)\n\nassert f(*g()) == \"llohe\"\n\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The rotated matrix should be:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Therefore, the function should return [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n    return rotated_matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, check if there exists a pair of numbers in the list\n    that sum up to the target.\n    \"\"\"\n    stack = []\n    for num in arr:\n        complement = target - num\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 85,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find a subset of numbers that add up to the target sum.\"\"\"\n    memo = {}\n\n    def dp(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n\n        if (i, curr_sum) not in memo:\n            memo[(i, curr_sum)] = dp(i + 1, curr_sum) or dp(i + 1, curr_sum + nums[i])\n\n        return memo[(i, curr_sum)]\n\n    return dp(0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]  # Example list of numbers\n    target = 16  # Example target sum\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n grid of integers, rotate the grid by 90 degrees clockwise.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n    \"\"\"\n\n    n = len(grid)\n\n    # Transpose the grid\n    for i in range(n):\n        for j in range(i, n):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        grid[i] = grid[i][::-1]\n\n    return grid\n\ndef g():\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1],\n                  [8, 5, 2],\n                  [9, 6, 3]]\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left\n    corner to the bottom-right corner. You can only move down or right.\n\n    Example:\n    Input: [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    Output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which sums up to 12.\n    \"\"\"\n\n    if not grid or not grid[0]:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[m - 1][n - 1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, convert it to its binary representation.\n    \"\"\"\n    binary_nums = []\n\n    for num in nums:\n        binary_num = bin(num)[2:]  # remove '0b' prefix from binary string\n        binary_nums.append(binary_num)\n\n    return binary_nums\n\ndef g() -> List[int]:\n    nums = [10, 5, 7]\n    return nums\n\nassert f(g()) == ['1010', '101', '111']\n\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> int:\n    \"\"\"\n    Given two strings s and t, determine the minimum number of operations required to convert s to t.\n    The possible operations are:\n        - Insert a character\n        - Delete a character\n        - Replace a character\n\n    Example:\n    s = \"horse\"\n    t = \"ros\"\n\n    Output:\n    3\n\n    Explanation:\n    The minimum number of operations required is 3:\n        - Replace 'h' with 'r'\n        - Insert 'o' after 'r'\n        - Replace 'e' with 's'\n    \"\"\"\n\n    m = len(s)\n    n = len(t)\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    return dp[m][n]\n\ndef g():\n    s = \"horse\"\n    t = \"ros\"\n    return s, t\n\nassert f(*g()) == 3\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, check if there exists a pair of numbers in the list\n    whose bitwise XOR is equal to the target.\n    \"\"\"\n    stack = []\n    for num in arr:\n        complement = num ^ target\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 6\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of bits that are set to 1 in the binary representation of 'n'.\n\n    Example:\n    Input: 7\n    Output: 3\n\n    Explanation:\n    The binary representation of 7 is 111, which has 3 bits set to 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return (n & 1) + f(n >> 1)\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == 3\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n\n    Sample input:\n    n = 6\n\n    Sample output:\n    8\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 70,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of digits, return the sum of all the even digits in the string.\n\n    Example:\n    s = \"123456789\"\n\n    The even digits in the string are 2, 4, 6, and 8.\n\n    Therefore, the function should return 20.\n    \"\"\"\n    return sum([int(digit) for digit in s if int(digit) % 2 == 0])\n\ndef g():\n    return \"123456789\"\n\nassert f(g()) == 20\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Count the number of islands in a grid.\n\n    An island is a group of connected cells with value 1. Cells are connected horizontally or vertically but not diagonally.\n    \n    Example:\n    Input:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    Output: 3\n    Explanation:\n    - There are 3 islands in the given grid: one with (0,0) and (0,1), one with (2,2), and one with (3,3) and (3,4).\n    \"\"\"\n\n    def dfs(grid, i, j):\n        # Check if the current cell is within the grid boundaries and is part of an island\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        # Mark the current cell as visited\n        grid[i][j] = -1\n\n        # Recursively explore the neighboring cells\n        dfs(grid, i-1, j)\n        dfs(grid, i+1, j)\n        dfs(grid, i, j-1)\n        dfs(grid, i, j+1)\n\n    # Get the dimensions of the grid\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize a variable to store the number of islands\n    count = 0\n\n    # Iterate through each cell in the grid\n    for i in range(m):\n        for j in range(n):\n            # If the current cell is part of an island, increment the count and perform DFS to mark the entire island as visited\n            if grid[i][j] == 1:\n                count += 1\n                dfs(grid, i, j)\n\n    # Return the number of islands\n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the shortest path from the top-left corner to the bottom-right corner\n    by only moving up, down, left, or right. The path can only traverse cells with a value of 1.\n    Return the length of the shortest path.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    The shortest path from (0, 0) to (3, 3) is [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)].\n    The length of this path is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    queue = [(0, 0, 0)]\n    visited = set()\n\n    while queue:\n        i, j, steps = queue.pop(0)\n        visited.add((i, j))\n\n        if i == m - 1 and j == n - 1:\n            return steps\n\n        # Check neighbors\n        if i > 0 and grid[i - 1][j] == 1 and (i - 1, j) not in visited:\n            queue.append((i - 1, j, steps + 1))\n            visited.add((i - 1, j))\n\n        if i < m - 1 and grid[i + 1][j] == 1 and (i + 1, j) not in visited:\n            queue.append((i + 1, j, steps + 1))\n            visited.add((i + 1, j))\n\n        if j > 0 and grid[i][j - 1] == 1 and (i, j - 1) not in visited:\n            queue.append((i, j - 1, steps + 1))\n            visited.add((i, j - 1))\n\n        if j < n - 1 and grid[i][j + 1] == 1 and (i, j + 1) not in visited:\n            queue.append((i, j + 1, steps + 1))\n            visited.add((i, j + 1))\n\n    return -1\n\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return grid\n\n\nassert f(g()) == 6\n",
        "idx_generation": 134,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Sample input:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3]]\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    def is_cyclic_util(node, visited, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic_util(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n\n    for node in range(num_vertices):\n        if not visited[node]:\n            if is_cyclic_util(node, visited, -1):\n                return True\n    return False\n\ndef g():\n    return [[1, 2], [0, 2], [0, 1, 3], [2, 4], [3, 5], [4, 6], [5]]\n\nassert f(g()) == True\n",
        "idx_generation": 59,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: dict, start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes start and end, determine if there exists a path from start to end.\n\n    Sample Input:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['C'], 'E': ['F'], 'F': ['C']}\n    start = 'A'\n    end = 'D'\n\n    Sample Output:\n    True\n    Explanation: There exists a path from 'A' to 'D' in the graph: 'A' -> 'B' -> 'C' -> 'D'.\n    \"\"\"\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    \n    return dfs(start, set())\n\ndef g():\n    return {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['C'], 'E': ['F'], 'F': ['C']}, 'A', 'D'\n\nassert f(*g()) == True\n",
        "idx_generation": 94,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given an integer n and a positive integer k, determine if there exist k distinct positive integers a_1, a_2, ..., a_k \n    such that their sum is equal to n and the product of any two integers a_i and a_j is not divisible by any other integer \n    in the set.\n    \"\"\"\n    def dfs(nums, target, k):\n        if k == 0:\n            return target == 0\n        for i in range(len(nums)):\n            if target - nums[i] >= 0:\n                if dfs(nums[i+1:], target - nums[i], k-1):\n                    return True\n        return False\n    \n    nums = [i for i in range(1, n+1)]\n    return dfs(nums, n, k)\n\ndef g(n=10, k=3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 93,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return all unique combinations of nums where the\n    sum of the combinations is equal to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    f(nums, target) => [[2, 2, 3], [7]]\n\n    Explanation: In the given array, there are two unique combinations that sum up to the target 7: [2, 2, 3] and [7].\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n        for i in range(start, len(nums)):\n            backtrack(nums, target - nums[i], i, path + [nums[i]], result)\n\n    result = []\n    nums.sort()\n    backtrack(nums, target, 0, [], result)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 372,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items without repetition.\n    Return the result modulo 10^9 + 7.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    10\n\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), (3, 4, 5).\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g():\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list with all duplicate elements removed and sorted in ascending order.\n\n    Example:\n    Input: [1, 3, 2, 2, 4, 1]\n    Output: [1, 2, 3, 4]\n    \"\"\"\n    nums = list(set(nums))  # Remove duplicates\n    nums.sort()  # Sort in ascending order\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 2, 2, 4, 1]\n\nassert f(g()) == [1, 2, 3, 4]\n\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 7\n    Output: 3\n    Explanation: The target value 7 is found at index 3 in the list.\n\n    Input: nums = [2, 4, 6, 8, 10], target = 5\n    Output: -1\n    Explanation: The target value 5 is not found in the list, so -1 is returned.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 7)\n\nassert f(*g()) == 3\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer k, determine if there exists a subarray of the given list that sums up to k.\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    return nums, k\n\nassert f(*g()) == True\n\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Note:\n    - You may assume that each input would have exactly one solution.\n    - The array is sorted in ascending order.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return [left, right]\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in ascending order using the merge sort algorithm.\n\n    Example:\n    Input: [4, 2, 1, 6, 3]\n    Output: [1, 2, 3, 4, 6]\n    \"\"\"\n\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n\n    return merge_sort(arr)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an unsorted array of integers.\n    \"\"\"\n    return [4, 2, 1, 6, 3]\n\nassert f(g()) == [1, 2, 3, 4, 6]\n\n",
        "idx_generation": 426,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    Output: True\n    Explanation: The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers such that there exists a pair of numbers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 6\nassert f(*g(nums, target)) == True\n\n",
        "idx_generation": 302,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> List[List[int]]:\n    \"\"\"Sort the given list of points in ascending order based on their distance from the origin (0,0).\"\"\"\n    def distance(p):\n        return p[0]**2 + p[1]**2\n    return sorted(points, key=distance)\n\ndef g():\n    points = [[1, 2], [3, 4], [0, 0], [5, 5]]\n    return points\n\nassert f(g()) == [[0, 0], [1, 2], [3, 4], [5, 5]]\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix (2D list) of integers and a target value, determine if the target value exists in the matrix.\n\n    The matrix is sorted row-wise and column-wise in ascending order.\n    \"\"\"\n\n    def binary_search(matrix, target, start_row, end_row, start_col, end_col):\n        if start_row > end_row or start_col > end_col:\n            return False\n        \n        mid_row = (start_row + end_row) // 2\n        mid_col = (start_col + end_col) // 2\n        \n        if matrix[mid_row][mid_col] == target:\n            return True\n        \n        if matrix[mid_row][mid_col] > target:\n            return binary_search(matrix, target, start_row, mid_row - 1, start_col, end_col) or binary_search(matrix, target, mid_row, end_row, start_col, mid_col - 1)\n        \n        return binary_search(matrix, target, start_row, mid_row, mid_col + 1, end_col) or binary_search(matrix, target, mid_row + 1, end_row, start_col, end_col)\n\n    if not matrix or not matrix[0]:\n        return False\n\n    return binary_search(matrix, target, 0, len(matrix) - 1, 0, len(matrix[0]) - 1)\n\ndef g(matrix=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], target=5):\n    return matrix, target\n\nassert f(*g()) == True\n",
        "idx_generation": 296,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a subsequence of length k, where the sum of the subsequence is equal to the target.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    for i in range(n):\n        curr_sum = arr[i]\n        if curr_sum == target:\n            count += 1\n\n        for j in range(i + 1, n):\n            curr_sum += arr[j]\n            if curr_sum == target:\n                count += 1\n\n    return count > 0\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 424,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Subset Sum\n\n    Given a list of integers and a target sum, determine if there is a subset of the list that adds up to the target sum.\n\n    Example:\n    arr = [2, 4, 6, 8]\n    target = 10\n    output: True (subset [2, 8] adds up to 10)\n    \"\"\"\n    def subset_sum(arr, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        if arr[n-1] > target:\n            return subset_sum(arr, target, n-1)\n        return subset_sum(arr, target, n-1) or subset_sum(arr, target-arr[n-1], n-1)\n\n    return subset_sum(arr, target, len(arr))\n    \ndef g(arr=[2, 4, 6, 8], target=10):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 77,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, determine if they are anagrams of each other after removing all non-alphabetic characters, ignoring case, and sorting the remaining characters.\n\n    Sample Input:\n    s1 = \"Listen\"\n    s2 = \"Silent\"\n\n    Sample Output:\n    True\n    Explanation: After removing non-alphabetic characters, ignoring case, and sorting the remaining characters, both strings become \"eilnst\", which are anagrams.\n\n    Sample Input:\n    s1 = \"Python\"\n    s2 = \"Java\"\n\n    Sample Output:\n    False\n    Explanation: After removing non-alphabetic characters, ignoring case, and sorting the remaining characters, s1 becomes \"hnopty\" and s2 becomes \"aajv\", which are not anagrams.\n    \"\"\"\n    letters1 = sorted(c.lower() for c in s1 if c.isalpha())\n    letters2 = sorted(c.lower() for c in s2 if c.isalpha())\n    return letters1 == letters2\ndef g(s1 = \"Listen\", s2 = \"Silent\"):\n    return s1, s2\nassert f(*g())\n",
        "idx_generation": 15,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after deleting at most one character.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n    Explanation: The string \"racecar\" is already a palindrome.\n\n    Input: s = \"abca\"\n    Output: True\n    Explanation: By deleting 'b', the string becomes \"aca\" which is a palindrome.\n\n    Input: s = \"abcda\"\n    Output: False\n    Explanation: By deleting any one character, the string cannot become a palindrome.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcda\"\n\nassert f(g()) == False\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, determine if it is possible to select a subarray from the array such that the sum of the subarray is equal to the target value.\n    \"\"\"\n    def is_subarray_sum(arr: List[int], target: int) -> bool:\n        n = len(arr)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if prefix_sum[j] - prefix_sum[i] == target:\n                    return True\n        return False\n\n    return is_subarray_sum(arr, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 208,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the list.\n    The list contains all the numbers from 1 to n, except for one number.\n    Return the missing number.\n\n    Example:\n    Input: nums = [1, 2, 3, 5, 6, 7]\n    Output: 4\n\n    Explanation: The number 4 is missing from the list.\n\n    \"\"\"\n    n = len(nums) + 1\n    total_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    missing_number = total_sum - actual_sum\n\n    return missing_number\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 5, 6, 7]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    The factorial of 5 is 5! = 5 * 4 * 3 * 2 * 1 = 120.\n    The number of trailing zeros in 120 is 1.\n    Therefore, the function should return 1.\n    \"\"\"\n\n    count = 0\n\n    while n >= 5:\n        n //= 5\n        count += n\n\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output: 6  # (the subarray [4, -1, 2, 1] has the maximum sum of 6)\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring that contains only digits.\n\n    Sample Input:\n    s = \"abc123def456ghi789\"\n\n    Sample Output:\n    3\n    \"\"\"\n\n    max_length = 0\n    current_length = 0\n\n    for char in s:\n        if char.isdigit():\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n\n    return max(max_length, current_length)\n\ndef g():\n    return \"abc123def456ghi789\"\n\nassert f(g()) == 3\n",
        "idx_generation": 392,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray of the list.\n\n    Sample Input:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Sample Output:\n    6\n\n    Explanation: The contiguous subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that there is a contiguous subarray with the maximum sum.\n    \"\"\"\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 6\n\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.\n\n    Example:\n    Input: nums = [1, 1, 1], k = 2\n    Output: 2\n\n    Explanation: The subarrays [1, 1] and [1, 1] have a sum of 2.\n\n    Constraints:\n    - 1 <= nums.length <= 2 * 10^4\n    - -1000 <= nums[i] <= 1000\n    - -10^7 <= k <= 10^7\n    \"\"\"\n\n    count = 0\n    sum_so_far = 0\n    sum_counts = {0: 1}\n\n    for num in nums:\n        sum_so_far += num\n\n        if sum_so_far - k in sum_counts:\n            count += sum_counts[sum_so_far - k]\n\n        if sum_so_far in sum_counts:\n            sum_counts[sum_so_far] += 1\n        else:\n            sum_counts[sum_so_far] = 1\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 1, 1], 2)\n\nassert f(*g()) == 2\n\n\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, False otherwise.\n\n    Sample input:\n    arr = [2, 4, 6, 8, 10]\n    target = 14\n\n    Sample output:\n    True\n    \"\"\"\n    seen = set()\n    for num in arr:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr = [2, 4, 6, 8, 10], target = 14):\n    return arr\n\nassert f(g(), 14) == True\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    The Fibonacci sequence is defined as follows:\n    - The first two numbers in the sequence are 0 and 1.\n    - Each subsequent number is the sum of the two preceding ones.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    8\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib_sequence = [0, 1]\n\n    for i in range(2, n + 1):\n        fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n\n    return fib_sequence[n]\n\ndef g():\n    n = 6\n    return [n]\n\nassert f(*g()) == 8\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Sample Input:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Sample Output:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Explanation: The original matrix is rotated 90 degrees clockwise.\n\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers such that it can be rotated 90 degrees clockwise.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n",
        "idx_generation": 253,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of distinct paths from the top-left cell to the bottom-right cell.\n    You can only move to the right or down, and you cannot visit cells with a value of 1.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    return [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n\nassert f(g()) == 2\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome, i.e., reads the same forwards and backwards.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: The string \"racecar\" reads the same forwards and backwards, so it is a palindrome.\n    \"\"\"\n\n    # Remove all non-alphanumeric characters and convert string to lowercase\n    s = ''.join(char.lower() for char in s if char.isalnum())\n\n    # Check if the reverse of s is equal to s\n    return s == s[::-1]\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Determine if a given string can be constructed by concatenating words from a given list, without any leftover characters.\n    \"\"\"\n    def helper(s, words, memo):\n        if s in memo:\n            return memo[s]\n        if s == '':\n            return True\n        for word in words:\n            if s.startswith(word) and helper(s[len(word):], words, memo):\n                memo[s] = True\n                return True\n        memo[s] = False\n        return False\n    \n    return helper(s, words, {})\n\ndef g(words: List[str]) -> str:\n    \"\"\"\n    Generate a string by concatenating words from the given list.\n    \"\"\"\n    import random\n    s = ''.join(random.sample(words, random.randint(1, len(words))))\n    return s\n\nassert f(g(['cat', 'dog', 'bird']), ['cat', 'dog', 'bird'])\n",
        "idx_generation": 88,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, check if there exists a subset of the list whose XOR is equal to the target number.\n    \"\"\"\n    n = len(nums)\n    for i in range(1, 2 ** n):\n        subset_xor = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_xor ^= nums[j]\n        if subset_xor == target:\n            return True\n    return False\n\ndef g():\n    return [3, 6, 9, 12, 15], 7\nassert f(*g()) == False\n",
        "idx_generation": 101,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: [4, 7, 2, 8, 9]\n    Output: 15 (4 ^ 11 = 15)\n\n    Hint: Use bit manipulation and dynamic programming to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    return [4, 7, 2, 8, 9]\n\nassert f(g()) == 15\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum number of moves required to move from the top-left corner to the bottom-right corner.\n    Each move can be either right or down, and the value in each cell represents the cost of moving to that cell.\n    Return the minimum number of moves.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 79,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if there exists a path from the top-left corner (0, 0)\n    to the bottom-right corner (N-1, M-1), where N is the number of rows and M is the number of columns.\n    You can only move down or right.\n    \"\"\"\n    N = len(grid)\n    M = len(grid[0])\n    \n    def dfs(i, j):\n        if i == N-1 and j == M-1:\n            return True\n        if i < N-1 and grid[i+1][j] == 1:\n            if dfs(i+1, j):\n                return True\n        if j < M-1 and grid[i][j+1] == 1:\n            if dfs(i, j+1):\n                return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g():\n    grid = [\n        [1, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find if there is a path from start to end.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in range(len(graph)):\n                if graph[node][neighbor] == 1:\n                    stack.append(neighbor)\n    return False\n\ndef g(graph=[[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], start=0, end=3):\n    return graph\n\nassert f(g(), 0, 3)\n",
        "idx_generation": 168,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a list of directed edges, determine if there is a cycle in the graph.\n    \"\"\"\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n    visited = set()\n    stack = set()\n\n    def dfs(node):\n        visited.add(node)\n        stack.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in stack:\n                return True\n\n        stack.remove(node)\n        return False\n\n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of directed edges.\n    \"\"\"\n    return [(1, 2), (2, 3), (3, 1)]\n\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import defaultdict\n\ndef f(prerequisites: List[Tuple[int, int]], numCourses: int) -> bool:\n    \"\"\"\n    Given a list of prerequisite pairs, determine if it is possible to finish all courses.\n    Each pair (a, b) represents that course b has a prerequisite of course a.\n    \"\"\"\n    graph = defaultdict(list)\n    for course, prerequisite in prerequisites:\n        graph[prerequisite].append(course)\n\n    visited = [0] * numCourses\n\n    def dfs(course):\n        if visited[course] == -1:\n            return False\n        if visited[course] == 1:\n            return True\n\n        visited[course] = -1\n\n        for neighbor in graph[course]:\n            if not dfs(neighbor):\n                return False\n\n        visited[course] = 1\n        return True\n\n    for course in range(numCourses):\n        if not dfs(course):\n            return False\n\n    return True\n\ndef g():\n    prerequisites = [(1, 0), (2, 1), (3, 2)]\n    numCourses = 4\n    return prerequisites, numCourses\n\nassert f(*g()) == True\n\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate all possible permutations of the numbers 1 to n.\n\n    Example:\n    Input: n = 3\n    Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Input: n = 4\n    Output: [[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]\n    \"\"\"\n\n    def backtrack(nums: List[int], path: List[int], used: List[bool], res: List[List[int]]) -> None:\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n\n            backtrack(nums, path, used, res)\n\n            used[i] = False\n            path.pop()\n\n    nums = [i for i in range(1, n + 1)]\n    res = []\n    used = [False] * n\n    backtrack(nums, [], used, res)\n\n    return res\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 3\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(strings: List[str]) -> bool:\n    \"\"\"\n    Given a list of strings, determine if there exists a string that can be formed by concatenating the strings in the list in any order.\n    \"\"\"\n    def is_valid_string(s: str, strings: List[str]) -> bool:\n        return s in strings\n    \n    def is_valid_concatenation(s: str, strings: List[str]) -> bool:\n        if s == \"\":\n            return True\n        for i in range(1, len(s)+1):\n            if s[:i] in strings and is_valid_concatenation(s[i:], strings):\n                return True\n        return False\n    \n    for string in strings:\n        if is_valid_concatenation(string, strings):\n            return True\n    return False\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of random strings.\n    \"\"\"\n    import random\n    strings = []\n    for _ in range(5):\n        string = \"\"\n        for _ in range(random.randint(1, 5)):\n            string += chr(random.randint(97, 122))\n        strings.append(string)\n    return strings\n\nassert f(g()) == True\n",
        "idx_generation": 393,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique permutations of the digits of n.\n    \"\"\"\n    digits = list(str(n))\n    counts = [0] * 10\n    for digit in digits:\n        counts[int(digit)] += 1\n\n    total_permutations = factorial(len(digits))\n    for count in counts:\n        if count > 1:\n            total_permutations //= factorial(count)\n\n    return total_permutations\n\ndef factorial(n: int) -> int:\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef g() -> int:\n    return 1122\n\nassert f(g()) == 6\n",
        "idx_generation": 478,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (not necessarily contiguous).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 18], with a length of 4.\n\n    Therefore, the function should return 4.\n\n    Note:\n    - The length of the list will be at least 1 and at most 2500.\n    - The range of integers in the list is -10^4 <= nums[i] <= 10^4.\n    \"\"\"\n    if len(nums) < 2:\n        return len(nums)\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two numbers in the array is 28 (5 XOR 25).\n\n    Therefore, the function should return 28.\n    \"\"\"\n    def findMaximumXOR(nums):\n        MAX_BITS = 32\n        result = 0\n\n        for i in range(MAX_BITS-1, -1, -1):\n            result <<= 1\n            prefixSet = set([num >> i for num in nums])\n\n            currMax = result | 1\n            for prefix in prefixSet:\n                if currMax ^ prefix in prefixSet:\n                    result |= 1\n                    break\n\n        return result\n\n    return findMaximumXOR(nums)\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 382,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there exists\n    a pair of numbers in the array that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11]\n\nassert f(g(), 10) == True\n\n",
        "idx_generation": 255,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the missing number in the sequence.\n\n    The array is sorted in ascending order and contains unique numbers from 1 to n, except for one missing number.\n\n    Example:\n    arr = [1, 2, 4, 5, 6]\n    Output: 3\n    Explanation: The missing number in the sequence is 3.\n    \"\"\"\n\n    # Use binary search to find the missing number\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == mid + 1:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left + 1\n\ndef g():\n    return [1, 2, 4, 5, 6]\n\nassert f(g()) == 3\n",
        "idx_generation": 447,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next greater element for each element in the list. If there is no greater element, return -1.\n    \"\"\"\n    stack = []\n    next_greater = [-1] * len(nums)\n    \n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            next_greater[stack.pop()] = nums[i]\n        stack.append(i)\n    \n    return next_greater\n\ndef g():\n    nums = [4, 5, 2, 8, 3, 9, 1]\n    return nums\n\nassert f(g()) == [5, 8, 8, 9, 9, -1, -1]\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number. The list is sorted in ascending order.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 5) has a bitwise XOR equal to 7 (2 ^ 5 = 7).\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_xor = nums[left] ^ nums[right]\n\n        if current_xor == target:\n            return True\n        elif current_xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 306,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int, a=1000) -> bool:\n    \"\"\"Find the remainder when s is divided by n, while ensuring s is greater than a.\"\"\"\n    return int(s) % n == 0 and int(s) > a\ndef g(n=100, a=1000):\n    s = str(n * (a // n + 1))\n    return s, n, a\nassert f(*g())\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    An increasing path is defined as a path from a given cell to another cell such that all cells\n    along the path have increasing values. The path can start from any cell and move in any of the four\n    cardinal directions (up, down, left, or right), but a cell cannot be visited more than once.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    The longest increasing path is [1, 2, 6, 9], so the output is 4.\n    \"\"\"\n    def dfs(i: int, j: int) -> int:\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        max_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_length = max(max_length, dfs(x, y) + 1)\n\n        memo[i][j] = max_length\n        return memo[i][j]\n\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    memo = [[0] * n for _ in range(m)]\n    max_length = 0\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Return the maximum product as an integer.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Possible products: 1 * 2 * 3 = 6, 1 * 2 * 4 = 8, 1 * 3 * 4 = 12, 2 * 3 * 4 = 24\n\n    The maximum product is 24.\n\n    So, f(nums) should return 24.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of at least 4 integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find if there exists a valid parenthesis sequence with n pairs of parentheses.\"\"\"\n    def helper(open_count, close_count):\n        if open_count == 0 and close_count == 0:\n            return True\n        if open_count > 0:\n            if helper(open_count - 1, close_count):\n                return True\n        if open_count < close_count:\n            if helper(open_count, close_count - 1):\n                return True\n        return False\n    \n    return helper(n, n)\n\ndef g(n=4):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it can be rearranged to form a palindrome.\n    \"\"\"\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n\n    odd_count = 0\n    for c in count:\n        if c % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that can be rearranged to form a palindrome.\n    \"\"\"\n    return \"aabbcdd\"\n\nassert f(g()) == True\n",
        "idx_generation": 33,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    def is_palindrome(left: int, right: int) -> bool:\n        if left >= right:\n            return True\n        if s[left] != s[right]:\n            return False\n        return is_palindrome(left + 1, right - 1)\n    \n    return is_palindrome(0, len(s) - 1)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses string. A valid parentheses string is a string consisting\n    of only '(' and ')', where each open parenthesis has a corresponding closing parenthesis and the parentheses are\n    properly nested.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\ndef g(n: int):\n    \"\"\"\n    Given a positive integer n, return a string of length 2n consisting of valid parentheses.\n    \"\"\"\n    def generate_parentheses(s: str, left: int, right: int):\n        if left == n and right == n:\n            parentheses.append(s)\n            return\n        if left < n:\n            generate_parentheses(s + '(', left + 1, right)\n        if right < left:\n            generate_parentheses(s + ')', left, right + 1)\n\n    parentheses = []\n    generate_parentheses('', 0, 0)\n    return parentheses\n\nassert f(g(3)[0])\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 227,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a target integer k, find the number of subarrays whose sum is divisible by k.\n\n    Sample Input:\n    arr = [4, 5, 0, -2, -3, 1]\n    k = 5\n\n    Sample Output:\n    7\n    Explanation: The subarrays whose sum is divisible by 5 are [4, 5, 0], [5], [5, 0, -2, -3, 1], [0], [0, -2, -3],\n    [-2, -3, 1], and [1].\n\n    Sample Input:\n    arr = [3, 2, 1, 4, 6]\n    k = 3\n\n    Sample Output:\n    4\n    Explanation: The subarrays whose sum is divisible by 3 are [3], [3, 2, 1, 4], [2, 1, 4], and [1].\n\n    \"\"\"\n    prefix_sum = 0\n    count = 0\n    remainder_map = {0: 1}\n    \n    for num in arr:\n        prefix_sum += num\n        remainder = prefix_sum % k\n        count += remainder_map.get(remainder, 0)\n        remainder_map[remainder] = remainder_map.get(remainder, 0) + 1\n    \n    return count\n\ndef g(arr=[4, 5, 0, -2, -3, 1], k=5):\n    return arr, k\n\nassert f(*g()) == 7\n",
        "idx_generation": 293,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    Input: nums = [2, 3, -2, 4]\n    Output: 6\n    Explanation: The subarray [2, 3] has the maximum product of 6.\n\n    Input: nums = [-2, 0, -1]\n    Output: 0\n    Explanation: The subarray [-2, 0, -1] has the maximum product of 0.\n    \"\"\"\n\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n\n        result = max(result, max_product)\n\n    return result\n\ndef g() -> List[int]:\n    nums = [2, 3, -2, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 460,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of itself and all previous elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    [1, 3, 6, 10, 15]\n    \"\"\"\n    result = []\n    running_sum = 0\n    for num in nums:\n        running_sum += num\n        result.append(running_sum)\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [1, 3, 6, 10, 15]\n\n",
        "idx_generation": 400,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a contiguous subarray of the list\n    that sums up to the target value. Return True if such subarray exists, False otherwise.\n\n    Sample Input:\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n\n    Sample Output:\n    True\n\n    Explanation: The subarray [20, 3, 10] sums up to the target value of 33.\n\n    \"\"\"\n    prefix_sum = 0\n    prefix_sums = set()\n\n    for num in arr:\n        prefix_sum += num\n\n        if prefix_sum == target or prefix_sum - target in prefix_sums:\n            return True\n\n        prefix_sums.add(prefix_sum)\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value such that there exists a contiguous subarray that sums up to the target value.\n    \"\"\"\n    arr = [1, 4, 20, 3, 10, 5]\n    target = 33\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exist two distinct indices i and j in the list such that nums[i] + nums[j] == target.\n\n    Example:\n    Input: nums = [-2, 0, 3, 5, 7, 9, 12], target = 8\n    Output: True\n\n    Explanation:\n    The sum of nums[2] and nums[4] is equal to the target number 8.\n    Therefore, there exist two distinct indices i and j such that nums[i] + nums[j] == target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number, where there exist two distinct indices i and j such that nums[i] + nums[j] == target.\n    \"\"\"\n    return ([-2, 0, 3, 5, 7, 9, 12], 8)\n\nassert f(*g()) == True\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string s is a balanced bracket sequence.\n    A balanced bracket sequence is a string consisting of only brackets ( '(' and ')' ),\n    where each opening bracket has a corresponding closing bracket and the brackets are properly nested.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\ndef g():\n    return \"(())()()\"\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of jumps required to reach the end of the list,\n    starting from the first element. Each element in the list represents the maximum number of steps\n    that can be jumped from that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n\n    The minimum number of jumps required is 2, which can be achieved by jumping from index 0 to index 1,\n    and then from index 1 to index 4.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n\n    return jumps[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 1, 1, 4]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to place k non-overlapping squares of size 2x2\n    such that each square covers exactly four cells with the same value.\n    \"\"\"\n    count = 0\n    for i in range(n-1):\n        for j in range(n-1):\n            if grid[i][j] == grid[i][j+1] == grid[i+1][j] == grid[i+1][j+1]:\n                count += 1\n    return count >= k\n\ndef g(n=4, k=2):\n    grid = [[1, 1, 2, 2],\n            [1, 1, 2, 2],\n            [3, 3, 4, 4],\n            [3, 3, 4, 4]]\n    return n, k, grid\n\nassert f(*g())\n",
        "idx_generation": 256,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of unique paths from the top-left cell to the bottom-right cell in an n x m grid.\n    You can only move to the right or down.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two positive integers n and m.\n    \"\"\"\n    return 3, 4\n\nassert f(*g()) == 10\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string, split it into a list of all possible substrings.\n    \"\"\"\n    n = len(s)\n    substrings = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.append(s[i:j])\n    return substrings\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == ['a', 'ab', 'abc', 'b', 'bc', 'c']\n\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string s and a pattern string, determine if the pattern is present in s.\n    \"\"\"\n    def is_match(s: str, pattern: str, i: int, j: int) -> bool:\n        if i == len(s) and j == len(pattern):\n            return True\n        elif j == len(pattern):\n            return False\n        elif i == len(s):\n            if pattern[j:] == \"*\":\n                return is_match(s, pattern, i, j + 1)\n            else:\n                return False\n        \n        if pattern[j] == \"*\" or pattern[j] == \"?\":\n            return is_match(s, pattern, i + 1, j + 1) or is_match(s, pattern, i + 1, j) or is_match(s, pattern, i, j + 1)\n        elif pattern[j] == s[i]:\n            return is_match(s, pattern, i + 1, j + 1)\n        else:\n            return False\n\n    return is_match(s, pattern, 0, 0)\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a pattern string.\n    \"\"\"\n    return (\"puzzle\", \"p*zle\")\n\nassert f(*g()) == True\n",
        "idx_generation": 118,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a number k, check if there exists a subset whose sum is divisible by k.\n    \"\"\"\n    n = len(nums)\n    for i in range(1, 2 ** n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += nums[j]\n        if subset_sum % k == 0:\n            return True\n    return False\n\ndef g():\n    return [3, 6, 9, 12, 15], 10\nassert f(*g()) == True\n",
        "idx_generation": 101,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers arr and a target integer, find the maximum number of operations needed to transform arr into a list where each element is equal to the target by performing bitwise OR operation on a subset of the list.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr: int) -> int:\n        if curr == target:\n            return 0\n        if index == len(arr):\n            return float('-inf')\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(arr, target, index + 1, curr | arr[index]) + 1\n\n        return max(exclude, include)\n\n    res = helper(arr, target, 0, 0)\n\n    if res == float('-inf'):\n        return -1\n    return res\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 6) == 2\n\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of ways to climb to the top of a staircase.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n\n    Output:\n    5\n\n    Explanation:\n    There are 5 ways to climb to the top:\n        - 1 step + 1 step + 1 step + 1 step\n        - 2 steps + 1 step + 1 step\n        - 1 step + 2 steps + 1 step\n        - 1 step + 1 step + 2 steps\n        - 2 steps + 2 steps\n    \"\"\"\n\n    if n < 3:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 86,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, find the kth largest element in the list.\n\n    Sample input:\n    nums = [3,2,1,5,6,4], k = 2\n\n    Sample output:\n    5\n\n    Explanation:\n    The second largest element in the list is 5.\n    \"\"\"\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heapq.heappop(heap)\n\ndef g():\n    nums = [3,2,1,5,6,4]\n    k = 2\n    return nums, k\n\nassert f(*g()) == 5\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start=1, target=6) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes and the values are lists of nodes that can be\n    reached from the key node, find if there exists a path from the start node to the target node.\n\n    Sample input:\n    {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n\n    Sample output:\n    True\n\n    In the given graph, there exists a path from node 1 to node 6: 1 -> 3 -> 5 -> 6.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        visited.add(node)\n        stack.extend([n for n in graph[node] if n not in visited])\n    return False\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 187,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given the total number of nodes in a directed graph and a list of directed edges, determine if there is a cycle in the graph.\n    \n    Sample Input:\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    \n    Sample Output:\n    True\n    \n    Explanation: The graph contains a cycle: 1 -> 2 -> 3 -> 1.\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    \n    visited = [False] * n\n    recursion_stack = [False] * n\n    \n    def dfs(node):\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n        \n        recursion_stack[node] = False\n        return False\n    \n    for node in range(n):\n        if not visited[node]:\n            if dfs(node):\n                return True\n    \n    return False\n\ndef g():\n    n = 4\n    edges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, determine if there is a path from a start node to an end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        visited.add(node)\n        neighbors = graph.get(node, [])\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                stack.append(neighbor)\n    return False\n\ndef g(graph: Dict[str, List[str]], start: str, end: str) -> Dict[str, List[str]]:\n    \"\"\"\n    Generate a directed graph with a path from a start node to an end node.\n    \"\"\"\n    graph[start] = [end]\n    return graph\n\ngraph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['E'], 'E': []}\nstart = 'A'\nend = 'E'\nassert f(g(graph, start, end), start, end) == True\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges, determine if it is possible to color the nodes\n    using m colors such that no two adjacent nodes have the same color.\n\n    Sample input:\n    3\n    2\n    [(0, 1), (1, 2)]\n\n    Sample output:\n    True\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    colors = [-1] * n\n\n    def is_valid(node: int, color: int) -> bool:\n        if colors[node] != -1:\n            return colors[node] == color\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not is_valid(neighbor, 1 - color):\n                return False\n        return True\n\n    for i in range(n):\n        if colors[i] == -1 and not is_valid(i, 0):\n            return False\n    return True\n\ndef g(n=4, m=3, edges=[(0, 1), (1, 2), (2, 3)]):\n    return n, m, edges\n\nassert f(*g())\n",
        "idx_generation": 109,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct palindromic subsequences.\n\n    A subsequence is obtained by deleting some characters (possibly none) from the original string without changing the order of the remaining characters.\n\n    Example:\n    s = \"bccb\"\n    Output: 6\n\n    Explanation:\n    There are 6 distinct palindromic subsequences: \"b\", \"c\", \"bb\", \"cc\", \"bcb\", \"bccb\".\n\n    s = \"aaaa\"\n    Output: 15\n    \"\"\"\n    n = len(s)\n    MOD = 10**9 + 7\n\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n\n                while left <= right and s[left] != s[i]:\n                    left += 1\n\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n\n                if left > right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n\n            dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]\n\ndef g(s: str = \"bccb\"):\n    return s\n\nassert f(g()) == 6\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the array, where index1 must be less than index2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 422,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: 24\n    Explanation: The maximum product of any three numbers is 2 * 3 * 4 = 24.\n\n    \"\"\"\n\n    nums.sort()\n\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n\n",
        "idx_generation": 405,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there is a pair of elements in the list that adds up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == True\n",
        "idx_generation": 266,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return all unique combinations of numbers from the array that sum up to the target.\n    The same number may be chosen from the array an unlimited number of times.\n    The combinations should be returned in ascending order.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], curr_sum: int) -> None:\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, path + [nums[i]], curr_sum + nums[i])\n\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subsequence within the list.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, -2, 3, 10, -4, 7, 2, -5]\n    The function should return 18 since the maximum sum is obtained from the subsequence [3, 10, 7, 2].\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, 10, -4, 7, 2, -5]\n    return nums\n\nassert f(g()) == 18\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by selecting two elements from the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum XOR value that can be obtained is 7 by selecting 3 and 4.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 335,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers in the list that add up to the target value.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14\n    Output: [4, 10]\n\n    Explanation: The numbers 4 and 10 add up to 14.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return [nums[left], nums[right]]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g()) == [4, 10]\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path (from a cell to its neighboring cell) where all cells along the path have increasing values.\n    The path can start from any cell and can move in any of the four directions (up, down, left, or right).\n    \"\"\"\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    max_length = 0\n\n    def dfs(i: int, j: int) -> int:\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        curr_length = 1\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                curr_length = max(curr_length, 1 + dfs(x, y))\n\n        dp[i][j] = curr_length\n        return curr_length\n\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be used to find the length of the longest increasing path.\n    \"\"\"\n    return matrix\n\nmatrix = [\n    [9, 9, 4],\n    [6, 6, 8],\n    [2, 1, 1]\n]\nassert f(g(matrix)) == 4\n\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and an integer k, return the k most frequent elements in the list.\n    \"\"\"\n\n    freq = {}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n\n    freq_list = [(num, count) for num, count in freq.items()]\n    freq_list.sort(key=lambda x: x[1], reverse=True)\n\n    return [num for num, _ in freq_list[:k]]\n\ndef g() -> List[int]:\n    return [1, 1, 1, 2, 2, 3]\n\nassert f(g(), 2) == [1, 2]\n",
        "idx_generation": 455,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all multiples of 3 or 5 that are\n    less than n.\n\n    Example:\n    n = 10\n\n    The multiples of 3 or 5 that are less than 10 are: 3, 5, 6, 9.\n\n    Therefore, the sum of these multiples is 3 + 5 + 6 + 9 = 23.\n\n    The function should return 23.\n    \"\"\"\n\n    sum = 0\n\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            sum += i\n\n    return sum\n\ndef g() -> int:\n    return 10\n\nassert f(g()) == 23\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, substr1='abc', substr2='def', n=2) -> bool:\n    \"\"\"\n    Determine if the given string contains exactly n occurrences of both substr1 and substr2,\n    with substr1 appearing before substr2\n    \"\"\"\n    count1 = s.count(substr1)\n    count2 = s.count(substr2)\n    return count1 == count2 == n and s.index(substr1) < s.index(substr2)\n\ndef g(substr1='abc', substr2='def', n=2):\n    \"\"\"\n    Generate a string with exactly n occurrences of both substr1 and substr2,\n    with substr1 appearing before substr2\n    \"\"\"\n    return substr1 * n + substr2 * n\n    \nassert f(g()) == True\n",
        "idx_generation": 44,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid palindrome after removing at most one character.\n\n    Example:\n    s = \"abcba\"\n\n    The string is already a palindrome, so it is valid.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        \"\"\"\n        Check if a string is a palindrome.\n        \"\"\"\n        return s == s[::-1]\n\n    n = len(s)\n    left = 0\n    right = n - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            # Remove left character and check if the remaining string is a palindrome\n            if is_palindrome(s[left+1:right+1]):\n                return True\n            # Remove right character and check if the remaining string is a palindrome\n            if is_palindrome(s[left:right]):\n                return True\n            # If removing both characters doesn't result in a palindrome, return False\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    s = \"abcba\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers 'nums' and a target integer 'target', \n    find two numbers in the array that add up to the target and return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The function should return [0, 1] because nums[0] + nums[1] equals 9.\n\n    Constraints:\n    - Each input will have exactly one solution.\n    - You may not use the same element twice.\n    - You can return the answer in any order.\n    \"\"\"\n\n    nums_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in nums_dict:\n            return [nums_dict[complement], i]\n        nums_dict[num] = i\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target integer.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 232,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the sum of all the elements in the grid that are divisible by 2.\n\n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    20\n    Explanation: The elements divisible by 2 are 2, 4, 6, and 8. The sum of these elements is 2 + 4 + 6 + 8 = 20.\n\n    Sample Input:\n    grid = [\n        [1, 3, 5],\n        [7, 9, 11],\n        [13, 15, 17]\n    ]\n\n    Sample Output:\n    0\n    Explanation: There are no elements divisible by 2 in the grid, so the sum is 0.\n    \"\"\"\n    total = 0\n    for row in grid:\n        for num in row:\n            if num % 2 == 0:\n                total += num\n    return total\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 20\n",
        "idx_generation": 229,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    A subarray is a contiguous part of the array.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 317,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Input: nums = [1]\n    Output: 1\n    \"\"\"\n    curr_max = nums[0]\n    max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        curr_max = max(nums[i], curr_max + nums[i])\n        max_sum = max(max_sum, curr_max)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that position.\n    The solution should be implemented without using division.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    f(nums) => [120, 60, 40, 30, 24]\n    \"\"\"\n\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    # Calculate the product of all numbers to the left of each position\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    # Calculate the product of all numbers to the right of each position\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    # Multiply the left and right products to get the final result\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n",
        "idx_generation": 406,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1, which are 2 and 7, add up to the target value of 9.\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number and its index\n    complement_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        else:\n            complement_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return [nums, target]\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a window size k, find the maximum element in each window of size k.\n    \"\"\"\n    if not arr or k == 0:\n        return []\n\n    n = len(arr)\n    result = []\n\n    for i in range(n - k + 1):\n        result.append(max(arr[i:i + k]))\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, 3, 2, 1, 5]\n\nassert f(g(), 3) == [4, 3, 5]\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Merge two sorted lists into a single sorted list.\n    \"\"\"\n    merged = []\n    i = j = 0\n    \n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n    \n    merged.extend(nums1[i:])\n    merged.extend(nums2[j:])\n    \n    return merged\n\ndef g():\n    nums1 = [1, 3, 5]\n    nums2 = [2, 4, 6]\n    return nums1, nums2\n\nassert f(*g()) == [1, 2, 3, 4, 5, 6]\n",
        "idx_generation": 110,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest arithmetic subsequence in the array.\n\n    Sample Input:\n    arr = [1, 7, 10, 13, 14, 19]\n\n    Sample Output:\n    4\n    Explanation: The longest arithmetic subsequence is [1, 7, 13, 19] with a common difference of 6.\n\n    Sample Input:\n    arr = [3, 6, 9, 12]\n\n    Sample Output:\n    4\n    Explanation: The longest arithmetic subsequence is [3, 6, 9, 12] with a common difference of 3.\n    \"\"\"\n\n    n = len(arr)\n    if n <= 2:\n        return n\n\n    dp = {}\n    longest = 2\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = arr[j] - arr[i]\n\n            if (i, diff) in dp:\n                dp[(j, diff)] = dp[(i, diff)] + 1\n            else:\n                dp[(j, diff)] = 2\n\n            longest = max(longest, dp[(j, diff)])\n\n    return longest\n\n\ndef g() -> List[int]:\n    return [1, 7, 10, 13, 14, 19]\n\n\nassert f(g()) == 4\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a 2D grid of integers, rotate the grid 90 degrees clockwise.\n\n    Example:\n    Input: grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    rotated_grid = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            rotated_grid[j][rows - 1 - i] = grid[i][j]\n    return rotated_grid\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers where rotating the grid 90 degrees clockwise is required to solve the puzzle.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 290,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n\n    The minimum path sum is the sum of all the numbers along the path that minimizes the sum.\n\n    Return the minimum path sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 1 + 3 + 1 + 1 + 1 = 7, so the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings, determine if one is a substring of the other.\n    \"\"\"\n    if len(s) < len(t):\n        s, t = t, s\n    return t in s\n\ndef g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s = \"abcdefg\"\n    t = \"cde\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindromic substring in s.\n\n    Example:\n    Input: \"babad\"\n    Output: 3\n\n    Explanation: The longest palindromic substring is \"aba\" or \"bab\".\n    \"\"\"\n\n    def expandAroundCenter(s: str, left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if s is None or len(s) < 1:\n        return 0\n\n    start = 0\n    end = 0\n\n    for i in range(len(s)):\n        len1 = expandAroundCenter(s, i, i)\n        len2 = expandAroundCenter(s, i, i + 1)\n        length = max(len1, len2)\n        if length > end - start:\n            start = i - (length - 1) // 2\n            end = i + length // 2\n\n    return end - start + 1\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there exist two integers in the list such that\n    their XOR is equal to k.\n\n    Example:\n    Input: [3, 5, 9, 2, 7], 10\n    Output: True\n\n    Explanation:\n    3 ^ 7 = 4\n    5 ^ 9 = 12\n    2 ^ 7 = 5\n    Therefore, the output is True.\n    \"\"\"\n    xor_set = set()\n    for num in nums:\n        if num ^ k in xor_set:\n            return True\n        xor_set.add(num)\n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value k where there exist two integers in the list such that\n    their XOR is equal to k.\n    \"\"\"\n    return [3, 5, 9, 2, 7], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 107,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there exists a pair of numbers in the list such that their XOR is equal to the target value.\n    \n    Example:\n    nums = [4, 5, 6, 7, 8]\n    target = 12\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a pair of numbers in the list, 4 and 8, such that their XOR is equal to the target value 12.\n    \"\"\"\n\n    def find_pair(nums, target, start, path, result):\n        if target == 0:\n            result[0] = True\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            find_pair(nums, target ^ nums[i], i + 1, path, result)\n            path.pop()\n\n    result = [False]\n    nums.sort()\n    find_pair(nums, target, 0, [], result)\n    return result[0]\n\ndef g() -> List[int]:\n    nums = [4, 5, 6, 7, 8]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 447,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, target_sum: int) -> bool:\n    \"\"\"Find if there exists a list of n positive integers such that their sum is equal to target_sum.\"\"\"\n    def helper(n, target_sum, curr_sum):\n        if n == 0:\n            return curr_sum == target_sum\n        for i in range(1, target_sum + 1):\n            if helper(n - 1, target_sum, curr_sum + i):\n                return True\n        return False\n    \n    return helper(n, target_sum, 0)\n\ndef g(n=3, target_sum=10):\n    return n, target_sum\n\nassert f(*g())\n",
        "idx_generation": 94,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every two nodes are connected to each other by a path.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The graph has 2 connected components:\n    - Component 1: Nodes 0, 1\n    - Component 2: Nodes 2, 3\n\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node):\n        stack = [node]\n        while stack:\n            curr = stack.pop()\n            if not visited[curr]:\n                visited[curr] = True\n                for neighbor in range(len(matrix)):\n                    if matrix[curr][neighbor] == 1 and not visited[neighbor]:\n                        stack.append(neighbor)\n    \n    n = len(matrix)\n    visited = [False] * n\n    count = 0\n\n    for node in range(n):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n    \n    return count\n\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == 2\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        current_node = stack.pop()\n        if current_node == end:\n            return True\n        visited.add(current_node)\n        if current_node in graph:\n            for neighbor in graph[current_node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    return False\n\ndef g(graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': ['F'], 'F': []}, start = 'A', end = 'F'):\n    return graph\n\nassert f(g(), 'A', 'F') == True\n",
        "idx_generation": 188,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, g1: List[List[int]], g2: List[List[int]]) -> bool:\n    \"\"\"\n    Given two graphs g1 and g2, find if there exists a subset of nodes in g1 such that the number of nodes in the subset is equal to k,\n    and the number of edges between the nodes in the subset in g1 is equal to the number of edges between the nodes in g2.\n    \"\"\"\n    def dfs(node, graph, visited):\n        count = 1\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                count += dfs(neighbor, graph, visited)\n        return count\n\n    def count_edges(nodes, graph):\n        edges = 0\n        for node in nodes:\n            for neighbor in graph[node]:\n                if neighbor in nodes:\n                    edges += 1\n        return edges // 2\n\n    visited = set()\n    for node in range(n):\n        if node not in visited:\n            size_g1 = dfs(node, g1, visited)\n            size_g2 = dfs(node, g2, visited)\n            if size_g1 == k and count_edges(range(n), g1) == count_edges(range(n), g2):\n                return True\n    return False\n\ndef g():\n    g1 = [[0, 1], [0, 2], [1, 2], [2, 3]]\n    g2 = [[0, 1], [0, 2], [1, 2], [2, 3]]\n    return len(g1), 3, g1, g2\n\nassert f(*g())\n",
        "idx_generation": 94,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if it contains a cycle.\n    Return True if the graph contains a cycle, otherwise return False.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    \n    def dfs(node, parent):\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        \n        return False\n    \n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    \n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of positive integers nums and a target value, determine the number of unique combinations of elements in nums that add up to the target.\n    Each number in nums may only be used once in each combination.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    Sample Output:\n    3\n\n    Explanation:\n    The unique combinations that add up to 7 are [1, 2, 4], [1, 3, 3], and [2, 5].\n    \"\"\"\n\n    def helper(nums, target, start, curr_sum, count):\n        if curr_sum == target:\n            count += 1\n            return count\n        if curr_sum > target or start == len(nums):\n            return count\n        \n        for i in range(start, len(nums)):\n            count = helper(nums, target, i + 1, curr_sum + nums[i], count)\n        \n        return count\n\n    return helper(nums, target, 0, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\n\n    Example:\n    Input: n = 2\n    Output: 91\n    Explanation: The answer should be the total numbers in the range of 0 <= x < 100, where all numbers have unique digits.\n    The numbers with repeating digits are: 11, 22, 33, 44, 55, 66, 77, 88, 99. Therefore, the count is 91.\n\n    Input: n = 1\n    Output: 10\n    Explanation: The answer should be the total numbers in the range of 0 <= x < 10, where all numbers have unique digits.\n    The numbers with repeating digits are: None. Therefore, the count is 10.\n    \"\"\"\n    count = 0\n    for i in range(10 ** n):\n        num = str(i)\n        if len(set(num)) == len(num):\n            count += 1\n    return count\n\ndef g(n: int = 2):\n    return n\n\nassert f(g()) == 91\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the first and last positions of the target in the list.\n    If the target is not found in the list, return [-1, -1].\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    start, end = -1, -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            start = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            end = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return [start, end]\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [3, 4]\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Return the index of the target element if found, otherwise return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n\n    The target element 3 is found at index 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(arr, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in non-decreasing order using the Bubble Sort algorithm.\n    \"\"\"\n    n = len(nums)\n    \n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    \n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an unsorted list of integers for Puzzle 4.\n    \"\"\"\n    return [5, 2, 8, 1, 3, 9, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5, 8, 9]\n",
        "idx_generation": 273,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations of numbers in nums that add up to the target.\n    Each number in nums may only be used once in each combination.\n    Return a list of lists containing the combinations in ascending order.\n    \"\"\"\n    def backtrack(start: int, remain: int, path: List[int]) -> None:\n        if remain == 0:\n            combinations.append(path)\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > remain:\n                break\n            backtrack(i + 1, remain - nums[i], path + [nums[i]])\n\n    nums.sort()\n    combinations = []\n    backtrack(0, target, [])\n    return combinations\n\ndef g():\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return (nums, target)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 450,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of elements whose XOR is equal to the target.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr\n\narr = [1, 2, 3, 4, 5, 6]\ntarget = 7\nassert f(g(arr, target), target)\n",
        "idx_generation": 338,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    f(nums) => 24\n\n    Explanation: The maximum product can be obtained by multiplying 2, 3, and 4 (2 * 3 * 4 = 24).\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n",
        "idx_generation": 206,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the maximum size of a square submatrix that contains only 1s.\n\n    Example:\n    Input: matrix = [\n                      [1, 0, 1, 0, 0],\n                      [1, 0, 1, 1, 1],\n                      [1, 1, 1, 1, 1],\n                      [1, 0, 0, 1, 0]\n                    ]\n    Output: 4\n\n    Explanation: The largest square submatrix with only 1s is highlighted in the matrix above.\n\n    Note:\n    - The input matrix will be a binary matrix, consisting only of 0s and 1s.\n    - The maximum size of the input matrix is 300 x 300.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size ** 2\n\ndef g() -> List[List[int]]:\n    return [\n              [1, 0, 1, 0, 0],\n              [1, 0, 1, 1, 1],\n              [1, 1, 1, 1, 1],\n              [1, 0, 0, 1, 0]\n           ]\n\nassert f(g()) == 4\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort them in lexicographic order. If two words are anagrams, sort them based on their original order.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\"]\n\n    After sorting, the list should be [\"cat\", \"tac\", \"dog\", \"god\"].\n\n    Therefore, the function should return [\"cat\", \"tac\", \"dog\", \"god\"].\n    \"\"\"\n    sorted_words = []\n\n    anagram_map = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagram_map:\n            anagram_map[sorted_word].append(word)\n        else:\n            anagram_map[sorted_word] = [word]\n\n    for sorted_word in sorted(anagram_map.keys()):\n        sorted_words.extend(anagram_map[sorted_word])\n\n    return sorted_words\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words for Puzzle 4.\n    \"\"\"\n    return [\"cat\", \"dog\", \"tac\", \"god\"]\n\nassert f(g()) == [\"cat\", \"tac\", \"dog\", \"god\"]\n\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray with at most three elements.\n    Return the maximum product.\n    \"\"\"\n    n = len(nums)\n    if n < 3:\n        return 0\n    max_product = float('-inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                current_product = nums[i] * nums[j] * nums[k]\n                max_product = max(max_product, current_product)\n    return max_product\n\ndef g(nums: List[int]) -> int:\n    \"\"\"\n    Generate a list of integers such that the maximum product of a subarray with at most three elements is achieved.\n    \"\"\"\n    return nums\n\n# Test case\nnums = [1, 2, 3, 4, 5, 6]\nassert f(g(nums)) == 120\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Determine if two strings are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    count = [0] * 26\n    \n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n    \n    for c in count:\n        if c != 0:\n            return False\n    \n    return True\n\n\ndef g(s1='abc', s2='cba'):\n    return s1, s2\n\nassert f(*g()) == True\n\n",
        "idx_generation": 96,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers arr, return True if there exists a subsequence (not necessarily contiguous) such that the sum of its\n    elements is divisible by 5, otherwise return False.\n    \"\"\"\n    def is_divisible_by_5(n: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is divisible by 5.\n        \"\"\"\n        return n % 5 == 0\n    \n    def compute_subsequences(nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Helper function to compute all possible subsequences of a list of integers.\n        \"\"\"\n        subsequences = [[]]\n        for num in nums:\n            for i in range(len(subsequences)):\n                current_subsequence = subsequences[i]\n                subsequences.append(current_subsequence + [num])\n        return subsequences\n    \n    subsequences = compute_subsequences(arr)\n    \n    for subsequence in subsequences:\n        subsequence_sum = sum(subsequence)\n        if is_divisible_by_5(subsequence_sum):\n            return True\n    \n    return False\n\ndef g() -> List[int]:\n    arr = [3, 7, 2, 9, 1]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of any two distinct numbers in the list.\n    \"\"\"\n    max_product = float('-inf')\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i+1, n):\n            product = numbers[i] * numbers[j]\n            max_product = max(max_product, product)\n    return max_product\n\ndef g():\n    numbers = [3, 7, 2, 4, 5, 1]\n    return numbers\n\nassert f(g()) == 35\n\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n!.\n\n    Sample input:\n    5\n\n    Sample output:\n    1\n    \"\"\"\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return a new array where each element is the product of all the elements in the original array except itself.\n\n    Example:\n    arr = [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The product of all elements in the original array except 1 is 24. The product of all elements except 2 is 12, and so on.\n\n    Note: You may assume that the input array does not contain any zeros.\n    \"\"\"\n    n = len(arr)\n    result = [1] * n\n\n    product = 1\n    for i in range(n):\n        result[i] *= product\n        product *= arr[i]\n\n    product = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= product\n        product *= arr[i]\n\n    return result\n\n\ndef g():\n    arr = [1, 2, 3, 4]\n    return arr\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 325,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], and the sum is 6.\n\n    Return the maximum sum.\n\n    Hint: Use Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n    \n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    \n    Explanation:\n    The product of all the numbers except 1 is 2 * 3 * 4 = 24.\n    The product of all the numbers except 2 is 1 * 3 * 4 = 12.\n    The product of all the numbers except 3 is 1 * 2 * 4 = 8.\n    The product of all the numbers except 4 is 1 * 2 * 3 = 6.\n    \"\"\"\n    n = len(nums)\n    left = [1] * n\n    right = [1] * n\n    result = [1] * n\n    \n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n    \n    for i in range(n):\n        result[i] = left[i] * right[i]\n    \n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if there exists a subset of the integers that adds up to the target sum.\n    \"\"\"\n    def dfs(index, cur_sum):\n        if cur_sum == target:\n            return True\n        if index >= len(nums) or cur_sum > target:\n            return False\n        if dfs(index + 1, cur_sum + nums[index]):\n            return True\n        if dfs(index + 1, cur_sum):\n            return True\n        return False\n    \n    return dfs(0, 0)\n\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n\n    left, right = 0, n\n\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n\n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    return 25  # Example perfect square\n\nassert f(g())\n",
        "idx_generation": 433,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"Remove all consecutive duplicate characters from a string.\"\"\"\n    stack = []\n    for char in string:\n        if not stack or char != stack[-1]:\n            stack.append(char)\n    return ''.join(stack)\n\ndef g():\n    return \"aabbbccccdeeeefffg\"\n\nassert f(g()) == \"abcdefg\"\n",
        "idx_generation": 130,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence in the array.\n\n    Sample Input:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101] with a length of 4.\n\n    Sample Input:\n    arr = [0, 1, 0, 3, 2, 3]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3] with a length of 4.\n    \"\"\"\n\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\n\nassert f(g()) == 4\n",
        "idx_generation": 436,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a grid of characters, rotate the grid 90 degrees clockwise.\n    Return the rotated grid.\n\n    Example:\n    grid = [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\n    Output:\n    [['g', 'd', 'a'],\n     ['h', 'e', 'b'],\n     ['i', 'f', 'c']]\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    rotated = [[''] * n for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            rotated[j][n-i-1] = grid[i][j]\n    return rotated\n\ndef g():\n    \"\"\"\n    Generate a grid of characters.\n    \"\"\"\n    return [['a', 'b', 'c'],\n            ['d', 'e', 'f'],\n            ['g', 'h', 'i']]\n\nassert f(g()) == [['g', 'd', 'a'],\n                  ['h', 'e', 'b'],\n                  ['i', 'f', 'c']]\n",
        "idx_generation": 309,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    output: 6\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"world hello\"\n\n    Hint: Use string split to split the string into words, reverse the list of words, and join them back into a string.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(g()) == \"world hello\"\n",
        "idx_generation": 449,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Return the length as an integer.\n\n    Example:\n    f(\"abcabcbb\") => 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i in range(len(s)):\n        if s[i] in char_map and start <= char_map[s[i]]:\n            start = char_map[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_map[s[i]] = i\n\n    return max_length\n\ndef g():\n    return (\"abcabcbb\",)\n\nassert f(g()) == True\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=12) -> bool:\n    \"\"\"\n    Given a list of positive integers and a target number, determine if it is possible to select a subset of the\n    numbers such that the sum of the subset equals the target number. You can use bitwise operators to select the\n    numbers in the subset.\n    \"\"\"\n    n = len(nums)\n    for i in range(1, 2**n):\n        subset_sum = sum([nums[j] for j in range(n) if (i & (1 << j))])\n        if subset_sum == target:\n            return True\n    return False\n\ndef g(target=12):\n    nums = [1, 4, 5, 2, 3]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, return the number of unique paths from the top-left corner of an n x m grid\n    to the bottom-right corner. You can only move down or right at any point in time.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g(n=3, m=3):\n    return n, m\n\nassert f(*g()) == 6\n",
        "idx_generation": 102,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', determine if there exists a path in the graph formed by the numbers such that the sum of the path is equal to the target.\n    Each number in the list can be used multiple times to form a path.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Path: 1 -> 1 -> 1 -> 1\n    The sum of the path is equal to the target, so the function should return True.\n    \"\"\"\n    def dfs(current_sum: int, index: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums) or current_sum > target:\n            return False\n        for i in range(index, len(nums)):\n            if dfs(current_sum + nums[i], i):\n                return True\n        return False\n\n    return dfs(0, 0)\n\ndef g(nums=[1, 2, 3], target=4):\n    \"\"\"\n    Generate a list of integers 'nums' and a target integer 'target' such that there exists a path in the graph formed by the numbers such that the sum of the path is equal to the target.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a shortest path from start to end in the graph.\n    Return True if there is a shortest path, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There is a shortest path from vertex 0 to vertex 3 in the given graph.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    distances = [float('inf')] * n\n    distances[start] = 0\n\n    queue = [start]\n\n    while queue:\n        node = queue.pop(0)\n\n        if node == end:\n            return True\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and distances[node] + 1 < distances[neighbor]:\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of unique paths to reach the destination (n, n) in a grid.\n    You can only move either down or right at any point in time.\n    \"\"\"\n    dp = [[1] * n] * n\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    return dp[n - 1][n - 1]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, tree: Dict[str, List[str]]) -> bool:\n    \"\"\"\n    Given a string and a tree represented as a dictionary,\n    return True if there is a path from the root node to a leaf node that spells out the given string, \n    otherwise return False.\n    \"\"\"\n    def dfs(node: str, depth: int, path: str) -> bool:\n        if path == s:\n            return True\n        if depth == 0 or node not in tree:\n            return False\n        for child in tree[node]:\n            if dfs(child, depth - 1, path + child):\n                return True\n        return False\n    \n    root = list(tree.keys())[0]\n    return dfs(root, len(s), root)\n\ndef g(tree: Dict[str, List[str]]) -> Tuple[str, Dict[str, List[str]]]:\n    \"\"\"\n    Generate a string by traversing the tree using depth-first search (DFS).\n    Return the generated string and the tree itself.\n    \"\"\"\n    def dfs(node: str, depth: int, path: str):\n        nonlocal tree\n        if depth == 0:\n            return\n        if node not in tree:\n            return\n        children = tree[node]\n        for child in children:\n            path += child\n            dfs(child, depth - 1, path)\n            path = path[:-1]\n    \n    root = list(tree.keys())[0]\n    path = root\n    dfs(root, len(root), path)\n    return path, tree\n\ntree = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['F'],\n    'D': ['G'],\n    'E': ['H'],\n    'F': ['I']\n}\nassert f(g(tree)[0], tree)\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=100, k=3) -> bool:\n    \"\"\"\n    Given a list of positive integers, find if there exists a combination of k numbers that sum up to the target.\n    Return True if such combination exists, False otherwise.\n    \"\"\"\n\n    def backtrack(start, k, curr_sum):\n        if k == 0:\n            return curr_sum == target\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, k - 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, k, 0)\n\n\ndef g(nums=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], target=100, k=3):\n    \"\"\"\n    Generate a combination of k numbers from the given list nums that sum up to the target.\n    \"\"\"\n\n    def generate_combination(start, k, curr_sum, combination):\n        if k == 0:\n            if curr_sum == target:\n                return combination\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, k - 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, k, 0, [])\n\n\nassert f(g()) == True\n",
        "idx_generation": 17,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of ways to reach the target sum by combining the numbers in the given list,\n    where each number can be used multiple times.\n    \"\"\"\n    if target == 0:\n        return 1\n    \n    ways = 0\n    for num in nums:\n        if target - num >= 0:\n            ways += f(nums, target - num)\n    \n    return ways\n\ndef g(nums=[1, 2, 3], target=4):\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers from the array that add up to the target value.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Return a list containing the two numbers that add up to the target value.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The sum of 2 and 7 is 9, so the function should return [2, 7].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers and a target value for Puzzle 3.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 12\n\nassert f(*g()) == [2, 10]\n\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there exists two numbers in the list such that their sum is equal to the target value.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6], target = 8\n    Output: True\n\n    Explanation: There exists two numbers in the list, 2 and 6, that sum up to 8.\n\n    Constraints:\n    - The input list is sorted in ascending order.\n    - The length of the list is at most 10^5.\n    - The elements in the list are unique integers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=8) -> List[int]:\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer,\n    determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to 9, so the function should return True.\n\n    Hint: Use the two-pointer technique to search for the pair of numbers.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums = [1, 2, 4, 7, 11, 15], target = 9):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there exist two numbers in the list that add up to the target.\n    The list is sorted in non-decreasing order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True (There exist two numbers, 2 and 7, that add up to 9)\n\n    Hint: Use the two-pointer technique to solve this problem efficiently.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == True\n\n",
        "idx_generation": 453,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists three elements in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 3, 4, and 5 have bitwise XOR of 3, which is equal to the target value 6.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            curr_xor = nums[i] ^ nums[left] ^ nums[right]\n\n            if curr_xor == target:\n                return True\n            elif curr_xor < target:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 6) == True\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"Check if a 2D grid is a magic square.\"\"\"\n    n = len(grid)\n    target_sum = n * (n * n + 1) // 2\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    diag_sum = sum(grid[i][i] for i in range(n))\n    anti_diag_sum = sum(grid[i][n - i - 1] for i in range(n))\n    return all(sum == target_sum for sum in row_sums + col_sums + [diag_sum, anti_diag_sum])\ndef g(grid=[[8, 1, 6], [3, 5, 7], [4, 9, 2]]):\n    return grid\nassert f(g()) == True\n",
        "idx_generation": 243,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    An increasing path is defined as a path in the grid where each cell is greater than the previous cell.\n    Return the length of the longest increasing path.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    f(grid) => 4\n    Explanation: The longest increasing path is [1, 2, 6, 9], which has a length of 4.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(row, col):\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        longest_path = 1\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if new_row >= 0 and new_row < rows and new_col >= 0 and new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                longest_path = max(longest_path, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = longest_path\n        return longest_path\n\n    max_path = 0\n    for row in range(rows):\n        for col in range(cols):\n            max_path = max(max_path, dfs(row, col))\n\n    return max_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, find the k most frequent words in the list.\n    Return the words in a list sorted by their frequency, with the most frequent word at the beginning.\n\n    Example:\n    Input: words = [\"cat\", \"cat\", \"dog\", \"dog\", \"dog\", \"mouse\"], k = 2\n    Output: [\"dog\", \"cat\"]\n\n    Explanation:\n    The word \"dog\" appears 3 times, which is the most frequent word.\n    The word \"cat\" appears 2 times, which is the second most frequent word.\n    Therefore, the output is [\"dog\", \"cat\"].\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    return sorted_words[:k]\n\ndef g() -> Tuple[List[str], int]:\n    \"\"\"\n    Generate a list of words and an integer k, where the k most frequent words can be found in the list.\n    \"\"\"\n    return ([\"cat\", \"cat\", \"dog\", \"dog\", \"dog\", \"mouse\"], 2)\n\nassert f(*g()) == [\"dog\", \"cat\"]\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Check if it is possible to select k numbers from the given list such that their sum is equal to the target.\n    \"\"\"\n    nums.sort()  # Sort the list in ascending order\n    \n    def backtrack(curr_sum, start, count):\n        if curr_sum == target and count == k:\n            return True\n        if curr_sum > target or count > k:\n            return False\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            \n            if backtrack(curr_sum + nums[i], i + 1, count + 1):\n                return True\n        \n        return False\n    \n    return backtrack(0, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 15\n    k = 3\n    return nums, target, k\n\nassert f(*g())\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(x: str) -> bool:\n    \"\"\"Check if the given string contains an anagram of the word 'python'.\"\"\"\n    return sorted('python') in [sorted(x[i:i+6]) for i in range(len(x)-5)]\n\ndef g():\n    return 'python' + 'y' + 'thon'\n\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        if len(s) <= 1:\n            return True\n        if s[0] != s[-1]:\n            return False\n        return is_palindrome(s[1:-1])\n    \n    return is_palindrome(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Note:\n    - You may assume that there is exactly one solution.\n    - The same element may not be used twice.\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of subarrays with an odd sum.\n    A subarray is a contiguous subsequence of the original array.\n    \n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    \n    Sample Output:\n    9\n    Explanation: The subarrays with an odd sum are [1], [1, 2, 3], [2, 3], [1, 2, 3, 4, 5], [3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 4], [3, 4].\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if sum(nums[i:j+1]) % 2 != 0:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers with values from 1 to 5.\n    \"\"\"\n    return list(range(1, 6))\n\nassert f(g()) == 9\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle with n rows.\n\n    Pascal's triangle is a triangular array of binomial coefficients. Each number is the sum of the two numbers above it.\n    The first row is [1], and each subsequent row is constructed by adding the adjacent numbers from the previous row.\n\n    Return the Pascal's triangle as a 2D list.\n\n    Example:\n    Input: n = 5\n    Output: [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n    \"\"\"\n    triangle = []\n\n    for i in range(n):\n        row = [1] * (i + 1)\n\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n\n        triangle.append(row)\n\n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [\n    [1],\n    [1, 1],\n    [1, 2, 1],\n    [1, 3, 3, 1],\n    [1, 4, 6, 4, 1]\n]\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the sum of all the previous elements in the list.\n\n    Example:\n    Input: nums = [1,2,3,4,5]\n    Output: [1, 3, 6, 10, 15]\n\n    Explanation: The sum of the previous elements for each element in the list is [1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5] = [1, 3, 6, 10, 15].\n    \"\"\"\n\n    prefix_sum = []\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        prefix_sum.append(current_sum)\n\n    return prefix_sum\n\ndef g():\n    nums = [1,2,3,4,5]\n    return nums\n\nassert f(g()) == [1, 3, 6, 10, 15]\n\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if the given number is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    \n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in nums that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    f(nums, target) => [0, 1]\n    Explanation: The numbers at indices 0 and 1, which are 2 and 7 respectively, add up to 9.\n\n    \"\"\"\n\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n\n    return []\n\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\n    Use a stack to check for balanced parentheses.\n\n    Example:\n    Input: \"({[]})\"\n    Output: True\n    \"\"\"\n    stack = []\n\n    for char in s:\n        if char in \"({[\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            if char == \")\" and stack[-1] == \"(\":\n                stack.pop()\n            elif char == \"}\" and stack[-1] == \"{\":\n                stack.pop()\n            elif char == \"]\" and stack[-1] == \"[\":\n                stack.pop()\n            else:\n                return False\n\n    return len(stack) == 0\n\ndef g(s=\"({[]})\"):\n    return [s]\n\nassert f(*g()) == True\n",
        "idx_generation": 164,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], dfs(x, y))\n\n        dp[i][j] += 1\n        return dp[i][j]\n\n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if the given grid is a valid Sudoku solution.\n    Each row, column, and 3x3 sub-grid should contain all numbers from 1 to 9 without repetition.\n    \"\"\"\n    n = len(grid)\n    \n    # Check rows\n    for row in grid:\n        if not is_valid(row):\n            return False\n    \n    # Check columns\n    for col in range(n):\n        column = [grid[row][col] for row in range(n)]\n        if not is_valid(column):\n            return False\n    \n    # Check 3x3 sub-grids\n    for i in range(0, n, 3):\n        for j in range(0, n, 3):\n            sub_grid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if not is_valid(sub_grid):\n                return False\n    \n    return True\n\ndef is_valid(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of numbers is valid, i.e., contains all numbers from 1 to 9 without repetition.\n    \"\"\"\n    num_set = set(nums)\n    return len(num_set) == 9 and all(num in num_set for num in range(1, 10))\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 350,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum along a path from the top-left cell to the bottom-right cell.\n    You can only move down or right at any point in time.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    \n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n        \n    for j in range(1, cols):\n        grid[0][j] += grid[0][j-1]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += max(grid[i-1][j], grid[i][j-1])\n            \n    return grid[-1][-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest common prefix among all the elements.\n\n    Example:\n    Input: [\"flower\", \"flow\", \"flight\"]\n    Output: 2\n\n    Explanation:\n    The longest common prefix is \"fl\".\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    min_length = float('inf')\n    for word in nums:\n        min_length = min(min_length, len(word))\n\n    longest_prefix = \"\"\n    for i in range(min_length):\n        char = nums[0][i]\n        for j in range(1, len(nums)):\n            if nums[j][i] != char:\n                return len(longest_prefix)\n        longest_prefix += char\n\n    return len(longest_prefix)\n\ndef g() -> List[int]:\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 451,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, find the longest palindromic substring.\n\n    Example:\n    s = \"babad\"\n\n    The longest palindromic substring in \"babad\" is \"bab\".\n\n    Therefore, the function should return \"bab\".\n    \"\"\"\n\n    n = len(s)\n    longest_palindrome = \"\"\n\n    def expand_around_center(s: str, left: int, right: int) -> str:\n        \"\"\"\n        Expand around a center character to find a palindrome.\n        \"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n\n    for i in range(n):\n        # Check for odd-length palindromes\n        palindrome = expand_around_center(s, i, i)\n        if len(palindrome) > len(longest_palindrome):\n            longest_palindrome = palindrome\n        \n        # Check for even-length palindromes\n        palindrome = expand_around_center(s, i, i+1)\n        if len(palindrome) > len(longest_palindrome):\n            longest_palindrome = palindrome\n    \n    return longest_palindrome\n\ndef g() -> str:\n    s = \"babad\"\n    return s\n\nassert f(g()) == \"bab\"\n\n",
        "idx_generation": 185,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, pattern='abc') -> bool:\n    \"\"\"\n    Given a string and a pattern string, determine if the pattern is present in the string using bit manipulation.\n    The pattern can contain the characters 'a', 'b', and 'c', where 'a' represents 0, 'b' represents 1, and 'c'\n    represents a wildcard that can be either 0 or 1.\n    \"\"\"\n    n = len(string)\n    m = len(pattern)\n    for i in range(n - m + 1):\n        match = True\n        for j in range(m):\n            if pattern[j] == 'a' and string[i + j] != '0':\n                match = False\n                break\n            elif pattern[j] == 'b' and string[i + j] != '1':\n                match = False\n                break\n            elif pattern[j] == 'c':\n                continue\n        if match:\n            return True\n    return False\n\ndef g(pattern='abc'):\n    string = '11010011'\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 116,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two positive integers n and m, determine if n is a power of m.\n    \"\"\"\n    if n == 1:\n        return True\n    if n < m:\n        return False\n    return f(n / m, m)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and m where n is a power of m.\n    \"\"\"\n    return 64, 2\n\nassert f(*g()) == True\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"Check if there exists a path in the given graph from the start node to the end node.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    \"\"\"Generate a graph with nodes and edges\"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['A']\n    }\n    return graph\n\nassert f(g())\n",
        "idx_generation": 443,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, return a list of the in-degrees of each node.\n\n    The in-degree of a node is the number of incoming edges to that node.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [0, 0, 1, 1],\n              [0, 0, 0, 0],\n              [1, 0, 1, 0]]\n\n    The graph has 4 nodes and the adjacency matrix represents the following edges:\n    - Node 0 has an incoming edge from Node 3.\n    - Node 1 has an incoming edge from Node 0.\n    - Node 2 has incoming edges from Node 1 and Node 3.\n    - Node 3 has an incoming edge from Node 1.\n\n    Therefore, the function should return [1, 1, 2, 1].\n    \"\"\"\n    in_degrees = [0] * len(matrix)\n\n    for row in matrix:\n        for i, edge in enumerate(row):\n            if edge == 1:\n                in_degrees[i] += 1\n\n    return in_degrees\n\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [0, 0, 1, 1],\n              [0, 0, 0, 0],\n              [1, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == [1, 1, 2, 1]\n\n",
        "idx_generation": 227,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find the longest path in the graph.\n\n    Args:\n        graph: A 2D list representing the adjacency matrix of the graph. graph[i][j] = 1 if there is an edge from node i to node j, 0 otherwise.\n    \n    Returns:\n        The length of the longest path in the graph.\n\n    Note:\n        The graph is guaranteed to be a directed acyclic graph (DAG).\n    \"\"\"\n    def dfs(node: int, visited: List[bool], memo: List[int]) -> int:\n        if visited[node]:\n            return memo[node]\n        visited[node] = True\n        max_length = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                max_length = max(max_length, dfs(neighbor, visited, memo))\n        memo[node] = max_length + 1\n        return memo[node]\n\n    max_length = 0\n    visited = [False] * len(graph)\n    memo = [0] * len(graph)\n    for node in range(len(graph)):\n        max_length = max(max_length, dfs(node, visited, memo))\n    return max_length\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 1],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == 4\n",
        "idx_generation": 107,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a path from start to end in the graph.\n    Return True if there is a path, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There is a path from vertex 0 to vertex 3 in the given graph.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n\n        if node == end:\n            return True\n\n        if not visited[node]:\n            visited[node] = True\n            neighbors = graph[node]\n            stack.extend([i for i in range(len(neighbors)) if neighbors[i]])\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=100, n=5) -> bool:\n    \"\"\"Find a list of n distinct positive integers that sum to the target value.\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == target\n\ndef g(target = 100, n = 5):\n    from itertools import combinations\n    options = range(1, target)\n    for c in combinations(options, n):\n        if sum(c) == target:\n            return list(c)\n            \nassert f(g()) == True\n",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subset of nums such that\n    the sum of the subset is divisible by 3.\n    \"\"\"\n    # Solution: We can use dynamic programming to solve this problem.\n    # Let dp[i][j] be True if there exists a subset of nums[:i] such that the sum is j modulo 3.\n    # Then, dp[i][j] = dp[i-1][j] or dp[i-1][(j-nums[i])%3].\n    # The final answer is dp[len(nums)][0].\n    n = len(nums)\n    dp = [[False] * 3 for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(3):\n            dp[i][j] = dp[i - 1][j] or dp[i - 1][(j - nums[i - 1]) % 3]\n    return dp[n][0]\n    \ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The maximum product of any two numbers in the list is 20 (4 * 5).\n    Return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string containing parentheses, braces, and brackets, determine if the expression is balanced.\n\n    Example:\n    Input: \"{[()()]}\"\n    Output: True\n\n    Input: \"{[(])}\"\n    Output: False\n    \"\"\"\n    stack = []\n    opening_brackets = ['(', '[', '{']\n    closing_brackets = [')', ']', '}']\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack:\n                return False\n            last_opening_bracket = stack.pop()\n            if opening_brackets.index(last_opening_bracket) != closing_brackets.index(char):\n                return False\n    if stack:\n        return False\n    return True\n\ndef g():\n    return \"{[()()]}\"\n\nassert f(g()) == True\n",
        "idx_generation": 298,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target value.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums, target\n\nassert f(*g([2, 7, 11, 15], 9)) == [0, 1]\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the sum of any two numbers in the list is equal to the XOR of all the numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The XOR of all the numbers in the list is 1 ^ 2 ^ 3 ^ 4 ^ 5 = 3.\n\n    The sum of 2 and 3 is 5, which is equal to the XOR of all the numbers.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    xor_sum = 0\n    sum_two = set()\n\n    for num in nums:\n        xor_sum ^= num\n\n    for num in nums:\n        if (xor_sum ^ num) in sum_two:\n            return True\n        sum_two.add(num)\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the median of the list.\n    \"\"\"\n    numbers.sort()\n    n = len(numbers)\n    if n % 2 == 0:\n        median = (numbers[n // 2 - 1] + numbers[n // 2]) / 2\n    else:\n        median = numbers[n // 2]\n    return median\n\ndef g():\n    numbers = [5, 2, 9, 1, 7, 4]\n    return numbers\n\nassert f(g()) == 4.5\n\n",
        "idx_generation": 244,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nfrom typing import Optional\n\ndef f(root: Optional[TreeNode]) -> int:\n    \"\"\"\n    Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\n    A valid BST is defined as follows:\n    - The left subtree of a node contains only nodes with keys less than the node's key.\n    - The right subtree of a node contains only nodes with keys greater than the node's key.\n    - Both the left and right subtrees must also be binary search trees.\n\n    Example:\n    Input: [2,1,3]\n         2\n        / \\\n       1   3\n    Output: True\n\n    Input: [5,1,4,null,null,3,6]\n         5\n        / \\\n       1   4\n          / \\\n         3   6\n    Output: False\n    \"\"\"\n    def isValidBSTUtil(node, min_val, max_val):\n        if node is None:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return (isValidBSTUtil(node.left, min_val, node.val) and\n                isValidBSTUtil(node.right, node.val, max_val))\n\n    return isValidBSTUtil(root, float('-inf'), float('inf'))\n\ndef g():\n    \"\"\"\n    Create the following binary search tree (BST):\n         5\n        / \\\n       1   4\n          / \\\n         3   6\n    \"\"\"\n    root = TreeNode(5)\n    root.left = TreeNode(1)\n    root.right = TreeNode(4)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(6)\n    return root\n\nassert f(g()) == False\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s consisting of lowercase letters, rearrange the letters in s such that no two adjacent characters are the same.\n\n    Sample Input:\n    s = \"aab\"\n\n    Sample Output:\n    \"aba\"\n\n    Explanation:\n    One possible rearrangement of the letters is \"aba\", where no two adjacent characters are the same.\n    \"\"\"\n\n    counts = {}\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n\n    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n\n    result = \"\"\n    prev_char = None\n\n    for char, count in sorted_counts:\n        if char == prev_char:\n            return \"\"\n\n        result += char\n        prev_char = char\n        count -= 1\n\n        if count > 0:\n            sorted_counts.append((char, count))\n\n    return result\n\ndef g():\n    s = \"aab\"\n    return s\n\nassert f(g()) == \"aba\"\n",
        "idx_generation": 125,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target sum, find all unique combinations in the list where the sum of the numbers is equal to the target.\n    Each number in the list may only be used once in each combination.\n    The combinations should be sorted in ascending order.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    f(nums, target) => [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation: The combinations with a sum of 8 are [1, 1, 6], [1, 2, 5], [1, 7], [2, 6].\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], current_sum: int) -> None:\n        if current_sum == target:\n            result.append(path[:])\n            return\n\n        for i in range(start, len(nums)):\n            # Skip duplicates to avoid duplicate combinations\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n\n            # Skip numbers that will make the current sum exceed the target\n            if current_sum + nums[i] > target:\n                break\n\n            path.append(nums[i])\n            backtrack(i + 1, path, current_sum + nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g():\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 224,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the original list except the one at i.\n    \"\"\"\n    n = len(arr)\n    left_products = [1] * n\n    right_products = [1] * n\n    output = [0] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * arr[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * arr[i + 1]\n\n    for i in range(n):\n        output[i] = left_products[i] * right_products[i]\n\n    return output\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (i, j) such that i < j and nums[i] + nums[j] is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    5\n    Explanation: The distinct pairs (i, j) that satisfy the condition are (0, 2), (0, 5), (1, 3), (1, 4), (3, 5).\n\n    Sample Input:\n    nums = [3, 6, 9, 12, 15]\n\n    Sample Output:\n    10\n    Explanation: The distinct pairs (i, j) that satisfy the condition are (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4).\n\n    \"\"\"\n\n    count = 0\n    freq = [0] * 3\n\n    for num in nums:\n        freq[num % 3] += 1\n\n    count += (freq[0] * (freq[0] - 1)) // 2  # Count pairs with both elements divisible by 3\n    count += freq[1] * freq[2]  # Count pairs with one element divisible by 3 and the other divisible by 1\n    count += (freq[0] * (freq[0] - 1) * (freq[0] - 2)) // 6  # Count pairs with all elements divisible by 3\n\n    return count\n\n\ndef g(nums=[1, 2, 3, 4, 5, 6]):\n    return (nums,)\n\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 302,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \"\"\"\n    def factorial(n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    return factorial(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a non-negative integer.\n    \"\"\"\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that sum up to the target value.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    arr = [2, 7, 11, 15], target = 9\n\n    The sum of the numbers at indices 0 and 1 is 2 + 7 = 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    # Create a dictionary to store the indices of each number\n    num_to_index = {}\n\n    for i, num in enumerate(arr):\n        # Check if the complement of the current number exists in the dictionary\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        else:\n            # Add the current number and its index to the dictionary\n            num_to_index[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 267,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle of size n.\n\n    Example:\n    Input: n = 5\n    Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n\n    Explanation:\n    Pascal's triangle is a triangular array of binomial coefficients. Each number in the triangle is the sum of the two numbers directly above it.\n    \"\"\"\n\n    triangle = [[1] * (i + 1) for i in range(n)]\n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s containing a valid arithmetic expression, evaluate the expression and return the result.\n\n    Example:\n    Input: \"3 + 4 * 2 - 1\"\n    Output: 10\n\n    Explanation: The expression \"3 + 4 * 2 - 1\" evaluates to 10.\n\n    Hint: Use a stack to store the numbers and operators while evaluating the expression.\n    \"\"\"\n    stack = []\n    num = 0\n    operator = '+'\n    for i in range(len(s)):\n        if s[i].isdigit():\n            num = num * 10 + int(s[i])\n        if i == len(s) - 1 or s[i] in '+-*/':\n            if operator == '+':\n                stack.append(num)\n            elif operator == '-':\n                stack.append(-num)\n            elif operator == '*':\n                stack[-1] *= num\n            elif operator == '/':\n                stack[-1] = int(stack[-1] / num)\n            num = 0\n            operator = s[i]\n    return sum(stack)\n\ndef g():\n    return \"3 + 4 * 2 - 1\"\n\nassert f(g()) == 10\n\n",
        "idx_generation": 208,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    f(nums) => 4\n    Explanation: The longest increasing subsequence in the list is [2, 3, 7, 101], which has a length of 4.\n\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 439,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, where each cell contains a non-negative integer, calculate the sum of all the elements in the grid.\n\n    Sample Input:\n    n = 3\n    m = 4\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n\n    Sample Output:\n    78\n\n    Explanation: The sum of all the elements in the grid is 1+2+3+4+5+6+7+8+9+10+11+12 = 78.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    return total_sum\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x m with random non-negative integer values.\n    \"\"\"\n    n = 3\n    m = 4\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 78\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine the number of unique paths from the top-left corner to the\n    bottom-right corner of an n x n grid. You can only move right, down, or diagonally at each step.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or j < 0:\n            return 0\n        if i == 0 and j == 0:\n            return 1\n        return dfs(i-1, j) + dfs(i, j-1) + dfs(i-1, j-1)\n    \n    return dfs(n-1, n-1) > 0\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i, char in enumerate(s):\n        # If the character is already in the map and its index is greater than or equal to the start index\n        # Update the start index to the index of the repeated character + 1\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n\n        # Update the index of the current character in the map\n        char_map[char] = i\n\n        # Update the maximum length if the current substring length is greater\n        max_length = max(max_length, i - start + 1)\n\n    return max_length\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n    f(s, wordDict) => True\n\n    Explanation: The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n    \"\"\"\n\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            if s[i - len(word):i] == word and dp[i - len(word)]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\ndef g():\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 206,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 7\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 3 and 5, which gives 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n    \"\"\"\n    def fibonacci(n, memo):\n        if memo[n] is not None:\n            return memo[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = [None] * (n+1)\n    return fibonacci(n, memo)\n\ndef g():\n    \"\"\"\n    Return the value of n.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> int:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find the longest path from the start node to the\n    end node with at most k edges.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    k = 2\n\n    The longest path from node 0 to node 3 with at most 2 edges is: [0, 2, 3], with a length of 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(graph)\n\n    queue = [(start, 0)]\n    visited = set()\n\n    max_path_length = 0\n\n    while queue:\n        node, edges = queue.pop(0)\n\n        if node == end and edges <= k:\n            max_path_length = max(max_path_length, edges)\n\n        if edges > k:\n            continue\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and (neighbor, edges + 1) not in visited:\n                queue.append((neighbor, edges + 1))\n                visited.add((neighbor, edges + 1))\n\n    return max_path_length\n\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, 2\n\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 274,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands in the grid. An island is defined as a group of connected 1s.\n    Two 1s are considered connected if they are adjacent horizontally or vertically.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 islands in the grid:\n    - The first island is formed by the 1s at positions (0, 0), (0, 1), (1, 0), and (1, 1).\n    - The second island is formed by the 1 at position (2, 2).\n    - The third island is formed by the 1s at positions (3, 3) and (3, 4).\n    \"\"\"\n\n    def dfs(row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(row - 1, col)\n        dfs(row + 1, col)\n        dfs(row, col - 1)\n        dfs(row, col + 1)\n\n    count = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col] == 1:\n                count += 1\n                dfs(row, col)\n    return count\n\ndef g():\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n",
        "idx_generation": 108,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid consisting of 0s and 1s, where 0 represents an empty cell and 1 represents a wall,\n    find the shortest path from the top left corner to the bottom right corner of the grid.\n    You can only move down or right.\n\n    Return the length of the shortest path.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Shortest path: (0,0) -> (0,1) -> (0,2) -> (0,3) -> (0,4) -> (1,4) -> (2,4) -> (3,4) -> (4,4)\n    Length of shortest path = 8\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf') for _ in range(n)] for _ in range(m)]\n    dp[0][0] = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 8\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(grid: List[List[int]], k=3, target=15) -> bool:\n    \"\"\"Find k numbers in the grid that add up to the target sum\"\"\"\n    from itertools import combinations\n    for comb in combinations([num for row in grid for num in row], k):\n        if sum(comb) == target:\n            return True\n    return False\n\ndef g(grid=[[1, 2, 3], [4, 5, 6], [7, 8, 9]], k=3, target=15):\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 51,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers, return all unique combinations of numbers that add up to a target sum.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    Explanation:\n    - The combinations are [2, 2, 3] and [7] which add up to 7.\n    \"\"\"\n    def backtrack(combination, start, target):\n        if target == 0:\n            result.append(list(combination))\n        elif target > 0:\n            for i in range(start, len(nums)):\n                combination.append(nums[i])\n                backtrack(combination, i, target - nums[i])\n                combination.pop()\n\n    nums.sort()\n    result = []\n    backtrack([], 0, target)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value) -> None:\n        self.stack.append(value)\n\n    def pop(self) -> int:\n        if not self.is_empty():\n            return self.stack.pop()\n        return -1\n\n    def is_empty(self) -> bool:\n        return len(self.stack) == 0\n\n    def peek(self) -> int:\n        if not self.is_empty():\n            return self.stack[-1]\n        return -1\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two arrays nums1 and nums2, find the intersection of the two arrays.\n    The intersection is the set of elements that are common to both arrays and should be output in ascending order.\n\n    Example:\n    Input: nums1 = [1, 2, 2, 1], nums2 = [2, 2]\n    Output: [2]\n\n    Explanation:\n    The intersection of the two arrays is [2].\n    \"\"\"\n\n    stack1 = Stack()\n    stack2 = Stack()\n\n    for num in nums1:\n        stack1.push(num)\n    \n    for num in nums2:\n        stack2.push(num)\n\n    intersection = []\n    while not stack1.is_empty() and not stack2.is_empty():\n        num1 = stack1.pop()\n        num2 = stack2.pop()\n        if num1 == num2:\n            intersection.append(num1)\n    \n    intersection.sort()\n    return intersection\n\n\ndef g() -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Generate two arrays of integers with some overlapping elements.\n    \"\"\"\n    return ([1, 2, 2, 1], [2, 2])\n\nassert f(*g()) == [2]\n\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 1, 9, 4]\n\n    Output:\n    [1, 2, 4, 5, 9]\n    \"\"\"\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 1, 9, 4]\n\nassert f(g()) == [1, 2, 4, 5, 9]\n",
        "idx_generation": 309,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    A path can only move down or right.\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The function should return 7 since the minimum sum path is 1->3->1->1->1.\n\n    Return the minimum sum as the result.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 461,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value between two numbers in the array.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value between two numbers in the array is obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    # Function to find the maximum XOR value in a subarray\n    def max_xor_in_subarray(arr: List[int]) -> int:\n        n = len(arr)\n        max_xor = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                xor = arr[i] ^ arr[j]\n                max_xor = max(max_xor, xor)\n\n        return max_xor\n\n    # Sort the array in descending order\n    nums.sort(reverse=True)\n\n    # Find the maximum XOR value in the entire array\n    max_xor = max_xor_in_subarray(nums)\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 386,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product that can be obtained by multiplying any three numbers from the list.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 504\n",
        "idx_generation": 261,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers arr, check if the elements of the list form a binary heap.\n\n    A binary heap is a complete binary tree where each parent node is smaller (or larger) than its child nodes.\n    The elements of the list can be rearranged to form a binary heap if the heap property is satisfied.\n\n    Example:\n    Input: [3, 7, 8, 10, 15, 20]\n    Output: True\n\n    Hint: Use the properties of a binary heap to determine if the list forms a heap.\n    \"\"\"\n\n    def is_heap(arr: List[int], n: int, i: int) -> bool:\n        # Check if the given index i is a valid index in the heap\n        if i >= n:\n            return True\n\n        # Check if the current node has a left child\n        left = 2 * i + 1\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the current node has a right child\n        right = 2 * i + 2\n        if right < n and arr[i] > arr[right]:\n            return False\n\n        # Recursively check the left and right subtrees\n        return is_heap(arr, n, left) and is_heap(arr, n, right)\n\n    n = len(arr)\n    return is_heap(arr, n, 0)\n\ndef g() -> List[int]:\n    return [3, 7, 8, 10, 15, 20]\n\nassert f(g()) == True\n\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct palindromic subsequences in s.\n\n    Example:\n    Input: \"bccb\"\n    Output: 6 (The distinct palindromic subsequences are \"b\", \"c\", \"bb\", \"cc\", \"bcb\", \"bccb\")\n\n    Hint: Use dynamic programming to count the distinct palindromic subsequences.\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] * 2\n                left = i + 1\n                right = j - 1\n                while left <= right and s[left] != s[i]:\n                    left += 1\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n                if left > right:\n                    dp[i][j] += 2\n                elif left == right:\n                    dp[i][j] += 1\n                else:\n                    dp[i][j] -= dp[left + 1][right - 1]\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n\n    return dp[0][n - 1]\n\ndef g():\n    return \"bccb\"\n\nassert f(g()) == 6\n",
        "idx_generation": 151,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom itertools import permutations\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if it is possible to rearrange the characters of s such that all possible substrings of length 2 are distinct\n    \"\"\"\n    substrings = set()\n    for i in range(len(s) - 1):\n        substrings.add(s[i:i+2])\n    return len(substrings) == len(s) - 1\n\ndef g(s = 'abc'):\n    perms = [''.join(p) for p in permutations(s)]\n    return max(perms)\n\nassert f(g()) == True\n",
        "idx_generation": 146,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, a='acrnphfqkqolqjvq', b='acrnphfqkqolqjvq', length=8) -> bool:\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'acrnphfqkqolqjvq', b = 'acrnphfqkqolqjvq', length = 8):\n    def find_string(a: str, b: str, length: int) -> str:\n        if length == 0:\n            return \"\"\n        for i in range(len(a) - length + 1):\n            if a[i:i + length] in b:\n                return a[i:i + length]\n        return find_string(a, b, length - 1)\n    \n    return find_string(a, b, length)\n\nassert f(g()) == True\n",
        "idx_generation": 235,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of subarrays that have an odd sum.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 9\n\n    Explanation:\n    The subarrays with an odd sum are: [1], [2], [3], [4], [5], [1, 2, 3], [1, 2, 3, 4, 5], [2, 3, 4], [3, 4, 5].\n\n    Therefore, the function should return 9.\n    \"\"\"\n\n    count = 0\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append(prefix_sums[-1] + num)\n\n    for i in range(len(prefix_sums)):\n        for j in range(i):\n            if (prefix_sums[i] - prefix_sums[j]) % 2 != 0:\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 9\n\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all prime numbers in the list.\n    \n    Example:\n    nums = [2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    f(nums) => 17\n    Explanation: The prime numbers in the list are 2, 3, 5, and 7. Their sum is 17.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_sum = 0\n    for num in nums:\n        if is_prime(num):\n            prime_sum += num\n    \n    return prime_sum\n\ndef g():\n    return ([2, 3, 4, 5, 6, 7, 8, 9, 10],)\n\nassert f(*g()) == 17\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n    \n    return factorial\n\ndef g(n=5):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return n\n\nassert f(g()) == 120\n\n",
        "idx_generation": 386,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum subarray.\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the numbers in the list.\n    \"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return product\n\ndef g():\n    nums = [2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 120\n\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, reverse the order of the elements using a stack.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [5, 4, 3, 2, 1]\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n\n    result = []\n    while stack:\n        result.append(stack.pop())\n\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [5, 4, 3, 2, 1]\n",
        "idx_generation": 211,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D DP table to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the first row and first column of the DP table\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, cols):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 29\n\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Given three integers n, m, and k, determine if it is possible to arrange n points on a grid of size m x m such that no two points are k or less units apart.\n    \"\"\"\n    if k <= 0:\n        return n <= 1\n    if k == 1:\n        return n <= 4\n    if n <= (k+1)**2 and m >= k+1:\n        return True\n    return False\n\ndef g(n = 6, m = 5, k = 2):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with each word reversed.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation: Each word in the string is reversed individually.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n\n    Sample Input:\n    string = \"abcabcbb\"\n\n    Sample Output:\n    3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_dict = {}\n\n    for i in range(len(string)):\n        if string[i] in char_dict and start <= char_dict[string[i]]:\n            start = char_dict[string[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_dict[string[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    string = \"abcabcbb\"\n    return string\n\nassert f(g()) == 3\n\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum bitwise XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum you can obtain by choosing a subsequence such that no two elements are adjacent.\n    \"\"\"\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0], arr[1])\n    \n    dp = [0] * len(arr)\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    \n    for i in range(2, len(arr)):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    \n    return dp[-1]\n\ndef g():\n    arr = [1, 2, 3, 1]\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 109,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(maze: List[List[int]]) -> int:\n    \"\"\"\n    Given a maze represented as a 2D list of integers where 0 represents a path and 1 represents a wall,\n    find the shortest path from the top-left corner to the bottom-right corner.\n\n    Example:\n    maze = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n\n    Output:\n    8\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n\n    queue = [(0, 0, 0)]  # (row, col, distance)\n    visited = set()\n\n    while queue:\n        row, col, distance = queue.pop(0)\n\n        if row == rows - 1 and col == cols - 1:\n            return distance\n\n        if (row, col) not in visited:\n            visited.add((row, col))\n\n            if row > 0 and maze[row - 1][col] == 0:  # move up\n                queue.append((row - 1, col, distance + 1))\n            if row < rows - 1 and maze[row + 1][col] == 0:  # move down\n                queue.append((row + 1, col, distance + 1))\n            if col > 0 and maze[row][col - 1] == 0:  # move left\n                queue.append((row, col - 1, distance + 1))\n            if col < cols - 1 and maze[row][col + 1] == 0:  # move right\n                queue.append((row, col + 1, distance + 1))\n\n    return -1\n\ndef g():\n    maze = [\n        [0, 1, 1, 0, 0],\n        [0, 0, 1, 1, 0],\n        [1, 0, 0, 0, 0],\n        [1, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    return maze\n\nassert f(g()) == 8\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is bipartite or not.\n    A graph is bipartite if it is possible to split the vertices into two independent sets such that every edge connects a vertex from one set to another.\n\n    Sample Input:\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The graph can be split into two sets: [0, 2] and [1, 3], where every edge connects a vertex from one set to another.\n    \"\"\"\n\n    def is_bipartite(graph, curr_node, colors):\n        for neighbor in graph[curr_node]:\n            if colors[neighbor] == -1:\n                colors[neighbor] = 1 - colors[curr_node]\n                if not is_bipartite(graph, neighbor, colors):\n                    return False\n            elif colors[neighbor] == colors[curr_node]:\n                return False\n        \n        return True\n\n    n = len(graph)\n    colors = [-1] * n\n\n    for i in range(n):\n        if colors[i] == -1:\n            colors[i] = 0\n            if not is_bipartite(graph, i, colors):\n                return False\n    \n    return True\n\ndef g():\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if it is a tree.\n\n    Sample Input:\n    graph = [[1, 2], [0, 2], [0, 1]]\n\n    Sample Output:\n    False\n    Explanation: The graph contains a cycle, so it is not a tree.\n\n    Sample Input:\n    graph = [[1, 2], [0], [0]]\n\n    Sample Output:\n    True\n    Explanation: The graph is a tree.\n    \"\"\"\n    visited = [False] * len(graph)\n    if has_cycle(graph, 0, visited, -1):\n        return False\n    return all(visited)\n\ndef has_cycle(graph: List[List[int]], node: int, visited: List[bool], parent: int) -> bool:\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if has_cycle(graph, neighbor, visited, node):\n                return True\n        elif neighbor != parent:\n            return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph that is a tree.\n    \"\"\"\n    return [[1, 2], [0], [0]]\n\nassert f(g()) == True\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers 'n' and 'k', calculate the value of the expression (n choose k).\n\n    Return the calculated value.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    if k > n - k:\n        k = n - k\n\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n\n    return result\n\ndef g(n=10, k=3):\n    \"\"\"\n    Generate two integers 'n' and 'k' for calculating (n choose k).\n    \"\"\"\n    return n, k\n\nassert f(*g()) == 120\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique permutations of the digits 1 to n.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n    \n    return factorial(n)\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 24\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if there are two numbers in the array that add up to\n    the target. Return True if such a pair exists, and False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n\n    Explanation: The pair (2, 5) in the array adds up to the target number 7.\n\n    Note: The array is guaranteed to be sorted in ascending order.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 426,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, find if there exists a pair of numbers that sum up to the target.\n\n    Return True if such a pair exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the closest value to the target.\n    If there are multiple closest values, return the smallest one.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    closest = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return target\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n        if abs(nums[mid] - target) < abs(closest - target) or (abs(nums[mid] - target) == abs(closest - target) and nums[mid] < closest):\n            closest = nums[mid]\n    return closest\n\ndef g():\n    nums = [1, 5, 10, 15, 20]\n    target = 12\n    return nums, target\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        possible_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if prefix ^ possible_xor in prefixes:\n                max_xor = possible_xor\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for finding the maximum XOR value between any two numbers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 402,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray product.\n\n    Example:\n    Input: [2, 3, -2, 4]\n    Output: 6\n    Explanation:\n    - The contiguous subarray [2, 3] has the maximum product of 6.\n    \"\"\"\n\n    n = len(arr)\n    max_product = float('-inf')\n    curr_product = 1\n\n    for i in range(n):\n        curr_product *= arr[i]\n        max_product = max(max_product, curr_product)\n        if curr_product == 0:\n            curr_product = 1\n\n    curr_product = 1\n\n    for i in range(n-1, -1, -1):\n        curr_product *= arr[i]\n        max_product = max(max_product, curr_product)\n        if curr_product == 0:\n            curr_product = 1\n\n    return max_product\n\ndef g():\n    arr = [2, 3, -2, 4]\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28 (The maximum XOR value is obtained by XORing 5 and 25)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)\n\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == 28\n\n",
        "idx_generation": 409,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, determine the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    def length_of_lis(nums, prev, curr):\n        if curr == len(nums):\n            return 0\n        taken = 0\n        if nums[curr] > prev:\n            taken = 1 + length_of_lis(nums, nums[curr], curr + 1)\n        not_taken = length_of_lis(nums, prev, curr + 1)\n        return max(taken, not_taken)\n\n    return length_of_lis(nums, float('-inf'), 0)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be constructed by concatenating a subsequence of itself multiple times.\n    Return True if it is possible, False otherwise.\n\n    Example:\n    s = \"abcabcabc\"\n    f(s) => True\n    Explanation: The string \"abcabcabc\" can be constructed by concatenating the subsequence \"abc\" three times.\n\n    \"\"\"\n\n    def is_subsequence(sub: str, s: str) -> bool:\n        i = 0\n        for char in s:\n            if i < len(sub) and char == sub[i]:\n                i += 1\n        return i == len(sub)\n\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            sub = s[:i]\n            if is_subsequence(sub, s):\n                return True\n\n    return False\n\ndef g():\n    return \"abcabcabc\"\n\nassert f(g()) == True\n",
        "idx_generation": 185,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str], k: int) -> bool:\n    \"\"\"\n    Given a string s, a list of words, and a positive integer k, return True if it is possible to construct the string s by repeating any combination of the words in the list exactly k times. Otherwise, return False.\n\n    Example:\n    s = \"abcabcabc\"\n    words = [\"a\", \"b\", \"c\"]\n    k = 3\n\n    The string s can be constructed by repeating the words \"a\", \"b\", and \"c\" three times, so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\") and len(s) == k * sum(len(word) for word in words)\n\ndef g() -> Tuple[str, List[str], int]:\n    \"\"\"\n    Generate a string s, a list of words, and a positive integer k.\n    \"\"\"\n    return \"abcabcabc\", [\"a\", \"b\", \"c\"], 3\n\nassert f(*g()) == True\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest subarray with an equal number of 0s and 1s.\n\n    Example:\n    nums = [0, 1, 0, 0, 1, 1, 0]\n\n    The longest subarray with an equal number of 0s and 1s is [0, 1, 0, 0, 1, 1], which has a length of 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    count = 0\n    max_length = 0\n    count_dict = {0: -1}\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            count -= 1\n        else:\n            count += 1\n        \n        if count in count_dict:\n            max_length = max(max_length, i - count_dict[count])\n        else:\n            count_dict[count] = i\n    \n    return max_length\n\ndef g() -> List[int]:\n    nums = [0, 1, 0, 0, 1, 1, 0]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 344,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n\n    A matrix is considered a magic square if the sum of each row, each column, and each diagonal is equal.\n\n    Example:\n    Input: matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n\n    Explanation:\n    The matrix:\n    2 7 6\n    9 5 1\n    4 3 8\n\n    The sum of each row, each column, and each diagonal is 15.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum_1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum_2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum_1 != target_sum or diagonal_sum_2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    \n    The maximum sum of a subarray can be obtained by selecting the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target sum.\n    Return the indices of the two numbers.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    The sum of the numbers at indices 0 and 1 is 2 + 7 = 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number\n    complement_dict = {}\n\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n\n    return []\n\ndef g():\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all the duplicate elements removed.\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g():\n    nums = [1, 2, 3, 4, 2, 3, 5]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    queue = []\n    for num in nums:\n        complement = target - num\n        if complement in queue:\n            return True\n        queue.append(num)\n        if len(queue) > 2:\n            queue.pop(0)\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)\n\nassert f(*g())\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'arr', find the maximum sum of a subarray using Kadane's algorithm.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers 'arr'.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right at any point in time.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n            \n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of non-negative integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 160,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama!\"\n\nassert f(g()) == True\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\"\"\"\n    def is_palindrome(string):\n        if len(string) <= 1:\n            return True\n        elif string[0] == string[-1]:\n            return is_palindrome(string[1:-1])\n        else:\n            return False\n    \n    return is_palindrome(s)\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of set bits (1s) in its binary representation.\n    Return the count of set bits.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 2\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if the list can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    Return True if such partition is possible, otherwise return False.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[target_sum]\n\ndef g():\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and the number of nodes n,\n    return the shortest path from node 0 to each node in the graph.\n    If a node is not reachable from node 0, its distance should be -1.\n\n    Example:\n    n = 5\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n\n    The shortest path from node 0 to each node in the graph is:\n    [0, 1, 1, 1, 2]\n\n    Therefore, the function should return [0, 1, 1, 1, 2].\n    \"\"\"\n    from collections import deque\n\n    if not edges:\n        return []\n\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    distances = [-1] * n\n    distances[0] = 0\n\n    queue = deque([0])\n\n    while queue:\n        node = queue.popleft()\n\n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n\n    return distances\n\ndef g():\n    n = 5\n    edges = [[0, 1], [0, 2], [0, 3], [2, 4]]\n    return n, edges\n\nassert f(*g()) == [0, 1, 1, 1, 2]\n\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if there is a path from\n    the source node (0) to the target node in the graph.\n    \"\"\"\n    visited = [False] * len(adj_list)\n    stack = [0]\n    \n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if not visited[node]:\n            visited[node] = True\n            stack.extend(adj_list[node])\n    \n    return False\n\ndef g(adj_list: List[List[int]], target: int):\n    \"\"\"\n    Generate an adjacency list for a directed graph with n nodes and randomly assign edges.\n    \"\"\"\n    n = len(adj_list)\n    for node in range(n):\n        neighbors = []\n        for i in range(n):\n            if i != node and random.choice([True, False]):\n                neighbors.append(i)\n        adj_list.append(neighbors)\n    \n    return adj_list\n\nadj_list = [[1, 2], [3, 4], [5], [6], [6], []]\ntarget = 6\nassert f(g(adj_list, target), target)\n",
        "idx_generation": 114,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start\n    node to the end node with at most k edges.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    k = 2\n\n    There exists a path from node 0 to node 3 with at most 2 edges: [0, 1, 2, 3].\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n\n    def dfs(node, edges):\n        if node == end and edges <= k:\n            return True\n\n        if edges > k:\n            return False\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if dfs(neighbor, edges + 1):\n                    return True\n\n        return False\n\n    return dfs(start, 0)\n\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, 2\n\n\nassert f(*g()) == True\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the number of distinct permutations of a string of length n, where each character appears exactly twice.\n    \"\"\"\n    def factorial(n):\n        if n <= 1:\n            return 1\n        return n * factorial(n - 1)\n    \n    return factorial(n) // (2 ** (n // 2))\n\ndef g(n: int) -> str:\n    \"\"\"\n    Generate a string of length n, where each character appears exactly twice.\n    \"\"\"\n    import string\n    import random\n    letters = random.sample(string.ascii_lowercase, n // 2)\n    return ''.join(letters * 2)\n\nassert f(len(g(6))) == 90\n",
        "idx_generation": 88,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique binary strings of length n that do not contain any\n    consecutive 1s. For example, if n = 3, the possible binary strings are [\"000\", \"001\", \"010\", \"100\", \"101\"],\n    so the answer would be 5.\n\n    \"\"\"\n    if n == 1:\n        return 2\n    a, b = 1, 2\n    for _ in range(n - 2):\n        a, b = b, a + b\n    return b\n\n\ndef g(n: int) -> int:\n    return n\n\nn = 4\nassert f(g(n)) == 5\n",
        "idx_generation": 139,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 60\n\n    Explanation: The maximum product can be obtained by multiplying 4, 5, and 3.\n\n    Note: The list will have at least three integers.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\n\nassert f(g()) == 60\n\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport heapq\nfrom typing import List, Tuple\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, find the kth largest element in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8], k = 3\n    Output: 8\n\n    Explanation:\n    The 3rd largest element in the list is 8.\n    \"\"\"\n\n    # Use a min-heap to keep track of the k largest elements\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n\n    return heapq.heappop(heap)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 8\n\n",
        "idx_generation": 328,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(coins: List[int], amount: int) -> int:\n    \"\"\"\n    Given a list of coin denominations and an amount, find the minimum number of coins required to make up the amount,\n    using the given coins. Return -1 if it is not possible to make up the amount.\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] != float('inf') else -1\n\ndef g(coins = [1, 2, 5], amount = 11):\n    return coins, amount\n\nassert f(*g()) == 3\n",
        "idx_generation": 468,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Find the location of a target value in the given grid.\n    Return the row and column indices as a tuple.\n    If the target is not found, return (-1, -1).\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return (i, j)\n    \n    return (-1, -1)\n\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g()) == (1, 1)\n\n",
        "idx_generation": 10,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value between any two numbers in the list is 5 XOR 25 = 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in arr:\n            prefix_set.add(num & mask)\n\n        expected_xor = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if (prefix ^ expected_xor) in prefix_set:\n                max_xor = expected_xor\n                break\n\n    return max_xor\n\ndef g():\n    arr = [3, 10, 5, 25, 2, 8]\n    return arr\n\nassert f(g()) == 28\n\n",
        "idx_generation": 406,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers from the list.\n    \n    Sample Input:\n    nums = [1, 2, 3, 4]\n    \n    Sample Output:\n    24\n    Explanation: The maximum product can be achieved by multiplying 2, 3, and 4: 2 * 3 * 4 = 24.\n    \"\"\"\n    \n    if len(nums) < 3:\n        return 0\n    \n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g(nums=[1, 2, 3, 4]):\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 287,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    Return the length of the longest increasing path.\n\n    Example:\n    Input: grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Note:\n    - You can move in any of the four directions: up, down, left, or right.\n    - You may assume all elements in the grid are unique.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        longest_path = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                longest_path = max(longest_path, 1 + dfs(new_row, new_col))\n\n        memo[row][col] = longest_path\n        return longest_path\n\n    longest_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\ndef g() -> List[List[int]]:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 4\n\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the first occurrence of the target element using binary search.\n    Return the index of the first occurrence if found, otherwise return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 160,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    s_count = [0] * 26\n    t_count = [0] * 26\n    \n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        t_count[ord(t[i]) - ord('a')] += 1\n    \n    return s_count == t_count\n\ndef g():\n    s = \"anagram\"\n    t = \"nagaram\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, wordDict: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\n    Return True if s can be segmented, False otherwise.\n\n    Example:\n    s = \"leetcode\"\n    wordDict = [\"leet\", \"code\"]\n\n    The string \"leetcode\" can be segmented into \"leet\" and \"code\".\n\n    Therefore, the function should return True.\n\n    Note:\n    - The same word in the dictionary may be reused multiple times in the segmentation.\n    - You may assume the dictionary does not contain duplicate words.\n    \"\"\"\n    def dfs(s, wordDict, memo):\n        if s in memo:\n            return memo[s]\n        if s == \"\":\n            return True\n\n        for word in wordDict:\n            if s.startswith(word) and dfs(s[len(word):], wordDict, memo):\n                memo[s] = True\n                return True\n\n        memo[s] = False\n        return False\n\n    return dfs(s, wordDict, {})\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words wordDict.\n    \"\"\"\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 360,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest subarray that has the same number of even and odd elements.\n    \"\"\"\n    prefix_sum = 0\n    max_length = 0\n    prefix_sums = {0: -1}\n    count_even = 0\n    count_odd = 0\n\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n        diff = count_even - count_odd\n\n        if diff in prefix_sums:\n            length = i - prefix_sums[diff]\n            max_length = max(max_length, length)\n        else:\n            prefix_sums[diff] = i\n\n    return max_length\n\ndef g():\n    nums = [2, 2, 1, 7, 5, 3, 8, 6, 4]\n    return nums\n\nassert f(g()) == 8\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, return the index of the first occurrence of the target number in the list.\n    If the target number is not present in the list, return -1.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]\n    target = 5\n    output: 5\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 316,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a subarray whose sum is divisible by 3.\n\n    Sample input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample output:\n    True\n\n    In the given list, the subarray [1, 2] has a sum of 3, which is divisible by 3.\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sum_mod = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        prefix_sum %= 3\n        if prefix_sum in prefix_sum_mod:\n            if i - prefix_sum_mod[prefix_sum] > 1:\n                return True\n        else:\n            prefix_sum_mod[prefix_sum] = i\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 403,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if the sum of each row and column is the same.\n\n    Sample Input:\n    grid = [\n        [4, 9, 2],\n        [3, 5, 7],\n        [8, 1, 6]\n    ]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The sum of each row and column is 15.\n    \"\"\"\n    n = len(grid)\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    return len(set(row_sums)) == 1 and len(set(col_sums)) == 1\n\ndef g(grid: List[List[int]]):\n    \"\"\"\n    Find the grid that satisfies the conditions of the problem.\n    \"\"\"\n    return grid\n\nassert f(g([[4, 9, 2], [3, 5, 7], [8, 1, 6]]))\n",
        "idx_generation": 279,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the elements reversed.\n    \"\"\"\n    reversed_nums = []\n    for i in range(len(nums)-1, -1, -1):\n        reversed_nums.append(nums[i])\n    return reversed_nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid mathematical expression with balanced parentheses.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0 or stack.pop() != '(':\n                return False\n    return len(stack) == 0\n\ndef g(n: int) -> str:\n    \"\"\"\n    Generate a string of n parentheses that forms a valid mathematical expression.\n    \"\"\"\n    return '(' * n + ')' * n\n\nassert f(g(3)) == True\n",
        "idx_generation": 242,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where the elements are non-consecutive.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n    output: 12\n\n    Explanation: The maximum sum subsequence without consecutive elements is [2, 9, 1], which has a sum of 12.\n    \"\"\"\n    def max_sum_subsequence(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subsequence(arr, n-1, memo), arr[n] + max_sum_subsequence(arr, n-2, memo))\n        return memo[n]\n\n    return max_sum_subsequence(arr, len(arr)-1, {})\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [2, 7, 9, 3, 1]\n    return arr\n\nassert f(g()) == 12\n\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the number of distinct paths from the top-left corner to the bottom-right corner of a grid.\n    \"\"\"\n    rows = len(nums)\n    cols = len(nums[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = 1\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 6\n",
        "idx_generation": 180,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed and capitalized.\n\n    Example:\n    words = [\"hello\", \"world\", \"python\"]\n\n    The function should return [\"OLLEH\", \"DLROW\", \"NOHTYP\"].\n    \"\"\"\n    reversed_words = []\n    for word in words:\n        reversed_word = word[::-1]\n        reversed_word = reversed_word.upper()\n        reversed_words.append(reversed_word)\n    return reversed_words\n\ndef g():\n    words = [\"hello\", \"world\", \"python\"]\n    return words\n\nassert f(g()) == [\"OLLEH\", \"DLROW\", \"NOHTYP\"]\n",
        "idx_generation": 459,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: int) -> bool:\n    \"\"\"\n    Determine if it is possible to divide the given string into two non-empty substrings,\n    such that the sum of their ASCII values is equal to the target.\n    \"\"\"\n    def dp(i: int, j: int, target: int) -> bool:\n        if target == 0:\n            return True\n        if i >= j:\n            return False\n        if (i, j, target) in memo:\n            return memo[(i, j, target)]\n        memo[(i, j, target)] = dp(i + 1, j, target - ord(s[i])) or dp(i, j - 1, target - ord(s[j - 1]))\n        return memo[(i, j, target)]\n\n    memo = {}\n    return dp(0, len(s), target)\n\ndef g(s: str, target: int) -> str:\n    \"\"\"\n    Generate a string that can be divided into two non-empty substrings,\n    such that the sum of their ASCII values is equal to the target.\n    \"\"\"\n    def generate_string(target: int) -> str:\n        if target <= 0:\n            return \"\"\n        return chr(target // 2) + generate_string(target // 2)\n\n    return generate_string(target) + s + generate_string(target)\n\nassert f(g(\"abc\", 97), 97)\n",
        "idx_generation": 223,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, return the number of ways to climb a staircase\n    with n steps, where at each step you can either climb 1 or 2 steps, and there are\n    m different types of steps available.\n\n    Example:\n    n = 3\n    m = 2\n\n    Output:\n    3\n\n    Explanation:\n    There are 3 possible ways to climb the staircase:\n    - [1, 1, 1] using step type 1\n    - [2, 1] using step type 1 and 2\n    - [1, 2] using step type 2 and 1\n\n    \"\"\"\n\n    # Function to calculate the number of ways to climb the staircase\n    def climb_staircase(n, m, memo):\n        if n == 0:\n            return 1\n        if n < 0:\n            return 0\n        if memo[n] != -1:\n            return memo[n]\n        \n        total_ways = 0\n        for i in range(1, min(m, n) + 1):\n            total_ways += climb_staircase(n - i, m, memo)\n        \n        memo[n] = total_ways\n        return total_ways\n\n    # Initialize memoization table\n    memo = [-1] * (n + 1)\n\n    return climb_staircase(n, m, memo)\n\ndef g():\n    n = 3\n    m = 2\n    return n, m\n\nassert f(*g()) == 3\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the shortest path between two nodes.\n    Return the length of the shortest path, or -1 if no path exists.\n\n    Sample input:\n    [\n        [1, 2],\n        [0, 3, 4],\n        [0, 5, 6],\n        [1, 7],\n        [1],\n        [2],\n        [2],\n        [3]\n    ]\n\n    Sample output:\n    3\n\n    Explanation:\n    The shortest path from node 0 to node 7 is [0, 1, 3, 7], with a length of 3.\n    \"\"\"\n    start = 0\n    end = 7\n    queue = [(start, 0)]\n    visited = set()\n    \n    while queue:\n        node, distance = queue.pop(0)\n        \n        if node == end:\n            return distance\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            queue.append((neighbor, distance + 1))\n    \n    return -1\n\ndef g():\n    return [\n        [1, 2],\n        [0, 3, 4],\n        [0, 5, 6],\n        [1, 7],\n        [1],\n        [2],\n        [2],\n        [3]\n    ]\n\nassert f(g()) == 3\n",
        "idx_generation": 374,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the topological ordering of the nodes.\n\n    Sample Input:\n    graph = [[1, 2], [3], [3, 4], [4], []]\n\n    Sample Output:\n    [0, 2, 1, 3, 4]\n\n    Explanation:\n    One possible topological ordering of the graph is [0, 2, 1, 3, 4].\n    \"\"\"\n\n    def dfs(node):\n        nonlocal graph, visited, ordering\n\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n        ordering.append(node)\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    ordering = []\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            dfs(node)\n\n    return ordering[::-1]\n\ndef g():\n    graph = [[1, 2], [3], [3, 4], [4], []]\n    return graph\n\nassert f(g()) == [0, 2, 1, 3, 4]\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> int:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, find the shortest path from the start node to the\n    end node with at most k edges.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    k = 2\n\n    The shortest path from node 0 to node 3 with at most 2 edges is: [0, 2, 3], with a length of 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(graph)\n\n    queue = [(start, 0)]\n    visited = set()\n\n    while queue:\n        node, edges = queue.pop(0)\n\n        if node == end and edges <= k:\n            return edges\n\n        if edges > k:\n            continue\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and (neighbor, edges + 1) not in visited:\n                queue.append((neighbor, edges + 1))\n                visited.add((neighbor, edges + 1))\n\n    return -1\n\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph, 0, 3, 2\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 184,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of possible permutations of the digits.\n    \"\"\"\n    count = 1\n    while n > 0:\n        count *= n\n        n -= 1\n    return count\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 120\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', find if there exists a combination of 'k' distinct numbers that sum up to 'n'.\n\n    Return True if such a combination exists, False otherwise.\n\n    Additionally, optimize the solution to minimize the number of recursive calls.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int, count: int) -> bool:\n        if curr_sum == n and count == k:\n            return True\n        if curr_sum > n or count > k:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i], count + 1):\n                return True\n        return False\n    \n    return backtrack(0, 0, 0)\n\ndef g(n=10, k=3, nums=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    \"\"\"\n    Generate a list of 'k' distinct numbers from 'nums' that sum up to 'n'.\n\n    Optimize the solution to minimize the number of recursive calls.\n    \"\"\"\n    from itertools import combinations\n    \n    for combo in combinations(nums, k):\n        if sum(combo) == n:\n            return list(combo)\n    return []\n\nassert f(10, 3, g()) == True\n\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number. If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The function should return 2 since 5 is found at index 2 in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array whose sum is equal to the target.\n    Return the indices of the two numbers (1-indexed) as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [1, 2]\n\n    Explanation:\n    The sum of 2 and 7 is equal to the target value 9.\n    Therefore, the indices of the two numbers are 1 and 2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left+1, right+1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value, where there exists two numbers in the array whose sum is equal to the target value.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 350,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    The target number 3 is found at index 2.\n    Return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 468,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other\"\"\"\n    if len(s1) != len(s2):\n        return False\n    sorted_s1 = sorted(s1)\n    sorted_s2 = sorted(s2)\n    return sorted_s1 == sorted_s2\ndef g(s1='listen', s2='silent'):\n    return s1, s2\nassert f(*g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list contains a number that is a power of two.\n    \"\"\"\n    for num in arr:\n        if num > 0 and (num & (num - 1)) == 0:\n            return True\n    return False\n\ndef g(n: int) -> List[int]:\n    \"\"\"\n    Generate a list of numbers from 1 to n.\n    \"\"\"\n    return list(range(1, n+1))\n\nassert f(g(10))\n",
        "idx_generation": 412,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    If the target value is not present in the array, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9], target = 5\n\n    The target value 5 is present at index 2 in the array.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 291,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the total number of islands in the matrix.\n    An island is a group of adjacent 1s (horizontally or vertically).\n    Return the count of islands.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows, cols = len(matrix), len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or matrix[row][col] == 0:\n            return\n        visited[row][col] = True\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j] and matrix[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    \n    return count\n\ndef g():\n    matrix = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 3\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and two integers n and k, determine if there exists a subsequence of length k\n    such that the sum of the subsequence is divisible by n.\n\n    Constraints:\n    - 1 <= len(nums) <= 10^4\n    - 1 <= n <= 100\n    - 1 <= k <= len(nums)\n    - -10^9 <= nums[i] <= 10^9\n    \"\"\"\n    def helper(i, curr_sum, curr_length):\n        if curr_length == k:\n            return curr_sum % n == 0\n        if i >= len(nums):\n            return False\n        \n        # Include the current number in the subsequence\n        if helper(i + 1, curr_sum + nums[i], curr_length + 1):\n            return True\n        \n        # Exclude the current number from the subsequence\n        if helper(i + 1, curr_sum, curr_length):\n            return True\n        \n        return False\n    \n    return helper(0, 0, 0)\n\ndef g(n=5, k=3, nums=[2, 4, 6, 8, 10, 12, 14]):\n    return n, k, nums\n\nassert f(*g())\n",
        "idx_generation": 160,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Check if it is possible to form the target string by concatenating multiple occurrences of the given string.\n    \"\"\"\n    return target in s * (len(target) // len(s) + 1)\n\ndef g(s: str, target: str) -> str:\n    \"\"\"\n    Generate a string by concatenating multiple occurrences of the given string until its length is equal to or greater than the target string.\n    \"\"\"\n    n = len(s)\n    m = len(target)\n    if m < n:\n        return s[:m]\n    elif m % n == 0:\n        return s * (m // n)\n    else:\n        return s * (m // n) + s[:m % n]\n\ns = \"abc\"\ntarget = \"abcabcabc\"\nassert f(g(s, target), target) == True\n",
        "idx_generation": 203,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array 'nums' of distinct integers and a target integer, return a list of all unique quadruplets\n    [nums[a], nums[b], nums[c], nums[d]] such that:\n    - 0 <= a, b, c, d < n (where n is the length of 'nums')\n    - a, b, c, and d are distinct\n    - nums[a] + nums[b] + nums[c] + nums[d] == target\n\n    Example:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n    Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    \"\"\"\n    def threeSum(nums, target):\n        n = len(nums)\n        result = []\n\n        for i in range(n-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n\n            left = i + 1\n            right = n - 1\n\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n\n                    left += 1\n                    right -= 1\n\n        return result\n\n    nums.sort()\n    n = len(nums)\n    result = []\n\n    for i in range(n-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n\n        three_sum_result = threeSum(nums[i+1:], target - nums[i])\n\n        for triple in three_sum_result:\n            result.append([nums[i]] + triple)\n\n    return result\n\ndef g() -> Tuple:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n    return nums, target\n\nassert f(*g()) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a subarray of nums with sum equal to k.\n    Return True if such a subarray exists, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 9\n    f(nums, k) => True\n    Explanation: The subarray [2, 3, 4] has a sum of 9.\n\n    \"\"\"\n\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum == k or prefix_sum - k in prefix_sums:\n            return True\n        prefix_sums.add(prefix_sum)\n\n    return False\n\n\ndef g():\n    return [1, 2, 3, 4, 5], 9\n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a sublist whose sum is equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    There exists a sublist [2, 3, 4] whose sum is equal to the target value.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def find_sublist(nums, target):\n        \"\"\"\n        Find a sublist whose sum is equal to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n+1):\n                sublist = nums[i:j]\n                if sum(sublist) == target:\n                    return True\n\n        return False\n\n    return find_sublist(nums, target)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 350,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    n = 5\n\n    The factorial of 5 is 5! = 5 * 4 * 3 * 2 * 1 = 120.\n\n    The number of trailing zeroes in 120 is 1.\n\n    Therefore, the function should return 1.\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n\n    return count\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 1\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array nums of n integers, find the maximum possible sum of a subarray such that the subarray does not contain adjacent elements (i.e., choose elements from the array such that no two adjacent elements are selected).\n\n    Example:\n    Input: nums = [2,7,9,3,1]\n    Output: 12\n    Explanation: Choose subarray [2,9,1] with maximum sum = 12.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n",
        "idx_generation": 328,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the next permutation of the numbers.\n\n    Example:\n    Input: [1, 2, 3]\n    Output: [1, 3, 2]\n\n    Explanation: The next permutation of [1, 2, 3] is [1, 3, 2].\n    \"\"\"\n\n    def next_permutation(nums: List[int]) -> None:\n        n = len(nums)\n        i = n - 2\n        \n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        if i >= 0:\n            j = n - 1\n            while j >= 0 and nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        left = i + 1\n        right = n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    \n    next_permutation(nums)\n    return nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string of parentheses, determine if the parentheses are balanced.\n\n    Sample Input:\n    s = \"(()())\"\n\n    Sample Output:\n    True\n    Explanation: The parentheses are balanced.\n\n    Sample Input:\n    s = \"())(\"\n\n    Sample Output:\n    False\n    Explanation: The parentheses are not balanced.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g():\n    return \"(()())\"\n\nassert f(g()) == True\n",
        "idx_generation": 264,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray where the elements are non-consecutive.\n\n    However, this time, you are only allowed to skip one element in the subarray.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [3, 4, -1, 2, 1, -5, 4]\n    output: 10\n\n    Explanation: The maximum sum subarray without consecutive elements and skipping at most one element is [3, -1, 1, 4], which has a sum of 10.\n    \"\"\"\n    def max_sum_subarray(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subarray(arr, n-1, memo), arr[n] + max_sum_subarray(arr, n-2, memo), arr[n] + max_sum_subarray(arr, n-3, memo))\n        return memo[n]\n\n    return max_sum_subarray(arr, len(arr)-1, {})\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 10\n\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum value that can be obtained by traversing from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Example:\n    Input: s = \"Hello World!\"\n    Output: \"World! Hello\"\n\n    Explanation: The words in the string are \"Hello\" and \"World!\". Reversing the order of the words gives \"World! Hello\".\n    Therefore, the function should return \"World! Hello\".\n    \"\"\"\n\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g() -> str:\n    return \"Hello World!\"\n\nassert f(g()) == \"World! Hello\"\n\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be formed by concatenating the words in the list.\n\n    Example:\n    Input: s = \"leetcode\", words = [\"leet\", \"code\"]\n    Output: True\n\n    Explanation: \"leetcode\" can be formed by concatenating \"leet\" and \"code\".\n    \"\"\"\n\n    def canForm(s: str, words: List[str], memo: dict) -> bool:\n        # Base case: if s is empty, it can be formed by concatenating an empty list of words\n        if s == \"\":\n            return True\n\n        # If the current substring has already been checked, return the result from memoization\n        if s in memo:\n            return memo[s]\n\n        # Check if s can be formed by concatenating any word in the list\n        for word in words:\n            if s.startswith(word) and canForm(s[len(word):], words, memo):\n                memo[s] = True\n                return True\n\n        memo[s] = False\n        return False\n\n    return canForm(s, words, {})\n\ndef g():\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n    return s, words\n\nassert f(*g()) == True\n",
        "idx_generation": 251,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, check if there exists a pair of numbers in the list\n    whose XOR is equal to the target.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        complement = target ^ num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(arr: List[int], target: int):\n    return arr, target\n\narr = [1, 2, 3, 4, 5, 6, 7]\ntarget = 6\nassert f(*g(arr, target)) == True\n",
        "idx_generation": 139,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 5\n\n    Output:\n    5\n\n    Explanation:\n    The 5th Fibonacci number is 5.\n\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    # Initialize the Fibonacci sequence\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    # Compute the Fibonacci sequence up to the nth number\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\n\ndef g():\n    n = 5\n    return n\n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph and two nodes, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    queue = [start]\n    \n    while queue:\n        node = queue.pop(0)\n        visited.add(node)\n        \n        if node == end:\n            return True\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    return False\n\ndef g(graph={0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}, start=2, end=3):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, determine if it is bipartite.\n    A bipartite graph is a graph whose vertices can be divided into two disjoint sets\n    such that every edge connects a vertex in one set to a vertex in the other set.\n    \n    Example:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    \n    Output:\n    True\n    \"\"\"\n    n = len(graph)\n    colors = [0] * n\n    \n    def dfs(node, color):\n        colors[node] = color\n        \n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                    return False\n        \n        return True\n    \n    for node in range(n):\n        if colors[node] == 0 and not dfs(node, 1):\n            return False\n    \n    return True\n\ndef g() -> List[List[int]]:\n    graph = [[0, 1, 0, 1],\n             [1, 0, 1, 0],\n             [0, 1, 0, 1],\n             [1, 0, 1, 0]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and end, determine if there is a path from start to end in the graph.\n\n    Sample Input:\n    graph = {\n        'A': ['B'],\n        'B': ['C'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n\n    Sample Output:\n    True\n\n    Explanation: There is a path from node 'A' to node 'D' in the graph.\n\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"\n    Generate a graph represented as an adjacency list and two nodes start and end such that there is a path from start to end in the graph.\n    \"\"\"\n    graph = {\n        'A': ['B'],\n        'B': ['C'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 202,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find whether there are 3 numbers in the given list whose sum is equal to the target.\n    \"\"\"\n    from itertools import combinations\n    for c in combinations(nums, 3):\n        if sum(c) == target:\n            return True\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6], target = 9):\n    return nums\n\nassert f(g(), 9)\n\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of combinations of k elements from a set of n elements.\n    Return the number of combinations.\n\n    Example:\n    n = 5\n    k = 2\n\n    The combinations of 2 elements from a set of 5 elements are: [1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5], [4, 5].\n\n    Therefore, the function should return 10.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    elif k > n:\n        return 0\n    else:\n        return f(n - 1, k - 1) + f(n - 1, k)\n\ndef g():\n    n = 5\n    k = 2\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of integers in the list such that their sum is equal to the target value.\n    Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    arr.sort()\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    arr = [2, 7, 11, 15]\n    target = 18\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 357,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the maximum sum of a non-empty subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum sum of a subarray is [4, -1, 2, 1] which has a sum of 6.\n    So the expected output is 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, words=['apple', 'banana', 'cherry', 'date', 'elderberry']) -> bool:\n    \"\"\"\n    Check if the given string s is a concatenation of the three lexicographically smallest words from the list.\n    \"\"\"\n    sorted_words = sorted(words)\n    return s == sorted_words[0] + sorted_words[1] + sorted_words[2]\n\ndef g(words=['apple', 'banana', 'cherry', 'date', 'elderberry']):\n    return ''.join(sorted(words)[:3])\n\nassert f(g()) == True\n",
        "idx_generation": 31,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the bitwise AND of all possible pairs of elements.\n\n    Example:\n    arr = [3, 5, 6]\n    Output: 2 (bitwise AND of (3, 5) = 1, bitwise AND of (3, 6) = 2, bitwise AND of (5, 6) = 4)\n\n    Explanation:\n    The sum of the bitwise AND of all possible pairs is 1 + 2 + 4 = 7.\n    \"\"\"\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            result += arr[i] & arr[j]\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [3, 5, 6]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 413,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the other elements in the original list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the other elements in nums for each element is:\n    - For 1: 2 * 3 * 4 = 24\n    - For 2: 1 * 3 * 4 = 12\n    - For 3: 1 * 2 * 4 = 8\n    - For 4: 1 * 2 * 3 = 6\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n    output = []\n    \n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * nums[i+1]\n    \n    for i in range(n):\n        output.append(prefix_products[i] * suffix_products[i])\n    \n    return output\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid with 0s and 1s, find the largest square of 1s in the grid and return its area.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1]\n    ]\n\n    The largest square of 1s in the grid is:\n    [\n        [1, 1],\n        [1, 1]\n    ]\n\n    Therefore, the function should return 4.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    max_len = 0\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            elif grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            max_len = max(max_len, dp[i][j])\n\n    return max_len * max_len\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1]\n    ]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers arr, find the sum of the maximum sum increasing subsequence of the array.\n\n    Example:\n    Input: arr = [1, 101, 2, 3, 100, 4, 5]\n    Output: 106\n    Explanation: The maximum sum increasing subsequence is [1, 2, 3, 100], with a sum of 106.\n\n    Note:\n    - A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n    - The subsequence from which we need to find the sum must be increasing.\n    \"\"\"\n\n    n = len(arr)\n    dp = [0] * n\n\n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + arr[i])\n\n    return max(dp)\n\ndef g():\n    return [1, 101, 2, 3, 100, 4, 5]\n\nassert f(g()) == 106\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if the given two strings are anagrams of each other.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for char in s1:\n        count[ord(char) - ord('a')] += 1\n    for char in s2:\n        count[ord(char) - ord('a')] -= 1\n    return all(count[i] == 0 for i in range(26))\n\ndef g():\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n\n    Example:\n    Input: strings = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n    \"\"\"\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    for string in strings[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of strings with a common prefix.\n    \"\"\"\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there are two distinct indices i and j in the list\n    such that nums[i] - nums[j] = k.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 1\n\n    The function should return True, since nums[1] - nums[4] = 5 - 2 = 3.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 2\n\n    The function should return False, since there are no two distinct indices in the list such that nums[i] - nums[j] = 2.\n\n    Note: The indices i and j must be distinct.\n\n    \"\"\"\n\n    seen = set()\n    for num in nums:\n        if num - k in seen:\n            return True\n        seen.add(num)\n    return False\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 5, 3, 4, 2]\n    k = 1\n    return nums, k\n\n\nassert f(*g())\n",
        "idx_generation": 408,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list that contains only the prime numbers from the original list.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [num for num in nums if is_prime(num)]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [2, 3, 5, 7]\n\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    Input: n = 10\n    Output: 23\n\n    Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. Their sum is 23.\n    \"\"\"\n\n    sum = 0\n    for num in range(n):\n        if num % 3 == 0 or num % 5 == 0:\n            sum += num\n    return sum\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 23\n",
        "idx_generation": 428,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a non-empty subarray.\n    The subarray must contain at least one number.\n\n    Example:\n    Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n\n    Explanation: The subarray [4,-1,2,1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')  # Initialize the maximum sum to negative infinity\n\n    for i in range(len(nums)):\n        current_sum = 0\n\n        for j in range(i, len(nums)):\n            current_sum += nums[j]  # Add the current element to the current sum\n\n            if current_sum > max_sum:\n                max_sum = current_sum  # Update the maximum sum if the current sum is greater\n\n    return max_sum\n\ndef g():\n    nums = [-2,1,-3,4,-1,2,1,-5,4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product is 4 * 5 = 20.\n\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is a palindrome, and False otherwise.\n    A palindrome is a sequence that reads the same forwards and backwards.\n\n    Sample Input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample Output:\n    True\n    \"\"\"\n\n    # Reverse the list using a stack\n    stack = []\n    for num in nums:\n        stack.append(num)\n    \n    reverse_nums = []\n    while stack:\n        reverse_nums.append(stack.pop())\n\n    # Check if the original list and reversed list are the same\n    return nums == reverse_nums\n\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 304,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Explanation: The largest square containing only 1's is the 2x2 square at the top right corner, which has an area of 4.\n\n    Note:\n    - The input matrix can have a maximum size of 300 x 300.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_side = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    \"\"\"\n    dp = [[1] * m for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g(n=3, m=4) -> int:\n    \"\"\"\n    Generate the dimensions of the grid.\n    \"\"\"\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 199,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The maximum XOR value is 28 (25 XOR 5), so the function should return 28.\n    \"\"\"\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n                \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2]\n\nassert f(g()) == 28\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to climb to the top of a staircase, where each step can be either 1 or 2.\n\n    Example:\n    n = 4\n\n    There are 5 ways to climb to the top:\n    1. [1, 1, 1, 1]\n    2. [1, 1, 2]\n    3. [1, 2, 1]\n    4. [2, 1, 1]\n    5. [2, 2]\n\n    Therefore, the function should return 5.\n    \"\"\"\n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g() -> int:\n    n = 4\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes start and end,\n    check if there is a path from start to end in the graph.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    stack = [start]\n    \n    while stack:\n        node = stack.pop()\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph.get(node, []))\n    \n    return False\n\n\ndef g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"C\", \"D\"],\n        \"C\": [\"D\"],\n        \"D\": [\"E\"],\n        \"E\": []\n    }\n    start = \"A\"\n    end = \"E\"\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 390,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two nodes start and end,\n    determine if there is a path from start to end in the graph.\n\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]]\n\n    f(graph, 0, 3) => True\n    Explanation: There is a path from node 0 to node 3 in the graph.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        if node == end:\n            return True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start)\n\ndef g():\n    return ([[0, 1, 1, 0],\n             [0, 0, 1, 0],\n             [0, 0, 0, 1],\n             [0, 0, 0, 0]], 0, 3)\n\nassert f(*g()) == True\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a cycle in the graph.\n\n    Example:\n    Input: graph = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    Output: True\n    Explanation: The graph represents the following connections: 0 -> 1 -> 2 -> 0. There is a cycle in the graph.\n\n    Hint: Use depth-first search (DFS) to detect cycles in the graph.\n    \"\"\"\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n        stack[node] = False\n        return False\n\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n    return False\n\ndef g():\n    return [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the total number of distinct subsets that can be formed from the list.\n    \"\"\"\n    n = len(arr)\n    total_subsets = 2 ** n\n    return total_subsets\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 16\n",
        "idx_generation": 118,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate a Pascal's triangle with n number of rows.\n\n    Example:\n    n = 5\n\n    Output:\n    [\n        [1],\n        [1, 1],\n        [1, 2, 1],\n        [1, 3, 3, 1],\n        [1, 4, 6, 4, 1]\n    ]\n    \"\"\"\n\n    triangle = []\n    for i in range(n):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle.append(row)\n    \n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [\n    [1],\n    [1, 1],\n    [1, 2, 1],\n    [1, 3, 3, 1],\n    [1, 4, 6, 4, 1]\n]\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output: 24  # (2 * 3 * 4)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 428,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    arr = [5, 2, 9, 1, 7]\n\n    The function should return [1, 2, 5, 7, 9].\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\ndef g() -> List[int]:\n    arr = [5, 2, 9, 1, 7]\n    return arr\n\nassert f(g()) == [1, 2, 5, 7, 9]\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 18], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 470,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Determine if two strings are anagrams of each other.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    freq_s = [0] * 26\n    freq_t = [0] * 26\n    for i in range(len(s)):\n        freq_s[ord(s[i]) - ord('a')] += 1\n        freq_t[ord(t[i]) - ord('a')] += 1\n    return freq_s == freq_t\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings that are anagrams of each other.\n    \"\"\"\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n",
        "idx_generation": 56,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists two elements in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The elements 1 and 2 have bitwise XOR of 3, which is equal to the target value 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_xor = nums[i] ^ nums[j]\n\n            if curr_xor == target:\n                return True\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 3) == True\n\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n\n    Example:\n    Input: 7\n    Output: True\n\n    Input: 12\n    Output: False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 7\n    \nassert f(g())\n",
        "idx_generation": 335,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7 (1 + 3 + 1 + 1 + 1).\n\n    Therefore, the function should return 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + grid[0][i]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 484,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list that sum up to the target.\n    Each number in the list may only be used once in each combination.\n    Return a list of all unique combinations.\n    \"\"\"\n    result = []\n    nums.sort()\n    backtrack(nums, target, [], result)\n    return result\n\ndef backtrack(nums, target, combination, result):\n    if target == 0:\n        result.append(combination)\n        return\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        if nums[i] > target:\n            break\n        backtrack(nums[i+1:], target-nums[i], combination+[nums[i]], result)\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 217,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"Check if a string can be split into n equal parts.\"\"\"\n    if len(s) % n != 0:\n        return False\n    part_len = len(s) // n\n    parts = [s[i:i+part_len] for i in range(0, len(s), part_len)]\n    return all(parts[i] == parts[i+1] for i in range(len(parts)-1))\n\ndef g(s = \"abcabcabcabc\", n = 4):\n    return s, n\n\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome after removing a single character.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    if is_palindrome(string):\n        return True\n\n    for i in range(len(string)):\n        modified_string = string[:i] + string[i+1:]\n        if is_palindrome(modified_string):\n            return True\n\n    return False\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g())\n",
        "idx_generation": 427,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the two numbers that sum up to the target.\n    Return the indices of these two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The pair of numbers that sum up to 9 is [2, 7].\n    The indices of these numbers in the list are 0 and 1.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 13\n\nassert f(g())\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the product of all elements in the original list except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output: [24, 12, 8, 6]\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 428,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers that sum up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The pair of numbers that sum up to 9 is [2, 7].\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 344,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 or 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 33\n    Explanation: The numbers divisible by 3 or 5 are 3, 5, 6, 9, and 10. Their sum is 33.\n\n    \"\"\"\n\n    total_sum = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            total_sum += num\n\n    return total_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle that can be formed\n    by connecting adjacent buildings.\n\n    Example:\n    Input: [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The maximum area of a rectangle that can be formed is 10, which is formed by the buildings with heights 5 and 6.\n\n    Hint: Use stack to solve this problem.\n    \"\"\"\n\n    heights.append(0)\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    return max_area\n\ndef g():\n    heights = [2, 1, 5, 6, 2, 3]\n    return heights\n\nassert f(g()) == 10\n",
        "idx_generation": 341,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Note:\n    - The subarray must contain at least one element.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    current_sum = max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid with n rows and m columns, find the number of unique paths from the top-left cell to the bottom-right cell.\n\n    Example:\n    Input: n = 3, m = 3, grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    Output: 6\n\n    Explanation:\n    There are 6 unique paths: RRDD, RDRD, RDDR, DRRD, DRDR, DDRR.\n\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n\n    return dp[n-1][m-1]\n\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    n = 3\n    m = 3\n    grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    return n, m, grid\n\n\nassert f(*g()) == 6\n",
        "idx_generation": 221,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n    \n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words\n\ndef g():\n    return 'Hello World'\n\nassert f(g()) == 'World Hello'\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome after removing at most one character.\n\n    Sample Input:\n    s = \"abca\"\n\n    Sample Output:\n    True\n    Explanation: By removing 'b', the string becomes a palindrome \"aca\".\n\n    Sample Input:\n    s = \"abbca\"\n\n    Sample Output:\n    False\n    Explanation: Even after removing at most one character, the string cannot be a palindrome.\n\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g(s=\"abca\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\n\nassert f(g()) == 28\n\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if it is possible to reach the target by performing arithmetic operations (+, -, *, /) on the integers.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, path: List[int]) -> bool:\n        if start == len(nums) and target == 0:\n            return True\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            \n            if target % nums[i] == 0:\n                if backtrack(nums, target // nums[i], i + 1, path + [nums[i]]):\n                    return True\n            \n            if backtrack(nums, target - nums[i], i + 1, path + [nums[i]]):\n                return True\n            \n            if backtrack(nums, target + nums[i], i + 1, path + [nums[i]]):\n                return True\n            \n            if backtrack(nums, target * nums[i], i + 1, path + [nums[i]]):\n                return True\n        \n        return False\n    \n    return backtrack(nums, target, 0, [])\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 9)\n\nassert f(*g()) == True\n",
        "idx_generation": 136,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary and two nodes start and end,\n    check if there is a path from start to end in the graph.\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    visited = set()\n    queue = [start]\n    \n    while queue:\n        node = queue.pop(0)\n        \n        if node == end:\n            return True\n        \n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph.get(node, []))\n    \n    return False\n\ndef g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"C\", \"D\"],\n        \"C\": [\"D\"],\n        \"D\": [\"E\"],\n        \"E\": []\n    }\n    start = \"A\"\n    end = \"E\"\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 401,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]], start: int, target: int, k: int) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, determine if there is a path from start to target\n    with at most k edges.\n    \"\"\"\n    def dfs(node: int, edges: int) -> bool:\n        if edges > k:\n            return False\n        if node == target:\n            return True\n        for neighbor in adj_list[node]:\n            if dfs(neighbor, edges + 1):\n                return True\n        return False\n\n    return dfs(start, 0)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representation of a directed graph.\n    \"\"\"\n    return [[1, 2], [3], [3, 4], [4, 5], [5], []]\n\nassert f(g(), 0, 5, 3) == True\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if the given graph is a binary tree, rooted at node 0.\n    A binary tree is a tree structure in which each node has at most two children.\n    \"\"\"\n    def dfs(node: int, parent: int) -> bool:\n        if visited[node]:\n            return False\n        visited[node] = True\n        for child in graph[node]:\n            if child == parent:\n                continue\n            if not dfs(child, node):\n                return False\n        return True\n\n    n = len(graph)\n    visited = [False] * n\n    return dfs(0, -1) and all(visited)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a random binary tree.\n    \"\"\"\n    import random\n    n = random.randint(2, 10)\n    graph = [[] for _ in range(n)]\n    for i in range(1, n):\n        parent = random.randint(0, i - 1)\n        graph[parent].append(i)\n        graph[i].append(parent)\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 223,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, find the number of ways to choose k elements from a set of n elements.\n\n    Example:\n    n = 5, k = 3\n\n    The set of elements is {1, 2, 3, 4, 5}.\n\n    The possible combinations of choosing 3 elements are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n\n    Therefore, the function should return 10.\n    \"\"\"\n\n    def choose(n: int, k: int) -> int:\n        \"\"\"\n        Helper function to calculate the number of ways to choose k elements from a set of n elements.\n        \"\"\"\n\n        if k == 0 or k == n:\n            return 1\n        else:\n            return choose(n - 1, k - 1) + choose(n - 1, k)\n\n    return choose(n, k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3\n\nassert f(*g()) == 10\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, return the count and say sequence for n.\n    The count and say sequence starts with \"1\" and each subsequent term is obtained by describing the previous term.\n    For example, when n = 4: \"1\" -> \"11\" -> \"21\" -> \"1211\" -> \"111221\" -> ...\n    Return the nth term in the count and say sequence as a string.\n    \"\"\"\n    if n == 1:\n        return \"1\"\n\n    prev = f(n - 1)\n    count = 1\n    result = \"\"\n    for i in range(1, len(prev)):\n        if prev[i] == prev[i - 1]:\n            count += 1\n        else:\n            result += str(count) + prev[i - 1]\n            count = 1\n\n    result += str(count) + prev[-1]\n\n    return result\n\ndef g(n=5):\n    return n\n\nassert f(g()) == \"111221\"\n\n",
        "idx_generation": 158,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n    Return the sorted list.\n    \"\"\"\n    arr.sort()\n    return arr\n\ndef g():\n    arr = [4, 2, 7, 1, 5]\n    return arr\n\nassert f(g()) == [1, 2, 4, 5, 7]\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    target = 6\n    return (nums, target)\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 371,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [4, 8, 2, 10, 6]\n    return nums\n\nassert f(g()) == 14\n\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(words: List[str]) -> bool:\n    \"\"\"Check if there exists a pair of words in the list that are anagrams of each other.\"\"\"\n    def is_anagram(word1, word2):\n        return sorted(word1) == sorted(word2)\n    \n    n = len(words)\n    for i in range(n):\n        for j in range(i+1, n):\n            if is_anagram(words[i], words[j]):\n                return True\n    return False\n\ndef g():\n    return [\"listen\", \"silent\", \"elbow\", \"below\", \"state\", \"taste\"]\n\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Hint: Use two pointers to iterate through the list and find the pairs whose XOR is equal to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 7) == True\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    output: 20\n    \"\"\"\n    sorted_nums = sorted(nums)\n    n = len(sorted_nums)\n    \n    return max(sorted_nums[0]*sorted_nums[1], sorted_nums[n-2]*sorted_nums[n-1])\n\ndef g(nums=[1, 2, 3, 4, 5]) -> List[int]:\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the unique triplets in the list that add up to zero.\n    Return a list of lists containing the triplet values.\n\n    Example:\n    Input:\n    nums = [-1, 0, 1, 2, -1, -4]\n\n    Output:\n    [\n        [-1, 0, 1],\n        [-1, -1, 2]\n    ]\n\n    Explanation:\n    The unique triplets that add up to zero are [-1, 0, 1] and [-1, -1, 2].\n    \"\"\"\n\n    nums.sort()  # Sort the list in ascending order\n    triplets = []\n\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(nums) - 1\n\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                triplets.append([nums[i], nums[left], nums[right]])\n\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return triplets\n\ndef g():\n    nums = [-1, 0, 1, 2, -1, -4]\n    return [nums]\n\nassert f(*g()) == [[-1, -1, 2], [-1, 0, 1]]\n\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the minimum number of elements that need to be removed\n    in order to make the remaining elements in the list distinct.\n\n    Example:\n    Input: [1, 2, 2, 3, 4, 4, 5]\n    Output: 2\n\n    Explanation:\n    By removing the two 2's, the remaining elements [1, 3, 4, 5] are distinct.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    for num, frequency in freq.items():\n        if frequency > 1:\n            count += frequency - 1\n\n    return count\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 321,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 ([2, 7]) add up to 9.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        num_dict = dict()\n        \n        for i, num in enumerate(nums):\n            if target - num in num_dict:\n                return [num_dict[target - num], i]\n            num_dict[num] = i\n        \n        return []\n    \n    return two_sum(nums, target)\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 444,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive divisors of n.\n\n    Sample Input:\n    n = 12\n\n    Sample Output:\n    28\n    Explanation: The positive divisors of 12 are 1, 2, 3, 4, 6, and 12. Their sum is 1 + 2 + 3 + 4 + 6 + 12 = 28.\n\n    Sample Input:\n    n = 20\n\n    Sample Output:\n    42\n    Explanation: The positive divisors of 20 are 1, 2, 4, 5, 10, and 20. Their sum is 1 + 2 + 4 + 5 + 10 + 20 = 42.\n    \"\"\"\n    divisor_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\ndef g(n=12):\n    return n\n\nassert f(g()) == 28\n",
        "idx_generation": 423,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def backtrack(index, total):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        for i in range(index, len(nums)):\n            current_num = nums[i]\n            nums[i], nums[index] = nums[index], nums[i]\n\n            if backtrack(index + 1, total + current_num):\n                return True\n\n            nums[i], nums[index] = nums[index], nums[i]\n\n        return False\n\n    return backtrack(0, 0)\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target value, determine whether there exists a subarray in the list\n    that sums up to the target.\n\n    Return True if such a subarray exists, and False otherwise.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 9\n    Output: True\n\n    Explanation:\n    The subarray [2, 3, 4] sums up to 9.\n    \"\"\"\n\n    # Use a sliding window approach to find subarrays that sum up to the target\n    window_sum = 0\n    left = 0\n\n    for right in range(len(arr)):\n        window_sum += arr[right]\n\n        while window_sum > target:\n            window_sum -= arr[left]\n            left += 1\n\n        if window_sum == target:\n            return True\n\n    return False\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 9\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 350,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> float:\n    \"\"\"\n    Given a list of numbers, calculate the mean (average) of the numbers.\n\n    Args:\n    - nums: A list of numbers\n\n    Returns:\n    - The mean of the numbers\n    \"\"\"\n    return sum(nums) / len(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3.0\n\n",
        "idx_generation": 447,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array, find the next greater element for each element in the array. If there is no greater element,\n    return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        while stack and stack[-1] <= arr[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(arr[i])\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 5.\n    \"\"\"\n    return [4, 5, 2, 9, 1, 7]\n\nassert f(g()) == [5, 9, 9, -1, 7, -1]\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of all elements along the path is greater than or equal to a target value.\n    \"\"\"\n    target = 20\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1] >= target\n\ndef g():\n    \"\"\"\n    Generate a matrix of integers where there exists a path from the top-left corner to the bottom-right corner\n    where the sum of all elements along the path is greater than or equal to a target value.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Return the maximum sum.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if the given string 's' is a palindrome.\n\n    Example:\n    s = \"racecar\"\n    Output: True\n    Explanation: \"racecar\" is a palindrome.\n\n    \"\"\"\n    s = s.lower()\n    s = ''.join(ch for ch in s if ch.isalnum())\n\n    return s == s[::-1]\n\ndef g(s=\"Race car!\") -> str:\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation:\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n    for i in range(len(s)):\n        if s[i] in seen and start <= seen[s[i]]:\n            start = seen[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        seen[s[i]] = i\n    return max_length\n\ndef g() -> str:\n    \"\"\"\n    Generate a string where the length of the longest substring without repeating characters is 3.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 295,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine if there exists a rectangle in the grid such that the bitwise XOR\n    of all the numbers in that rectangle is equal to zero.\n\n    Example:\n\n    grid = [\n        [1, 0, 1],\n        [0, 1, 0],\n        [1, 0, 1]\n    ]\n\n    The grid contains a rectangle with the numbers [1, 0, 1] and [0, 1, 0]. The bitwise XOR of all the numbers\n    in this rectangle is equal to zero.\n\n    Therefore, the function should return True.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    \n    for i in range(m):\n        for j in range(n):\n            for k in range(i+1, m):\n                for l in range(j+1, n):\n                    xor = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            xor ^= grid[x][y]\n                    if xor == 0:\n                        return True\n    return False\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1],\n        [0, 1, 0],\n        [1, 0, 1]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 149,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n    Output: 8 (8 is the 6th Fibonacci number)\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    queue = [start]\n    while queue:\n        current_node = queue.pop(0)\n        if current_node == end:\n            return True\n        visited.add(current_node)\n        if current_node in graph:\n            for neighbor in graph[current_node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False\n\ndef g(graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': ['F'], 'F': []}, start = 'A', end = 'F'):\n    return graph\n\nassert f(g(), 'A', 'F') == True\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph with n nodes and a list of edges, determine if the graph contains a cycle.\n\n    Example:\n    Input: n = 4, edges = [[0,1],[1,2],[2,3],[3,0]]\n    Output: True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n\n    \"\"\"\n\n    def has_cycle(node: int, visited: List[bool], parent: int) -> bool:\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    graph = [[] for _ in range(n)]\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False\n\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0,1],[1,2],[2,3],[3,0]]\n    return n, edges\n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 147,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a number of nodes n, a list of edges connecting the nodes, and the start and end nodes,\n    determine if there is a path from the start node to the end node in the graph.\n    \"\"\"\n    # Create a dictionary to store the graph\n    graph = {}\n    for edge in edges:\n        u, v = edge[0], edge[1]\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Create a stack to perform depth-first search\n    stack = [start]\n    \n    # Create a set to store the visited nodes\n    visited = set()\n    \n    # Perform depth-first search\n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node == end:\n            return True\n        if node in graph:\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return False\n\ndef g():\n    n = 5\n    edges = [[1, 2], [1, 3], [2, 4], [2, 5]]\n    start = 1\n    end = 5\n    return (n, edges, start, end)\n\nassert f(*g())\n",
        "idx_generation": 285,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two positive integers n and k, determine the number of ways to arrange k items from a set of n items,\n    where each item can be repeated any number of times.\n    \"\"\"\n    arrangements = n ** k\n    return arrangements\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 125\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, determine the number of unique combinations that can be formed by selecting a subset of the numbers such that their sum is equal to a target value.\n    \"\"\"\n    def backtrack(index, target):\n        if target == 0:\n            return 1\n        if target < 0 or index >= len(nums):\n            return 0\n        \n        count = 0\n        count += backtrack(index + 1, target - nums[index])  # include the current number\n        count += backtrack(index + 1, target)  # exclude the current number\n        \n        return count\n    \n    target = sum(nums) // 2\n    return backtrack(0, target)\n\ndef g(nums = [1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list using the bubble sort algorithm and return the sorted list.\n\n    Example:\n    Input: nums = [5, 2, 8, 1, 9]\n    Output: [1, 2, 5, 8, 9]\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n-1):\n        for j in range(n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 8, 1, 9]\n\nassert f(g()) == [1, 2, 5, 8, 9]\n\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that add up to a specific target.\n\n    Return True if there are two numbers that add up to the target, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    The numbers 2 and 10 add up to 12, so the output is True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return (nums, target)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string s and a list of words, find all the words in the list that are anagrams of s.\n\n    An anagram is a word formed by rearranging the letters of another word.\n\n    Return a list of the anagrams found.\n\n    Example:\n    s = \"listen\"\n    words = [\"enlist\", \"silent\", \"inlets\", \"banana\", \"apple\"]\n\n    The anagrams of \"listen\" in the list are: [\"enlist\", \"silent\", \"inlets\"]\n\n    Therefore, the function should return [\"enlist\", \"silent\", \"inlets\"].\n    \"\"\"\n    def is_anagram(word1, word2):\n        return sorted(word1) == sorted(word2)\n\n    anagrams = []\n    for word in words:\n        if is_anagram(s, word):\n            anagrams.append(word)\n    \n    return anagrams\n\ndef g() -> Tuple[str, List[str]]:\n    s = \"listen\"\n    words = [\"enlist\", \"silent\", \"inlets\", \"banana\", \"apple\"]\n    return s, words\n\nassert f(*g()) == [\"enlist\", \"silent\", \"inlets\"]\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a pair of numbers in the array that XOR to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [1, 2, 3, 4, 5], target = 6\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        xor_sum = arr[left] ^ arr[right]\n        if xor_sum == target:\n            return True\n        elif xor_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 14)\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24 (The maximum product is 2 * 3 * 4 = 24)\n\n    Hint: Sort the list in ascending order and consider the cases where the maximum product can be obtained.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n",
        "idx_generation": 340,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, determine the number of unique and valid binary search trees that can be formed with n nodes.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return n\n\nn = 5\nassert f(g(n)) == 42\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, check if it is possible to rearrange the characters of s\n    such that no two adjacent characters are the same, and the resulting string has exactly k distinct characters.\n\n    Example:\n    s = \"aabbc\"\n    k = 3\n\n    f(s, k) => True\n\n    Explanation: By rearranging the characters, we can obtain the string \"ababc\", which has exactly 3 distinct characters.\n\n    \"\"\"\n    distinct_chars = len(set(s))\n    return distinct_chars == k\n\ndef g() -> Tuple[str, int]:\n    return \"aabbc\", 3\n\nassert f(*g())\n",
        "idx_generation": 324,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and an integer k, return a list of all numbers that appear at least k times in the array.\n\n    Example:\n    Input: nums = [1, 2, 3, 2, 1, 4, 4, 2, 5], k = 2\n    Output: [1, 2, 4]\n    Explanation: The numbers that appear at least 2 times in the array are 1, 2, and 4.\n\n    Input: nums = [1, 2, 3, 4, 5], k = 3\n    Output: []\n    Explanation: There are no numbers that appear at least 3 times in the array.\n\n    Input: nums = [1, 2, 3, 4, 1, 2, 3, 1, 2, 1], k = 1\n    Output: [1, 2, 3, 4]\n    Explanation: All numbers appear at least 1 time in the array.\n    \"\"\"\n    count = {}\n    result = []\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    for num, freq in count.items():\n        if freq >= k:\n            result.append(num)\n    return result\n\ndef g(nums: List[int] = [1, 2, 3, 2, 1, 4, 4, 2, 5], k: int = 2):\n    return nums, k\n\nassert f(*g()) == [1, 2, 4]\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The maximum product is 20 (4 * 5).\n    Therefore, the function should return 20.\n    \"\"\"\n    n = len(nums)\n    max_product = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray.\n    A subarray is a contiguous portion of the list.\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The subarray with the maximum sum is [4, -1, 2, 1], and the maximum sum is 6.\n    Return 6\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum += num\n        max_sum = max(max_sum, curr_sum)\n        if curr_sum < 0:\n            curr_sum = 0\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 366,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the sum of all numbers that are divisible by 3.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 18\n    Explanation: The numbers divisible by 3 in the grid are 3, 6, and 9. Their sum is 18.\n    \"\"\"\n\n    # Traverse the grid and sum up all numbers that are divisible by 3\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            if num % 3 == 0:\n                total_sum += num\n\n    return total_sum\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 18\n",
        "idx_generation": 447,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid parentheses sequence.\n\n    Example:\n    s = \"()((())())\"\n\n    f(s) => True\n\n    Explanation: The string contains a valid parentheses sequence.\n    \"\"\"\n\n    stack = []\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"()((())())\"\n\nassert f(g()) == True\n",
        "idx_generation": 364,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the minimum number of coins needed to make the target sum.\n    You may assume that you have an infinite number of each kind of coin.\n\n    Example:\n    Input: [1, 2, 5], 11\n    Output: 3\n\n    Explanation:\n    The minimum number of coins needed to make 11 is 3: 5 + 5 + 1 = 11.\n    \"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for coin in nums:\n            if i >= coin:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 5], 11)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x m grid filled with non-negative numbers, find the minimum sum path from the top-left cell to the\n    bottom-right cell. You can only move down or right at any step. Return the minimum sum.\n\n    Sample Input:\n    n = 3\n    m = 3\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Sample Output:\n    7\n\n    Explanation: The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 7.\n\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[n - 1][m - 1]\n\ndef g():\n    n = 3\n    m = 3\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 7\n",
        "idx_generation": 249,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Check if there exists a substring of length n in the given string that is a palindrome.\n    \"\"\"\n    return any(s[i:i+n] == s[i:i+n][::-1] for i in range(len(s) - n + 1))\n\ndef g(n: int = 3) -> str:\n    \"\"\"\n    Generate a string containing a palindrome substring of length n.\n    \"\"\"\n    if n % 2 == 0:\n        return \"a\" * (n // 2) + \"b\" * (n // 2)\n    else:\n        return \"a\" * (n // 2) + \"b\" + \"a\" * (n // 2)\n    \nassert f(g(), 3) == True\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, pattern: str) -> bool:\n    \"\"\"\n    Determine if the given string 'string' matches the given pattern 'pattern'.\n\n    The pattern consists of only lowercase letters and '.' as a wildcard character that can match any single character.\n\n    Return True if the string matches the pattern, False otherwise.\n    \"\"\"\n    m = len(string)\n    n = len(pattern)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if pattern[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] == '.' or pattern[j - 1] == string[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif pattern[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] == '.' or pattern[j - 2] == string[i - 1]:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j]\n\n    return dp[m][n]\n\ndef g() -> (str, str):\n    \"\"\"\n    Generate a string and a pattern for Puzzle 4.\n    \"\"\"\n    string = \"aab\"\n    pattern = \"c*a*b\"\n    return string, pattern\n\nassert f(*g()) == True\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: int) -> int:\n    \"\"\"\n    Given an integer, count the number of set bits (1s) in its binary representation.\n    \"\"\"\n    count = 0\n\n    while nums > 0:\n        count += nums & 1\n        nums >>= 1\n\n    return count\n\ndef g():\n    nums = 23\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 154,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n)\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 55\n",
        "idx_generation": 144,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine the number of unique paths from the top-left corner to the\n    bottom-right corner of an n x n grid. You can only move right or down at each step.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1] > 0\n\ndef g(n=3):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary where the keys are the nodes and the values are lists of\n    neighboring nodes, determine if there is a path from the start node to the end node. Return True if a path exists,\n    otherwise return False.\n\n    Example:\n    graph = {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [5],\n        5: []\n    }\n    start = 0\n    end = 5\n    There is a path from node 0 to node 5: 0 -> 2 -> 5, so the function should return True.\n\n    Note: The graph may contain cycles and nodes may have multiple outgoing edges.\n    \"\"\"\n\n    def dfs(node):\n        if node == end:\n            return True\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n        return False\n\n    visited = set()\n    return dfs(start)\n\ndef g(graph={0: [1, 2], 1: [3, 4], 2: [5], 3: [], 4: [5], 5: []}, start=0, end=5):\n    \"\"\"\n    Generate a directed graph represented as a dictionary where the keys are the nodes and the values are lists of\n    neighboring nodes such that there is a path from the start node to the end node.\n\n    Example:\n    start = 0\n    end = 5\n    There is a path from node 0 to node 5: 0 -> 2 -> 5, so the generated graph should be:\n    {\n        0: [1, 2],\n        1: [3, 4],\n        2: [5],\n        3: [],\n        4: [5],\n        5: []\n    }\n\n    Note: The graph may contain cycles and nodes may have multiple outgoing edges.\n    \"\"\"\n    return graph\nassert f(g(), 0, 5)\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a combination of k integers from the range [1, n] such that\n    the sum of the k integers is divisible by k.\n\n    Example:\n    n = 7, k = 3\n\n    Possible combinations:\n    [1, 2, 4] -> sum = 7 (divisible by 3)\n    [1, 3, 3] -> sum = 7 (divisible by 3)\n    [2, 2, 3] -> sum = 7 (divisible by 3)\n\n    Therefore, the function should return True.\n\n    Hint: Use combinatorics to generate all possible combinations of k integers from the range [1, n].\n    \"\"\"\n    def combinations(arr, k):\n        res = []\n        def backtrack(start, curr):\n            if len(curr) == k:\n                res.append(curr[:])\n                return\n            for i in range(start, len(arr)):\n                curr.append(arr[i])\n                backtrack(i+1, curr)\n                curr.pop()\n        backtrack(0, [])\n        return res\n    \n    nums = list(range(1, n+1))\n    comb = combinations(nums, k)\n    return any(sum(c) % k == 0 for c in comb)\n\ndef g(n=7, k=3):\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 207,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return a list of all the combinations.\n\n    Example:\n    Input:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(start, curr):\n        if len(curr) == k:\n            combinations.append(curr[:])\n            return\n        for i in range(start, n + 1):\n            curr.append(i)\n            backtrack(i + 1, curr)\n            curr.pop()\n    \n    combinations = []\n    backtrack(1, [])\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if there are two numbers in the list whose sum is equal to the target.\n\n    Return True if there exists two numbers in the list that add up to the target, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    The sum of 2 and 5 is equal to the target, so the function should return True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 7) == True\n\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next greater element for each element in the list.\n\n    The next greater element is the first element to the right that is greater than the current element. If there is no\n    such element, return -1.\n\n    Return a list containing the next greater element for each element in the input list.\n    \"\"\"\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [2, 3, 4, -1]\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array that add up to the target.\n    Return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output: [0, 1]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the number of occurrences of the target value in the list.\n\n    Sample Input:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n\n    Sample Output:\n    3\n\n    Explanation:\n    The target value 2 appears 3 times in the list.\n\n    \"\"\"\n    def binary_search(nums, target, left, right, is_left):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                if is_left:\n                    if mid == 0 or nums[mid - 1] != target:\n                        return mid\n                    else:\n                        right = mid - 1\n                else:\n                    if mid == len(nums) - 1 or nums[mid + 1] != target:\n                        return mid\n                    else:\n                        left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    left_index = binary_search(nums, target, 0, len(nums) - 1, True)\n    if left_index == -1:\n        return 0\n    right_index = binary_search(nums, target, left_index, len(nums) - 1, False)\n    return right_index - left_index + 1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 150,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using interpolation search.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 6\n    Output: 5\n\n    Explanation: The target value 6 is located at index 5 in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right and nums[left] <= target <= nums[right]:\n        pos = left + ((target - nums[left]) * (right - left)) // (nums[right] - nums[left])\n\n        if nums[pos] == target:\n            return pos\n        elif nums[pos] < target:\n            left = pos + 1\n        else:\n            right = pos - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g(), 6) == 5\n",
        "idx_generation": 353,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset of the list whose sum is divisible by 10.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: True\n    Explanation:\n    - The subset [1, 2, 3, 4] has a sum of 10, which is divisible by 10.\n    \"\"\"\n\n    def subset_sum(nums, target, current_sum, index):\n        if current_sum % target == 0:\n            return True\n        if index >= len(nums):\n            return False\n\n        include = subset_sum(nums, target, current_sum + nums[index], index + 1)\n        exclude = subset_sum(nums, target, current_sum, index + 1)\n\n        return include or exclude\n\n    return subset_sum(nums, 10, 0, 0)\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Calculate the sum of the ASCII values of all the characters in the given string s.\n    \"\"\"\n    ascii_sum = sum(ord(c) for c in s)\n    return ascii_sum\n\ndef g():\n    return 'hello'\n\nassert f(g()) == 532\n",
        "idx_generation": 356,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the product of all the numbers except the current number at each index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The product of all numbers except the number at index 0 is 2 * 3 * 4 = 24.\n    The product of all numbers except the number at index 1 is 1 * 3 * 4 = 12.\n    The product of all numbers except the number at index 2 is 1 * 2 * 4 = 8.\n    The product of all numbers except the number at index 3 is 1 * 2 * 3 = 6.\n    Return [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n",
        "idx_generation": 472,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all elements that are divisible by 3.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements divisible by 3 are 3, 6, and 9.\n    The sum of these elements is 3 + 6 + 9 = 18.\n\n    Therefore, the function should return 18.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0:\n                total_sum += num\n    return total_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 18\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The pair of numbers that add up to the target value 9 is [2, 7].\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return [num_map[complement], i]\n        \n        num_map[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [[2, 7, 11, 15], 9]\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subarray with the same number of even and odd elements,\n    and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 1, 3, 5]\n\n    The subarray [2, 4, 6, 1, 3] has 3 even elements and 2 odd elements, so the function should return True.\n\n    nums = [2, 4, 6, 1, 3]\n\n    The subarray [2, 4, 6] has 3 even elements and 0 odd elements, so the function should return False.\n    \"\"\"\n    count = 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count += 1\n        else:\n            count -= 1\n        \n        if count in count_map:\n            if i - count_map[count] > 1:\n                return True\n        else:\n            count_map[count] = i\n    \n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 6, 1, 3, 5]\n\nassert f(g()) == True\n\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string consisting of parentheses, brackets, and curly braces, determine if the string is balanced.\n    A string is balanced if every opening parenthesis, bracket, or curly brace has a corresponding closing parenthesis,\n    bracket, or curly brace in the correct order.\n    \"\"\"\n    stack = []\n    opening = set(['(', '[', '{'])\n    closing = set([')', ']', '}'])\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] != '(':\n                return False\n            if char == ']' and stack[-1] != '[':\n                return False\n            if char == '}' and stack[-1] != '{':\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    s = \"((()))\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers excluding the current number.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The output list is calculated as [2*3*4, 1*3*4, 1*2*4, 1*2*3].\n\n    Hint: Use dynamic programming to calculate the products of the prefix and suffix of each number.\n    \"\"\"\n\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n\n    for i in range(1, n):\n        prefix[i] = prefix[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix[i] = suffix[i+1] * nums[i+1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n\n    The minimum path sum is the sum of all the numbers along the path with the smallest sum.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n    Explanation:\n    - The minimum path from the top-left cell to the bottom-right cell is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n\n    # Get the dimensions of the grid\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize a 2D array to store the minimum path sum\n    dp = [[0] * n for _ in range(m)]\n\n    # Fill in the first row and first column of the dp array\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Fill in the remaining cells of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    # Return the minimum path sum\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 259,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str, target: str) -> int:\n    \"\"\"\n    Given a string and a target substring, count the number of occurrences of the target substring in the string.\n\n    Example:\n    string = \"banana\"\n    target = \"ana\"\n\n    The target substring \"ana\" appears twice in the string \"banana\".\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    length = len(target)\n    \n    for i in range(len(string) - length + 1):\n        if string[i:i+length] == target:\n            count += 1\n    \n    return count\n\ndef g() -> (str, str):\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return \"banana\", \"ana\"\n\nassert f(*g()) == 2\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcdcba\"\n\n    The string \"abcdcba\" is a palindrome and does not require removing any character.\n\n    Therefore, the function should return True.\n\n    Note:\n    - The input string s will only contain lowercase letters.\n    \"\"\"\n    def is_palindrome(left: int, right: int, count: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                if count == 1:\n                    return False\n                return is_palindrome(left + 1, right, count + 1) or is_palindrome(left, right - 1, count + 1)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s) - 1, 0)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string s.\n    \"\"\"\n    return \"abcdcba\"\n\nassert f(g()) == True\n",
        "idx_generation": 304,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the kth bit in the binary representation of n.\n\n    Example:\n    n = 5, k = 2\n\n    The binary representation of 5 is 101.\n    The 2nd bit from the right is 0.\n    Therefore, the function should return 0.\n    \"\"\"\n    binary = bin(n)[2:]\n    if len(binary) < k:\n        return 0\n    return int(binary[-k])\n\ndef g():\n    n = 5\n    k = 2\n    return n, k\n\nassert f(*g()) == 0\n\n",
        "idx_generation": 156,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n    output: 8\n\n    Explanation: The 6th Fibonacci number is 8.\n    \"\"\"\n\n    def fib(n: int) -> int:\n        if n <= 1:\n            return n\n        else:\n            return fib(n-1) + fib(n-2)\n\n    return fib(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]], start_node=0, end_node=1) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from start_node to end_node.\n    \"\"\"\n\n    def dfs(node, visited):\n        visited[node] = True\n        if node == end_node:\n            return True\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] and not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(start_node, visited)\ndef g(start_node=0, end_node=1):\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph\nassert f(g()) == True\n",
        "idx_generation": 152,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n\n    The graph contains a cycle from node 0 to node 3.\n    Therefore, the function should return True.\n    \"\"\"\n\n    stack = []\n    visited = [False] * len(graph)\n\n    def dfs(node):\n        if visited[node]:\n            return True\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n        stack.pop()\n        return False\n\n    for node in range(len(graph)):\n        if dfs(node):\n            return True\n\n    return False\n\ndef g():\n    return [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]\n\nassert f(g())\n",
        "idx_generation": 300,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10 (There are 10 ways to choose 3 elements from a set of 5 elements)\n\n    Hint: Use the combinatorial formula C(n, k) = n! / (k! * (n-k)!)\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num-1)\n\n    return factorial(n) // (factorial(k) * factorial(n-k))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two positive integers.\n    \"\"\"\n    return [5, 3]\n\nassert f(*g()) == 10\n",
        "idx_generation": 217,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n and a positive integer k, return the number of ways to choose k items from a set of n items.\n    \"\"\"\n    def choose(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return choose(n-1, k-1) + choose(n-1, k)\n    \n    return choose(n, k)\n\ndef g(n: int, k: int):\n    return n, k\n\nassert f(*g(5, 3)) == 10\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11], target = 7\n    Output: 3\n\n    Explanation: The target value 7 is located at index 3 in the sorted list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        middle = (left + right) // 2\n        if nums[middle] == target:\n            return middle\n        elif nums[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 434,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list using the bubble sort algorithm.\n\n    Return the sorted list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g():\n    return [5, 2, 9, 1, 7]\n\nassert f(g()) == [1, 2, 5, 7, 9]\n\n",
        "idx_generation": 411,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n\n    The target value 8 is found at index 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings s1 and s2, check if s1 is a rotation of s2.\n\n    A rotation of a string is obtained by moving some characters from the beginning to the end.\n\n    Sample Input:\n    s1 = \"abcde\"\n    s2 = \"cdeab\"\n\n    Sample Output:\n    True\n    Explanation: s1 is a rotation of s2 by moving the characters \"cde\" from the beginning to the end.\n\n    Sample Input:\n    s1 = \"abcde\"\n    s2 = \"abced\"\n\n    Sample Output:\n    False\n    Explanation: s1 is not a rotation of s2 as the characters are not in the same order.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    s1 = s1 + s1\n    return s2 in s1\n\ndef g(s1: str = \"abcde\", s2: str = \"cdeab\"):\n    return s1, s2\n\nassert f(*g()) == True\n",
        "idx_generation": 166,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any two distinct numbers is 20 (4 * 5).\n\n    Therefore, the function should return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target sum, determine if there is a subset of the list that adds up to the target sum.\n\n    Args:\n        nums: A list of non-negative integers.\n        target: The target sum.\n\n    Returns:\n        True if there exists a subset that adds up to the target sum, False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8], target = 10\n    Output: True\n\n    Explanation:\n    The subset [2, 8] adds up to the target sum 10.\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int, index: int, memo: List[bool]) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if memo[index][target] != -1:\n            return memo[index][target]\n        if nums[index] <= target:\n            if subset_sum(nums, target-nums[index], index+1, memo):\n                memo[index][target] = True\n                return True\n        memo[index][target] = subset_sum(nums, target, index+1, memo)\n        return memo[index][target]\n\n    memo = [[-1] * (target+1) for _ in range(len(nums))]\n    return subset_sum(nums, target, 0, memo)\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\n\nassert f(*g()) == True\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of lowercase letters, return the longest substring that contains\n    all the vowels (a, e, i, o, u) in the same order as they appear in the string.\n\n    Example:\n    s = \"aeiouabcdefg\"\n    Output: \"aeiou\"\n\n    s = \"aeioubcdfg\"\n    Output: \"\"\n\n    s = \"aebcduiofg\"\n    Output: \"aebcduio\"\n    \"\"\"\n\n    vowels = \"aeiou\"\n    longest_substring = \"\"\n    current_substring = \"\"\n\n    for char in s:\n        if char in vowels:\n            current_substring += char\n\n            if current_substring == vowels:\n                return current_substring\n\n            if current_substring == vowels[:len(current_substring)]:\n                if len(current_substring) > len(longest_substring):\n                    longest_substring = current_substring\n        else:\n            current_substring = \"\"\n\n    return longest_substring\n\ndef g():\n    return \"aeiouabcdefg\"\n\nassert f(g()) == \"aeiou\"\n",
        "idx_generation": 395,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    n = 17\n    return n\n\nassert f(g())\n",
        "idx_generation": 444,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 385,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the square of the corresponding element in the input list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 4, 9, 16, 25]\n\n    Hint: Use list comprehension to iterate through the input list and calculate the square of each element.\n    \"\"\"\n\n    return [num ** 2 for num in nums]\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [1, 4, 9, 16, 25]\n",
        "idx_generation": 449,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of bars in a histogram, find the largest rectangle that can be formed by the bars.\n    Return the area of the largest rectangle.\n\n    Example:\n    heights = [2, 1, 5, 6, 2, 3]\n    The largest rectangle that can be formed is [5, 6, 2], with an area of 10.\n    Therefore, the function should return 10.\n    \"\"\"\n    stack = []\n    max_area = 0\n    i = 0\n\n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n\n    while stack:\n        top = stack.pop()\n        area = heights[top] * (i - stack[-1] - 1 if stack else i)\n        max_area = max(max_area, area)\n\n    return max_area\n\ndef g() -> List[int]:\n    return [2, 1, 5, 6, 2, 3]\n\nassert f(g()) == 10\n\n",
        "idx_generation": 386,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS) in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum path sum from the top-left cell to the bottom-right cell.\n\n    The maximum path sum is the sum of all the numbers along the path with the largest sum.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n    Explanation:\n    - The maximum path from the top-left cell to the bottom-right cell is 1 -> 3 -> 5 -> 1 -> 1, which has a sum of 12.\n    \"\"\"\n\n    # Get the dimensions of the grid\n    m = len(grid)\n    n = len(grid[0])\n\n    # Initialize a 2D array to store the maximum path sum\n    dp = [[0] * n for _ in range(m)]\n\n    # Fill in the first row and first column of the dp array\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    # Fill in the remaining cells of the dp array\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    # Return the maximum path sum\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(word: str) -> str:\n    \"\"\"\n    Given a string 'word', return the string with all vowels replaced by 'z'.\n\n    Example:\n    word = \"hello\"\n\n    Output: \"hzllz\"\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for vowel in vowels:\n        word = word.replace(vowel, 'z')\n    return word\n\ndef g() -> str:\n    word = \"hello\"\n    return word\n\nassert f(g()) == \"hzllz\"\n\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    if len(s) <= 1:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return f(s[1:-1])\n\ndef g():\n    return \"racecar\"\n    \nassert f(g()) == True\n\n",
        "idx_generation": 318,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the maximum XOR value that can be obtained by selecting two different elements from the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    The possible XOR values for the pairs of elements are: 3 ^ 10 = 9, 3 ^ 5 = 6, 3 ^ 25 = 28, 3 ^ 2 = 1, 3 ^ 8 = 11, 10 ^ 5 = 15, 10 ^ 25 = 19, 10 ^ 2 = 8, 10 ^ 8 = 2, 5 ^ 25 = 28, 5 ^ 2 = 7, 5 ^ 8 = 13, 25 ^ 2 = 27, 25 ^ 8 = 17, 2 ^ 8 = 10\n\n    The maximum XOR value is 28.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers arr.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 159,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an n x n matrix, find the sum of all elements in the matrix.\n\n    Example:\n    Input: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: 45 (The sum of all elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45)\n\n    Hint: Use recursion to calculate the sum of each row in the matrix.\n    \"\"\"\n    def row_sum(row: List[int]) -> int:\n        if len(row) == 0:\n            return 0\n        else:\n            return row[0] + row_sum(row[1:])\n\n    if len(matrix) == 0:\n        return 0\n    else:\n        return row_sum(matrix[0]) + f(matrix[1:])\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 45\n",
        "idx_generation": 155,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges connecting the nodes, determine if there is a cycle in the graph.\n    Return True if a cycle exists, False otherwise.\n\n    Sample input:\n    n = 5\n    edges = [(1, 2), (2, 3), (3, 4), (4, 2), (4, 5)]\n\n    Sample output:\n    True\n\n    Explanation:\n    There is a cycle in the graph: 2 -> 3 -> 4 -> 2.\n    \"\"\"\n    graph = {}\n    for u, v in edges:\n        if u in graph:\n            graph[u].append(v)\n        else:\n            graph[u] = [v]\n    \n    visited = set()\n    stack = []\n    for node in range(1, n+1):\n        if node not in visited:\n            if has_cycle(graph, node, visited, stack):\n                return True\n    return False\n\ndef has_cycle(graph, node, visited, stack):\n    visited.add(node)\n    stack.append(node)\n    \n    if node in graph:\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if has_cycle(graph, neighbor, visited, stack):\n                    return True\n            elif neighbor in stack:\n                return True\n    \n    stack.remove(node)\n    return False\n\ndef g():\n    n = 5\n    edges = [(1, 2), (2, 3), (3, 4), (4, 2), (4, 5)]\n    return n, edges\n\nassert f(*g()) == True\n\n",
        "idx_generation": 152,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency list and two nodes start and end, determine if there exists a path from start to end in the graph.\n\n    Example:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n\n    There exists a path from 'A' to 'E': ['A', 'B', 'D', 'E'].\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    start = 'A'\n    end = 'E'\n    return graph, start, end\n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 302,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of ways to arrange n distinct objects in k groups.\n\n    Example:\n    n = 5\n    k = 2\n\n    There are 10 ways to arrange 5 objects in 2 groups: [1, 4], [2, 3], [3, 2], [4, 1], [1, 3], [3, 1], [2, 2], [1, 2], [2, 1], [1, 1].\n\n    Therefore, the function should return 10.\n    \"\"\"\n\n    def arrange_objects(n: int, k: int, memo: Dict[Tuple[int, int], int]) -> int:\n        \"\"\"\n        Recursively calculate the number of ways to arrange objects in groups.\n        \"\"\"\n        if k == 0 or n == k:\n            return 1\n        elif (n, k) in memo:\n            return memo[(n, k)]\n        else:\n            result = arrange_objects(n-1, k-1, memo) + arrange_objects(n-1, k, memo)\n            memo[(n, k)] = result\n            return result\n\n    memo = {}\n    return arrange_objects(n, k, memo)\n\n\ndef g():\n    n = 5\n    k = 2\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 246,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"Find the number of distinct combinations of elements in nums that sum up to target.\"\"\"\n    def count_combinations(nums, target):\n        if target == 0:\n            return 1\n        if target < 0 or not nums:\n            return 0\n        return count_combinations(nums[1:], target - nums[0]) + count_combinations(nums[1:], target)\n    \n    return count_combinations(nums, target) > 0\n\ndef g(target=0):\n    nums = [1, 2, 3, 4, 5]\n    return nums, target\n\nassert f(g()) == True\n",
        "idx_generation": 171,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    After rotating 90 degrees clockwise, the matrix becomes:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    Therefore, the function should return [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated_matrix = [[0] * n for _ in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n\n    return rotated_matrix\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm and return the sorted list.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 8, 6, 1, 9, 3]\n\nassert f(g()) == [1, 2, 3, 5, 6, 8, 9]\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, return the shortest string that contains all the characters from the input strings.\n    \"\"\"\n    all_chars = set()\n    for string in strings:\n        all_chars.update(set(string))\n    \n    shortest_string = \"\"\n    for char in sorted(all_chars):\n        shortest_string += char\n    \n    return shortest_string\n\n\ndef g():\n    strings = [\"abc\", \"defg\", \"hijk\"]\n    return strings\n\nassert f(g()) == 'abcdefghijk'\n",
        "idx_generation": 200,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: 60\n    Explanation: The maximum product of any three numbers in the list is 4 * 5 * 3 = 60.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n",
        "idx_generation": 368,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there exists a combination of numbers in the list that adds up to the target.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The combination [2, 3, 5] adds up to 10.\n    \"\"\"\n\n    def backtrack(nums, start, target, path, result):\n        if target == 0:\n            result.append(path[:])\n            return\n\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(nums, i, target - nums[i], path, result)\n            path.pop()\n\n    result = []\n    nums.sort()\n    backtrack(nums, 0, target, [], result)\n    return len(result) > 0\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 3, 5, 7]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 249,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list containing all words that start with the given prefix.\n    If no words start with the prefix, return an empty list.\n    \"\"\"\n    matching_words = []\n    for word in words:\n        if word.startswith(prefix):\n            matching_words.append(word)\n    return matching_words\n\ndef g(words=[\"apple\", \"banana\", \"apricot\", \"avocado\", \"blueberry\"], prefix=\"ap\"):\n    return words\n\nassert f(g(), prefix=\"ap\") == [\"apple\", \"apricot\"]\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a prime number.\n\n    Example:\n    Input:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g():\n    return 7\n\nassert f(g()) == True\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There are two numbers in the list, 3 and 4, that add up to the target number 7.\n\n    Hint: Use two pointers, one starting from the beginning of the list and the other starting from the end.\n    Move the pointers towards each other and check if the sum of the numbers at the pointers is equal to the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 449,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, determine if there exists a pair of integers in the array whose sum is equal to the target value.\n    Use a stack to solve the problem.\n\n    Example:\n    Input: arr = [2, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation:\n    The pair (2, 7) sums up to 9, therefore the function should return True.\n    \"\"\"\n    stack = []\n    for num in arr:\n        if target - num in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value where there exists a pair of integers whose sum is equal to the target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == True\n\n",
        "idx_generation": 393,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \n    Args:\n    nums (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum sum of a subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 259,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", and the length is 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for i in range(len(s)):\n        if s[i] in seen and start <= seen[s[i]]:\n            start = seen[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        seen[s[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    \"\"\"\n    n = len(s)\n    if n <= 1:\n        return n\n    \n    max_len = 0\n    start = 0\n    seen = {}\n    for end in range(n):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        seen[s[end]] = end\n        max_len = max(max_len, end - start + 1)\n    \n    return max_len\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 321,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Return the maximum XOR value.\n\n    Constraints:\n    - The length of the list will be at least 2.\n    - The list may contain duplicate elements.\n    - The integers in the list will be non-negative.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there is a combination of numbers in the list that adds up to the target.\n    Return True if such combination exists, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    f(nums, target) => True\n    Explanation: There is a combination of 2 and 8 that adds up to 10.\n    \"\"\"\n\n    def dp(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i >= len(nums) or curr_sum > target:\n            return False\n        if dp(i+1, curr_sum + nums[i]):\n            return True\n        if dp(i+1, curr_sum):\n            return True\n        return False\n\n    return dp(0, 0)\n\ndef g():\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 167,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine if there exists a path from the top-left\n    corner to the bottom-right corner, where the path consists of only 1s.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 1, 1, 0],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1]\n    ]\n\n    There exists a path from (0, 0) to (3, 3) consisting of only 1s.\n\n    Therefore, the function should return True.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n\n    def is_valid(i, j):\n        return 0 <= i < m and 0 <= j < n and grid[i][j] == 1\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n        if is_valid(i, j):\n            grid[i][j] = 0\n            return dfs(i + 1, j) or dfs(i, j + 1)\n        return False\n\n    return dfs(0, 0)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 1, 1, 0],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 156,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> List[str]:\n    \"\"\"\n    Given a directed graph, find a path from start to end using Breadth-First Search (BFS).\n\n    Example:\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n\n    Output:\n    [\"A\", \"C\", \"F\"]\n\n    Explanation:\n    A -> C -> F is a path from start to end.\n    \"\"\"\n    queue = [[start]]\n    visited = set()\n\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n\n        if node == end:\n            return path\n\n        if node not in visited:\n            neighbors = graph.get(node, [])\n            for neighbor in neighbors:\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n            visited.add(node)\n\n    return []\n\ndef g():\n    graph = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\"],\n        \"C\": [\"F\"],\n        \"D\": [],\n        \"E\": [\"F\"],\n        \"F\": []\n    }\n    start = \"A\"\n    end = \"F\"\n    return graph, start, end\n\nassert f(*g()) == [\"A\", \"C\", \"F\"]\n",
        "idx_generation": 305,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, calculate the number of ways to arrange n items into m groups.\n\n    Example:\n    Input: n = 5, m = 3\n    Output: 10 (There are 10 ways to arrange 5 items into 3 groups)\n\n    Hint: Use combinatorial analysis and the concept of combinations to solve this problem.\n    \"\"\"\n    def factorial(num):\n        if num <= 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    combinations = factorial(n) // (factorial(m) * factorial(n - m))\n    return combinations\n\ndef g():\n    n = 5\n    m = 3\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 277,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Count the number of ways to choose k elements from a set of n elements, where order does not matter and repetition is allowed.\n    \"\"\"\n    def combinations(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return combinations(n-1, k) + combinations(n-1, k-1)\n    \n    return combinations(n, k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate values for n and k.\n    \"\"\"\n    return (5, 3)\n\nassert f(*g()) == 10\n",
        "idx_generation": 182,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The target value 5 is located at index 2.\n    Therefore, the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n",
        "idx_generation": 425,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find if there exists a subsequence of the list whose sum equals the target number.\n    Return True if such a subsequence exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n\n    # Create a 2D array to store the subproblem results\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    # Base cases\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 18\n\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n\n    Hint: Split the string into words, reverse the order of the words, and join them back into a string.\n    \"\"\"\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the median of the list.\n\n    Example:\n    nums = [5, 2, 9, 1, 7, 6, 3]\n    output: 5\n\n    Explanation:\n    The median is the middle value of a sorted list of numbers. In this case, when the list is sorted, the median is 5.\n    If the list has an even number of elements, the median is the average of the two middle values.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        median = (nums[n//2-1] + nums[n//2]) / 2\n    else:\n        median = nums[n//2]\n    return median\n\ndef g() -> List[int]:\n    nums = [5, 2, 9, 1, 7, 6, 3]\n    return nums\n\nassert f(g()) == 5\n\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=5) -> bool:\n    \"\"\"\n    Find a combination of numbers from the given list that adds up to the target value,\n    considering only non-consecutive numbers\n    \"\"\"\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        if num <= target:\n            dp[num] = True\n    for i in range(target + 1):\n        if not dp[i]:\n            for num in nums:\n                if i - num >= 0 and not dp[i-num]:\n                    dp[i] = True\n    return dp[target]\n\ndef g(nums=[1, 2, 3, 4, 5, 6, 7]):\n    \"\"\"\n    Generate a list of numbers from the given list, with consecutive numbers\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            result.append(nums[i])\n    return result\n\nassert f(g()) == True\n",
        "idx_generation": 263,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str, n=3) -> bool:\n    \"\"\"Check if two strings are anagrams.\"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for i in range(len(s)):\n        count_s[ord(s[i]) - ord('a')] += 1\n        count_t[ord(t[i]) - ord('a')] += 1\n    for i in range(26):\n        if count_s[i] != count_t[i]:\n            return False\n    return True\ndef g(n = 3):\n    return \"abc\" * n, \"cab\" * n\nassert f(*g())\n",
        "idx_generation": 435,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that have a sum equal to zero.\n\n    Example:\n    nums = [1, -2, 3, -1, -2, 4, 2, -1]\n    Output: 4\n    Explanation: The distinct pairs with a sum equal to zero are (-2, 2), (-2, 2), (-1, 1), and (-1, 1).\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    num_set = set(nums)\n\n    for num in num_set:\n        if -num in num_set:\n            count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, -2, 3, -1, -2, 4, 2, -1]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing the indices of all occurrences of the target number.\n    If the target number does not exist in the list, return an empty list.\n    \"\"\"\n    indices = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            indices.append(i)\n    return indices\n\ndef g(nums=[1, 2, 3, 2, 4, 5, 2, 6, 2, 7], target=2):\n    return nums\n\nassert f(g(), target=2) == [1, 3, 6, 8]\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum submatrix where the sum is less than or equal to a given target.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        row_sums = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                row_sums[i] += matrix[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be used to find the maximum sum submatrix.\n    \"\"\"\n    return matrix\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6]\n]\nassert f(g(matrix)) == 21\n\n",
        "idx_generation": 453,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, calculate the next greater element for each element in the list.\n    The next greater element of an element in the list is the first element to its right that is greater than it.\n\n    Example:\n    Input: [4, 5, 2, 25, 10]\n    Output: [5, 25, 25, -1, -1]\n\n    Hint: Use a stack to keep track of the next greater elements.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(arr)\n\n    for i in range(len(arr)-1, -1, -1):\n        while stack and stack[-1] <= arr[i]:\n            stack.pop()\n\n        if stack:\n            result[i] = stack[-1]\n\n        stack.append(arr[i])\n\n    return result\n\ndef g() -> List[int]:\n    return [4, 5, 2, 25, 10]\n\nassert f(g()) == [5, 25, 25, -1, -1]\n\n",
        "idx_generation": 406,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, return the number of paths from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    n = 3, m = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n\n    The grid represents a 3x3 grid with all cells initially set to 0.\n    The number of paths from the top-left cell to the bottom-right cell is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def backtrack(row, col):\n        if row == n - 1 and col == m - 1:\n            return 1\n        if row >= n or col >= m:\n            return 0\n        return backtrack(row + 1, col) + backtrack(row, col + 1)\n\n    return backtrack(0, 0)\n\ndef g():\n    n = 3\n    m = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n    return n, m, grid\n\nassert f(*g()) == 6\n",
        "idx_generation": 460,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n    \"\"\"\n    if n == 1:\n        return 1\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 3\n\nassert f(g()) == 6\n",
        "idx_generation": 260,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all substrings of s of length k.\n\n    Example:\n    s = \"abcde\"\n    k = 3\n\n    Output:\n    [\"abc\", \"bcd\", \"cde\"]\n    \"\"\"\n    substrings = []\n    for i in range(len(s) - k + 1):\n        substrings.append(s[i:i+k])\n    return substrings\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer k.\n    \"\"\"\n    s = \"abcde\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"abc\", \"bcd\", \"cde\"]\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring.\n\n    Example:\n    Input: \"babad\"\n    Output: \"bab\"\n    Explanation: The longest palindromic substring in \"babad\" is \"bab\".\n    \"\"\"\n    if len(s) < 2:\n        return s\n    \n    start = 0\n    max_length = 1\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return left + 1, right - 1\n    \n    for i in range(len(s)):\n        left1, right1 = expand_around_center(i, i)\n        left2, right2 = expand_around_center(i, i + 1)\n        \n        if right1 - left1 + 1 > max_length:\n            start = left1\n            max_length = right1 - left1 + 1\n            \n        if right2 - left2 + 1 > max_length:\n            start = left2\n            max_length = right2 - left2 + 1\n            \n    return s[start:start + max_length]\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"babad\"\n\nassert f(g()) == \"bab\"\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of bits required to represent it in binary form.\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return 1 + f(n // 2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer for Puzzle 4.\n    \"\"\"\n    return 25\n\nassert f(g()) == 5\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n    \"\"\"\n    max_product = float('-inf')\n    curr_max = 1\n    curr_min = 1\n    \n    for num in nums:\n        if num < 0:\n            curr_max, curr_min = curr_min, curr_max\n        \n        curr_max = max(num, curr_max * num)\n        curr_min = min(num, curr_min * num)\n        \n        max_product = max(max_product, curr_max)\n    \n    return max_product\n\ndef g():\n    nums = [2, 3, -2, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph as an adjacency matrix and two nodes start and end, determine if there exists a path from start to end.\n\n    Sample Input:\n    graph = [[0, 1, 1, 0, 0],\n             [1, 0, 1, 1, 0],\n             [1, 1, 0, 0, 1],\n             [0, 1, 0, 0, 0],\n             [0, 0, 1, 0, 0]]\n    start = 0\n    end = 4\n\n    Sample Output:\n    True\n    Explanation: There exists a path from node 0 to node 4 in the graph: 0 -> 1 -> 2 -> 4.\n    \"\"\"\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    \n    return dfs(start, set())\n\ndef g():\n    return [[0, 1, 1, 0, 0],\n            [1, 0, 1, 1, 0],\n            [1, 1, 0, 0, 1],\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0]], 0, 4\n\nassert f(*g()) == True\n",
        "idx_generation": 167,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right cell (marked as 9) \n    starting from the top-left cell (marked as 1). You can only move down or right, and cannot move \n    outside the grid or cross through cells marked as 0.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    \n    def dfs(i, j):\n        # Base cases\n        if i == n-1 and j == m-1:\n            return True\n        if i >= n or j >= m or grid[i][j] == 0:\n            return False\n        \n        # Recursive cases\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g(grid=[[1, 0, 1, 1], \n            [1, 1, 1, 0], \n            [0, 1, 1, 1], \n            [1, 1, 0, 9]]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, return all possible permutations of nums.\n\n    Sample Input:\n    nums = [1, 2, 3]\n\n    Sample Output:\n    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Sample Input:\n    nums = [0, 1]\n\n    Sample Output:\n    [[0, 1], [1, 0]]\n\n    \"\"\"\n    def backtrack(first: int):\n        if first == n:\n            output.append(nums[:])\n        for i in range(first, n):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first + 1)\n            nums[first], nums[i] = nums[i], nums[first]\n\n    n = len(nums)\n    output = []\n    backtrack(0)\n    return output\n\ndef g(nums=[1, 2, 3]):\n    return nums\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n",
        "idx_generation": 284,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of unique combinations that add up to the target.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, curr_sum: int) -> int:\n        if curr_sum == target:\n            return 1\n        if curr_sum > target:\n            return 0\n        \n        count = 0\n        for i in range(start, len(nums)):\n            count += backtrack(nums, target, i, curr_sum + nums[i])\n        \n        return count\n    \n    return backtrack(nums, target, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 185,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, substr='abc', m=3) -> bool:\n    \"\"\"\n    Determine if the given string contains exactly m occurrences of the substring substr\n    \"\"\"\n    count = s.count(substr)\n    return count == m\n\ndef g(substr='abc', m=3):\n    \"\"\"\n    Generate a string with exactly m occurrences of the substring substr\n    \"\"\"\n    return substr * m\n    \nassert f(g()) == True\n",
        "idx_generation": 44,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers in the list is 60 (4 * 5 * 3).\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order using the quicksort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 1, 9, 4]\n\n    Output:\n    [9, 5, 4, 2, 1]\n    \"\"\"\n    def partition(nums, low, high):\n        pivot = nums[high]\n        i = low - 1\n        for j in range(low, high):\n            if nums[j] >= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1], nums[high] = nums[high], nums[i+1]\n        return i + 1\n    \n    def quicksort(nums, low, high):\n        if low < high:\n            pi = partition(nums, low, high)\n            quicksort(nums, low, pi - 1)\n            quicksort(nums, pi + 1, high)\n    \n    quicksort(nums, 0, len(nums) - 1)\n    \n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 1, 9, 4]\n\nassert f(g()) == [9, 5, 4, 2, 1]\n",
        "idx_generation": 438,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine if the target value is present in the list.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: True\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return False\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string s, split the string into words and return a list of words in reverse order.\n\n    Example:\n    s = \"hello world\"\n\n    Splitting the string into words gives [\"hello\", \"world\"].\n    Reversing the order of the words gives [\"world\", \"hello\"].\n\n    Therefore, the function should return [\"world\", \"hello\"].\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return reversed_words\n\ndef g():\n    s = \"hello world\"\n    return s\n\nassert f(g()) == [\"world\", \"hello\"]\n",
        "idx_generation": 211,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all even Fibonacci numbers less than or equal to n.\n\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding numbers.\n\n    Example:\n    n = 10\n    Output: 10\n    Explanation: The even Fibonacci numbers less than or equal to 10 are 0, 2, and 8. Their sum is 10.\n    \"\"\"\n\n    fib = [0, 1]  # Initialize the Fibonacci sequence with the first two numbers\n\n    # Generate the Fibonacci sequence up to n\n    while fib[-1] <= n:\n        fib.append(fib[-1] + fib[-2])\n\n    # Calculate the sum of all even Fibonacci numbers\n    even_sum = sum(num for num in fib if num <= n and num % 2 == 0)\n\n    return even_sum\n\ndef g():\n    return 10\n\nassert f(g()) == 10\n",
        "idx_generation": 389,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4 (The longest increasing subsequence is [2, 3, 7, 101])\n\n    Hint: This problem can be solved using dynamic programming and binary search.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n\n",
        "idx_generation": 264,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be represented as a concatenation of two non-empty substrings.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s[:i] + s[:i] == s:\n            return True\n    return False\n\ndef g():\n    return \"abcabc\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 446,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    Input: 10\n    Output: 23\n    Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6 and 9. Their sum is 23.\n    \"\"\"\n\n    result = 0\n\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n\n    return result\n\ndef g():\n    return 10\n\nassert f(g()) == 23\n\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The function should return [24, 12, 8, 6] since the product of all numbers except 1 is 24, the product of all numbers except 2 is 12, the product of all numbers except 3 is 8, and the product of all numbers except 4 is 6.\n    \"\"\"\n\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a tuple (index1, index2).\n    Assume that there is exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The two numbers that sum up to the target 9 are 2 and 7.\n    The indices of these numbers are 0 and 1, respectively.\n\n    Therefore, the function should return (0, 1).\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return (num_map[complement], i)\n        \n        num_map[num] = i\n    \n    return ()\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == (0, 1)\n\n",
        "idx_generation": 454,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only the characters '(' and ')', determine if the input string is valid.\n\n    A string is valid if:\n    - Open brackets must be closed by the same type of brackets.\n    - Open brackets must be closed in the correct order.\n\n    Sample Input:\n    s = \"()\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"()[]{}\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"(]\"\n\n    Sample Output:\n    False\n\n    \"\"\"\n    stack = []\n    for char in s:\n        if char in \"({[\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            if char == \")\" and stack[-1] != \"(\":\n                return False\n            if char == \"]\" and stack[-1] != \"[\":\n                return False\n            if char == \"}\" and stack[-1] != \"{\":\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(s=\"()\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two.\n    Return the nth number as the result.\n\n    Example:\n    n = 6\n    The function should return 8 since the 6th Fibonacci number is 8.\n\n    Return the nth Fibonacci number as the result.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev = 0\n    curr = 1\n\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 461,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two positive integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at each step.\n\n    Example:\n    n = 3, m = 2\n\n    The grid looks like this:\n\n    1 1\n    1 1\n    1 1\n\n    There are 3 unique paths from the top-left corner to the bottom-right corner.\n    Therefore, the function should return 3.\n    \"\"\"\n\n    # Create a 2D grid of size n x m initialized with 1s\n    grid = [[1] * m for _ in range(n)]\n\n    # Calculate the number of unique paths for each cell\n    for i in range(1, n):\n        for j in range(1, m):\n            grid[i][j] = grid[i-1][j] + grid[i][j-1]\n\n    return grid[n-1][m-1]\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and m.\n    \"\"\"\n    return 3, 2\n\nassert f(*g()) == 3\n",
        "idx_generation": 267,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the string word by word.\n\n    Example:\n    s = \"the sky is blue\"\n    f(s) => \"blue is sky the\"\n\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\n\ndef g():\n    return \"the sky is blue\"\n\n\nassert f(g()) == \"blue is sky the\"\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    So, the expected output is 3.\n\n    Returns the length of the longest substring without repeating characters.\n    \"\"\"\n\n    def longest_substring(s: str) -> int:\n        \"\"\"\n        Finds the length of the longest substring without repeating characters.\n        \"\"\"\n        start = 0\n        max_length = 0\n        seen = {}\n\n        for end, char in enumerate(s):\n            if char in seen and start <= seen[char]:\n                start = seen[char] + 1\n            else:\n                max_length = max(max_length, end - start + 1)\n            \n            seen[char] = end\n\n        return max_length\n\n    return longest_substring(s)\n\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum XOR value between any two numbers in the grid.\n\n    Return the maximum XOR value.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum XOR value between any two numbers in the grid is 15, which can be obtained by XORing 7 and 8.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            for x in range(len(grid)):\n                for y in range(len(grid[0])):\n                    xor = grid[i][j] ^ grid[x][y]\n                    max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 15\n\n",
        "idx_generation": 180,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 4\n    f(n) => 5\n    Explanation: There are 5 unique ways to climb to the top of a staircase with 4 steps: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2].\n\n    \"\"\"\n\n    if n <= 2:\n        return n\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 187,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int, paths: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if there is a path from node 0 to node n-1 in a directed graph with k edges.\n    paths is a list of tuples representing edges in the graph.\n    \"\"\"\n    def dfs(node, visited):\n        visited.add(node)\n        if node == n-1:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    \n    graph = [[] for _ in range(n)]\n    for u, v in paths:\n        graph[u].append(v)\n    \n    visited = set()\n    return dfs(0, visited)\n\n\ndef g(n=5, k=7):\n    paths = [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4], [2, 4], [4, 0]]\n    return n, k, paths\n\nassert f(*g())\n",
        "idx_generation": 173,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of characters, determine if it contains a valid word from a given dictionary.\n    A valid word can be formed by connecting adjacent cells (horizontally or vertically) without \n    reusing the same cell. The path can start from any cell and can use any number of cells.\n    \"\"\"\n    def dfs(i, j, word):\n        # Base case\n        if len(word) == 0:\n            return True\n        \n        # Recursive cases\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n            return False\n        \n        temp = grid[i][j]\n        grid[i][j] = '#'\n        \n        res = dfs(i-1, j, word[1:]) or dfs(i+1, j, word[1:]) or dfs(i, j-1, word[1:]) or dfs(i, j+1, word[1:])\n        \n        grid[i][j] = temp\n        \n        return res\n    \n    dictionary = {'apple', 'banana', 'cherry', 'date'}\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, grid[i][j]):\n                return True\n    \n    return False\n\ndef g(grid=[['a', 'b', 'c', 'd'],\n            ['e', 'f', 'g', 'h'],\n            ['i', 'j', 'k', 'l'],\n            ['m', 'n', 'o', 'p']]):\n    return grid\n\nassert f(g())\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s, determine if it is possible to split the string into k non-empty palindromic substrings.\n    A palindromic substring is a substring that reads the same forwards and backwards.\n    \"\"\"\n    n = len(s)\n    \n    def is_palindrome(start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    \n    def dfs(start, count):\n        # Base case\n        if count == k:\n            return True\n        \n        # Recursive cases\n        for i in range(start, n):\n            if is_palindrome(start, i):\n                if dfs(i+1, count+1):\n                    return True\n        return False\n    \n    return dfs(0, 0)\n\ndef g(s='aabbaa', k=2):\n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 322,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    Input: n = 3\n    Output: 3\n    Explanation: There are 3 ways to climb to the top: 1+1+1, 1+2, and 2+1.\n\n    Input: n = 4\n    Output: 5\n    Explanation: There are 5 ways to climb to the top: 1+1+1+1, 1+2+1, 2+1+1, 1+1+2, and 2+2.\n    \"\"\"\n\n    def count_ways(n: int, memo: Dict[int, int]) -> int:\n        if n <= 1:\n            return 1\n        if n in memo:\n            return memo[n]\n        memo[n] = count_ways(n-1, memo) + count_ways(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return count_ways(n, memo)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, strings=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']) -> bool:\n    \"\"\"Find the longest string in a list that starts with a vowel and ends with a consonant.\"\"\"\n    return max((string for string in strings if string[0] in 'aeiou' and string[-1] not in 'aeiou'), key=len) == s\ndef g(strings=['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew', 'kiwi', 'lemon']):\n    return max((string for string in strings if string[0] in 'aeiou' and string[-1] not in 'aeiou'), key=len)\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 6\n",
        "idx_generation": 437,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target element to find.\n\n    Returns:\n    - The index of the target element if found, otherwise -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 9) == 4\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of integers, find two numbers that add up to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14, substring = \"10\"\n    Output: True\n\n    Explanation: The numbers 4 and 10 add up to 14. The concatenation of 4 and 10 is \"410\",\n    which contains the substring \"10\".\n    \"\"\"\n\n    nums.sort()\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            concatenated = str(nums[left]) + str(nums[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    substring = \"10\"\n    return nums, target, substring\n\nassert f(*g()) == True\n",
        "idx_generation": 218,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    \n    The maximum product can be obtained by multiplying 3, 4, and 5.\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    \n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n",
        "idx_generation": 398,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations of elements in the list that add up to the target.\n    Return a list of lists containing the combinations.\n    \"\"\"\n    def backtrack(start, curr_sum, combination):\n        if curr_sum == target:\n            result.append(combination[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            backtrack(i, curr_sum + nums[i], combination)\n            combination.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, 0, [])\n    return result\n\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 266,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    char_count = [0] * 26\n\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n\n    for char in t:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target sum, determine if there are two numbers in the list such that\n    their sum is equal to the target. Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums = [2, 4, 6, 8, 10], target = 12):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The sum of nums[0] and nums[1] is 2 + 7 = 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        num_indices[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the next smaller element for each element in the array. If there is no smaller element,\n    return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        while stack and stack[-1] >= arr[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(arr[i])\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 5.\n    \"\"\"\n    return [4, 5, 2, 9, 1, 7]\n\nassert f(g()) == [2, 2, 1, 1, -1, -1]\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in the given array using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> List[int]:\n    return arr\n\nassert f(g()) == 6\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum path from the top-left corner to the bottom-right corner.\n    In each step, you can only move down or right.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum path from the top-left corner to the bottom-right corner is 29.\n\n    Therefore, the function should return 29.\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for row in range(1, rows):\n        dp[row][0] = dp[row-1][0] + grid[row][0]\n\n    for col in range(1, cols):\n        dp[0][col] = dp[0][col-1] + grid[0][col]\n\n    for row in range(1, rows):\n        for col in range(1, cols):\n            dp[row][col] = max(dp[row-1][col], dp[row][col-1]) + grid[row][col]\n\n    return dp[rows-1][cols-1]\n\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\n\nassert f(g()) == 29\n\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    n = len(s)\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(n):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g() -> str:\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome using recursion.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: The string \"racecar\" is a palindrome.\n    \"\"\"\n\n    if len(s) <= 1:\n        return True\n    elif s[0] == s[-1]:\n        return f(s[1:-1])\n    else:\n        return False\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 339,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if there exists a pair of numbers in the matrix\n    whose XOR is equal to the target number.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 14\n\n    There exists a pair (6, 8) in the matrix whose XOR is equal to the target number 14.\n\n    Therefore, the function should return True.\n    \"\"\"\n    nums = [num for row in matrix for num in row]\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g() -> (List[List[int]], int):\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 14\n    return matrix, target\n\nassert f(*g()) == True\n",
        "idx_generation": 183,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i is the product of all the numbers in the\n    original list except the one at index i.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    [24, 12, 8, 6]\n\n    Explanation: The output list is obtained by multiplying all the numbers in the original list except the one at\n    each index. For example, at index 0, the product is 2 * 3 * 4 = 24.\n\n    \"\"\"\n    n = len(nums)\n    left_prod = [1] * n\n    right_prod = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_prod[i] = left_prod[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_prod[i] = right_prod[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_prod[i] * right_prod[i]\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if there is a path from a given start node to a given end node.\n\n    Sample Input:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    Sample Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the given directed graph.\n\n    \"\"\"\n\n    def dfs(graph: List[List[int]], start: int, end: int) -> bool:\n        if start == end:\n            return True\n\n        visited[start] = True\n\n        for i in range(len(graph[0])):\n            if graph[start][i] == 1 and not visited[i]:\n                if dfs(graph, i, end):\n                    return True\n\n        return False\n\n    visited = [False] * len(graph)\n\n    return dfs(graph, start, end)\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g(), 0, 3) == True\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(tree: Dict[str, List[str]], start: str, target: str) -> bool:\n    \"\"\"\n    Given a tree represented as a dictionary where the keys are the nodes and the values\n    are lists of adjacent nodes, check if there exists a path from the start node to the\n    target node.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    stack = [start]\n    visited = set()\n\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(tree[node])\n    \n    return False\n\ndef g():\n    tree = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['G'],\n        'F': [],\n        'G': []\n    }\n    start = 'A'\n    target = 'G'\n    return tree, start, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k].\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 10\n    Explanation: The pairs (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4) satisfy the condition nums[i] < nums[j] < nums[k].\n\n    Input: nums = [5, 4, 3, 2, 1]\n    Output: 0\n    Explanation: There are no pairs that satisfy the condition nums[i] < nums[j] < nums[k].\n    \"\"\"\n\n    def count_triplets(nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums[i] < nums[j] < nums[k]:\n                        count += 1\n\n        return count\n\n    return count_triplets(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 10\n",
        "idx_generation": 323,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Return the number of ways to arrange non-attacking queens on an n x n chessboard.\n\n    Sample Input:\n    n = 4\n\n    Sample Output:\n    2\n\n    Explanation: There are 2 ways to arrange 4 queens on a 4 x 4 chessboard without any queen attacking another.\n    \"\"\"\n\n    def backtrack(row: int, queens: List[int]) -> int:\n        if row == n:\n            return 1\n\n        count = 0\n\n        for col in range(n):\n            if is_safe(row, col, queens):\n                queens.append(col)\n                count += backtrack(row + 1, queens)\n                queens.pop()\n\n        return count\n\n    def is_safe(row: int, col: int, queens: List[int]) -> bool:\n        for r, c in enumerate(queens):\n            if c == col or abs(row - r) == abs(col - c):\n                return False\n        return True\n\n    return backtrack(0, [])\n\ndef g() -> int:\n    \"\"\"\n    Generate the size of the chessboard.\n    \"\"\"\n    n = 4\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 214,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, words=['cat', 'dog', 'fish', 'hamster', 'bird', 'turtle', 'rabbit', 'snake', 'lizard', 'mouse']) -> bool:\n    \"\"\"Find the number of words in a list that contain exactly 3 vowels.\"\"\"\n    return sum(1 for word in words if sum(1 for letter in word if letter in 'aeiou') == 3) == s\ndef g(words=['cat', 'dog', 'fish', 'hamster', 'bird', 'turtle', 'rabbit', 'snake', 'lizard', 'mouse']):\n    return sum(1 for word in words if sum(1 for letter in word if letter in 'aeiou') == 3)\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of pairs of integers in the list\n    that add up to the target value.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 10\n\n    Output:\n    2\n    Explanation:\n    Pairs: (2, 8), (4, 6)\n    \"\"\"\n    count = 0\n    num_map = {}\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_map:\n            count += num_map[complement]\n        num_map[num] = num_map.get(num, 0) + 1\n    \n    return count\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 438,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    Input: nums = [4, 2, 7, 1, 5]\n    Output: [1, 2, 4, 5, 7]\n\n    Explanation: The list is sorted in ascending order.\n\n    Note: Implement the bubble sort algorithm in place, without using any extra space.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums\n\n\ndef g() -> List[int]:\n    nums = [4, 2, 7, 1, 5]\n    return nums\n\n\nassert f(g()) == [1, 2, 4, 5, 7]\n\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9, 11], target = 7\n    Output: 3\n    Explanation: The target value 7 is found at index 3 in the list.\n\n    Note:\n    - The input list will be sorted in ascending order.\n    \"\"\"\n\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\n\ndef g():\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return arr, target\n\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers in the list that add up to a target value.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> (List[int], int):\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 225,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the median.\n\n    Example:\n    nums = [1, 5, 3, 2, 4]\n\n    The median of the numbers is 3.\n    Therefore, the function should return 3.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    if n % 2 == 0:\n        median = (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        median = nums[n // 2]\n\n    return median\n\ndef g():\n    return [1, 5, 3, 2, 4]\n\nassert f(g()) == 3\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there exists a combination of numbers in the list that adds up to the target.\n\n    Example:\n    nums = [2, 3, 5, 7]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The combination [2, 3, 5] adds up to 10.\n    \"\"\"\n\n    def backtrack(nums, start, target, path, result):\n        if target == 0:\n            result.append(path[:])\n            return\n\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(nums, i, target - nums[i], path, result)\n            path.pop()\n\n    result = []\n    nums.sort()\n    backtrack(nums, 0, target, [], result)\n    return len(result) > 0\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 3, 5, 7]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import defaultdict\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them together based on their anagrams.\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n    Return a list of lists where each inner list contains words that are anagrams of each other.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    The function should return [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]].\n\n    Note:\n    The order of the output does not matter.\n    \"\"\"\n    anagram_map = defaultdict(list)\n\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        anagram_map[sorted_word].append(word)\n\n    return list(anagram_map.values())\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the one at that index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The output should be [24, 12, 8, 6], since:\n    - The product of all elements except the first one is 2 * 3 * 4 = 24\n    - The product of all elements except the second one is 1 * 3 * 4 = 12\n    - The product of all elements except the third one is 1 * 2 * 4 = 8\n    - The product of all elements except the fourth one is 1 * 2 * 3 = 6\n\n    Return the new list as the result.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    result = [1] * n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n",
        "idx_generation": 452,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product is 3 * 4 = 12.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.stack:\n            return self.stack.pop()\n        return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only '(' and ')', determine if the string is balanced.\n    A balanced string is one in which all parentheses are properly closed and nested.\n\n    Return True if the string is balanced, otherwise return False.\n\n    Example:\n    s = \"((())())\"\n\n    The string is balanced as all parentheses are properly closed and nested, so the function should return True.\n    \"\"\"\n\n    stack = Stack()\n\n    for char in s:\n        if char == '(':\n            stack.push(char)\n        elif char == ')':\n            if stack.is_empty():\n                return False\n            stack.pop()\n\n    return stack.is_empty()\n\ndef g() -> str:\n    s = \"((())())\"\n    return s\n\nassert f(g()) == True\n\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def backtrack(index, total, used):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n\n            used[i] = True\n\n            if backtrack(index + 1, total + nums[i], used):\n                return True\n\n            used[i] = False\n\n        return False\n\n    used = [False] * len(nums)\n    return backtrack(0, 0, used)\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n\n",
        "idx_generation": 465,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    \"\"\"\n    def helper(grid, r, c, memo):\n        if memo[r][c] != -1:\n            return memo[r][c]\n        max_length = 1\n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] > grid[r][c]:\n                max_length = max(max_length, 1 + helper(grid, nr, nc, memo))\n        memo[r][c] = max_length\n        return max_length\n\n    n = len(grid)\n    m = len(grid[0])\n    memo = [[-1] * m for _ in range(n)]\n    max_length = 0\n    for r in range(n):\n        for c in range(m):\n            max_length = max(max_length, helper(grid, r, c, memo))\n    return max_length\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Return the grid itself.\n    \"\"\"\n    return grid\n\ngrid = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\nassert f(g(grid)) == 4\n\n",
        "idx_generation": 278,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, split the string into k-sized chunks and return a list of the chunks.\n\n    Example:\n    Input:\n    s = \"abcdefghi\"\n    k = 3\n\n    Output:\n    [\"abc\", \"def\", \"ghi\"]\n    \"\"\"\n    chunks = []\n    for i in range(0, len(s), k):\n        chunk = s[i:i+k]\n        chunks.append(chunk)\n    return chunks\n\ndef g():\n    s = \"abcdefghi\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"abc\", \"def\", \"ghi\"]\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, return True if the string s can be formed by concatenating the words in the list, in any order. Otherwise, return False.\n\n    Example:\n    s = \"applepie\"\n    words = [\"apple\", \"pie\"]\n\n    The string s can be formed by concatenating the words \"apple\" and \"pie\", so the function should return True.\n\n    Note:\n    - The string s and the words in the list will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(idx, path):\n        if idx == len(s):\n            return path == s\n\n        for word in words:\n            if s.startswith(path + word):\n                if dfs(idx + len(word), path + word):\n                    return True\n\n        return False\n\n    return dfs(0, \"\")\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words.\n    \"\"\"\n    return \"applepie\", [\"apple\", \"pie\"]\n\nassert f(*g()) == True\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers whose XOR is equal to the target number.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    There exists a pair (2, 8) whose XOR is equal to the target number 10.\n\n    Therefore, the function should return True.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n    return False\n\ndef g() -> (List[int], int):\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 183,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, determine the number of unique paths from the top-left corner to the bottom-right corner\n    of a n x m grid. You can only move down or right.\n\n    Example:\n    n = 3, m = 3\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner in a 3 x 3 grid.\n    \"\"\"\n\n    def count_paths(n: int, m: int, i: int, j: int) -> int:\n        if i == n - 1 and j == m - 1:\n            return 1\n        if i >= n or j >= m:\n            return 0\n\n        return count_paths(n, m, i + 1, j) + count_paths(n, m, i, j + 1)\n\n    return count_paths(n, m, 0, 0)\n\n\ndef g():\n    n = 3\n    m = 3\n    return n, m\n\n\nassert f(*g()) == 6\n",
        "idx_generation": 210,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if it contains a cycle.\n\n    Sample Input:\n    graph = [[1, 2], [0, 2], [0, 1]]\n\n    Sample Output:\n    True\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0\n\n    Sample Input:\n    graph = [[1, 2, 3], [0, 2], [0, 1], [0]]\n\n    Sample Output:\n    False\n    Explanation: The graph does not contain a cycle.\n    \"\"\"\n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if not visited[node]:\n            if has_cycle(graph, node, visited, -1):\n                return True\n    return False\n\ndef has_cycle(graph: List[List[int]], node: int, visited: List[bool], parent: int) -> bool:\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if has_cycle(graph, neighbor, visited, node):\n                return True\n        elif neighbor != parent:\n            return True\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph with a cycle.\n    \"\"\"\n    return [[1, 2], [0, 2], [0, 1]]\n\nassert f(g()) == True\n",
        "idx_generation": 177,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a clear path. You can only move down or right.\n\n    Return True if a path exists, False otherwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    def backtrack(row, col):\n        if row == rows - 1 and col == cols - 1:\n            return True\n        if row >= rows or col >= cols or matrix[row][col] == 0:\n            return False\n        return backtrack(row + 1, col) or backtrack(row, col + 1)\n\n    return backtrack(0, 0)\n\ndef g(matrix=[[1, 1, 1], [1, 0, 1], [1, 1, 1]]):\n    \"\"\"\n    Generate a matrix with obstacles and clear paths.\n    \"\"\"\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target sum, determine the number of\n    unique combinations that add up to the target sum.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output:\n    7\n    Explanation:\n    There are 7 unique combinations that add up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 326,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, determine the number of ways to express n as a sum of 1s, 2s, and 3s.\n\n    Example:\n    n = 4\n\n    Output:\n    7\n\n    Explanation:\n    There are 7 ways to express 4 as a sum of 1s, 2s, and 3s:\n    1 + 1 + 1 + 1\n    1 + 1 + 2\n    1 + 2 + 1\n    2 + 1 + 1\n    2 + 2\n    1 + 3\n    3 + 1\n    \"\"\"\n\n    def count_ways(n: int, cache: dict) -> int:\n        if n < 0:\n            return 0\n        if n == 0:\n            return 1\n\n        if n in cache:\n            return cache[n]\n\n        count = count_ways(n - 1, cache) + count_ways(n - 2, cache) + count_ways(n - 3, cache)\n        cache[n] = count\n        return count\n\n    cache = {}\n    return count_ways(n, cache)\n\n\ndef g():\n    n = 4\n    return n\n\n\nassert f(g()) == 7\n",
        "idx_generation": 226,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the count of palindromic substrings in the given integer n.\n    \"\"\"\n    s = str(n)\n    count = 0\n\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                count += 1\n\n    return count\n\ndef g():\n    return 12321\n\nassert f(g()) == 7\n",
        "idx_generation": 78,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, find the maximum product of any three numbers in the array.\n    Return True if the maximum product is greater than or equal to 100, otherwise False.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    return arr[n-1] * arr[n-2] * arr[n-3] >= 100\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == False\n\n",
        "idx_generation": 438,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\nimport heapq\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    Output: 5\n\n    Explanation: The second largest element in the list is 5.\n\n    Note:\n    - You may assume k is always valid, 1 \u2264 k \u2264 array's length.\n    \"\"\"\n\n    pq = []\n\n    for num in nums:\n        heapq.heappush(pq, num)\n        if len(pq) > k:\n            heapq.heappop(pq)\n\n    return heapq.heappop(pq)\n\ndef g(nums=[3, 2, 1, 5, 6, 4], k=2):\n    return nums, k\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 491,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers contains a Pythagorean triplet.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    bool: True if the list contains a Pythagorean triplet, False otherwise.\n    \"\"\"\n    squares = [num * num for num in nums]\n    squares.sort()\n\n    for i in range(len(squares) - 1, 1, -1):\n        c = squares[i]\n        left = 0\n        right = i - 1\n\n        while left < right:\n            a = squares[left]\n            b = squares[right]\n\n            if a + b == c:\n                return True\n            elif a + b < c:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g():\n    return [3, 1, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 489,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if a given string is a palindrome and contains only alphabetic characters.\"\"\"\n    s = s.lower()\n    s = ''.join(c for c in s if c.isalpha())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal, Panama!\"\n\nassert f(g()) == True\n",
        "idx_generation": 239,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [-10, -3, 1, 2, 3, 4]\n\n    The maximum product of any three elements is (-10) * (-3) * 4 = 120.\n\n    Therefore, the function should return 120.\n    \"\"\"\n    max_product = float('-inf')\n    nums.sort()\n    n = len(nums)\n    max_product = max(max_product, nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [-10, -3, 1, 2, 3, 4]\n\nassert f(g()) == 120\n",
        "idx_generation": 442,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target value, determine if it is possible to split the list into two\n    subsets such that the sum of elements in both subsets is equal to the target value.\n\n    Example:\n    Input: nums = [1, 5, 11, 5]\n           target = 11\n    Output: True\n\n    Explanation: The list can be split into [1, 5, 5] and [11], where the sum of elements in both subsets is equal to 11.\n    \"\"\"\n\n    total_sum = sum(nums)\n    if total_sum % 2 != 0 or max(nums) > target:\n        return False\n\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[target_sum]\n\ndef g() -> (List[int], int):\n    return [1, 5, 11, 5], 11\n\nassert f(*g()) == True\n",
        "idx_generation": 273,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, return a list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value such that there exists a pair of numbers in the list that add up to the target.\n    \"\"\"\n    nums = [3, 5, 2, 8, 10, 4]\n    target = 7\n    return nums, target\n\nassert f(*g()) != []\n\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1]\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list.\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number\n    complements = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n\n        # Check if the complement exists in the dictionary\n        if complement in complements:\n            # Return the indices of the two numbers\n            return [complements[complement], i]\n\n        # Add the current number and its index to the dictionary\n        complements[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 457,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of all the odd numbers.\n    \"\"\"\n    queue = []\n    for num in nums:\n        if num % 2 != 0:\n            queue.append(num ** 2)\n    return sum(queue)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g()) == 84\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of different ways to represent n as a sum of 1, 3, and 4.\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    return f(n - 1) + f(n - 3) + f(n - 4)\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, count the number of valid paths from the top-left cell to the bottom-right cell.\n    A valid path can only consist of cells containing a value of 1.\n    \"\"\"\n    def dfs(row, col):\n        if row == n-1 and col == m-1:\n            return 1\n        count = 0\n        if row+1 < n and grid[row+1][col] == 1:\n            count += dfs(row+1, col)\n        if col+1 < m and grid[row][col+1] == 1:\n            count += dfs(row, col+1)\n        return count\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    return (3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]])\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 283,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    All occurrences of a character must be replaced with another character while preserving the order of characters.\n    No two characters may map to the same character, but a character may map to itself.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n\n        if char_s in char_map:\n            if char_map[char_s] != char_t:\n                return False\n        else:\n            if char_t in used_chars:\n                return False\n\n            char_map[char_s] = char_t\n            used_chars.add(char_t)\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return (\"egg\", \"add\")\n\nassert f(*g()) == True\n\n",
        "idx_generation": 490,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cherry\"]\n\n    The new list should be [\"elppa\", \"ananab\", \"yrrehc\"], where each word is reversed.\n\n    Constraints:\n    - The input list words will have at least one word.\n    \"\"\"\n\n    # Base case: when words is empty, return an empty list\n    if not words:\n        return []\n\n    # Recursive case: reverse the first word and concatenate it with the new list of reversed words\n    reversed_words = f(words[:-1]) + [words[-1][::-1]]\n    return reversed_words\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words that can be used as input for the function f.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\"]\n\nassert f(g()) == [\"elppa\", \"ananab\", \"yrrehc\"]\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which gives 28 (5 XOR 25 = 28).\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 183,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a number is a perfect square.\n    A perfect square is a number that can be expressed as the product of two equal integers.\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        if n < 0:\n            return False\n        if n == 0 or n == 1:\n            return True\n        for i in range(2, int(n**0.5) + 1):\n            if i * i == n:\n                return True\n        return False\n    \n    return is_perfect_square(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a perfect square number.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 214,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start_node: int, end_node: int, k: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, a start node, an end node, and an integer k, find if there exists a path from the start node to the end node with exactly k edges.\n\n    Sample Input:\n    graph = [[1, 2], [3, 4], [5], [6, 7], [], [8], [], [], []]\n    start_node = 0\n    end_node = 6\n    k = 3\n\n    Sample Output:\n    True\n\n    Explanation:\n    The graph can be visualized as follows:\n\n            0\n           / \\\n          1   2\n         / \\\n        3   4\n       / \\\n      6   7\n     /\n    8\n\n    There exists a path 0 -> 1 -> 3 -> 6 with exactly 3 edges, which leads to the end node 6.\n    \"\"\"\n\n    def dfs(node, depth):\n        if depth == k and node == end_node:\n            return True\n        if depth < k:\n            for neighbor in graph[node]:\n                if dfs(neighbor, depth + 1):\n                    return True\n        return False\n\n    return dfs(start_node, 0)\n\ndef g():\n    graph = [[1, 2], [3, 4], [5], [6, 7], [], [8], [], [], []]\n    start_node = 0\n    end_node = 6\n    k = 3\n    return graph, start_node, end_node, k\n\nassert f(*g()) == True\n",
        "idx_generation": 187,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(graph: List[List[int]], start: int, end: int, k: int) -> bool:\n    \"\"\"Find the shortest path in a graph from start to end with exactly k edges.\"\"\"\n    def shortest_path(graph, start, end, k):\n        if start == end and k == 0:\n            return True\n        if k <= 0:\n            return False\n        \n        visited = set()\n        queue = deque([(start, 0)])\n        \n        while queue:\n            node, edges = queue.popleft()\n            \n            if node == end and edges == k:\n                return True\n            \n            if edges < k:\n                for neighbor in graph[node]:\n                    if (neighbor, edges + 1) not in visited:\n                        queue.append((neighbor, edges + 1))\n                        visited.add((neighbor, edges + 1))\n        \n        return False\n    \n    return shortest_path(graph, start, end, k)\n\ndef g():\n    graph = [[1, 2], [2, 3], [3], []]\n    start = 0\n    end = 3\n    k = 2\n    return graph, start, end, k\n\nassert f(*g())\n",
        "idx_generation": 354,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range from 1 to n.\n\n    Example:\n    n = 4\n    k = 2\n\n    The possible combinations of 2 numbers out of the range from 1 to 4 are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n\n    Therefore, the function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n\n    def backtrack(start, combination):\n        if len(combination) == k:\n            combinations.append(combination[:])\n            return\n        for i in range(start, n + 1):\n            combination.append(i)\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    combinations = []\n    backtrack(1, [])\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 337,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of unique combinations of the integers that sum up to the target.\n    \"\"\"\n    def backtrack(nums: List[int], target: int, start: int, path: List[int], result: List[List[int]]) -> None:\n        if target < 0:\n            return\n        if target == 0:\n            result.append(path)\n            return\n        \n        for i in range(start, len(nums)):\n            backtrack(nums, target - nums[i], i, path + [nums[i]], result)\n    \n    result = []\n    backtrack(nums, target, 0, [], result)\n    return len(result)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == 2\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct substrings that can be formed from it.\n\n    Sample Input:\n    s = \"abc\"\n\n    Sample Output:\n    6\n    Explanation: The distinct substrings are \"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\".\n    \"\"\"\n    def count_substrings(s):\n        n = len(s)\n        substrings = set()\n        for i in range(n):\n            for j in range(i+1, n+1):\n                substrings.add(s[i:j])\n        return len(substrings)\n    \n    return count_substrings(s)\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == 6\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    The list is sorted in non-decreasing order, so return True.\n\n    arr = [5, 4, 3, 2, 1]\n    The list is not sorted in non-decreasing order, so return False.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] and nums[1] is equal to the target 9.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n\n    The target element 9 is found at index 4.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers is a permutation of the first n natural numbers.\n    \"\"\"\n    n = len(arr)\n    if set(arr) != set(range(1, n+1)):\n        return False\n    return True\n\ndef g(n: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that is a permutation of the first n natural numbers.\n    \"\"\"\n    return list(range(1, n+1))\n\nassert f(g(5)) == True\n",
        "idx_generation": 242,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n    Explanation:\n    The maximum product can be achieved by multiplying 2, 3, and 4, resulting in 24.\n\n    Note:\n    - The length of the input list will be at least 3.\n    - The input list may contain negative numbers.\n    \"\"\"\n\n    def max_product(nums):\n        nums.sort()\n        n = len(nums)\n        return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\n    return max_product(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of subarrays whose sum is equal to the target.\n\n    Example:\n    Input: [1, 1, 1], 2\n    Output: 2\n\n    Explanation:\n    There are two subarrays with a sum of 2: [1, 1] and [1, 1].\n    \"\"\"\n    count = 0\n    curr_sum = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        curr_sum += num\n        count += prefix_sums.get(curr_sum - target, 0)\n        prefix_sums[curr_sum] = prefix_sums.get(curr_sum, 0) + 1\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 1, 1], 2)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 274,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any non-adjacent numbers in the list.\n\n    Example:\n    Input: [2, 4, 6, 2, 5]\n    Output: 13\n    Explanation:\n    The maximum sum can be achieved by selecting numbers 2, 6, and 5, resulting in a sum of 13.\n\n    Note:\n    - The length of the input list will be at least 3.\n    - The input list may contain negative numbers.\n    \"\"\"\n\n    def max_sum(nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n        return dp[n - 1]\n\n    return max_sum(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 6, 2, 5]\n\nassert f(g()) == 13\n\n",
        "idx_generation": 459,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Input: nums = [1]\n    Output: 1\n    Explanation: The subarray [1] has the maximum sum of 1.\n    \"\"\"\n\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 460,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with any duplicate elements removed.\n    The order of the elements in the resulting list should be the same as the original list.\n    \"\"\"\n    stack = []\n    seen = set()\n\n    for num in nums:\n        if num not in seen:\n            stack.append(num)\n            seen.add(num)\n    \n    return stack\n\ndef g():\n    nums = [1, 2, 3, 2, 4, 5, 1]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase. You can climb either 1 or 2 steps at a time.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation: There are 5 ways to climb to the top: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2].\n\n    Constraints:\n    - The input integer is positive and does not exceed 10^4.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4) -> int:\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 471,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input: [\n      [1, 3, 1],\n      [1, 5, 1],\n      [4, 2, 1]\n    ]\n    Output: 7\n    Explanation: The minimum path sum from the top-left cell (1) to the bottom-right cell (1) is 7.\n\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers, where the minimum path sum from the top-left cell to the bottom-right cell is minimum.\n    \"\"\"\n    return [\n      [1, 3, 1],\n      [1, 5, 1],\n      [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among all strings.\n\n    Args:\n    strings (List[str]): The list of strings.\n\n    Returns:\n    str: The longest common prefix among all strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n    prefix = \"\"\n    for i in range(min_length):\n        char = strings[0][i]\n        if all(s[i] == char for s in strings):\n            prefix += char\n        else:\n            break\n\n    return prefix\n\ndef g():\n    strings = [\"flower\", \"flow\", \"flight\"]\n    return strings\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Determine if a given string matches a pattern, where the pattern consists of only letters and dots.\n    A dot matches any single character.\n\n    Example:\n    s = \"apple\"\n    pattern = \"a..le\"\n\n    The pattern matches the string \"apple\" because the dots can match any character.\n\n    Returns True if the string matches the pattern, False otherwise.\n    \"\"\"\n\n    def match_pattern(s: str, pattern: str) -> bool:\n        \"\"\"\n        Recursively checks if a string matches a pattern.\n        \"\"\"\n        if len(s) == 0 and len(pattern) == 0:\n            # Base case: both the string and pattern are empty\n            return True\n\n        if len(s) == 0 or len(pattern) == 0:\n            # Base case: either the string or pattern is empty\n            return False\n\n        if pattern[0] == '.':\n            # Case 1: the pattern has a dot, which can match any character\n            return match_pattern(s[1:], pattern[1:])\n\n        if s[0] == pattern[0]:\n            # Case 2: the first characters of the string and pattern match\n            return match_pattern(s[1:], pattern[1:])\n\n        return False\n\n    return match_pattern(s, pattern)\n\n\ndef g():\n    s = \"apple\"\n    pattern = \"a..le\"\n    return s, pattern\n\nassert f(*g()) == True\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], x: int) -> int:\n    \"\"\"\n    Count the number of elements in the given list that have the xth bit set to 1.\n    \"\"\"\n    count = 0\n    for num in arr:\n        if (num >> x) & 1:\n            count += 1\n    return count\n\ndef g():\n    return [3, 5, 9, 6, 12, 15]\n\nassert f(g(), 2) == 4\n",
        "idx_generation": 188,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n) == 55\n\ndef g():\n    return 10\n\nassert f(g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of characters, determine if it contains a valid word formed by connecting adjacent\n    letters horizontally, vertically, or diagonally. Each letter can only be used once.\n    \"\"\"\n    if not grid or not grid[0]:\n        return False\n\n    def dfs(row: int, col: int, word: str, visited: List[List[bool]]) -> bool:\n        \"\"\"\n        Perform depth-first search to check if a valid word can be formed starting from a specific position.\n        \"\"\"\n        if not word:\n            return True\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] != word[0]:\n            return False\n\n        visited[row][col] = True\n        result = dfs(row + 1, col, word[1:], visited) or dfs(row - 1, col, word[1:], visited) or dfs(row, col + 1, word[1:], visited) or dfs(row, col - 1, word[1:], visited) or dfs(row + 1, col + 1, word[1:], visited) or dfs(row - 1, col - 1, word[1:], visited) or dfs(row + 1, col - 1, word[1:], visited) or dfs(row - 1, col + 1, word[1:], visited)\n        visited[row][col] = False\n\n        return result\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if dfs(i, j, grid[i][j], [[False] * len(grid[0]) for _ in range(len(grid))]):\n                return True\n\n    return False\n\ndef g(grid: List[List[str]]) -> str:\n    \"\"\"\n    Find a valid word formed by connecting adjacent letters horizontally, vertically, or diagonally in the grid.\n    Each letter can only be used once.\n    \"\"\"\n    if not grid or not grid[0]:\n        return \"\"\n\n    def dfs(row: int, col: int, word: str, visited: List[List[bool]]) -> List[str]:\n        \"\"\"\n        Perform depth-first search to find a valid word starting from a specific position.\n        \"\"\"\n        if not word:\n            return [word]\n\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or visited[row][col] or grid[row][col] != word[0]:\n            return []\n\n        visited[row][col] = True\n        result = []\n        for r, c in [(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1), (row + 1, col + 1), (row - 1, col - 1), (row + 1, col - 1), (row - 1, col + 1)]:\n            temp = dfs(r, c, word[1:], visited)\n            if temp:\n                result.extend([grid[row][col] + t for t in temp])\n        visited[row][col] = False\n\n        return result\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            words = dfs(i, j, grid[i][j], [[False] * len(grid[0]) for _ in range(len(grid))])\n            if words:\n                return words[0]\n\n    return \"\"\n\nassert f(g([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]]))\n",
        "idx_generation": 189,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> int:\n    \"\"\"\n    Given a directed graph and two nodes, find the number of paths from the start node to the end node.\n    Each node in the graph is represented by a string, and the graph is represented as a dictionary where\n    each key is a node and the corresponding value is a list of its neighboring nodes.\n\n    Sample Input:\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n\n    Sample Output:\n    3\n    Explanation: There are 3 paths from node 'A' to node 'D': 'A' -> 'B' -> 'C' -> 'D', 'A' -> 'B' -> 'D', 'A' -> 'C' -> 'D'.\n    \"\"\"\n\n    def dfs(node):\n        nonlocal count\n        if node == end:\n            count += 1\n            return\n        for neighbor in graph[node]:\n            dfs(neighbor)\n    \n    count = 0\n    dfs(start)\n    return count\n\ndef g():\n    graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['A']}\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g()) == 3\n",
        "idx_generation": 358,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of ways to choose k items from n distinct items.\n\n    Example:\n    n = 5, k = 3\n\n    Possible combinations: (5, 4, 3), (5, 4, 2), (5, 4, 1), (5, 3, 2), (5, 3, 1), (5, 2, 1), (4, 3, 2), (4, 3, 1), (4, 2, 1), (3, 2, 1)\n\n    So, f(n, k) should return 10.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 342,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations of the list.\n    \"\"\"\n    def backtrack(nums: List[int], path: List[int], result: List[List[int]]) -> None:\n        if len(path) == len(nums):\n            result.append(path)\n            return\n        \n        for i in range(len(nums)):\n            if nums[i] in path:\n                continue\n            backtrack(nums, path + [nums[i]], result)\n    \n    result = []\n    backtrack(nums, [], result)\n    return len(result)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n",
        "idx_generation": 227,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the vowels of s.\n    Return the string with reversed vowels.\n\n    Example:\n    s = \"hello\"\n\n    f(s) => \"holle\"\n\n    Explanation: The reversed vowels in the string \"hello\" are 'o' and 'e', so the resulting string is \"holle\".\n    \"\"\"\n\n    vowels = set('aeiouAEIOU')\n    s = list(s)\n    i, j = 0, len(s) - 1\n\n    while i < j:\n        if s[i] in vowels and s[j] in vowels:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        elif s[i] in vowels:\n            j -= 1\n        else:\n            i += 1\n\n    return ''.join(s)\n\ndef g() -> str:\n    return \"hello\"\n\nassert f(g()) == \"holle\"\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order and return the sorted list.\n\n    Example:\n    nums = [5, 3, 7, 1, 2]\n    Output: [1, 2, 3, 5, 7]\n\n    \"\"\"\n\n    return sorted(nums)\n\n\ndef g() -> List[int]:\n    nums = [5, 3, 7, 1, 2]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 7]\n",
        "idx_generation": 441,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the Quick Sort algorithm.\n    \"\"\"\n    def partition(arr, low, high):\n        i = (low - 1)\n        pivot = arr[high]\n    \n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i = i + 1\n                arr[i], arr[j] = arr[j], arr[i]\n    \n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n    \n    def quickSort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n    \n            quickSort(arr, low, pi - 1)\n            quickSort(arr, pi + 1, high)\n    \n    n = len(nums)\n    quickSort(nums, 0, n - 1)\n    return nums\n\ndef g():\n    nums = [64, 34, 25, 12, 22, 11, 90]\n    return nums\n\nassert f(g()) == [11, 12, 22, 25, 34, 64, 90]\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers that add up to a specific target.\n    Return the indices of the two numbers in the array.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output: [0, 1]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 275,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is a geometric progression, False otherwise.\n    A geometric progression is defined as a sequence of numbers where each term after the first is found by multiplying the previous term by a fixed, non-zero number called the common ratio.\n\n    Sample Input:\n    nums = [2, 4, 8, 16]\n\n    Sample Output:\n    True\n    \"\"\"\n\n    if len(nums) < 2:\n        return False\n\n    ratio = nums[1] / nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] / nums[i-1] != ratio:\n            return False\n\n    return True\n\ndef g():\n    return [2, 4, 8, 16]\n\nassert f(g()) == True\n",
        "idx_generation": 468,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list that can be added to the target value.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        return subset_sum(nums, target, index+1, current_sum + nums[index]) or subset_sum(nums, target, index+1, current_sum)\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 9) == True\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the maximum sum of any contiguous subarray of size k.\n\n    Example:\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n\n    Output:\n    9\n\n    Explanation:\n    The subarray with maximum sum is [5, 1, 3], which sums up to 9.\n    \"\"\"\n\n    n = len(nums)\n\n    if n < k:\n        return 0\n\n    max_sum = sum(nums[:k])\n    current_sum = max_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i-k]\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 9\n\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value that can be obtained by selecting two numbers from the list is 28, which can be obtained by XORing the numbers 25 and 3.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    queue = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            queue.append(i)\n    if queue:\n        return queue.pop(0)\n    else:\n        return -1\n\ndef g() -> Tuple[List[int], int]:\n    return [4, 2, 8, 6, 3, 9, 1], 6\n\nassert f(*g()) == 3\n",
        "idx_generation": 478,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n    \n    Hint: Use backtracking to generate all combinations of k numbers.\n\n    \"\"\"\n    def backtrack(start, combo):\n        if len(combo) == k:\n            results.append(combo[:])\n        for i in range(start, n+1):\n            combo.append(i)\n            backtrack(i+1, combo)\n            combo.pop()\n    \n    results = []\n    backtrack(1, [])\n    return results\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n",
        "idx_generation": 473,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the number of unique paths from top-left to bottom-right in a grid of size n x n.\"\"\"\n    def count_paths(i: int, j: int, memo: dict) -> int:\n        if i == n-1 and j == n-1:\n            return 1\n        if i >= n or j >= n:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        right_paths = count_paths(i, j+1, memo)\n        down_paths = count_paths(i+1, j, memo)\n        memo[(i, j)] = right_paths + down_paths\n        return memo[(i, j)]\n\n    memo = {}\n    return count_paths(0, 0, memo)\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 301,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list with words that start with the given prefix.\n\n    Example:\n    Input:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n\n    Output:\n    [\"banana\"]\n    \"\"\"\n    return [word for word in words if word.startswith(prefix)]\n\ndef g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n    return words, prefix\n\nassert f(*g()) == [\"banana\"]\n",
        "idx_generation": 494,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if it is possible to form the string s by concatenating the words in any order.\n    Return True if the string can be formed, False otherwise.\n\n    Example:\n    s = \"leetcode\"\n    words = [\"leet\", \"code\"]\n\n    f(s, words) => True\n    Explanation: The string \"leetcode\" can be formed by concatenating \"leet\" and \"code\".\n\n    \"\"\"\n\n    def backtrack(start):\n        if start == len(s):\n            return True\n\n        for word in words:\n            if s.startswith(word, start):\n                if backtrack(start + len(word)):\n                    return True\n\n        return False\n\n    return backtrack(0)\n\ndef g():\n    return \"leetcode\", [\"leet\", \"code\"]\n\nassert f(*g()) == True\n\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_val)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 197,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation:\n    From the top-left corner, there are a total of 6 ways to reach the bottom-right corner:\n    1. Right -> Right -> Down\n    2. Right -> Down -> Right\n    3. Down -> Right -> Right\n    4. Down -> Down -> Right\n    5. Down -> Right -> Down\n    6. Right -> Down -> Down\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[n - 1][n - 1]\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 219,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, determine if the graph has a cycle.\n    \"\"\"\n    def has_cycle(n, edges):\n        # Create a list to store the visited status of each node\n        visited = [False] * n\n        # Create a list to store the parent node of each node\n        parent = [-1] * n\n\n        # Recursive function to check for cycles\n        def is_cyclic(node):\n            visited[node] = True\n            for neighbor in edges[node]:\n                if not visited[neighbor]:\n                    parent[neighbor] = node\n                    if is_cyclic(neighbor):\n                        return True\n                elif parent[node] != neighbor:\n                    return True\n            return False\n\n        # Check if the graph has a cycle\n        for node in range(n):\n            if not visited[node]:\n                if is_cyclic(node):\n                    return True\n        return False\n\n    # Check if the graph has a cycle\n    return has_cycle(n, edges)\n\ndef g(n=4, edges=[[0, 1], [1, 2], [2, 3], [3, 0]]):\n    return n, edges\n\nassert f(*g())\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list and an integer n,\n    determine if the graph is bipartite.\n\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n\n    Return True if the graph is bipartite, False otherwise.\n\n    Example:\n    Input: n = 4, edges = [[0,1],[1,2],[2,3],[3,0]]\n    Output: False\n    Explanation: The graph contains a cycle with odd length, so it is not bipartite.\n    \"\"\"\n\n    # Initialize a color array to store the color of each vertex\n    color = [-1] * n\n\n    # Set the color of the first vertex to 0\n    color[0] = 0\n\n    # Initialize a queue for BFS traversal\n    queue = []\n    queue.append(0)\n\n    # While the queue is not empty\n    while queue:\n        # Dequeue a vertex\n        u = queue.pop(0)\n\n        # Traverse all adjacent vertices of u\n        for v in edges[u]:\n            # If the adjacent vertex v is not colored\n            if color[v] == -1:\n                # Color the adjacent vertex with a different color than u\n                color[v] = 1 - color[u]\n                queue.append(v)\n            # If the adjacent vertex v is already colored with the same color as u, the graph is not bipartite\n            elif color[v] == color[u]:\n                return False\n\n    return True\n\n\ndef g():\n    n = 4\n    edges = [[0,1],[1,2],[2,3],[3,0]]\n    return (n, edges)\n\nassert f(*g()) == False\n\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Check if a string 's' can be rearranged to form another string 't' by permuting its characters.\n\n    Sample Input:\n    s = \"listen\"\n    t = \"silent\"\n\n    Sample Output:\n    True\n    Explanation: The string 'listen' can be rearranged to form 'silent' by permuting its characters.\n\n    Sample Input:\n    s = \"hello\"\n    t = \"world\"\n\n    Sample Output:\n    False\n    Explanation: The string 'hello' cannot be rearranged to form 'world' by permuting its characters.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for char in s:\n        count_s[ord(char) - ord('a')] += 1\n    for char in t:\n        count_t[ord(char) - ord('a')] += 1\n    return count_s == count_t\n\ndef g():\n    return \"listen\", \"silent\"\n\nassert f(*g()) == True\n\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of combinations of valid parentheses pairs that can be formed.\n    A valid parentheses pair is defined as a string of opening and closing parentheses that are properly nested.\n\n    Example:\n    n = 3\n\n    f(n) => 5\n    Explanation: The valid parentheses pairs are \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\".\n\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n\n",
        "idx_generation": 241,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a string s of length n such that each substring of length k within s contains exactly k distinct characters.\n    \"\"\"\n    def has_k_distinct_chars(s: str, k: int) -> bool:\n        char_count = {}\n        distinct_chars = 0\n        for char in s:\n            if char_count.get(char, 0) == 0:\n                distinct_chars += 1\n            char_count[char] = char_count.get(char, 0) + 1\n            if distinct_chars > k:\n                return False\n        return distinct_chars == k\n    \n    for i in range(n - k + 1):\n        substring = \"\".join(chr(ord('a') + j) for j in range(i, i + k))\n        if not has_k_distinct_chars(substring, k):\n            return False\n    return True\n\ndef g(n=5, k=2) -> Tuple[int, int]:\n    \"\"\"\n    Generate two integers n and k.\n    \"\"\"\n    return n, k\n\nassert f(*g()) == True\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest\n\ndef g() -> List[int]:\n    nums = [5, 2, 7, 1, 8, 4]\n    return nums\n\nassert f(g()) == 2\n\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (LIS).\n    A subsequence is a sequence that can be derived from an array by deleting some or no elements\n    without changing the order of the remaining elements.\n\n    Example:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    The function should return 4, as the longest increasing subsequence is [2, 3, 7, 101].\n\n    Note:\n    The LIS does not need to be contiguous.\n    \"\"\"\n    dp = [1] * len(arr)\n\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the even numbers sorted in ascending order followed by the odd numbers sorted in descending order.\n    \n    Sample Input:\n    nums = [5, 2, 9, 12, 7, 4]\n    \n    Sample Output:\n    [2, 4, 12, 9, 7, 5]\n    \"\"\"\n    even_nums = sorted([num for num in nums if num % 2 == 0])\n    odd_nums = sorted([num for num in nums if num % 2 != 0], reverse=True)\n    return even_nums + odd_nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers with values from 1 to 10.\n    \"\"\"\n    return list(range(1, 11))\n\nassert f(g()) == [2, 4, 6, 8, 10, 9, 7, 5, 3, 1]\n",
        "idx_generation": 278,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a sorted list of the squares of those integers.\n\n    Example:\n    nums = [-4, -2, 0, 2, 4]\n\n    The squares of the integers in the list are [16, 4, 0, 4, 16].\n\n    Therefore, the function should return [0, 4, 4, 16, 16].\n    \"\"\"\n    return sorted([num**2 for num in nums])\n\ndef g():\n    return [-4, -2, 0, 2, 4]\n\nassert f(g()) == [0, 4, 4, 16, 16]\n",
        "idx_generation": 473,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of positive integers nums and a target integer k, determine if there exists a subset of nums such that the sum of the subset is equal to k.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (k+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][0] = True\n    \n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if nums[i-1] <= j:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n    \n    return dp[n][k]\n\ndef g(nums = [1, 2, 3, 4, 5], k = 9):\n    return nums\n\nassert f(g(), 9)\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n    The subarray must contain at least one number.\n\n    Example:\n    Input: nums = [2,3,-2,4]\n    Output: 6\n\n    Explanation: The subarray [2,3] has the maximum product of 6.\n    \"\"\"\n\n    max_product = float('-inf')  # Initialize the maximum product to negative infinity\n\n    for i in range(len(nums)):\n        current_product = 1\n\n        for j in range(i, len(nums)):\n            current_product *= nums[j]  # Multiply the current element to the current product\n\n            if current_product > max_product:\n                max_product = current_product  # Update the maximum product if the current product is greater\n\n    return max_product\n\ndef g():\n    nums = [2,3,-2,4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, return True if the matrix can be transformed into a magic square, otherwise return False.\n\n    A magic square is a square matrix where the sum of each row, each column, and both diagonals is the same.\n\n    Example:\n    Input: [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n\n    Explanation:\n    The matrix can be transformed into the following magic square:\n        2 9 4\n        7 5 3\n        6 1 8\n    The sum of each row, each column, and both diagonals is 15.\n    \"\"\"\n\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n        for i in range(n):\n            if sum(matrix[i]) != target_sum:\n                return False\n            if sum(row[i] for row in matrix) != target_sum:\n                return False\n        if sum(matrix[i][i] for i in range(n)) != target_sum:\n            return False\n        if sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n            return False\n        return True\n\n    return is_magic_square(matrix)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix where all rows, columns, and diagonals have the same sum.\n    \"\"\"\n    return [[8, 1, 6], [3, 5, 7], [4, 9, 2]]\n\nassert f(g()) == True\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the next greater element for each element in the list.\n    If there is no greater element, return -1.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n\n    for i in range(n):\n        while stack and nums[i] > nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [4, 2, 5, 7, 3, 1, 6]\n\n    return nums\n\nassert f(g()) == [5, 5, 7, -1, 6, 6, -1]\n",
        "idx_generation": 482,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct subsequences of s.\n\n    Example:\n    Input: s = \"rabbbit\"\n    Output: 3\n    \n    Hint: Use dynamic programming to count the number of distinct subsequences.\n\n    \"\"\"\n    def count_subsequences(i, j):\n        if j == len(t):\n            return 1\n        if i == len(s):\n            return 0\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if s[i] == t[j]:\n            dp[i][j] = count_subsequences(i+1, j+1) + count_subsequences(i+1, j)\n        else:\n            dp[i][j] = count_subsequences(i+1, j)\n        return dp[i][j]\n    \n    t = \"rabbit\"\n    dp = [[-1] * (len(t)+1) for _ in range(len(s)+1)]\n    return count_subsequences(0, 0)\n\ndef g():\n    s = \"rabbbit\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 473,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of islands in the grid.\n\n    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\n    Assume all four edges of the grid are surrounded by water.\n    \"\"\"\n    num_islands = 0\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and not visited[i][j]:\n                num_islands += 1\n                dfs(grid, visited, i, j)\n\n    return num_islands\n\ndef dfs(grid: List[List[int]], visited: List[List[bool]], row: int, col: int) -> None:\n    rows, cols = len(grid), len(grid[0])\n    if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] == 0 or visited[row][col]:\n        return\n\n    visited[row][col] = True\n    dfs(grid, visited, row + 1, col)\n    dfs(grid, visited, row - 1, col)\n    dfs(grid, visited, row, col + 1)\n    dfs(grid, visited, row, col - 1)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n\n",
        "idx_generation": 312,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(string: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, reverse the order of the words in the string.\n    Return the modified string.\n\n    Example:\n    string = \"hello world\"\n    The function should return \"world hello\" since the words are reversed.\n    \"\"\"\n\n    words = string.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string\n\ndef g():\n    string = \"hello world\"\n    k = 3\n    return string, k\n\nassert f(*g()) == \"world hello\"\n\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if it is possible to form the target word by concatenating the words in the list in any order.\n\n    Example:\n    words = [\"good\", \"morning\", \"world\"]\n    target = \"goodmorningworld\"\n\n    The words can be concatenated in the following order:\n    - \"good\" + \"morning\" + \"world\" = \"goodmorningworld\"\n\n    Therefore, the function should return True.\n\n    Note:\n    - The words in the list will only contain lowercase letters.\n    - The target word will only contain lowercase letters.\n    - Each word in the list can be used multiple times.\n    \"\"\"\n\n    def dfs(words, target, path):\n        if not target:\n            return True\n\n        for i in range(len(words)):\n            if target.startswith(words[i]):\n                remaining_words = words[:i] + words[i+1:]\n                if dfs(remaining_words, target[len(words[i]):], path + words[i]):\n                    return True\n\n        return False\n\n    return dfs(words, target, \"\")\n\ndef g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate a list of words and a target word.\n    \"\"\"\n    return [\"good\", \"morning\", \"world\"], \"goodmorningworld\"\n\nassert f(*g()) == True\n",
        "idx_generation": 369,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the bitwise AND of all elements\n    in the subset is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 0\n\n    The subsets [1, 3] and [2, 4] have a bitwise AND of 0.\n\n    Therefore, the output should be True.\n    \"\"\"\n    total_and = nums[0]\n    for num in nums[1:]:\n        total_and &= num\n    return total_and == target\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target where there exists a subset with a bitwise AND of the target.\n    \"\"\"\n    return [1, 2, 3, 4], 0\n\nassert f(*g()) == True\n\n",
        "idx_generation": 200,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return arr[0]\n    elif n == 2:\n        return max(arr[0], arr[1])\n    \n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    \n    return dp[-1]\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 9\n",
        "idx_generation": 224,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes and a list of directed edges between nodes, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(node: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        \n        stack[node] = False\n        return False\n    \n    # Build adjacency list representation of the graph\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    \n    visited = [False] * n\n    stack = [False] * n\n    \n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, stack):\n                return True\n    \n    return False\n\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of directed edges.\n    \"\"\"\n    return (4, [[0, 1], [1, 2], [2, 3], [3, 0]])\n\n\nassert f(*g()) == True\n",
        "idx_generation": 204,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the shortest path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    5\n\n    Explanation:\n    The shortest path is: 1 -> 3 -> 1 -> 1 -> 1, which has a length of 5.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Create a 2D memoization table to store the minimum distance to each cell\n    dist = [[float('inf')] * cols for _ in range(rows)]\n    dist[0][0] = grid[0][0]\n\n    # Create a queue to perform breadth-first search\n    queue = deque([(0, 0)])\n\n    # Define the possible directions to move\n    directions = [(1, 0), (0, 1), (1, 1)]\n\n    while queue:\n        row, col = queue.popleft()\n\n        # Explore all possible directions\n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n\n            # Check if the new cell is within the grid boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # Calculate the distance to the new cell\n                new_dist = dist[row][col] + grid[nr][nc]\n\n                # Update the minimum distance if necessary\n                if new_dist < dist[nr][nc]:\n                    dist[nr][nc] = new_dist\n                    queue.append((nr, nc))\n\n    return dist[rows-1][cols-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 5\n\n",
        "idx_generation": 371,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers\n    out of the range 1 to n.\n\n    Sample Input:\n    n = 4\n    k = 2\n\n    Sample Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(curr, start):\n        if len(curr) == k:\n            combinations.append(curr.copy())\n            return\n        for i in range(start, n+1):\n            curr.append(i)\n            backtrack(curr, i+1)\n            curr.pop()\n    \n    combinations = []\n    backtrack([], 1)\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 361,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Sample input:\n    n = 4\n\n    Sample output:\n    5\n\n    Explanation:\n    The possible ways to climb to the top of a 4-step staircase are:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 2 steps + 1 step + 1 step\n    3. 1 step + 2 steps + 1 step\n    4. 1 step + 1 step + 2 steps\n    5. 2 steps + 2 steps\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g():\n    n = 4\n    return [n]\n\nassert f(*g()) == 5\n",
        "idx_generation": 244,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it can be rearranged into a palindrome.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    odd_count = 0\n    for count in counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    s = \"aabbcddc\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target exists in the list.\n    Return True if the target exists, otherwise return False.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 4\n\nassert f(*g()) == False\n",
        "idx_generation": 443,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the smallest difference between the target and any element in the list.\n    Return the absolute value of the difference.\n    \n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 7\n    Output: 1\n    Explanation: The closest element to 7 is 6, with a difference of 1.\n    \"\"\"\n    def find_closest(nums, target, left, right):\n        if left == right:\n            return abs(nums[left] - target)\n        \n        mid = (left + right) // 2\n        diff_left = find_closest(nums, target, left, mid)\n        diff_right = find_closest(nums, target, mid + 1, right)\n        \n        return min(diff_left, diff_right)\n    \n    nums.sort()\n    return find_closest(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 1\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given an integer n, return the corresponding Roman numeral as a string.\n\n    Sample Input:\n    n = 4\n\n    Sample Output:\n    \"IV\"\n    Explanation: The Roman numeral for 4 is \"IV\".\n\n    Sample Input:\n    n = 9\n\n    Sample Output:\n    \"IX\"\n    Explanation: The Roman numeral for 9 is \"IX\".\n    \"\"\"\n    roman_numerals = {\n        1: \"I\",\n        4: \"IV\",\n        5: \"V\",\n        9: \"IX\",\n        10: \"X\",\n        40: \"XL\",\n        50: \"L\",\n        90: \"XC\",\n        100: \"C\",\n        400: \"CD\",\n        500: \"D\",\n        900: \"CM\",\n        1000: \"M\"\n    }\n    result = \"\"\n    for numeral, symbol in sorted(roman_numerals.items(), reverse=True):\n        while n >= numeral:\n            result += symbol\n            n -= numeral\n    return result\n\ndef g(n=4):\n    return n\n\nassert f(g()) == \"IV\"\n",
        "idx_generation": 280,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subarray with at least 3 elements such that the sum of the elements is divisible by 3.\n    Otherwise, return False.\n    \"\"\"\n    count = [0, 0, 0]  # Count of remainders when divided by 3\n    result = 0\n\n    for num in nums:\n        count[num % 3] += 1\n\n    # If total count of remainders is less than 3, it is impossible to form a subarray with sum divisible by 3\n    if sum(count) < 3:\n        return False\n\n    # Case 1: If there exists a subarray with sum divisible by 3\n    if count[0] >= 3:\n        return True\n\n    # Case 2: If there exists a subarray with sum divisible by 3\n    if count[1] > 0 and count[2] > 0:\n        return True\n\n    # Case 3: If there exists a subarray with sum divisible by 3\n    if count[1] >= 3:\n        return True\n\n    # Case 4: If there exists a subarray with sum divisible by 3\n    if count[2] >= 3:\n        return True\n\n    return False\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the subarray with the maximum sum.\n    \"\"\"\n    if not nums:\n        return []\n\n    current_sum = max_sum = nums[0]\n    current_start = max_start = max_end = 0\n\n    for i in range(1, len(nums)):\n        if current_sum + nums[i] < nums[i]:\n            current_sum = nums[i]\n            current_start = i\n        else:\n            current_sum += nums[i]\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_start = current_start\n            max_end = i\n\n    return nums[max_start:max_end+1]\n\nassert f(g([1, 2, 3, 4, 5, 6])) == True\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    4\n\n    Explanation:\n    The distinct pairs (i, j) are (1, 2), (1, 5), (2, 4), and (3, 4), which sum up to 3, 6, 7, and 9 respectively. \n    Out of these pairs, (3, 4) and (1, 2) are divisible by 3, so the answer is 4.\n    \"\"\"\n\n    count = 0\n    remainder_count = [0] * 3\n\n    for num in nums:\n        remainder_count[num % 3] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs with remainder 0\n    count += remainder_count[1] * remainder_count[2]  # Count pairs with remainders 1 and 2\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 463,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next smallest element for each element in the list.\n    If no such element exists, return -1.\n\n    Example:\n    Input: [4, 2, 9, 5, 1]\n    Output: [2, 1, 5, 1, -1]\n\n    Explanation:\n    The next smallest element for 4 is 2.\n    The next smallest element for 2 is 1.\n    The next smallest element for 9 is 5.\n    The next smallest element for 5 is 1.\n    There is no next smallest element for 1, so the value is -1.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] < nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    return [4, 2, 9, 5, 1]\n\nassert f(g()) == [2, 1, 5, 1, -1]\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where no two elements in the subsequence are adjacent.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: 12\n\n    Explanation: The maximum sum can be obtained by selecting the subsequence [2, 4, 6].\n\n    Constraints:\n    - The length of the list is at most 10^5.\n    - The elements in the list are non-negative integers.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g(nums=[1, 2, 3, 4, 5, 6]) -> List[int]:\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 475,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    You can only move down or right.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n\n",
        "idx_generation": 312,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n\n    Example:\n    s = \"hello world\"\n\n    The reversed order of the words is \"world hello\".\n\n    Therefore, the function should return \"world hello\".\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_s = ' '.join(reversed_words)\n    \n    return reversed_s\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello world\"\n\nassert f(g()) == \"world hello\"\n",
        "idx_generation": 495,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string s and a pattern, determine if s matches the pattern.\n    The pattern consists of lowercase letters and the character '.' which matches any single character.\n    Return True if s matches the pattern, False otherwise.\n\n    Example:\n    s = \"abb\"\n    pattern = \"a.b\"\n    f(s, pattern) => True\n    Explanation: The pattern \"a.b\" matches the string \"abb\" where '.' matches the second 'b'.\n\n    \"\"\"\n\n    def match(s: str, pattern: str, s_index: int, pattern_index: int) -> bool:\n        if s_index == len(s) and pattern_index == len(pattern):\n            return True\n        if s_index == len(s) or pattern_index == len(pattern):\n            return False\n        if pattern[pattern_index] == '.':\n            return match(s, pattern, s_index + 1, pattern_index + 1)\n        if s[s_index] == pattern[pattern_index]:\n            return match(s, pattern, s_index + 1, pattern_index + 1)\n        return False\n\n    return match(s, pattern, 0, 0)\n\n\ndef g():\n    return \"abb\", \"a.b\"\n\n\nassert f(*g()) == True\n\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, reverse the bits of each integer in the list.\n\n    Return a new list with the integers after the bits are reversed.\n\n    Example:\n    arr = [2, 4, 6]\n\n    The binary representation of 2 is '10'. Reversing the bits gives '01', which is equal to 1 in decimal.\n    The binary representation of 4 is '100'. Reversing the bits gives '001', which is equal to 1 in decimal.\n    The binary representation of 6 is '110'. Reversing the bits gives '011', which is equal to 3 in decimal.\n\n    Therefore, the function should return [1, 1, 3].\n    \"\"\"\n    reversed_arr = []\n    for num in arr:\n        reversed_num = int(bin(num)[2:][::-1], 2)\n        reversed_arr.append(reversed_num)\n    return reversed_arr\n\ndef g():\n    arr = [2, 4, 6]\n    return arr\n\nassert f(g()) == [1, 1, 3]\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    Input: [2, 3, -2, 4]\n    Output: 6\n    Explanation:\n    - The maximum product of a subarray in the given list is 6, which corresponds to the subarray [2, 3].\n    \"\"\"\n\n    max_product = float('-inf')\n    curr_max = 1\n    curr_min = 1\n\n    for num in nums:\n        if num < 0:\n            curr_max, curr_min = curr_min, curr_max\n\n        curr_max = max(num, curr_max * num)\n        curr_min = min(num, curr_min * num)\n\n        max_product = max(max_product, curr_max)\n\n    return max_product\n\ndef g():\n    nums = [2, 3, -2, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their corresponding list of neighbors,\n    determine if there exists a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n        \n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as a dictionary, and randomly choose a start and end node.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5]}\n    start = 1\n    end = 5\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 205,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if there is a path from the start node to the end node.\n    \"\"\"\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return False\n\ndef g():\n    graph = {\n        0: [1, 2],\n        1: [0, 2],\n        2: [0, 1, 3],\n        3: [2, 4],\n        4: [3]\n    }\n    start = 0\n    end = 4\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 376,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int, target_sum: int) -> bool:\n    \"\"\"Find k numbers from the range 1 to n (inclusive) which sum up to target_sum.\"\"\"\n    def count_combinations(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        return count_combinations(n-1, k-1) + count_combinations(n-1, k)\n    \n    return count_combinations(n, k) == target_sum\n\ndef g(n=10, k=3, target_sum=120):\n    return [n, k, target_sum]\n\nassert f(*g())\n",
        "idx_generation": 363,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n    \"\"\"\n    if len(nums) == 0:\n        return [[]]\n    permutations = []\n    for i in range(len(nums)):\n        remaining = nums[:i] + nums[i+1:]\n        for perm in f(remaining):\n            permutations.append([nums[i]] + perm)\n    return permutations\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the sorted list in non-decreasing order.\n    \"\"\"\n    return sorted(nums)\n\nnums = [1, 2, 3]\nassert f(g(nums)) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings, determine if they are isomorphic. Two strings are isomorphic if the characters in one string can be replaced to get the other string.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    mapping_s = {}\n    mapping_t = {}\n    \n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n        \n        if char_s in mapping_s:\n            if mapping_s[char_s] != char_t:\n                return False\n        else:\n            mapping_s[char_s] = char_t\n        \n        if char_t in mapping_t:\n            if mapping_t[char_t] != char_s:\n                return False\n        else:\n            mapping_t[char_t] = char_s\n    \n    return True\n\ndef g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 216,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers (1-indexed) as an array of integers, where the first index is less than the second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [1,2]\n    Explanation: The sum of 2 and 7 is 9. Therefore index 1 and 2 are returned.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left + 1, right + 1]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [1, 2]\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(arr: List[int], target: int, start: int, end: int) -> bool:\n        if start >= end:\n            return False\n        \n        if arr[start] + arr[end] == target:\n            return True\n        elif arr[start] + arr[end] < target:\n            return two_sum(arr, target, start + 1, end)\n        else:\n            return two_sum(arr, target, start, end - 1)\n\n    return two_sum(arr, target, 0, len(arr) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == True\n",
        "idx_generation": 118,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], target: str) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that can be formed by rearranging the letters of the target word.\n\n    Example:\n    words = ['cat', 'dog', 'tac', 'god', 'act']\n    target = 'cat'\n    output: ['cat', 'tac', 'act']\n    Explanation: The words that can be formed by rearranging the letters of 'cat' are 'cat', 'tac', and 'act'.\n\n    Note: The output list should not contain any duplicates.\n    \"\"\"\n    target_sorted = sorted(target)\n    result = []\n    for word in words:\n        if sorted(word) == target_sorted:\n            result.append(word)\n    return result\n\ndef g():\n    words = ['cat', 'dog', 'tac', 'god', 'act']\n    target = 'cat'\n    return words, target\n\nassert f(*g()) == ['cat', 'tac', 'act']\n",
        "idx_generation": 282,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find all unique combinations in nums where the numbers sum\n    to target. The same number may be chosen from nums an unlimited number of times. A combination should not contain\n    the same number twice, and the combinations should be returned in ascending order.\n\n    Example:\n    Input: nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    Note:\n    - All numbers (including target) will be positive integers.\n    - The solution set must not contain duplicate combinations.\n    - The order of combinations does not matter.\n    \"\"\"\n\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, path + [nums[i]], curr_sum + nums[i])\n\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g(nums = [2,3,6,7], target = 7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 343,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The elements of the matrix in spiral order are 1, 2, 3, 6, 9, 8, 7, 4, and 5.\n    \"\"\"\n\n    spiral_order = []\n    if not matrix:\n        return spiral_order\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle\n    that can be formed by connecting adjacent buildings.\n\n    Example:\n    Input: heights = [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The maximum area rectangle can be formed by connecting the buildings with heights 5 and 6.\n\n    Note:\n    - The widths of the buildings are all equal to 1.\n    - The list of heights will have at least one building.\n    \"\"\"\n\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area\n\ndef g():\n    return [2, 1, 5, 6, 2, 3]\n\nassert f(g()) == 10\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The subarray with the maximum product is [2, 3], and the product is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_product = float('-inf')\n    current_max = 1\n    current_min = 1\n\n    for num in nums:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n\n        max_product = max(max_product, current_max)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, -2, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right at any point in time. However, some cells in the grid are blocked and cannot be traversed.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 2\n\n",
        "idx_generation": 315,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n    Explanation: \"racecar\" is a palindrome.\n\n    Input: \"hello\"\n    Output: False\n    Explanation: \"hello\" is not a palindrome.\n    \"\"\"\n\n    def is_palindrome(left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s)-1)\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport collections\nfrom typing import List\n\ndef f(s: str) -> List[List[str]]:\n    \"\"\"\n    Given a string s, partition it into as many parts as possible so that each part is a palindrome.\n    Return a list of all possible partitions.\n\n    Example:\n    s = \"aab\"\n\n    The function should return [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]], since \"a\", \"a\", \"b\" and \"aa\", \"b\" are valid partitions.\n\n    s = \"aaa\"\n\n    The function should return [[\"a\", \"a\", \"a\"], [\"aa\", \"a\"], [\"a\", \"aa\"], [\"aaa\"]], since \"a\", \"a\", \"a\", \"aa\", \"a\", \"a\", \"aaa\" are valid partitions.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def backtrack(s, start, partition, result):\n        if start == len(s):\n            result.append(partition[:])\n            return\n        for i in range(start, len(s)):\n            if is_palindrome(s[start:i+1]):\n                partition.append(s[start:i+1])\n                backtrack(s, i+1, partition, result)\n                partition.pop()\n\n    result = []\n    backtrack(s, 0, [], result)\n    return result\n\ndef g():\n    s = \"aab\"\n    return s\n\nassert f(g()) == [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]]\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is achieved between 5 and 25: 5 XOR 25 = 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 213,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Sample Input:\n    n = 4\n\n    Sample Output:\n    5\n    Explanation: There are 5 ways to climb to the top of the staircase with 4 steps: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2]\n\n    Sample Input:\n    n = 5\n\n    Sample Output:\n    8\n    Explanation: There are 8 ways to climb to the top of the staircase with 5 steps: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 2, 1, 1], [2, 1, 1, 1], [1, 2, 2], [2, 1, 2], [2, 2]\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 256,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if it contains a cycle.\n\n    Sample Input:\n    graph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n\n    Sample Output:\n    True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n    \"\"\"\n\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n\n        return False\n\n    visited = [False] * len(graph)\n\n    for i in range(len(graph)):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 209,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]]) -> List[int]:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency list, return a valid topological ordering of the graph\n    nodes.\n\n    Example:\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5], 5: []}\n\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n    in_degrees = {node: 0 for node in graph}\n\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degrees[neighbor] += 1\n\n    queue = [node for node in graph if in_degrees[node] == 0]\n    order = []\n\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n\n        for neighbor in graph[node]:\n            in_degrees[neighbor] -= 1\n\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    return order\n\ndef g():\n    \"\"\"\n    Generate a directed acyclic graph represented as an adjacency list.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5], 5: []}\n    return graph\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 395,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\ndef f(nums: List[int], target=10, n=3) -> bool:\n    \"\"\"Find n distinct positive integers from nums that sum to target\"\"\"\n    from itertools import combinations\n    for comb in combinations(nums, n):\n        if sum(comb) == target:\n            return True\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 10, n = 3):\n    return nums\n\nassert f(g())\n",
        "idx_generation": 371,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, determine if there exists a combination of numbers from the list that adds up to the target.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index == len(arr) or curr_sum > target:\n            return False\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr_sum)\n\n        # Include the current element\n        include = helper(arr, target, index, curr_sum + arr[index])\n\n        return exclude or include\n\n    return helper(arr, target, 0, 0)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 9) == True\n\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> int:\n    \"\"\"\n    Given a string s and an integer k, count the number of distinct substrings of length k in s.\n\n    Sample Input:\n    s = \"abcabc\"\n    k = 3\n\n    Sample Output:\n    3\n    Explanation: The distinct substrings of length 3 in \"abcabc\" are \"abc\", \"bca\", and \"cab\".\n\n    Sample Input:\n    s = \"aaaaa\"\n    k = 2\n\n    Sample Output:\n    1\n    Explanation: The only distinct substring of length 2 in \"aaaaa\" is \"aa\".\n    \"\"\"\n    substrings = set()\n    for i in range(len(s) - k + 1):\n        substr = s[i:i+k]\n        substrings.add(substr)\n    return len(substrings)\n\ndef g(s=\"abcabc\", k=3):\n    return s, k\n\nassert f(*g()) == 3\n",
        "idx_generation": 280,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    The output should be sorted by the frequency from highest to lowest. If two words have the same frequency, sort them alphabetically.\n\n    Example:\n    words = [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"]\n    k = 4\n    Output: [\"the\", \"is\", \"sunny\", \"day\"]\n    \"\"\"\n\n    from collections import Counter\n\n    counter = Counter(words)\n\n    sorted_words = sorted(counter.keys(), key=lambda x: (-counter[x], x))\n\n    return sorted_words[:k]\n\ndef g() -> (List[str], int):\n    return [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], 4\n\nassert f(*g()) == [\"the\", \"is\", \"sunny\", \"day\"]\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous) in the list.\n    Return True if the length of the longest increasing subsequence is greater than or equal to 4, otherwise return False.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp) >= 4\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value of any two numbers in the list.\n\n    Return the minimum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The minimum XOR value is 1, which is obtained by XORing 3 and 2.\n\n    Therefore, the function should return 1.\n    \"\"\"\n    nums.sort()\n    min_xor = float('inf')\n    for i in range(len(nums)-1):\n        xor_val = nums[i] ^ nums[i+1]\n        min_xor = min(min_xor, xor_val)\n    \n    return min_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == True\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find all combinations of k numbers in the list that add up to the target.\n    Return a list of lists containing the combinations.\n    \"\"\"\n    def backtrack(start: int, remain: int, path: List[int]) -> None:\n        if remain == 0 and len(path) == k:\n            combinations.append(path)\n            return\n        if remain < 0 or len(path) > k:\n            return\n\n        for i in range(start, len(nums)):\n            backtrack(i + 1, remain - nums[i], path + [nums[i]])\n\n    combinations = []\n    backtrack(0, target, [])\n    return combinations\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    k = 2\n    return (nums, target, k)\n\n\nassert f(*g()) == [[2, 5], [3, 4]]\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    rotated_matrix = [[0] * rows for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_matrix[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated_matrix\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], and the length is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    You can move in four directions: up, down, left, and right.\n\n    Example:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    The longest increasing path in the grid is [1, 2, 6, 9], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_length = 0\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        length = 1\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                length = max(length, dfs(new_row, new_col) + 1)\n\n        memo[row][col] = length\n        return length\n\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g() -> List[List[int]]:\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, convert it to its binary representation and count the number of bits that are set to 1.\n\n    Example:\n    num = 13\n\n    The binary representation of 13 is 1101, and it contains 3 bits that are set to 1.\n    Therefore, the function should return 3.\n    \"\"\"\n    binary = bin(num)[2:]\n    count = 0\n\n    for bit in binary:\n        if bit == '1':\n            count += 1\n\n    return count\n\ndef g() -> int:\n    num = 13\n    return num\n\nassert f(g()) == 3\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string_list: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of strings and a target string, check if the target string can be generated by concatenating\n    the strings in the list in a specific order. Each string in the list can be used only once.\n\n    Return True if the target string can be generated, False otherwise.\n    \"\"\"\n    def backtrack(curr_string: str, remaining_list: List[str]) -> bool:\n        if curr_string == target:\n            return True\n        for i in range(len(remaining_list)):\n            if target.startswith(curr_string + remaining_list[i]):\n                if backtrack(curr_string + remaining_list[i], remaining_list[:i] + remaining_list[i+1:]):\n                    return True\n        return False\n\n    return backtrack('', string_list)\n\ndef g():\n    string_list = ['abc', 'def', 'ghi']\n    target = 'abcdefghi'\n    return string_list, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 395,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the element that appears only once.\n\n    Example:\n    nums = [2, 3, 2, 4, 4]\n\n    The element 3 appears only once in the list.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    return [2, 3, 2, 4, 4]\n\nassert f(g()) == 3\n",
        "idx_generation": 215,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the nth number in the Fibonacci sequence.\n    \"\"\"\n    if n <= 0:\n        return None\n    if n == 1 or n == 2:\n        return 1\n    \n    prev, curr = 1, 1\n    for _ in range(3, n+1):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 266,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their neighbors, find if there is a path from the start node\n    to the target node using a depth-first search (DFS).\n    \"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == target:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\ndef g():\n    return {\n        1: [2, 3],\n        2: [4],\n        3: [5],\n        4: [],\n        5: [6],\n        6: []\n    }, 1, 6\nassert f(*g())\n",
        "idx_generation": 220,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node\n    to the end node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There exists a path from the start node 0 to the end node 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr_node, end, visited):\n    if curr_node == end:\n        return True\n\n    visited[curr_node] = True\n\n    for i in range(len(graph[curr_node])):\n        if graph[curr_node][i] == 1 and not visited[i]:\n            if dfs(graph, i, end, visited):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nassert f(g(), 0, 3) == True\n\n",
        "idx_generation": 433,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find all the permutations of the list.\n\n    Example:\n    nums = [1, 2, 3]\n    output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n    Explanation:\n    A permutation is an arrangement of elements where order matters. In this case, we need to find all possible permutations of the list [1, 2, 3].\n    \"\"\"\n    def backtrack(nums, path, res):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n\n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of unique paths from the top-left corner of a grid to the bottom-right corner.\n    You can only move down or right at each step.\n    The grid has n rows and m columns.\n\n    Example:\n    n = 3, m = 4\n\n    The grid will look like this:\n\n    1  1  1  1\n    1  2  3  4\n    1  3  6 10\n\n    There are 10 unique paths from the top-left corner to the bottom-right corner.\n\n    Returns the number of unique paths.\n    \"\"\"\n\n    def unique_paths(n: int, m: int, memo: dict) -> int:\n        \"\"\"\n        Calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with n rows and m columns.\n        \"\"\"\n        if n == 1 or m == 1:\n            # Base case: there is only one path when there is only one row or one column\n            return 1\n        if (n, m) in memo:\n            return memo[(n, m)]\n\n        # Calculate the number of unique paths for the remaining subgrids by moving down or right\n        down_paths = unique_paths(n - 1, m, memo)\n        right_paths = unique_paths(n, m - 1, memo)\n\n        # Store the result in the memoization dictionary\n        memo[(n, m)] = down_paths + right_paths\n\n        return memo[(n, m)]\n\n    memo = {}\n    return unique_paths(n, m, memo)\n\n\ndef g():\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 251,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Given two strings, determine if they are anagrams of each other.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    count1 = [0] * 26\n    count2 = [0] * 26\n    \n    for c1, c2 in zip(s1, s2):\n        count1[ord(c1) - ord('a')] += 1\n        count2[ord(c2) - ord('a')] += 1\n    \n    return count1 == count2\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two anagram strings.\n    \"\"\"\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 291,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, check if the target number is present in the list using binary search.\n\n    Args:\n    - nums: A sorted list of integers\n    - target: The target number to search for\n\n    Returns:\n    - True if the target number is present in the list, False otherwise\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 447,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value,\n    return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 127,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the words in descending order of their length.\n    If two words have the same length, sort them in lexicographical order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cherry\", \"kiwi\"]\n\n    Output:\n    [\"banana\", \"cherry\", \"apple\", \"kiwi\"]\n\n    Explanation:\n    The words are sorted based on their length in descending order. The words \"banana\" and \"cherry\" have the same\n    length, so they are sorted in lexicographical order.\n\n    \"\"\"\n    words.sort(key=lambda x: (-len(x), x))\n    return words\n\n\ndef g() -> List[str]:\n    words = [\"banana\", \"apple\", \"cherry\", \"kiwi\"]\n    return words\n\n\nassert f(g()) == [\"banana\", \"cherry\", \"apple\", \"kiwi\"]\n",
        "idx_generation": 299,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, return a new list where each element is the sum of all previous elements in arr.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    The new list should be [1, 3, 6, 10], where the first element is the same as the original list and each subsequent element is the sum of all previous elements in the original list.\n\n    Constraints:\n    - The input list arr will have at least one element.\n    \"\"\"\n\n    # Base case: when arr is empty, return an empty list\n    if not arr:\n        return []\n\n    # Recursive case: compute the new list by adding the first element of arr to each element of the new list\n    new_arr = f(arr[:-1]) + [sum(arr)]\n    return new_arr\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be used as input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [1, 3, 6, 10]\n",
        "idx_generation": 354,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def dp(index, total):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        if dp(index + 1, total + nums[index]):\n            return True\n\n        if dp(index + 1, total - nums[index]):\n            return True\n\n        if dp(index + 1, total * nums[index]):\n            return True\n\n        if nums[index] != 0 and dp(index + 1, total / nums[index]):\n            return True\n\n        return False\n\n    return dp(0, 0)\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the length of the shortest path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    Each 1 represents a cell that can be traversed, while each 0 represents a wall that cannot be traversed.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 1, 1]\n    ]\n\n    The shortest path from the top-left corner (0, 0) to the bottom-right corner (3, 3) has a length of 6 units.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n    \n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 1, 1, 0],\n        [0, 1, 1, 1],\n        [1, 0, 1, 1],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 341,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(text: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string while preserving the whitespace between them.\n\n    Example:\n    text = \"hello world\"\n\n    The function should return \"world hello\".\n    \"\"\"\n    words = text.split()\n    reversed_text = ' '.join(reversed(words))\n    return reversed_text\n\ndef g() -> str:\n    text = \"hello world\"\n    return text\n\nassert f(g()) == \"world hello\"\n",
        "idx_generation": 499,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Return True if s is a palindrome, False otherwise.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    return is_palindrome(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 421,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list containing the bitwise complement of each element.\n\n    The bitwise complement of an integer n is defined as ~(n).\n\n    Example:\n    nums = [5, 3, 8]\n\n    The bitwise complement of 5 is ~(5) = -6.\n    The bitwise complement of 3 is ~(3) = -4.\n    The bitwise complement of 8 is ~(8) = -9.\n\n    Therefore, the function should return [-6, -4, -9].\n    \"\"\"\n    return [~num for num in nums]\n\ndef g():\n    return [5, 3, 8]\n\nassert f(g()) == [-6, -4, -9]\n",
        "idx_generation": 215,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, determine if there exists a subset of the array that sums up to the target value.\n\n    Example:\n    arr = [2, 4, 6, 8], target = 10\n\n    The subset [2, 8] sums up to 10.\n    Therefore, the function should return True.\n    \"\"\"\n\n    def subset_sum(arr: List[int], target: int, index: int) -> bool:\n        # Base cases\n        if target == 0:\n            return True\n        if index >= len(arr):\n            return False\n\n        # Recursive cases\n        if arr[index] <= target:\n            # Include the current element in the subset\n            if subset_sum(arr, target - arr[index], index + 1):\n                return True\n\n        # Exclude the current element from the subset\n        return subset_sum(arr, target, index + 1)\n\n    return subset_sum(arr, target, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    return [2, 4, 6, 8], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 267,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph with n nodes and a list of edges, determine if the graph contains a cycle.\n\n    Example:\n    Input: n = 4, edges = [[0,1],[1,2],[2,3],[3,0]]\n    Output: True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n\n    \"\"\"\n\n    def has_cycle(node: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    graph = [[] for _ in range(n)]\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n\n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, stack):\n                return True\n\n    return False\n\n\ndef g() -> Tuple[int, List[List[int]]]:\n    n = 4\n    edges = [[0,1],[1,2],[2,3],[3,0]]\n    return n, edges\n\n\nassert f(*g()) == True\n",
        "idx_generation": 221,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, check if there exists a Hamiltonian path in the graph.\n    A Hamiltonian path is a path in a graph that visits each vertex exactly once.\n    \"\"\"\n\n    def backtrack(curr_node, visited, num_visited):\n        \"\"\"\n        Helper function to perform backtracking to find a Hamiltonian path.\n        \"\"\"\n        if num_visited == len(matrix):\n            return True\n        \n        for next_node in range(len(matrix)):\n            if matrix[curr_node][next_node] == 1 and not visited[next_node]:\n                visited[next_node] = True\n                if backtrack(next_node, visited, num_visited + 1):\n                    return True\n                visited[next_node] = False\n        \n        return False\n\n    # Initialize visited array\n    visited = [False] * len(matrix)\n\n    # Start the backtracking from each vertex\n    for start_node in range(len(matrix)):\n        visited[start_node] = True\n        if backtrack(start_node, visited, 1):\n            return True\n        visited[start_node] = False\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a random adjacency matrix for a directed graph with 4 vertices.\n    \"\"\"\n    return [[0, 1, 1, 0],\n            [1, 0, 0, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0]]\n    \nassert f(g())\n",
        "idx_generation": 452,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of possible combinations of k elements from a list of n elements.\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n    \n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef g():\n    n = 6\n    k = 3\n    return n, k\n\nassert f(*g()) == 20\n\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, return the number of unique combinations of k elements from the list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n\n    Sample Output:\n    10\n\n    \"\"\"\n    def backtrack(start, comb, count):\n        if len(comb) == k:\n            count[0] += 1\n            return\n        \n        for i in range(start, len(nums)):\n            comb.append(nums[i])\n            backtrack(i+1, comb, count)\n            comb.pop()\n    \n    count = [0]\n    backtrack(0, [], count)\n    return count[0]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if a string contains a substring with exactly k distinct characters.\"\"\"\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            substr = s[i:j]\n            if len(set(substr)) == k:\n                return True\n    return False\n\ndef g(s = \"abcbcadefg\", k = 3):\n    return s, k\n\nassert f(*g())\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target value.\n    \"\"\"\n    target = 10\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers where there exists a pair of numbers whose sum is equal to the target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n",
        "idx_generation": 448,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target number.\n\n    Sample input:\n    [2, 7, 11, 15], 9\n\n    Sample output:\n    [2, 7]\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [arr[left], arr[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 137,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that multiply to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that multiply to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        product = numbers[left] * numbers[right]\n        if product == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif product < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 80\n    substring = \"10\"\n    return numbers, target, substring\n\nassert f(*g()) == True\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target integer, return a list of all unique combinations of the integers that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    f(nums, target) => [[2, 2, 3], [7]]\n\n    Explanation: The unique combinations of the integers in nums that sum up to the target 7 are [2, 2, 3] and [7].\n\n    \"\"\"\n\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i, path, target-nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) where a and b are elements of the list\n    and a < b.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The distinct pairs are (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5).\n    Therefore, the function should return 10.\n    \"\"\"\n    distinct_pairs = set()\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] < arr[j]:\n                distinct_pairs.add((arr[i], arr[j]))\n\n    return len(distinct_pairs)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 10\n",
        "idx_generation": 467,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 1]\n    f(nums) => 4\n    Explanation: The subarray [2, 1] has the maximum sum of 4.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[-1]\n\n\ndef g():\n    return [1, 2, 3, 1]\n\n\nassert f(g()) == 4\n\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum sum path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output: 7\n    Explanation: The minimum sum path is 1 -> 3 -> 1 -> 1 -> 1, which has a sum of 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 353,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindromic substring in s.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n\n    max_len = 1\n    for i in range(n):\n        dp[i][i] = True\n\n    start = 0\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i == 1 or dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    if j - i + 1 > max_len:\n                        max_len = j - i + 1\n                        start = i\n\n    return max_len\n\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with a palindromic substring.\n    \"\"\"\n    return \"babad\"\n\nassert f(g()) == 3\n",
        "idx_generation": 422,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 216,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The maximum product of a subarray.\n    \"\"\"\n    max_product = float('-inf')\n    curr_max = curr_min = 1\n\n    for num in nums:\n        if num < 0:\n            curr_max, curr_min = curr_min, curr_max\n\n        curr_max = max(num, curr_max * num)\n        curr_min = min(num, curr_min * num)\n        max_product = max(max_product, curr_max)\n\n    return max_product\n\n\ndef g() -> List[int]:\n    nums = [-2, -3, 4, -1, -2, 1, 5, -3]\n    return nums\n\n\nassert f(g()) == 360\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, check if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    def dfs(node: int, visited: List[bool], stack: List[bool]) -> bool:\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 227,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, return True if there is a cycle in the graph, and False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    Output: True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique combinations of k numbers from the range 1 to n, inclusive.\n\n    Example:\n    n = 4\n    k = 2\n    Output: 6\n\n    Explanation:\n    The possible combinations are: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]\n    \"\"\"\n\n    def dfs(start: int, path: List[int]) -> None:\n        if len(path) == k:\n            combinations.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            path.append(i)\n            dfs(i + 1, path)\n            path.pop()\n\n    combinations = []\n    dfs(1, [])\n    return len(combinations)\n\ndef g() -> List[int]:\n    return [4, 2]\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 381,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a subset of nums that sums up to the target value.\"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, memo: dict) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        if nums[index] > target:\n            return subset_sum(nums, target, index + 1, memo)\n        include = subset_sum(nums, target - nums[index], index + 1, memo)\n        exclude = subset_sum(nums, target, index + 1, memo)\n        memo[(index, target)] = include or exclude\n        return memo[(index, target)]\n\n    memo = {}\n    return subset_sum(nums, target, 0, memo)\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 12\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 270,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if a given string has a length divisible by k and contains at least one uppercase character.\"\"\"\n    return len(s) % k == 0 and any(c.isupper() for c in s)\n\ndef g(k: int = 3):\n    return \"Python\"\n\nassert f(g(), k=3) == True\n",
        "idx_generation": 363,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Args:\n        nums: A sorted list of integers.\n        target: The target value.\n\n    Returns:\n        The index of the target value in the list, or -1 if it is not found.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, right)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value,\n    return True if there exist three elements in the list that sum up to the target value,\n    and False otherwise.\n    \"\"\"\n    nums.sort()\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Generate a list of integers and a target value such that there exist three elements in the list that sum up to the target value.\n    \"\"\"\n    return nums, target\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 9\nassert f(*g(nums, target))\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if the given strings are anagrams of each other.\n    Return True if they are anagrams, False otherwise.\n    \"\"\"\n    sorted_s1 = sorted(s1)\n    sorted_s2 = sorted(s2)\n    return sorted_s1 == sorted_s2\n\ndef g():\n    s1 = \"listen\"\n    s2 = \"silent\"\n    return s1, s2\n\nassert f(*g())\n",
        "idx_generation": 351,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return True if its length is greater than or equal to 3.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp) >= 3\n\ndef g():\n    nums = [1, 3, 2, 4, 5, 6, 4, 7, 8]\n    return nums\n\nassert f(g())\n",
        "idx_generation": 377,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value. Return the indices of those numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value 9. The indices of these numbers in the list are 0 and 1.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    def find_indices(nums, target):\n        \"\"\"\n        Find the indices of two numbers in the list that add up to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n\n        return []\n\n    return find_indices(nums, target)\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible parentheses combinations with n pairs of parentheses.\n\n    Example:\n    Input: 3\n    Output: ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Explanation:\n    There are 5 possible combinations of parentheses pairs with 3 pairs of parentheses.\n    \"\"\"\n\n    def backtrack(s: str, left: int, right: int, result: List[str]) -> None:\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n\n        if left < n:\n            backtrack(s + '(', left + 1, right, result)\n        if right < left:\n            backtrack(s + ')', left, right + 1, result)\n\n    result = []\n    backtrack('', 0, 0, result)\n    return result\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the size of the largest square submatrix consisting only of 1s.\n    \"\"\"\n    rows = len(matrix)\n    if rows == 0:\n        return 0\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_size = 0\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n    return max_size ** 2\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of 0s and 1s for Puzzle 3.\n    \"\"\"\n    return [[1, 0, 1, 0, 0],\n            [1, 0, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 0, 0, 1, 0]]\n\nassert f(g()) == 4\n",
        "idx_generation": 362,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcba\"\n\n    After removing the character 'c', the string becomes a palindrome.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string for Puzzle 5.\n    \"\"\"\n    return \"abcba\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 474,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum XOR value between any two numbers in the matrix.\n\n    Return the maximum XOR value.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum XOR value between any two numbers in the matrix is 15, which can be obtained by XORing 7 and 8.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            for x in range(len(matrix)):\n                for y in range(len(matrix[0])):\n                    xor = matrix[i][j] ^ matrix[x][y]\n                    max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 15\n\n",
        "idx_generation": 220,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect square.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Explanation:\n    16 is a perfect square (4^2 = 16).\n    \"\"\"\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root ** 2 == n\n\ndef g(n: int):\n    \"\"\"\n    Find the next perfect square greater than or equal to n.\n    \"\"\"\n    root = int(n ** 0.5)\n    if root ** 2 == n:\n        return n\n    else:\n        return (root + 1) ** 2\n\nassert f(g(16))\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine the number of distinct paths from start to end in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There are 2 distinct paths from vertex 0 to vertex 3 in the given graph.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(graph)\n    count = 0\n\n    def dfs(node: int) -> None:\n        nonlocal count\n\n        if node == end:\n            count += 1\n            return\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                dfs(neighbor)\n\n    dfs(start)\n\n    return count\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    return graph, start, end\n\nassert f(*g()) == 2\n",
        "idx_generation": 230,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of an undirected graph, find the number of connected components in the graph.\n    A connected component is a subgraph in which there is a path between any two vertices.\n\n    Return the number of connected components in the graph.\n    \"\"\"\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor, visited)\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    count = 0\n    for node in range(num_nodes):\n        if not visited[node]:\n            dfs(node, visited)\n            count += 1\n    \n    return count\n\ndef g(graph: List[List[int]]):\n    return graph\n\nassert f(g([[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]])) == 2\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, check if it can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n    \n    Example:\n    nums = [1, 5, 11, 5]\n    \n    Output:\n    True\n    \n    Explanation:\n    The array can be partitioned into [1, 5, 5] and [11] where the sum of elements in both subsets is 11.\n    \"\"\"\n    total_sum = sum(nums)\n    \n    if total_sum % 2 != 0:\n        return False\n    \n    target_sum = total_sum // 2\n    \n    return subset_sum(nums, len(nums) - 1, target_sum)\n\ndef subset_sum(nums: List[int], n: int, target: int) -> bool:\n    if target == 0:\n        return True\n    if n < 0 or target < 0:\n        return False\n    \n    include = subset_sum(nums, n - 1, target - nums[n])\n    exclude = subset_sum(nums, n - 1, target)\n    \n    return include or exclude\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 392,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items.\n    \"\"\"\n    def combinations(n, k):\n        if k == 0 or k == n:\n            return 1\n        return combinations(n-1, k-1) + combinations(n-1, k)\n    \n    return combinations(n, k)\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings 's' and 't', determine if 't' is an anagram of 's'.\n\n    Example:\n    Input: s = \"anagram\", t = \"nagaram\"\n    Output: True\n\n    Explanation:\n    The strings \"anagram\" and \"nagaram\" are anagrams of each other.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    count = [0] * 26\n\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for num in count:\n        if num != 0:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    return (\"anagram\", \"nagaram\")\n\nassert f(*g())\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of non-negative integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers in the list.\n\n    Args:\n        nums: A list of non-negative integers.\n        target: The target value.\n\n    Returns:\n        The indices of the two numbers that sum up to the target value.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 ([2, 7]) sum up to the target value 9.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and a number of elements to select (k),\n    return True if there exist k elements in the list that sum up to the target value,\n    and False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total == target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort()\n    return backtrack(0, 0, 0)\n\ndef g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and a number of elements to select (k),\n    such that there exist k elements in the list that sum up to the target value.\n    \"\"\"\n    nums.sort()\n    return nums, target, k\n\n# Test case\nnums = [1, 2, 3, 4, 5]\ntarget = 10\nk = 3\nassert f(*g(nums, target, k))\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them based on anagrams.\n\n    Sample Input:\n    words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n\n    Sample Output:\n    [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n    Explanation: The words 'eat', 'tea', and 'ate' are anagrams of each other, so they are grouped together.\n    The words 'tan' and 'nat' are anagrams of each other, so they are grouped together.\n    The word 'bat' does not have any anagrams, so it forms its own group.\n    \"\"\"\n\n    anagrams = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n    \n    return list(anagrams.values())\n\ndef g():\n    words = ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']\n    return words\n\nassert f(g()) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n",
        "idx_generation": 358,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Return the length of the LIS.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, i.e., the sum of a contiguous subarray with the largest sum.\n\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which corresponds to the subarray [4, -1, 2, 1].\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase with n steps.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation: There are 5 distinct ways to climb to the top of a staircase with 4 steps: 1-1-1-1, 1-1-2, 1-2-1, 2-1-1, 2-2.\n\n    Note:\n    - You can climb either 1 or 2 steps at a time.\n    \"\"\"\n\n    # Recursive function to count distinct ways to climb the staircase\n    def count_ways(n: int, memo: List[int]) -> int:\n        if n == 0:\n            return 1\n        if n < 0:\n            return 0\n        if memo[n] != -1:\n            return memo[n]\n        memo[n] = count_ways(n - 1, memo) + count_ways(n - 2, memo)\n        return memo[n]\n\n    # Use memoization to count distinct ways\n    memo = [-1] * (n + 1)\n    return count_ways(n, memo)\n\ndef g() -> int:\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down, right, or diagonally.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    Output: 15\n    Explanation: The minimum sum path is 1 -> 2 -> 3 -> 6 -> 9, which has a sum of 15.\n    \"\"\"\n\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 15\n",
        "idx_generation": 368,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, substrings: List[str]) -> bool:\n    \"\"\"\n    Determine if a string can be constructed by concatenating multiple substrings from a given list.\n    \"\"\"\n    def dfs(s):\n        if s == \"\":\n            return True\n        for substr in substrings:\n            if s.startswith(substr):\n                if dfs(s[len(substr):]):\n                    return True\n        return False\n    \n    return dfs(s)\n\ndef g(substrings: List[str]) -> bool:\n    \"\"\"\n    Generate a string that can be constructed by concatenating multiple substrings from a given list.\n    \"\"\"\n    return \"\".join(substrings)\n\nassert f(g(substrings=[\"abc\", \"def\", \"ghi\"]), substrings=[\"abc\", \"def\", \"ghi\"])\n\n",
        "idx_generation": 475,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits in the binary representation of a given integer.\n    \"\"\"\n    binary = bin(n)[2:]\n    count = 0\n    for bit in binary:\n        if bit == '1':\n            count += 1\n    return count\n\ndef g():\n    \"\"\"\n    Generate a random integer.\n    \"\"\"\n    return 27\n\nassert f(g()) == 4\n",
        "idx_generation": 225,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers nums and a target integer target,\n    find the minimum number of operations required to make all elements of nums equal to target.\n    An operation is defined as either adding or subtracting x from nums[i], where x is a positive integer.\n\n    Return the minimum number of operations.\n\n    Note: You may assume that the list is non-empty and the target is always a positive integer.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 2\n\n    f(nums, target) => 2\n    Explanation: The minimum number of operations required is 2.\n    We can subtract 1 from the first element and add 1 to the third element, resulting in [0, 2, 3].\n    Then, we can add 1 to the first element and subtract 1 from the third element, resulting in [1, 2, 2].\n\n    \"\"\"\n\n    def dfs(nums, target, index):\n        if index == len(nums):\n            return 0\n\n        if nums[index] == target:\n            return dfs(nums, target, index + 1)\n\n        diff = target - nums[index]\n\n        if diff > 0:\n            add = dfs(nums, target, index + 1) + diff\n            subtract = float('inf')\n            if nums[index] - diff >= 1:\n                subtract = dfs(nums, target, index + 1) + 1\n            return min(add, subtract)\n        else:\n            subtract = dfs(nums, target, index + 1) - diff\n            add = float('inf')\n            if nums[index] + diff >= 1:\n                add = dfs(nums, target, index + 1) + 1\n            return min(add, subtract)\n\n    return dfs(nums, target, 0)\n\ndef g():\n    nums = [1, 2, 3]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 283,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, target: int, pattern: str) -> bool:\n    \"\"\"\n    Given a directed graph as a dictionary where the keys are the nodes (integers) and the values are lists of nodes\n    that can be reached from the key node, find if there exists a path from the start node to the target node\n    where each node's value matches a specific pattern.\n\n    Sample input:\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    target = 6\n    pattern = 'ODD'\n\n    Sample output:\n    True\n\n    In the given graph, there exists a path from node 1 to node 6 where each node's value is an odd number: 1 -> 3 -> 5 -> 6.\n    \"\"\"\n    visited = set()\n    stack = [(start, '')]\n    while stack:\n        node, path = stack.pop()\n        if node == target and all(p.isdigit() and int(p) % 2 != 0 for p in path):\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + str(node)))\n    return False\n\ndef g():\n    graph = {1: [2, 3], 2: [4], 3: [4, 5], 4: [6], 5: [6], 6: []}\n    start = 1\n    target = 6\n    pattern = 'ODD'\n    return graph, start, target, pattern\n\nassert f(*g()) == True\n",
        "idx_generation": 233,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique paths from the top-left cell to the bottom-right cell of a grid of size n x n.\n    You can only move down or right.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation: There are 6 unique paths from the top-left cell to the bottom-right cell of a 3 x 3 grid.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]\n\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 482,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items.\n\n    Input: n = 8, k = 2\n    Output: 28\n    Explanation: There are 28 ways to choose 2 items from a set of 8 items.\n    \"\"\"\n    def combinations(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n\n    return combinations(n, k)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of two positive integers.\n    \"\"\"\n    return [6, 4]\n\nassert f(*g()) == 15\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, x: int) -> bool:\n    \"\"\"\n    Given a number n, calculate the binomial coefficient C(n, x), where C(n, x) represents \n    the number of ways to choose x items from a set of n items.\n\n    Sample Input:\n    n = 5\n    x = 2\n\n    Sample Output:\n    10\n\n    Explanation:\n    There are 10 ways to choose 2 items from a set of 5 items.\n    \"\"\"\n\n    if x < 0 or x > n:\n        return 0\n\n    if x == 0 or x == n:\n        return 1\n\n    dp = [[0] * (x + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, x) + 1):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[n][x]\n\ndef g():\n    return 5, 2\n\nassert f(*g()) == 10\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, target='abc', count=4) -> bool:\n    \"\"\"\n    Given a string s, determine if it is possible to rearrange the letters in s to form the target string,\n    such that the target string appears count number of times consecutively. Return True if it is possible,\n    False otherwise.\n    \"\"\"\n    def is_valid(s, target, count):\n        return s.count(target) == count\n\n    return is_valid(s, target, count)\n\ndef g(target='abc', count=4):\n    \"\"\"\n    Generate a string by repeating the target string count number of times.\n    \"\"\"\n    return target * count\n\nassert f(g())\n",
        "idx_generation": 436,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer,\n    return the index of the target if it is found in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 7\n\n    The target number 7 is found at index 3, so the function should return 3.\n\n    Hint: Use binary search to find the target number.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums = [1, 2, 4, 7, 11, 15], target = 7):\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 449,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to find the index of the target value in the list.\n    If the target value is not found, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: 2 (index of 5 in the list)\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return -1\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all possible substrings of length k\n    that can be formed from s, in lexicographical order.\n\n    Example:\n    s = \"abcde\", k = 3\n    Output: [\"abc\", \"bcd\", \"cde\"]\n\n    s = \"hello\", k = 2\n    Output: [\"el\", \"he\", \"ll\", \"lo\"]\n\n    Note:\n    - The length of string s will be at least k.\n    - The length of string s will be at most 10^4.\n    - All characters in string s are lowercase letters.\n    \"\"\"\n    substrings = []\n    n = len(s)\n\n    for i in range(n - k + 1):\n        substrings.append(s[i:i+k])\n\n    return sorted(substrings)\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer k.\n    \"\"\"\n    return \"abcde\", 3\n\nassert f(*g()) == [\"abc\", \"bcd\", \"cde\"]\n",
        "idx_generation": 372,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations in nums where the numbers sum to target.\n    Each number in nums may only be used once in the combination.\n\n    Example:\n    Input: nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Hint: Use backtracking to generate all possible combinations. Sort the nums array to handle duplicate numbers.\n    \"\"\"\n    def backtrack(nums, target, path, start):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if nums[i] > target:\n                break\n            backtrack(nums, target - nums[i], path + [nums[i]], i + 1)\n    \n    nums.sort()\n    res = []\n    backtrack(nums, target, [], 0)\n    return res\n\ndef g():\n    return [10, 1, 2, 7, 6, 1, 5], 8\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n",
        "idx_generation": 378,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return the first n Fibonacci numbers.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    [0, 1, 1, 2, 3, 5]\n\n    Explanation:\n    The first 6 Fibonacci numbers are [0, 1, 1, 2, 3, 5].\n    \"\"\"\n\n    fib_nums = [0, 1]\n\n    while len(fib_nums) < n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n\n    return fib_nums\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == [0, 1, 1, 2, 3, 5]\n",
        "idx_generation": 472,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the minimum sum of a path from the top-left corner to the bottom-right corner. \n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n    Explanation: The minimum sum path is 1 -> 2 -> 3 -> 6 -> 9.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 21\n\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, calculate the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n\n    Return the number of unique paths.\n\n    Example:\n    n = 3, m = 7\n\n    There are 28 unique paths from the top-left corner to the bottom-right corner of a 3 x 7 grid.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][m-1]\n\ndef g():\n    return 3, 7\n\nassert f(*g()) == 28\n\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subset of nums such that the bitwise AND of all the elements in the subset is equal to 0.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    True\n    Explanation: The subset [1, 2, 3, 4] has a bitwise AND equal to 0.\n\n    Sample Input:\n    nums = [1, 2, 3, 5]\n\n    Sample Output:\n    False\n    Explanation: There is no subset with a bitwise AND equal to 0.\n    \"\"\"\n    def subset_with_bitwise_and_zero(nums: List[int], index: int, current_and: int) -> bool:\n        if index == len(nums):\n            return current_and == 0\n        return subset_with_bitwise_and_zero(nums, index + 1, current_and) or subset_with_bitwise_and_zero(nums, index + 1, current_and & nums[index])\n\n    return subset_with_bitwise_and_zero(nums, 0, 0)\n\ndef g(nums: List[int]):\n    \"\"\"\n    Find a subset of nums such that the bitwise AND of all the elements in the subset is equal to 0.\n    \"\"\"\n    subset = []\n    for num in nums:\n        if num == 0:\n            return [num]\n        if num & (num - 1) == 0:\n            subset.append(num)\n    return subset\n\nnums = [1, 2, 3, 4]\nassert f(g(nums)) == True\n",
        "idx_generation": 231,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x n grid. You can only move either down or right at any point in time.\n\n    Sample Input:\n    n = 3\n\n    Sample Output:\n    6\n    Explanation: There are 6 unique paths from the top-left corner to the bottom-right corner of a 3 x 3 grid.\n\n    Sample Input:\n    n = 7\n\n    Sample Output:\n    924\n    Explanation: There are 924 unique paths from the top-left corner to the bottom-right corner of a 7 x 7 grid.\n    \"\"\"\n\n    def unique_paths_helper(m: int, n: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if m == 1 or n == 1:\n            return 1\n        if (m, n) in memo:\n            return memo[(m, n)]\n        memo[(m, n)] = unique_paths_helper(m - 1, n, memo) + unique_paths_helper(m, n - 1, memo)\n        return memo[(m, n)]\n\n    memo = {}\n    return unique_paths_helper(n, n, memo)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix 'graph',\n    determine if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    def dfs(v: int, visited: List[bool], parent: int) -> bool:\n        visited[v] = True\n\n        for i in range(len(graph)):\n            if graph[v][i] == 1:\n                if not visited[i]:\n                    if dfs(i, visited, v):\n                        return True\n                elif parent != i:\n                    return True\n\n        return False\n\n    visited = [False] * len(graph)\n\n    for i in range(len(graph)):\n        if not visited[i]:\n            if dfs(i, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an undirected graph represented as an adjacency matrix.\n    \"\"\"\n    graph = [[0, 1, 0, 0],\n             [1, 0, 1, 1],\n             [0, 1, 0, 1],\n             [0, 1, 1, 0]]\n\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 240,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from a set of n items without repetition.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 5 items in the set: {1, 2, 3, 4, 5}.\n    The number of ways to choose 3 items from this set without repetition is 10: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    \"\"\"\n    factorial = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorial[i] = factorial[i - 1] * i\n\n    return factorial[n] // (factorial[k] * factorial[n - k])\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 419,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target sum, return all unique combinations of numbers that add up to the target.\n    Each number in a combination can be used multiple times.\n    \n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n    \n    Sample Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n    Explanation: The combinations are [2, 2, 3] and [7].\n    \"\"\"\n    def backtrack(curr, remaining, start):\n        if sum(curr) == target:\n            combinations.append(curr)\n            return\n        if sum(curr) > target:\n            return\n        for i in range(start, len(remaining)):\n            backtrack(curr + [remaining[i]], remaining, i)\n    \n    combinations = []\n    backtrack([], nums, 0)\n    return combinations\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple with a list of integers and a target sum.\n    \"\"\"\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 277,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it can be rearranged into a palindrome.\n\n    Example:\n    Input: \"aab\"\n    Output: True\n\n    Explanation:\n    \"aab\" can be rearranged into \"aba\", which is a palindrome.\n    \"\"\"\n\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 == 1:\n            odd_count += 1\n\n    return odd_count <= 1\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that can be rearranged into a palindrome.\n    \"\"\"\n    return \"aab\"\n\nassert f(g()) == True\n\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n\n",
        "idx_generation": 450,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Sample input:\n    nums = [2, 4, 6, 8, 10, 12, 14], target = 8\n\n    Sample output:\n    3\n\n    Explanation:\n    The target value 8 is found at index 3 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10, 12, 14], 8\n\nassert f(*g()) == 3\n",
        "idx_generation": 139,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if it is a palindrome list.\n\n    Example:\n    nums = [1, 2, 3, 2, 1]\n    output: True\n\n    Explanation:\n    A palindrome list is a list that remains the same when its elements are reversed. In this case, the list [1, 2, 3, 2, 1] is a palindrome.\n    \"\"\"\n    return nums == nums[::-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n\n",
        "idx_generation": 378,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the\n    numbers sum to target. Each number in nums may only be used once in the combination.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n\n    A solution set is:\n    [\n        [1, 1, 6],\n        [1, 2, 5],\n        [1, 7],\n        [2, 6]\n    ]\n\n    Therefore, the function should return [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]].\n    \"\"\"\n    result = []\n    nums.sort()\n    n = len(nums)\n\n    def backtrack(start, path, target):\n        if target == 0:\n            result.append(path[:])\n            return\n        for i in range(start, n):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            if nums[i] > target:\n                break\n            path.append(nums[i])\n            backtrack(i + 1, path, target - nums[i])\n            path.pop()\n\n    backtrack(0, [], target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple of an array of integers and an integer for Puzzle 5.\n    \"\"\"\n    return ([10, 1, 2, 7, 6, 1, 5], 8)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n",
        "idx_generation": 380,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates from the list and return the resulting list.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n\n    The list without duplicates should be [1, 2, 3, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 4, 5].\n    \"\"\"\n    return list(set(nums))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence (LIS) in the list.\n    Return the LIS in ascending order.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)\n    lis = []\n    curr_length = max_length\n\n    for i in range(n - 1, -1, -1):\n        if dp[i] == curr_length:\n            lis.append(nums[i])\n            curr_length -= 1\n\n    lis.reverse()\n    return lis\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return [nums]\n\nassert f(*g()) == [2, 3, 7, 18]\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which has a sum of 12.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers in the list whose XOR is equal to the target value.\n\n    Example:\n    Input: nums = [2, 5, 3, 8, 6, 4], target = 7\n    Output: True\n\n    Explanation: The XOR of 5 and 2 is 7.\n    \"\"\"\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == target:\n                return True\n\n    return False\n\ndef g():\n    nums = [2, 5, 3, 8, 6, 4]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 236,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n    Explanation: The 6th Fibonacci number is 8.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    55\n    Explanation: The 10th Fibonacci number is 55.\n    \"\"\"\n    if n <= 1:\n        return n\n    return f(n-1) + f(n-2)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> List[List[int]]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find all possible paths from a starting node to an ending node.\n\n    Example:\n    Input: graph = [[1, 2], [3], [3], []], start = 0, end = 3\n    Output: [[0, 1, 3], [0, 2, 3]] (There are two possible paths from node 0 to node 3: [0, 1, 3] and [0, 2, 3])\n\n    Hint: Use depth-first search (DFS) to find all possible paths from the starting node to the ending node.\n    \"\"\"\n    def dfs(node, path):\n        if node == end:\n            paths.append(path)\n            return\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                dfs(neighbor, path + [neighbor])\n    \n    paths = []\n    dfs(start, [start])\n    return paths\n\ndef g():\n    return ([[1, 2], [3], [3], []], 0, 3)\n\nassert f(*g()) == [[0, 1, 3], [0, 2, 3]]\n",
        "idx_generation": 247,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique k-length strings that can be formed using n distinct characters.\n    \"\"\"\n    def count_strings(n: int, k: int, current: str, count: int) -> int:\n        if k == 0:\n            return count + 1\n        for i in range(n):\n            count = count_strings(n, k - 1, current + str(i), count)\n        return count\n    \n    return count_strings(n, k, \"\", 0)\n\ndef g(n = 3, k = 2):\n    return n, k\n\nassert f(*g()) == 9\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right corner from the top-left corner.\n    You can only move down or right.\n\n    The cost of each cell represents the cost to step on that cell.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    \n    Output:\n    7\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total cost of 7.\n\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(1, cols):\n        grid[0][i] += grid[0][i-1]\n\n    for i in range(1, rows):\n        grid[i][0] += grid[i-1][0]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n\n    return grid[rows-1][cols-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 284,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of numbers from 1 to n (inclusive) that do not contain the digit 3.\n\n    Example:\n    Input: n = 10\n    Output: 9\n    Explanation: The numbers from 1 to 10 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n    The numbers that do not contain the digit 3 are [1, 2, 4, 5, 6, 7, 8, 9, 10].\n    Therefore, the count is 9.\n\n    Input: n = 20\n    Output: 19\n    Explanation: The numbers from 1 to 20 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].\n    The numbers that do not contain the digit 3 are [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20].\n    Therefore, the count is 19.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if '3' not in str(i):\n            count += 1\n    return count\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 9\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the same elements, but in reverse order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The reverse of the list is [5, 4, 3, 2, 1].\n\n    Therefore, the function should return [5, 4, 3, 2, 1].\n    \"\"\"\n    return nums[::-1]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n\n",
        "idx_generation": 451,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input: [2, 3, 4, 5, 6]\n    Output: 30 (The maximum product is obtained by multiplying 5 and 6: 5 * 6 = 30)\n\n    Hint: This problem can be solved using bit manipulation and dynamic programming.\n    \"\"\"\n    max_product = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g() -> List[int]:\n    return [2, 3, 4, 5, 6]\n\nassert f(g()) == 30\n\n",
        "idx_generation": 140,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and an integer k, return True if there are two distinct indices i and j in the list\n    such that arr[i] ^ arr[j] = k, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if k ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    arr = [4, 2, 8, 6, 10]\n    k = 12\n    return arr, k\n\nassert f(*g()) == True\n",
        "idx_generation": 397,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of elements in the list that sum up to the target number.\n\n    Example:\n    Input: arr = [2, 4, 6, 8, 10], target = 16\n    Output: 2\n    Explanation: The minimum number of elements that sum up to 16 is 2, which can be achieved by selecting 8 and 8 from the list.\n    \"\"\"\n    def subset_sum(arr: List[int], n: int, target: int) -> int:\n        if target == 0:\n            return 0\n        if n == 0 and target != 0:\n            return float('inf')\n        if arr[n-1] > target:\n            return subset_sum(arr, n-1, target)\n        return min(subset_sum(arr, n-1, target), 1 + subset_sum(arr, n-1, target-arr[n-1]))\n\n    return subset_sum(arr, len(arr), target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return ([2, 4, 6, 8, 10], 16)\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 391,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an N x N matrix, determine if it is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same.\n    \"\"\"\n    \n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n",
        "idx_generation": 476,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the amount of water that can be trapped between the buildings.\n    \n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    \n    Output:\n    6\n    \"\"\"\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - heights[i]\n    \n    return water\n\ndef g():\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return heights\n\nassert f(g()) == 6\n",
        "idx_generation": 488,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right. Each cell has a cost associated with it.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 7\n\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a cost of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 408,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there exists a pair of numbers whose bitwise AND is equal to 0.\n    \"\"\"\n    arr.sort()  # Sorting the list in ascending order\n    for i in range(len(arr)-1):\n        if (arr[i] & arr[i+1]) == 0:\n            return True\n    return False\n\ndef g():\n    return [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nassert f(g()) == True\n",
        "idx_generation": 237,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\"\"\"\n    def fibonacci(n: int, memo: dict) -> int:\n        if n <= 1:\n            return n\n        if n in memo:\n            return memo[n]\n        memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n        return memo[n]\n\n    memo = {}\n    return fibonacci(n, memo)\n\ndef g(n: int = 5):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 301,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes and a list of directed edges between nodes, return the number of nodes that can be reached from a given starting node.\n    \"\"\"\n    def dfs(node: int, visited: List[bool]) -> int:\n        visited[node] = True\n        count = 1\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                count += dfs(neighbor, visited)\n        \n        return count\n    \n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n    \n    visited = [False] * n\n    start_node = 0\n    \n    return dfs(start_node, visited)\n\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of directed edges.\n    \"\"\"\n    return (5, [[0, 1], [0, 2], [1, 3], [1, 4]])\n\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations of the integers that sum up to the target.\n    \"\"\"\n    def backtrack(start, curr_sum):\n        nonlocal count\n        if curr_sum == target:\n            count += 1\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, curr_sum + nums[i])\n    \n    count = 0\n    backtrack(0, 0)\n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 448,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n\n    Output:\n    [\n        [1, 2, 3],\n        [1, 3, 2],\n        [2, 1, 3],\n        [2, 3, 1],\n        [3, 1, 2],\n        [3, 2, 1]\n    ]\n    \"\"\"\n\n    def backtrack(first=0):\n        if first == len(nums):\n            output.append(nums[:])\n        for i in range(first, len(nums)):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first + 1)\n            nums[first], nums[i] = nums[i], nums[first]\n\n    output = []\n    backtrack()\n    return output\n\ndef g():\n    nums = [1, 2, 3]\n    return [nums]\n\nassert f(*g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]\n\n",
        "idx_generation": 295,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subarray.\n\n    Example:\n    Input: [1, 2, 3, 2, 4, 5, 6]\n    Output: 4\n\n    Explanation:\n    The longest increasing subarray is [2, 4, 5, 6].\n\n    Therefore, the function should return 4.\n    \"\"\"\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n\n    return max_length\n\ndef g() -> List[int]:\n    return [1, 2, 3, 2, 4, 5, 6]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 451,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 141,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of words, return the longest common prefix among all the words.\n\n    Example:\n    Input: words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation:\n    The longest common prefix among the words \"flower\", \"flow\", and \"flight\" is \"fl\".\n    \"\"\"\n    if not words:\n        return \"\"\n    shortest_word = min(words, key=len)\n    for i, char in enumerate(shortest_word):\n        if any(word[i] != char for word in words):\n            return shortest_word[:i]\n    return shortest_word\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words to be used as input for the function f.\n    \"\"\"\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the number of ways to make the target sum using the given list of numbers, where each number can be used multiple times.\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\n\nassert f(*g()) == 7\n",
        "idx_generation": 393,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all prime numbers less than or equal to n.\n\n    Return the sum.\n\n    Example:\n    n = 10\n\n    The prime numbers less than or equal to 10 are [2, 3, 5, 7].\n    The sum of these prime numbers is 2 + 3 + 5 + 7 = 17.\n\n    Therefore, the function should return 17.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_sum += i\n\n    return prime_sum\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 17\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    return f(n-1) + f(n-2)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally (down-right).\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n\n    Explanation: The maximum sum path from the top-left cell (1) to the bottom-right cell (1) is 1 + 3 + 1 + 5 + 2 = 12.\n\n    Hint: Use dynamic programming to calculate the maximum sum path for each cell in the grid.\n    Start by initializing a new grid with the same size as the input grid.\n    Then, iterate through each cell in the new grid, calculating the maximum sum path based on the adjacent cells.\n    Finally, return the value in the bottom-right cell of the new grid.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n",
        "idx_generation": 412,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of bits required to represent all the numbers.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10]\n    Output: 4\n\n    Explanation: The numbers can be represented using 4 bits: 0010, 0100, 0110, 1000, 1010.\n    \"\"\"\n\n    max_num = max(nums)\n    bit_count = 0\n\n    while max_num > 0:\n        max_num >>= 1\n        bit_count += 1\n\n    return bit_count\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of the first n Fibonacci numbers.\n    \n    Example:\n    n = 5\n    \n    f(n) => 12\n    Explanation: The first 5 Fibonacci numbers are 1, 1, 2, 3, and 5. Their sum is 12.\n    \"\"\"\n    def fibonacci(n):\n        if n <= 0:\n            return []\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 1]\n        \n        fib_list = [1, 1]\n        while len(fib_list) < n:\n            fib_list.append(fib_list[-1] + fib_list[-2])\n        \n        return fib_list\n    \n    fib_nums = fibonacci(n)\n    fib_sum = sum(fib_nums)\n    \n    return fib_sum\n\ndef g():\n    return (5,)\n\nassert f(*g()) == 12\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a number of nodes and a list of directed edges between nodes, return the number of nodes that can reach a given target node.\n    \"\"\"\n    def dfs(node: int, visited: List[bool]) -> int:\n        visited[node] = True\n        count = 1\n        \n        for neighbor in reverse_graph[node]:\n            if not visited[neighbor]:\n                count += dfs(neighbor, visited)\n        \n        return count\n    \n    reverse_graph = [[] for _ in range(n)]\n    for u, v in edges:\n        reverse_graph[v].append(u)\n    \n    visited = [False] * n\n    target_node = n-1\n    \n    return dfs(target_node, visited)\n\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes and a list of directed edges.\n    \"\"\"\n    return (5, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]])\n\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, count the number of occurrences of the target in the list.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num == target:\n            count += 1\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 2, 2, 5, 2]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 4\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations of numbers in the list that add up to the target.\n    \n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    \n    f(nums, target) => 2\n    Explanation: There are two combinations that add up to 10: [2, 8] and [4, 6].\n    \"\"\"\n    def count_combinations(i, curr_sum):\n        if curr_sum == target:\n            return 1\n        if i >= len(nums) or curr_sum > target:\n            return 0\n        \n        return count_combinations(i+1, curr_sum + nums[i]) + count_combinations(i+1, curr_sum)\n    \n    num_combinations = count_combinations(0, 0)\n    \n    return num_combinations\n\ndef g():\n    return ([2, 4, 6, 8], 10)\n\nassert f(*g()) == 2\n",
        "idx_generation": 303,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n    Explanation: The maximum product can be obtained by multiplying 2, 3, and 4.\n\n    \"\"\"\n\n    nums.sort()\n\n    # Case 1: All positive numbers\n    max_product = nums[-1] * nums[-2] * nums[-3]\n\n    # Case 2: Two negative numbers and one positive number\n    if nums[0] < 0 and nums[1] < 0:\n        max_product = max(max_product, nums[0] * nums[1] * nums[-1])\n\n    return max_product\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, check if there exists two distinct indices i and j in the array such that \n    the absolute difference between nums[i] and nums[j] is at most target and i and j differ by at most k.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, min(i + target + 1, n)):\n            if abs(arr[i] - arr[j]) <= target:\n                return True\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 5) == True\n",
        "idx_generation": 147,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list where each string is sorted in ascending order of their lengths.\n    If multiple strings have the same length, they should be sorted in alphabetical order.\n\n    Example:\n    Input: strings = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n    Output: [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n    \"\"\"\n\n    return sorted(strings, key=lambda x: (len(x), x))\n\ndef g() -> List[str]:\n    return [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n\nassert f(g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of distinct integers and a target integer target, return a list of all unique combinations of nums where the sum is equal to target.\n\n    You may return the combinations in any order.\n\n    The same number may be chosen from nums an unlimited number of times.\n\n    Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\n    It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n    Example:\n    nums = [2,3,6,7], target = 7\n    Output: [[2,2,3],[7]]\n\n    nums = [2,3,5], target = 8\n    Output: [[2,2,2,2],[2,3,3],[3,5]]\n    \"\"\"\n    result = []\n    nums.sort()\n    dfs(nums, target, 0, [], result)\n    return result\n\ndef dfs(nums: List[int], target: int, index: int, path: List[int], result: List[List[int]]):\n    if target == 0:\n        result.append(path)\n        return\n    for i in range(index, len(nums)):\n        if nums[i] > target:\n            break\n        dfs(nums, target - nums[i], i, path + [nums[i]], result)\n\ndef g(nums: List[int] = [2, 3, 6, 7], target: int = 7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays that have a sum equal to 0.\n    \"\"\"\n\n    prefix_sum = 0\n    count = 0\n    sum_map = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in sum_map:\n            count += sum_map[prefix_sum]\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g():\n    return [4, 2, -3, -1, 0, 4]\n\nassert f(g()) == 2\n",
        "idx_generation": 478,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n\n    Example:\n    nums = [2, 7, 9, 3, 1]\n\n    The maximum sum of a subarray with the given constraint is 12, which can be achieved by selecting the subarray [2, 9, 1].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    if n == 1:\n        return nums[0]\n    \n    max_sum = max(nums[0], nums[1])\n    prev_2_sum = nums[0]\n    prev_1_sum = max_sum\n    \n    for i in range(2, n):\n        current_sum = max(prev_2_sum + nums[i], prev_1_sum)\n        max_sum = max(max_sum, current_sum)\n        prev_2_sum, prev_1_sum = prev_1_sum, current_sum\n    \n    return max_sum\n\ndef g():\n    nums = [2, 7, 9, 3, 1]\n    return nums\n\nassert f(g()) == 12\n\n",
        "idx_generation": 491,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    output: 6\n\n    Explanation: There are 6 unique paths: RRDD, RDRD, RDDR, DRRD, DRDR, DDRR.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n",
        "idx_generation": 428,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two different elements from the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value can be obtained by selecting 5 and 25, which gives an XOR value of 28.\n\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max_xor ^ prefix) in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, check if there exists a subset of the integers that adds up to the\n    target.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n    Output: True\n\n    Explanation: The subset [2, 8] adds up to the target 10.\n\n    \"\"\"\n    def backtrack(index, current_sum):\n        if current_sum == target:\n            return True\n\n        if current_sum > target or index >= len(nums):\n            return False\n\n        if memo[index][current_sum] != -1:\n            return memo[index][current_sum]\n\n        if backtrack(index + 1, current_sum + nums[index]):\n            memo[index][current_sum] = True\n            return True\n\n        if backtrack(index + 1, current_sum):\n            memo[index][current_sum] = True\n            return True\n\n        memo[index][current_sum] = False\n        return False\n\n    memo = [[-1] * (target + 1) for _ in range(len(nums))]\n\n    return backtrack(0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adj_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a directed graph, determine if the graph contains a cycle.\n\n    Return True if the graph contains a cycle, False otherwise.\n    \"\"\"\n    def dfs(node: int, visited: List[bool], recursion_stack: List[bool]) -> bool:\n        visited[node] = True\n        recursion_stack[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n\n        recursion_stack[node] = False\n        return False\n\n    num_nodes = len(adj_list)\n    visited = [False] * num_nodes\n    recursion_stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, recursion_stack):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representation of a directed graph.\n    \"\"\"\n    adj_list = [[1, 2], [2, 3], [3], []]\n    return adj_list\n\nassert f(g()) == False\n\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of k numbers out of the range from 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    The possible combinations are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    Therefore, the function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n    combinations = []\n\n    def backtrack(start, curr_combo):\n        if len(curr_combo) == k:\n            combinations.append(curr_combo[:])\n        else:\n            for i in range(start, n+1):\n                curr_combo.append(i)\n                backtrack(i+1, curr_combo)\n                curr_combo.pop()\n\n    backtrack(1, [])\n\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique subsets that can be formed from the elements of nums.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The subsets that can be formed from [1, 2, 3] are:\n    [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]\n\n    Therefore, the function should return 8.\n\n    Note:\n    - The input list nums may contain duplicates.\n    - The subsets should be unique, meaning that the same subset should not be counted multiple times.\n    \"\"\"\n    def backtrack(start, curr):\n        nonlocal count\n        count.add(tuple(curr))\n        for i in range(start, len(nums)):\n            backtrack(i + 1, curr + [nums[i]])\n\n    count = set()\n    backtrack(0, [])\n    return len(count)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == 8\n",
        "idx_generation": 304,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers (1-indexed) as a list, where the first index is smaller than the second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n    You can return the answer in any order.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left+1, right+1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value that can be used to find two numbers that add up to the target.\n    \"\"\"\n    return nums, target\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(*g(nums, target)) == [2, 5]\n\n",
        "idx_generation": 453,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n\n    Input: nums = [7, 7, 7, 7, 7, 7, 7]\n    Output: 1\n    Explanation: Each number is its own increasing subsequence, therefore the length is 1.\n    \"\"\"\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 1, 6, 2, 3, 4, 8]\n\nassert f(g()) == 5\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    An anagram is a word formed by rearranging the letters of another word. For example, \"listen\" and \"silent\" are anagrams.\n\n    Example:\n    Input:\n    words = [\"listen\", \"silent\", \"heart\", \"earth\", \"bread\"]\n\n    Output:\n    [\"listen\", \"silent\", \"heart\", \"earth\"]\n    \"\"\"\n\n    # Create a dictionary to store the sorted letters of each word and the corresponding list of anagrams\n    anagram_dict = {}\n\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagram_dict:\n            anagram_dict[sorted_word].append(word)\n        else:\n            anagram_dict[sorted_word] = [word]\n\n    # Filter out the words that have more than one anagram\n    result = [word for word_list in anagram_dict.values() if len(word_list) > 1 for word in word_list]\n\n    return result\n\ndef g():\n    words = [\"listen\", \"silent\", \"heart\", \"earth\", \"bread\"]\n    return [words]\n\nassert f(*g()) == [\"listen\", \"silent\", \"heart\", \"earth\"]\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target number, count the number of unique combinations in the list that sum up to the target.\n\n    Each number in the list can be used unlimited times.\n\n    Return the count of unique combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n\n    nums = [2, 5, 9]\n    target = 10\n    Output: 56\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 414,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the product of all the numbers except the current number at each index.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    [24, 12, 8, 6]\n    \"\"\"\n    n = len(nums)\n    products = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        products[i] *= left_product\n        left_product *= nums[i]\n\n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        products[i] *= right_product\n        right_product *= nums[i]\n\n    return products\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if it is possible to divide the given list of integers into two non-empty sublists,\n    such that the sum of their elements is equal to the target.\n    \"\"\"\n    def dp(i: int, curr_sum: int, target: int) -> bool:\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n        if (i, curr_sum) in memo:\n            return memo[(i, curr_sum)]\n        memo[(i, curr_sum)] = dp(i + 1, curr_sum + nums[i], target) or dp(i + 1, curr_sum, target)\n        return memo[(i, curr_sum)]\n\n    memo = {}\n    return dp(0, 0, target)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be divided into two non-empty sublists,\n    such that the sum of their elements is equal to the target.\n    \"\"\"\n    def generate_list(target: int) -> List[int]:\n        if target <= 0:\n            return []\n        return [target // 2] + generate_list(target // 2)\n\n    return generate_list(target) + nums + generate_list(target)\n\nassert f(g([1, 2, 3], 2), 2)\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a grid of integers, find a valid path from the start cell to the end cell by only moving down or right.\n    Return a list of tuples representing the path.\n\n    Example:\n    grid = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n\n    Explanation: The valid path is (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2).\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i-1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j-1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1 and (dp[i-1][j] or dp[i][j-1]):\n                dp[i][j] = True\n\n    if not dp[m-1][n-1]:\n        return []\n\n    path = []\n    x, y = end\n    while x != start[0] or y != start[1]:\n        path.append((x, y))\n        if x > 0 and dp[x-1][y]:\n            x -= 1\n        else:\n            y -= 1\n    path.append(start)\n    path.reverse()\n\n    return path\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    grid = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    return grid, start, end\n\nassert f(*g()) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n",
        "idx_generation": 428,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 254,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n        - F(0) = 0\n        - F(1) = 1\n        - F(n) = F(n-1) + F(n-2) for n > 1\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 317,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given the number of nodes n and a list of edges, check if it is possible to form a directed acyclic graph (DAG) from the given edges.\n\n    Each edge in the list represents a directed connection between two nodes.\n\n    Return True if it is possible to form a DAG, and False otherwise.\n\n    Example:\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4]]\n\n    The edges represent the following connections:\n    1 -> 2\n    2 -> 3\n    3 -> 4\n\n    It is possible to form a DAG with these edges:\n    1 -> 2 -> 3 -> 4\n\n    Therefore, the function should return True.\n\n    Note:\n    - The nodes are labeled from 1 to n.\n    - The list of edges will not contain any duplicate connections.\n    \"\"\"\n\n    # Create an adjacency list to represent the connections between nodes\n    adj_list = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n\n    # Use depth-first search (DFS) with cycle detection to check if it is possible to form a DAG\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    # Check for cycles in the graph\n    visited = [False] * (n+1)\n    stack = [False] * (n+1)\n    for node in range(1, n+1):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return False\n\n    return True\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate the number of nodes n and a list of edges.\n    \"\"\"\n    return 4, [[1, 2], [2, 3], [3, 4]]\n\nassert f(*g()) == True\n",
        "idx_generation": 253,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from n items without repetition.\n    \"\"\"\n\n    if k == 0 or k == n:\n        return 1\n    if k > n:\n        return 0\n\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g()) == 10\n",
        "idx_generation": 489,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of ways to arrange n pairs of parentheses such that they are balanced.\n    \"\"\"\n    def backtrack(s: str, left: int, right: int, res: List[str]):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right, res)\n        if right < left:\n            backtrack(s + ')', left, right + 1, res)\n\n    res = []\n    backtrack(\"\", 0, 0, res)\n    return len(res)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the maximum product of any two elements in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 250\n    Explanation: The maximum product is obtained by multiplying 10 and 25 (10 * 25 = 250).\n\n    \"\"\"\n\n    max_product = float('-inf')\n    max_num = float('-inf')\n    second_max_num = float('-inf')\n    min_num = float('inf')\n    second_min_num = float('inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max_num = max_num\n            max_num = num\n        elif num > second_max_num:\n            second_max_num = num\n\n        if num < min_num:\n            second_min_num = min_num\n            min_num = num\n        elif num < second_min_num:\n            second_min_num = num\n\n    max_product = max(max_num * second_max_num, min_num * second_min_num)\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 250\n\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if there are two numbers in the array that add up to the target.\n    Return True if there exist two numbers in the array that add up to the target, otherwise return False.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 7\n\n    The pair of numbers [3, 4] adds up to the target value of 7.\n\n    Therefore, the function should return True.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 152,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list that contains the strings sorted by their lengths in ascending order.\n    If two strings have the same length, they should be sorted in lexicographic order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n\n    The sorted list should be [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"].\n\n    Therefore, the function should return [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"].\n    \"\"\"\n    words.sort(key=lambda x: (len(x), x))\n    return words\n\ndef g() -> List[str]:\n    words = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n    return words\n\nassert f(g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n",
        "idx_generation": 437,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the next permutation in lexicographic order.\n\n    If the input list is the last permutation, return the first permutation.\n\n    Example:\n    nums = [1, 2, 3]\n    The next permutation is [1, 3, 2], since it is the smallest permutation greater than the original list [1, 2, 3].\n\n    Return the next permutation as the result.\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n\n    # Find the first decreasing element from the right\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = n - 1\n        # Find the first element greater than the decreasing element\n        while j >= 0 and nums[i] >= nums[j]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    # Reverse the suffix after the decreasing element\n    left = i + 1\n    right = n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n\n",
        "idx_generation": 452,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are divisible by 3 or 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    The function should return 33, as 3 + 5 + 6 + 9 + 10 = 33.\n    \"\"\"\n    divisible_sum = 0\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            divisible_sum += num\n    return divisible_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to travel through that cell,\n    find the minimum cost to travel from the top-left corner to the bottom-right corner.\n\n    You can only move down or right at each step.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Note:\n    - You can assume that the grid is rectangular and has at least one cell.\n    - The cost of traveling through a cell will be a positive integer.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the path from top left to bottom right which minimizes the sum of all numbers along its path.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n    Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum of all numbers along its path.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 440,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n=16):\n    \"\"\"\n    Generate an integer that is a power of two.\n    \"\"\"\n    return 1 << n\n\nassert f(g()) == True\n",
        "idx_generation": 259,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers nums, determine if it can be divided into two subsets such that the sum of elements in both subsets is equal.\n\n    Example:\n    nums = [1, 5, 11, 5]\n\n    The array can be divided into two subsets [1, 5, 5] and [11] with equal sum.\n\n    Therefore, the function should return True.\n\n    Note:\n    - The length of the array will be at most 200.\n    - The range of integers in the array is 0 <= nums[i] <= 100.\n    \"\"\"\n    def can_partition(nums: List[int], index: int, current_sum: int, target_sum: int, memo: List[List[bool]]) -> bool:\n        if index == len(nums):\n            return current_sum == target_sum\n\n        if memo[index][current_sum] != -1:\n            return memo[index][current_sum]\n\n        if current_sum + nums[index] <= target_sum:\n            if can_partition(nums, index + 1, current_sum + nums[index], target_sum, memo):\n                memo[index][current_sum] = True\n                return True\n\n        if can_partition(nums, index + 1, current_sum, target_sum, memo):\n            memo[index][current_sum] = True\n            return True\n\n        memo[index][current_sum] = False\n        return False\n\n    total_sum = sum(nums)\n\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    memo = [[-1] * (target_sum + 1) for _ in range(len(nums))]\n\n    return can_partition(nums, 0, 0, target_sum, memo)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers nums.\n    \"\"\"\n    return [1, 5, 11, 5]\n\nassert f(g()) == True\n",
        "idx_generation": 319,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as a dictionary, determine if there is a path from a start node to an end node.\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['C'],\n        'E': ['F'],\n        'F': ['C']\n    }\n    start = 'A', end = 'D'\n    The function should return True since there is a path from 'A' to 'D': A -> B -> C -> D.\n    \"\"\"\n\n    visited = set()\n\n    def dfs(node):\n        if node == end:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(start)\n\ndef g():\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['C'],\n        'E': ['F'],\n        'F': ['C']\n    }\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a collection of integers that might contain duplicates, return all possible unique permutations.\n\n    Example:\n    nums = [1, 1, 2]\n    Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n    \"\"\"\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result\n\ndef g(nums: List[int] = [1, 1, 2]):\n    return nums\n\nassert f(g()) == [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Generate all unique permutations of the numbers 1 to n.\n    \"\"\"\n    def backtrack(nums: List[int], path: List[int], res: List[List[int]]):\n        if len(path) == len(nums):\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            if nums[i] not in path:\n                backtrack(nums, path + [nums[i]], res)\n\n    nums = list(range(1, n+1))\n    res = []\n    backtrack(nums, [], res)\n    return res\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 12\n\n    Explanation: The maximum product of any two numbers in the list [1, 2, 3, 4] is 3*4 = 12.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix where each cell contains a non-negative integer, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right at each step.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j-1]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g(matrix: List[List[int]]):\n    \"\"\"\n    Generate a matrix with non-negative integers.\n    \"\"\"\n    return matrix\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert f(g(matrix)) == 6\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers\n    in the original list except for the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the numbers in the original list except for 1 is 2 * 3 * 4 = 24.\n    The product of all the numbers in the original list except for 2 is 1 * 3 * 4 = 12.\n    The product of all the numbers in the original list except for 3 is 1 * 2 * 4 = 8.\n    The product of all the numbers in the original list except for 4 is 1 * 2 * 3 = 6.\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n\n    n = len(nums)\n    product = 1\n    result = []\n\n    # Compute the product of all the numbers in the list\n    for num in nums:\n        product *= num\n\n    # Compute the product of all the numbers except for the corresponding element\n    for num in nums:\n        result.append(product // num)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine if it is possible to reach the target\n    by repeatedly adding or subtracting any number in the list. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output: True\n\n    Explanation:\n    1 + 1 + 1 + 1 = 4\n    \"\"\"\n    def backtrack(start, current_sum):\n        if current_sum == target:\n            return True\n        for i in range(start, len(nums)):\n            if current_sum + nums[i] <= target:\n                if backtrack(i, current_sum + nums[i]):\n                    return True\n            if current_sum - nums[i] >= target:\n                if backtrack(i, current_sum - nums[i]):\n                    return True\n        return False\n\n    return backtrack(0, 0)\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The function should return 12, as the maximum sum of a path is 12 (1 -> 3 -> 5 -> 2 -> 1).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n\n    def max_path_sum(grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        dp = [[0] * cols for _ in range(rows)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, rows):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n        return dp[rows - 1][cols - 1]\n\n    return max_path_sum(grid)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 459,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"Count the number of set bits in the binary representation of a number.\"\"\"\n    count = 0\n    while s:\n        count += s & 1\n        s >>= 1\n    return count\n\ndef g(s: str) -> int:\n    \"\"\"Convert the string to its corresponding ASCII value and return it.\"\"\"\n    ascii_value = ord(s)\n    return ascii_value\n\nassert f(g('A')) == 2\n",
        "idx_generation": 262,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, compute the sum of all positive integers less than or equal to n.\n    \"\"\"\n    if n == 1:\n        return 1\n    return n + f(n - 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 15\n\n",
        "idx_generation": 325,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(adj_list: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an adjacency list representation of a directed graph and two nodes, start and end,\n    determine if there is a path from start to end in the graph.\n    \"\"\"\n    def dfs(adj_list, node, visited):\n        if node == end:\n            return True\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(adj_list, neighbor, visited):\n                    return True\n        return False\n    \n    num_nodes = len(adj_list)\n    visited = [False] * num_nodes\n    return dfs(adj_list, start, visited)\n\ndef g(adj_list=[[1, 2], [3], [4, 5], [], [], []], start=0, end=5):\n    return adj_list, start, end\n\nassert f(*g())\n",
        "idx_generation": 271,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of numbers and a target sum, find all unique combinations in the list where the numbers sum up to\n    the target. Each number in the list can be used multiple times.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [\n        [2, 2, 3],\n        [7]\n    ]\n\n    Explanation: The combinations [2, 2, 3] and [7] sum up to the target 7.\n\n    Sample Input:\n    nums = [2, 3, 5]\n    target = 8\n\n    Sample Output:\n    [\n        [2, 2, 2, 2],\n        [2, 3, 3],\n        [3, 5]\n    ]\n\n    Explanation: The combinations [2, 2, 2, 2], [2, 3, 3], and [3, 5] sum up to the target 8.\n\n    \"\"\"\n    def backtrack(remain, current_combination, start):\n        if remain == 0:\n            result.append(list(current_combination))\n            return\n        elif remain < 0:\n            return\n\n        for i in range(start, len(nums)):\n            current_combination.append(nums[i])\n            backtrack(remain - nums[i], current_combination, i)\n            current_combination.pop()\n\n    result = []\n    backtrack(target, [], 0)\n    return result\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 319,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \n    Args:\n    nums (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum product of any three numbers.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    # Case 1: All positive numbers\n    max_product = nums[n-1] * nums[n-2] * nums[n-3]\n    \n    # Case 2: Two negative numbers and one positive number\n    if nums[0] < 0 and nums[1] < 0:\n        max_product = max(max_product, nums[0] * nums[1] * nums[n-1])\n    \n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\n\n    Example:\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The target value 9 exists in the matrix at position (2, 2).\n    \"\"\"\n\n    def search(matrix, target, row_start, row_end, col_start, col_end):\n        if row_start > row_end or col_start > col_end:\n            return False\n        row_mid = (row_start + row_end) // 2\n        col_mid = (col_start + col_end) // 2\n        if matrix[row_mid][col_mid] == target:\n            return True\n        elif matrix[row_mid][col_mid] > target:\n            return search(matrix, target, row_start, row_mid - 1, col_start, col_end) or \\\n                   search(matrix, target, row_start, row_end, col_start, col_mid - 1)\n        else:\n            return search(matrix, target, row_mid + 1, row_end, col_start, col_end) or \\\n                   search(matrix, target, row_start, row_end, col_mid + 1, col_end)\n\n    if not matrix or not matrix[0]:\n        return False\n\n    return search(matrix, target, 0, len(matrix) - 1, 0, len(matrix[0]) - 1)\n\ndef g():\n    matrix = [\n        [1, 4, 7, 11, 15],\n        [2, 5, 8, 12, 19],\n        [3, 6, 9, 16, 22],\n        [10, 13, 14, 17, 24],\n        [18, 21, 23, 26, 30]\n    ]\n    target = 9\n    return matrix, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 157,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, determine if it is possible to rearrange the characters of s such that no two adjacent characters are the same, and the resulting string has at least k distinct substrings of length 2.\n\n    Return True if it is possible, False otherwise.\n\n    Example:\n    Input: s = \"abb\", k = 2\n    Output: True\n    Explanation: The string \"abb\" can be rearranged as \"bab\" or \"bba\", which both have at least 2 distinct substrings of length 2 (\"ba\" and \"bb\").\n    \"\"\"\n    from collections import Counter\n\n    counts = Counter(s)\n    max_freq = max(counts.values())\n\n    if max_freq > (len(s) + 1) // 2:\n        return False\n\n    return True\n\ndef g():\n    s = \"abb\"\n    k = 2\n    return s, k\n\nassert f(*g()) == True\n",
        "idx_generation": 464,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all unique combinations in nums where the numbers sum to target.\n\n    Example:\n    Input: [2, 3, 5], 8\n    Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n    Explanation:\n    There are three unique combinations that add up to 8: [2, 2, 2, 2], [2, 3, 3], and [3, 5].\n    \"\"\"\n    result = []\n    nums.sort()\n\n    def backtrack(curr_sum, start, path):\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(curr_sum + nums[i], i, path + [nums[i]])\n\n    backtrack(0, 0, [])\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 3, 5], 8)\n\nassert f(*g()) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n",
        "idx_generation": 454,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    A subarray is a contiguous subsequence of the original list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 4 + (-1) + 2 + 1 = 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous) in the list.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right of the grid.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation: The minimum path sum is 7 (1 -> 3 -> 1 -> 1 -> 1).\n\n    Hint: Use dynamic programming to calculate the minimum path sum.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the bitwise XOR of all the elements in the subset is equal to the target.\n    \"\"\"\n    def helper(nums: List[int], target: int, index: int, curr: int) -> bool:\n        if curr == target:\n            return True\n        if index == len(nums):\n            return False\n\n        # Exclude the current element\n        exclude = helper(nums, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(nums, target, index + 1, curr ^ nums[index])\n\n        return exclude or include\n\n    return helper(nums, target, 0, 0)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return nums\n\nassert f(g([2, 4, 6, 8, 10], 12), 12) == True\n\n",
        "idx_generation": 265,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of ways to reach the bottom-right corner of a n x m grid from the top-left corner. You can only move down or right.\n\n    Sample Input:\n    n = 3\n    m = 4\n\n    Sample Output:\n    10\n\n    Explanation: From the top-left corner, there are 10 possible paths to reach the bottom-right corner of a 3 x 4 grid.\n\n    \"\"\"\n    if n == 1 or m == 1:\n        return 1\n    return f(n - 1, m) + f(n, m - 1)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two random integers n and m.\n    \"\"\"\n    n = 3\n    m = 4\n    return n, m\n\nassert f(*g()) == 10\n",
        "idx_generation": 355,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if there exists a path from\n    vertex 0 to vertex n-1.\n    \"\"\"\n    def dfs(graph, visited, curr):\n        if curr == len(graph) - 1:\n            return True\n        visited[curr] = True\n        for neighbor in range(len(graph)):\n            if graph[curr][neighbor] and not visited[neighbor]:\n                if dfs(graph, visited, neighbor):\n                    return True\n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, visited, 0)\n\ndef g(graph=[[0, 1, 1, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]]):\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 272,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of positive integers and a target number, find the minimum number of combinations of the integers that sum up to the target.\n    Each number in the list can be used multiple times.\n\n    Example:\n    nums = [2, 3, 5]\n    target = 11\n\n    The minimum number of combinations that sum up to the target is 3: [5, 3, 3].\n    So, the expected output is 3.\n\n    Returns the minimum number of combinations.\n    \"\"\"\n\n    def min_combinations(nums: List[int], target: int) -> int:\n        \"\"\"\n        Finds the minimum number of combinations that sum up to the target.\n        \"\"\"\n        if target == 0:\n            return 0\n        if target < 0 or not nums:\n            return float('inf')\n\n        min_count = float('inf')\n        for num in nums:\n            count = min_combinations(nums, target - num) + 1\n            min_count = min(min_count, count)\n\n        return min_count\n\n    return min_combinations(nums, target)\n\n\ndef g():\n    nums = [2, 3, 5]\n    target = 11\n    return nums, target\n\nassert f(*g()) == 3\n",
        "idx_generation": 336,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, group them by anagrams and return the groups.\n    \n    Args:\n    words (List[str]): The input list of words.\n    \n    Returns:\n    List[str]: The groups of anagrams.\n    \"\"\"\n    anagram_groups = {}\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word not in anagram_groups:\n            anagram_groups[sorted_word] = []\n        anagram_groups[sorted_word].append(word)\n    \n    return list(anagram_groups.values())\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n",
        "idx_generation": 456,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Longest Increasing Subsequence\n\n    Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\n    A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n    Example:\n    f([10,9,2,5,3,7,101,18]) => 4\n    Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n\n    \"\"\"\n\n    def length_of_lis(nums):\n        if not nums:\n            return 0\n\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        return max(dp)\n\n    return length_of_lis(nums)\n\ndef g():\n    return ([10,9,2,5,3,7,101,18],)\n\nassert f(g()) == True\n",
        "idx_generation": 160,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest common prefix among them.\n\n    Example:\n    words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation:\n    The longest common prefix among the words is \"fl\".\n    \"\"\"\n    def common_prefix(str1, str2):\n        prefix = ''\n        i = 0\n\n        while i < len(str1) and i < len(str2) and str1[i] == str2[i]:\n            prefix += str1[i]\n            i += 1\n\n        return prefix\n\n    if not words:\n        return ''\n\n    prefix = words[0]\n\n    for i in range(1, len(words)):\n        prefix = common_prefix(prefix, words[i])\n\n        if not prefix:\n            return ''\n\n    return prefix\n\ndef g():\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets that have an even sum.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n\n    Output:\n    4\n\n    Explanation:\n    The subsets with an even sum are [1], [2], [3], [2,3].\n    \"\"\"\n\n    def count_subsets(nums: List[int], index: int, current_sum: int) -> int:\n        if index == len(nums):\n            if current_sum % 2 == 0:\n                return 1\n            else:\n                return 0\n        else:\n            count = 0\n            count += count_subsets(nums, index + 1, current_sum + nums[index])\n            count += count_subsets(nums, index + 1, current_sum)\n            return count\n\n    return count_subsets(nums, 0, 0)\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 456,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray with the maximum sum is [4, -1, 2, 1], and its sum is 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there is a subset of nums that sums up to the target value.\n    Return True if such subset exists, False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8], target = 10\n    Output: True\n\n    Explanation:\n    The subset [2, 8] has a sum of 10, which is equal to the target value.\n    \"\"\"\n\n    def subset_sum(nums: List[int], target: int, curr_sum: int, index: int) -> bool:\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        \n        include = subset_sum(nums, target, curr_sum + nums[index], index + 1)\n        exclude = subset_sum(nums, target, curr_sum, index + 1)\n        \n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)\n\ndef g() -> List[int]:\n    return [2, 4, 6, 8], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 399,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. \n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner.\n\n    Input: n = 1\n    Output: 1\n    Explanation: There is only 1 unique path to reach the bottom-right corner.\n    \"\"\"\n\n    def count_paths(n: int) -> int:\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = 1\n            dp[0][i] = 1\n\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[n - 1][n - 1]\n\n    return count_paths(n)\n\ndef g(n = 3) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a binary number n, count the number of set bits (bits with value 1) in the binary representation of n.\n\n    Sample Input:\n    n = 101010\n\n    Sample Output:\n    3\n\n    Explanation:\n    The binary representation of 101010 has 3 set bits.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g():\n    return 42\n\nassert f(g()) == 3\n",
        "idx_generation": 275,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[int]:\n    \"\"\"\n    Given two integers n and m, return a list of the first n Fibonacci numbers modulo m.\n\n    Sample Input:\n    n = 6\n    m = 100\n\n    Sample Output:\n    [0, 1, 1, 2, 3, 5]\n    \"\"\"\n    fib_nums = [0, 1]  # Initialize the first two Fibonacci numbers\n    for i in range(2, n):\n        fib_nums.append((fib_nums[i - 1] + fib_nums[i - 2]) % m)  # Calculate the next Fibonacci number modulo m\n    return fib_nums\n\ndef g(n=6, m=100):\n    return n, m\n\nassert f(*g()) == [0, 1, 1, 2, 3, 5]\n",
        "idx_generation": 357,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, count the number of paths from node 0 to node N-1.\n    \"\"\"\n    N = len(graph)\n    count = 0\n\n    def dfs(node):\n        nonlocal count\n        if node == N-1:\n            count += 1\n            return\n        for neighbor in range(N):\n            if graph[node][neighbor] == 1:\n                dfs(neighbor)\n\n    dfs(0)\n    return count\n\ndef g() -> List[List[int]]:\n    return [[0, 1, 1], [0, 0, 1], [0, 0, 0]]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 283,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of possible combinations that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n\n    Hint: Use dynamic programming to solve this problem.\n    \"\"\"\n\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 341,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', \n    check if there exists a pair of integers in the list whose sum is equal to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    Explanation: The pair (2, 5) has a sum of 7.\n\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 457,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g(nums = [10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 161,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n    Return the longest common prefix as a string.\n\n    Example:\n    Input: words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation: The longest common prefix among the given strings is \"fl\".\n    \"\"\"\n\n    if len(words) == 0:\n        return \"\"\n\n    prefix = words[0]\n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if prefix == \"\":\n                return \"\"\n    \n    return prefix\n\n\ndef g() -> List[str]:\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words\n\nassert f(g()) == \"fl\"\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'nums', return True if it can be partitioned into two subsets such that the sum of elements\n    in both subsets is equal, otherwise return False.\n\n    Example:\n    Input: [1, 5, 11, 5]\n    Output: True\n    Explanation: The array can be partitioned into [1, 5, 5] and [11] with equal sum.\n    \"\"\"\n\n    def can_partition(nums):\n        total_sum = sum(nums)\n\n        if total_sum % 2 != 0:\n            return False\n\n        target_sum = total_sum // 2\n        dp = [False] * (target_sum + 1)\n        dp[0] = True\n\n        for num in nums:\n            for i in range(target_sum, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n\n        return dp[target_sum]\n\n    return can_partition(nums)\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n\n",
        "idx_generation": 459,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: From the top-left corner, there are a total of 6 unique paths to the bottom-right corner.\n    \"\"\"\n    def unique_paths_helper(i, j, m, n, memo):\n        if i == m - 1 and j == n - 1:\n            return 1\n        if i >= m or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n\n        right = unique_paths_helper(i, j + 1, m, n, memo)\n        down = unique_paths_helper(i + 1, j, m, n, memo)\n        memo[i][j] = right + down\n\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, n, memo)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence with the constraint that no two numbers in the subsequence\n    should be adjacent in the original list. Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum sum can be achieved by selecting numbers 2, 4, and 6.\n\n    \"\"\"\n    n = len(nums)\n\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 12\n",
        "idx_generation": 105,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7, which corresponds to the path 1 -> 3 -> 1 -> 1 -> 1.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initialize the DP array\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Fill in the DP array\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the missing number in the range from 0 to n.\n\n    Example:\n    Input: [0, 1, 3, 4, 5]\n    Output: 2 (The missing number in the range from 0 to 5 is 2)\n\n    Hint: Use bit manipulation (XOR) to find the missing number.\n    \"\"\"\n    missing = len(nums)\n    for i, num in enumerate(nums):\n        missing ^= i ^ num\n    return missing\n\ndef g():\n    return [0, 1, 3, 4, 5]\n\nassert f(g()) == 2\n",
        "idx_generation": 277,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones.\n    The sequence starts with 0 and 1.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th Fibonacci number is 8.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    fib = [0] * (n + 1)\n    fib[1] = 1\n\n    for i in range(2, n + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n\n    return fib[n]\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 373,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given a directed graph with n nodes and m edges represented as an adjacency list, find the maximum number of nodes\n    in a connected component of the graph.\n\n    Example:\n    n = 6\n    m = 5\n    edges = [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6]]\n\n    Output: 3\n\n    Explanation:\n    The graph has 3 connected components: [1, 2, 3], [4, 5], [6]. The largest connected component has 3 nodes.\n    \"\"\"\n    graph = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n\n    for u, v in edges:\n        graph[u].append(v)\n\n    def dfs(node):\n        visited[node] = True\n        count = 1\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                count += dfs(neighbor)\n\n        return count\n\n    max_component = 0\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            component_size = dfs(node)\n            max_component = max(max_component, component_size)\n\n    return max_component\n\ndef g():\n    \"\"\"\n    Returns the number of nodes n, the number of edges m, and the edges represented as an adjacency list.\n    \"\"\"\n    n = 6\n    m = 5\n    edges = [[1, 2], [2, 3], [3, 1], [4, 5], [5, 6]]\n    return n, m, edges\n\nassert f(*g()) == 3\n",
        "idx_generation": 291,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target value, determine if it is possible to choose a combination of numbers from the\n    list that sums up to the target value. Each number in the list can be used multiple times.\n    \"\"\"\n    def can_sum(target: int, nums: List[int], memo: dict) -> bool:\n        \"\"\"\n        Helper function that returns True if it is possible to choose a combination of numbers from the list that sums up to the\n        target value.\n        \"\"\"\n        if target in memo:\n            return memo[target]\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n        \n        for num in nums:\n            remainder = target - num\n            if can_sum(remainder, nums, memo):\n                memo[target] = True\n                return True\n        \n        memo[target] = False\n        return False\n    \n    memo = {}\n    return can_sum(target, arr, memo)\n\ndef g() -> (List[int], int):\n    arr = [2, 4, 6, 8]\n    target = 14\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 345,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value\n    if it is found in the list. If the target value is not found, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7], target = 4\n    Output: 3\n\n    arr = [10, 20, 30, 40, 50], target = 25\n    Output: -1\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), 4) == 3\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers arr, rearrange the array such that every second element is greater than its left and right neighbors.\n    If it is not possible to rearrange the array in such a way, return an empty array.\n\n    Example:\n    Input: arr = [1, 4, 5, 2, 3]\n    Output: [1, 5, 2, 4, 3]\n    Explanation: The rearranged array satisfies the condition where every second element is greater than its left and right neighbors.\n                 The possible rearrangements are [1, 5, 2, 4, 3] and [1, 5, 3, 4, 2].\n\n    Note:\n    - You may assume that the input array always has an even length.\n    - If there are multiple possible rearrangements, you may return any of them.\n    \"\"\"\n\n    arr.sort()\n\n    n = len(arr)\n    result = [0] * n\n    left = 0\n    right = n - 1\n\n    for i in range(n):\n        if i % 2 == 0:\n            result[i] = arr[left]\n            left += 1\n        else:\n            result[i] = arr[right]\n            right -= 1\n\n    for i in range(1, n - 1, 2):\n        if result[i] <= result[i - 1] or result[i] <= result[i + 1]:\n            return []\n\n    return result\n\ndef g():\n    return [1, 4, 5, 2, 3]\n\nassert f(g()) == [1, 5, 2, 4, 3]\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list containing the strings in sorted order,\n    except group all the strings that begin with 'x' first.\n\n    Example:\n    Input: ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']\n    Output: ['xanadu', 'xyz', 'aardvark', 'apple', 'mix']\n\n    Explanation:\n    The strings that begin with 'x' are ['xanadu', 'xyz'].\n    The remaining strings are ['aardvark', 'apple', 'mix'].\n    Sorting the two groups separately and then combining them results in the output: \n    ['xanadu', 'xyz', 'aardvark', 'apple', 'mix'].\n    \"\"\"\n\n    x_words = sorted([word for word in words if word.startswith('x')])\n    other_words = sorted([word for word in words if not word.startswith('x')])\n\n    return x_words + other_words\n\ndef g() -> List[str]:\n    return ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']\n\nassert f(g()) == ['xanadu', 'xyz', 'aardvark', 'apple', 'mix']\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses combinations of length 2n.\n    Use recursion to generate the combinations.\n    Return a list of strings representing the valid parentheses combinations.\n    \"\"\"\n    result = []\n    generate_parentheses(result, \"\", n, n)\n    return result\n\ndef generate_parentheses(result: List[str], curr: str, left: int, right: int) -> None:\n    if left == 0 and right == 0:\n        result.append(curr)\n        return\n\n    if left > 0:\n        generate_parentheses(result, curr + \"(\", left - 1, right)\n\n    if right > left:\n        generate_parentheses(result, curr + \")\", left, right - 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    n = 3\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n",
        "idx_generation": 468,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given list.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\n\ndef g():\n    nums = [2, -3, 5, -2, 1, 7, -10]\n    return nums\n\nassert f(g()) == 11\n",
        "idx_generation": 484,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum subarray, which is a contiguous subarray with the largest sum.\n\n    Return the maximum sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (The maximum sum subarray is [4, -1, 2, 1], which has a sum of 6)\n\n    Hint: This problem can be solved using dynamic programming and Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    Return the maximum XOR value.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 7\n\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 3 and 4 (3 ^ 4 = 7).\n    \"\"\"\n\n    maxXor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixSet = set()\n\n        for num in nums:\n            prefix = num & mask\n            prefixSet.add(prefix)\n\n        tempXor = maxXor | (1 << i)\n        for prefix in prefixSet:\n            if tempXor ^ prefix in prefixSet:\n                maxXor = tempXor\n                break\n\n    return maxXor\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 7\n",
        "idx_generation": 278,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the sum of the first n natural numbers.\"\"\"\n    if n <= 0:\n        return 0\n    return n + f(n-1)\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 379,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of size n x m consisting of 0s and 1s, find the maximum size of a square submatrix that contains only 1s.\n    Return the area of the square.\n\n    Example:\n    Input:\n    n = 4\n    m = 5\n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum size of a square submatrix that contains only 1s is 2x2, so the area is 4.\n    \"\"\"\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    max_area = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j] ** 2)\n    return max_area\n\n\ndef g():\n    n = 4\n    m = 5\n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    return n, m, matrix\n\n\nassert f(*g()) == 4\n",
        "idx_generation": 292,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n different objects in a row such that no two specific objects are adjacent to each other.\n\n    Return the total number of possible arrangements.\n    \"\"\"\n    def count_arrangements(n: int, k: int) -> int:\n        if n < k:\n            return 0\n        elif k == 0:\n            return 1\n        else:\n            return (n - k + 1) * count_arrangements(n - 2, k - 1) + count_arrangements(n - 1, k)\n\n    return count_arrangements(n, n // 2)\n\ndef g(n = 4):\n    return n\n\nassert f(g()) == 6\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the number of pairs of numbers in the list that add up to the target.\n    \"\"\"\n    nums.sort()\n    count = 0\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value such that the number of pairs of numbers in the list that add up to the target is greater than 0.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10, 12]\n    target = 14\n    return nums, target\n\nassert f(*g()) > 0\n\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence within the list.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr\n\nassert f(g()) == 4\n",
        "idx_generation": 165,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n\n    Example:\n    Input: s = \"anagram\", t = \"nagaram\"\n    Output: True\n\n    Input: s = \"rat\", t = \"car\"\n    Output: False\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_count = [0] * 26\n\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n\n    for char in t:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n    \n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return \"anagram\", \"nagaram\"\n\nassert f(*g()) == True\n",
        "idx_generation": 486,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses sequences of length n.\n\n    Example:\n    Input:\n    n = 3\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def backtrack(seq, opens, closes):\n        if len(seq) == 2 * n:\n            result.append(''.join(seq))\n            return\n        if opens < n:\n            seq.append('(')\n            backtrack(seq, opens + 1, closes)\n            seq.pop()\n        if closes < opens:\n            seq.append(')')\n            backtrack(seq, opens, closes + 1)\n            seq.pop()\n\n    result = []\n    backtrack([], 0, 0)\n    return result\n\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subarray.\n\n    Return the length of the longest increasing subarray.\n\n    Example:\n    Input: [1, 3, 5, 4, 7]\n    Output: 3 (The longest increasing subarray is [1, 3, 5])\n\n    Hint: This problem can be solved using dynamic programming.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        if nums[i] > nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\ndef g():\n    return [1, 3, 5, 4, 7]\n\nassert f(g()) == 3\n\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray XOR.\n\n    The XOR of two numbers is the bitwise exclusive or operation, which returns 1 if the corresponding bits are different, and 0 if they are the same.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The maximum subarray XOR is 7, which is obtained by XORing the subarray [3, 4].\n\n    The function should return 7.\n    \"\"\"\n    max_xor = 0\n    n = len(arr)\n\n    for i in range(n):\n        curr_xor = arr[i]\n        for j in range(i+1, n):\n            curr_xor = curr_xor ^ arr[j]\n            max_xor = max(max_xor, curr_xor)\n\n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 281,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    output: 3\n\n    Explanation: There are three distinct ways to climb to the top:\n    - 1 step + 1 step + 1 step\n    - 1 step + 2 steps\n    - 2 steps + 1 step\n    \"\"\"\n\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g(4)) == 5\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary where the keys are nodes and the values are lists of adjacent nodes,\n    determine if there is a path from the start node to the end node.\n\n    Example:\n    Input:\n    graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n    \"\"\"\n\n    def dfs(node: int, visited: Set[int]) -> bool:\n        visited.add(node)\n\n        if node == end:\n            return True\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g():\n    graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}\n    start = 0\n    end = 3\n    return [graph, start, end]\n\nassert f(*g()) == True\n\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number k, find the number of unique combinations\n    of numbers in the list that add up to k. Each number in the list may be used\n    multiple times in each combination.\n\n    Example:\n    nums = [1, 2, 3], k = 4\n    Output: 7\n\n    nums = [2, 5, 9], k = 12\n    Output: 4\n    \"\"\"\n\n    def helper(target):\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        count = 0\n        for num in nums:\n            count += helper(target - num)\n        \n        memo[target] = count\n        return count\n    \n    memo = {}\n    return helper(k)\n\ndef g():\n    return [1, 2, 3]\n\nassert f(g(), 4) == 7\n",
        "idx_generation": 356,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers, find the missing number in the range from 0 to n.\n\n    Example:\n    Input: [0, 1, 2, 4, 5, 6]\n    Output: 3\n    Explanation: The missing number in the range from 0 to 6 is 3.\n    \"\"\"\n\n    def find_missing_number(nums):\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if nums[mid] == mid:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return left\n\n    return find_missing_number(nums)\n\ndef g() -> List[int]:\n    nums = [0, 1, 2, 4, 5, 6]\n    return nums\n\nassert f(g()) == 3\n\n",
        "idx_generation": 459,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n    An increasing subsequence is a sequence of numbers in the list that are in increasing order, but not necessarily adjacent.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 165,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of three numbers is 60, which corresponds to 4 * 5 * 3.\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort(reverse=True)\n    return max(nums[0] * nums[1] * nums[2], nums[0] * nums[-1] * nums[-2])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> List[List[str]]:\n    \"\"\"\n    Given an integer n, generate all possible valid parentheses combinations of length 2n.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n        \n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        \n        if right < left:\n            backtrack(s + ')', left, right + 1)\n    \n    combinations = []\n    backtrack('', 0, 0)\n    return combinations\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n",
        "idx_generation": 476,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all elements in the grid. Each element in the grid represents the height of a building.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    \"\"\"\n\n    total_sum = 0\n\n    for row in grid:\n        for element in row:\n            total_sum += element\n\n    return total_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if it is possible to select a subset of the integers such that their sum is equal to the target number.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, memo: Dict[Tuple[int, int, int], bool]) -> bool:\n        if target == 0:\n            return True\n        if index >= len(nums):\n            return False\n        if (index, target) in memo:\n            return memo[(index, target)]\n        if nums[index] <= target:\n            if subset_sum(nums, target - nums[index], index + 1, memo):\n                memo[(index, target)] = True\n                return True\n        memo[(index, target)] = subset_sum(nums, target, index + 1, memo)\n        return memo[(index, target)]\n    \n    return subset_sum(nums, target, 0, {})\n    \ndef g(n=5, nums=[2, 4, 6, 8, 10], target=18):\n    return n, nums, target\nassert f(*g())\n",
        "idx_generation": 110,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 ^ 25 = 28).\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers, where the maximum XOR value of any two elements is maximum.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 289,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Implement the Fibonacci sequence using recursion.\n\n    Example:\n    Input: n = 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g(n: int) -> int:\n    return n\n\nn = 6\nassert f(g(n)) == 8\n",
        "idx_generation": 384,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int, path: List[int]) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find if there is a path from start to end using the given path.\n    \"\"\"\n    if start == end:\n        return True\n    \n    for node in graph[start]:\n        if node not in path:\n            path.append(node)\n            if f(graph, node, end, path):\n                return True\n            path.remove(node)\n    \n    return False\n\ndef g():\n    graph = [\n        [1, 2],     # Node 0 is connected to nodes 1 and 2\n        [3, 4],     # Node 1 is connected to nodes 3 and 4\n        [4],        # Node 2 is connected to node 4\n        [5],        # Node 3 is connected to node 5\n        [3, 5],     # Node 4 is connected to nodes 3 and 5\n        []          # Node 5 has no connections\n    ]\n    start = 0\n    end = 5\n    path = [start]\n    \n    return graph, start, end, path\n\nassert f(*g())\n\n",
        "idx_generation": 294,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to choose k elements from a set of n elements.\n    This is equivalent to calculating the binomial coefficient (n choose k).\n    \"\"\"\n    def binomial_coefficient(n, k):\n        # Base cases\n        if k == 0 or k == n:\n            return 1\n        if k > n:\n            return 0\n\n        # Recursive formula\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n\n    # Calculate the binomial coefficient\n    return binomial_coefficient(n, k)\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median element.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2\n    else:\n        return nums[n // 2]\n\ndef g():\n    nums = [5, 2, 7, 9, 1, 3]\n    return nums\n\nassert f(g()) == 4.0\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of heights representing the elevation map of a landscape, calculate the volume of water\n    that can be trapped between the bars.\n\n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    Volume of trapped water = 6\n\n    Return the volume of trapped water.\n    \"\"\"\n    if not heights:\n        return 0\n\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    left_max[0] = heights[0]\n    right_max[n-1] = heights[n-1]\n\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n\n    volume = 0\n    for i in range(n):\n        volume += min(left_max[i], right_max[i]) - heights[i]\n\n    return volume\n\ndef g() -> List[int]:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return heights\n\nassert f(g()) == 6\n\n",
        "idx_generation": 166,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and an integer k, determine if there exists a subarray with a sum divisible by k.\n\n    Example:\n    nums = [4, 7, 2, 3, 1, 8, 9]\n    k = 5\n\n    The subarray [7, 2, 3, 1] has a sum of 13, which is divisible by 5.\n\n    Therefore, the function should return True.\n    \"\"\"\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append((prefix_sums[-1] + num) % k)\n    \n    remainder_counts = {}\n    for prefix_sum in prefix_sums:\n        if prefix_sum in remainder_counts:\n            return True\n        remainder_counts[prefix_sum] = 1\n    \n    return False\n\ndef g():\n    nums = [4, 7, 2, 3, 1, 8, 9]\n    k = 5\n    return nums, k\n\nassert f(*g()) == True\n\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of valid parentheses strings of length 2*n.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: There are 5 valid parentheses strings of length 6: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\".\n\n    Note:\n    - A valid parentheses string is a string consisting of \"(\" and \")\" characters, such that every open parenthesis \"(\" has a matching closing parenthesis \")\".\n    - The length of the string is always an even number.\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    # Recursive function to generate valid parentheses strings\n    def generate_parentheses(left: int, right: int, s: str, result: List[str]):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            generate_parentheses(left - 1, right, s + '(', result)\n        if right > left:\n            generate_parentheses(left, right - 1, s + ')', result)\n\n    # Generate all valid parentheses strings of length 2*n\n    valid_parentheses = []\n    generate_parentheses(n, n, '', valid_parentheses)\n\n    return len(valid_parentheses) % (10**9 + 7)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a valid arithmetic progression.\n\n    An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    The difference between consecutive terms is 2, so this is a valid arithmetic progression.\n\n    Return True if the list is a valid arithmetic progression, False otherwise.\n    \"\"\"\n    if len(nums) < 2:\n        return True\n\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n\n    return True\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the arithmetic progression.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 485,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray such that no two elements in the subarray are adjacent.\n    \n    Example:\n    arr = [4, 1, 1, 9, 2]\n    \n    The maximum sum of a subarray with no adjacent elements is 13, which can be achieved by selecting the subarray [4, 9].\n    \n    Therefore, the function should return 13.\n    \"\"\"\n    n = len(arr)\n    \n    if n == 0:\n        return 0\n    \n    if n == 1:\n        return arr[0]\n    \n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    \n    for i in range(2, n):\n        dp[i] = max(arr[i] + dp[i - 2], dp[i - 1])\n    \n    return dp[-1]\n\ndef g() -> List[int]:\n    arr = [4, 1, 1, 9, 2]\n    return arr\n\nassert f(g()) == 13\n\n",
        "idx_generation": 113,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int, bit_position: int) -> bool:\n    \"\"\"\n    Given a number and a bit position, return True if the bit at the given position is set (1), and False otherwise.\n    \"\"\"\n    return (num >> bit_position) & 1\n\ndef g(num: int, bit_position: int) -> List[int]:\n    \"\"\"\n    Generate a number and a bit position such that the bit at the given position is set (1).\n    \"\"\"\n    return num, bit_position\n\n# Test case\nnum = 10\nbit_position = 1\nassert f(*g(num, bit_position))\n\n",
        "idx_generation": 305,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n\n    The Fibonacci sequence is a series of numbers in which each number (Fibonacci number) is\n    the sum of the two preceding ones. It starts with 0 and 1.\n\n    Example:\n    Input: n = 6\n    Output: 8\n    Explanation: The Fibonacci sequence is [0, 1, 1, 2, 3, 5, 8]. The 6th number is 8.\n    \"\"\"\n\n    memo = {}\n\n    def fibonacci(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n        return memo[n]\n\n    return fibonacci(n)\n\ndef g(n = 6):\n    return (n,)\n\nassert f(*g()) == 8\n",
        "idx_generation": 389,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start_node: int, end_node: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list, a start node, and an end node, determine if there is a path from the start node to the end node.\n\n    Sample Input:\n    graph = [[1, 2], [3, 4], [5], [6, 7], [], [8], [], [], []]\n    start_node = 0\n    end_node = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The graph can be visualized as follows:\n\n            0\n           / \\\n          1   2\n         / \\\n        3   4\n       / \\\n      6   7\n     /\n    8\n\n    There exists a path from node 0 to node 6.\n    \"\"\"\n\n    def dfs(node):\n        if node == end_node:\n            return True\n        for neighbor in graph[node]:\n            if dfs(neighbor):\n                return True\n        return False\n\n    return dfs(start_node)\n\ndef g():\n    graph = [[1, 2], [3, 4], [5], [6, 7], [], [8], [], [], []]\n    start_node = 0\n    end_node = 6\n    return graph, start_node, end_node\n\nassert f(*g()) == True\n\n",
        "idx_generation": 297,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the value of the binomial coefficient C(n, k).\n\n    Example:\n    n = 5, k = 2\n\n    The binomial coefficient C(5, 2) is calculated as (5!)/(2!*(5-2)!) = 10.\n\n    Therefore, the function should return 10.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    else:\n        return f(n-1, k-1) + f(n-1, k)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two random integers n and k.\n    \"\"\"\n    return [5, 2]\n\nassert f(*g()) == 10\n",
        "idx_generation": 373,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicate elements removed.\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g():\n    nums = [1, 2, 3, 2, 4, 5, 3]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 460,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target in the list using binary search.\n    If the target is not found, return -1.\n    \n    Sample Input:\n    arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    target = 14\n    \n    Sample Output:\n    6\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n    target = 14\n    return arr, target\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 166,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, sort the strings lexicographically in descending order.\n\n    Example:\n    arr = ['cat', 'dog', 'apple', 'banana']\n    After sorting, the list becomes ['dog', 'cat', 'banana', 'apple'].\n    Return ['dog', 'cat', 'banana', 'apple'].\n    \"\"\"\n    sorted_arr = sorted(arr, reverse=True)\n    return sorted_arr\n\ndef g() -> List[str]:\n    return ['cat', 'dog', 'apple', 'banana']\n\nassert f(g()) == ['dog', 'cat', 'banana', 'apple']\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target sum, find all unique combinations in nums where the candidate numbers sum to target.\n\n    Each number in nums may only be used once in the combination.\n\n    Note:\n    - All numbers (including target) will be positive integers.\n    - The solution set must not contain duplicate combinations.\n\n    Example:\n    Input: nums = [10,1,2,7,6,1,5], target = 8\n    Output: [[1,1,6],[1,2,5],[1,7],[2,6]]\n    \"\"\"\n\n    def backtrack(start, path, target):\n        if target == 0:\n            res.append(path)\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i+1, path+[nums[i]], target-nums[i])\n\n    nums.sort()\n    res = []\n    backtrack(0, [], target)\n    return res\n\ndef g() -> Tuple[List[int], int]:\n    nums = [10,1,2,7,6,1,5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1,1,6],[1,2,5],[1,7],[2,6]]\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The maximum subarray sum is achieved by the subarray [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 486,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a path from (0, 0) to (2, 2) is 1 + 4 + 7 + 8 + 9 = 29.\n\n    Therefore, the function should return 29.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = matrix[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    \n    return dp[-1][-1]\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 29\n\n",
        "idx_generation": 113,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            return True\n\n        complements.add(num)\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers, check if there exists a subarray with a sum equal to the target.\n\n    Example:\n    nums = [1, 4, 2, -2, 5]\n    target = 7\n\n    The subarray [2, -2, 5] has a sum of 7, so the output is True.\n    \"\"\"\n\n    def helper(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if start >= len(nums):\n            return False\n\n        return helper(start + 1, curr_sum + nums[start]) or helper(start + 1, curr_sum)\n\n    return helper(0, 0)\n\ndef g():\n    nums = [1, 4, 2, -2, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 401,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import Any, List\n\nclass TreeNode:\n    def __init__(self, val: Any = 0, left: \"TreeNode\" = None, right: \"TreeNode\" = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef f(root: TreeNode) -> int:\n    \"\"\"\n    Given the root of a binary tree, find the maximum sum of any path in the tree.\n    A path is a sequence of nodes in the tree where no node is visited more than once.\n    The path does not necessarily need to go through the root.\n\n    Example:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n\n    The maximum sum of any path in the tree is 6 (the path is [2, 1, 3]).\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def max_path_sum_helper(node: TreeNode) -> int:\n        nonlocal max_sum\n        if not node:\n            return 0\n\n        left_sum = max(0, max_path_sum_helper(node.left))\n        right_sum = max(0, max_path_sum_helper(node.right))\n\n        max_sum = max(max_sum, node.val + left_sum + right_sum)\n\n        return node.val + max(left_sum, right_sum)\n\n    max_sum = float(\"-inf\")\n    max_path_sum_helper(root)\n    return max_sum\n\ndef g() -> TreeNode:\n    \"\"\"\n    Generate a binary tree with TreeNode objects.\n    \"\"\"\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    return root\n\nassert f(g()) == 6\n",
        "idx_generation": 304,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Generate all possible permutations of the numbers from 1 to n.\n\n    Example:\n    n = 3\n    output: [['1', '2', '3'], ['1', '3', '2'], ['2', '1', '3'], ['2', '3', '1'], ['3', '1', '2'], ['3', '2', '1']]\n    \"\"\"\n    def backtrack(nums, path, visited):\n        if len(path) == n:\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            if not visited[i]:\n                visited[i] = True\n                backtrack(nums, path + [nums[i]], visited)\n                visited[i] = False\n\n    result = []\n    nums = [str(i) for i in range(1, n+1)]\n    visited = [False] * n\n    backtrack(nums, [], visited)\n    return result\n\ndef g(n=3):\n    return n\n\nassert f(g()) == [['1', '2', '3'], ['1', '3', '2'], ['2', '1', '3'], ['2', '3', '1'], ['3', '1', '2'], ['3', '2', '1']]\n",
        "idx_generation": 376,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    The function should return True since 3 + 4 = 7.\n\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    The function should return False since there are no two numbers that add up to 10.\n\n    Return True or False as the result.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\ndef h() -> int:\n    \"\"\"\n    Generate a target value.\n    \"\"\"\n    target = 7\n    return target\n\nassert f(g(), h()) == True\n\n",
        "idx_generation": 461,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation:\n    - The longest increasing subsequence in the given list is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine the number of unique combinations\n    of numbers in the list that sum up to the target. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n\n    Explanation:\n    The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n",
        "idx_generation": 498,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a grid represented by a 2D list of integers and a target value,\n    return a new grid where all occurrences of the target value are replaced by 0.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n\n    Output:\n    [\n        [1, 2, 3],\n        [4, 0, 6],\n        [7, 8, 9]\n    ]\n    \"\"\"\n    new_grid = []\n    for row in grid:\n        new_row = []\n        for num in row:\n            if num == target:\n                new_row.append(0)\n            else:\n                new_row.append(num)\n        new_grid.append(new_row)\n    return new_grid\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g()) == [\n    [1, 2, 3],\n    [4, 0, 6],\n    [7, 8, 9]\n]\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n\n    Sample Input:\n    n = 4\n\n    Sample Output:\n    5\n\n    Explanation:\n    There are 5 distinct ways to climb to the top:\n    1. 1 step + 1 step + 1 step + 1 step\n    2. 1 step + 2 steps + 1 step\n    3. 2 steps + 1 step + 1 step\n    4. 1 step + 1 step + 2 steps\n    5. 2 steps + 2 steps\n\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == 5\n\n",
        "idx_generation": 115,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a pair of numbers in the list whose\n    bitwise XOR is equal to the target number. The list is not sorted.\n\n    Sample Input:\n    nums = [5, 3, 2, 7, 1]\n    target = 6\n\n    Sample Output:\n    True\n\n    Explanation:\n    The pair (5, 3) has a bitwise XOR equal to 6 (5 ^ 3 = 6).\n    \"\"\"\n\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            return True\n\n        complements.add(num)\n\n    return False\n\ndef g():\n    nums = [5, 3, 2, 7, 1]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 306,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 403,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> int:\n    \"\"\"\n    Given a graph and two nodes, return the number of unique paths from the start node to the end node.\n    Each node in the graph is represented by a string, and the graph is represented as a dictionary where the keys are the nodes and the values are lists of adjacent nodes.\n    \"\"\"\n    def dfs(node: str) -> int:\n        if node == end:\n            return 1\n        \n        if node in visited:\n            return 0\n        \n        visited.add(node)\n        paths = 0\n        \n        for neighbor in graph[node]:\n            paths += dfs(neighbor)\n        \n        visited.remove(node)\n        \n        return paths\n    \n    visited = set()\n    return dfs(start)\n\ndef g() -> Dict[str, List[str]]:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['E'],\n        'E': []\n    }\n    return graph\n\nassert f(g(), 'A', 'E') == 3\n\n",
        "idx_generation": 313,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique permutations of the numbers from 1 to n.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation:\n    The unique permutations of [1, 2, 3] are:\n    [1, 2, 3]\n    [1, 3, 2]\n    [2, 1, 3]\n    [2, 3, 1]\n    [3, 1, 2]\n    [3, 2, 1]\n    \"\"\"\n    def backtrack(nums, used, perm, perms):\n        if len(perm) == len(nums):\n            perms.append(perm[:])\n        else:\n            for i in range(len(nums)):\n                if not used[i]:\n                    used[i] = True\n                    perm.append(nums[i])\n                    backtrack(nums, used, perm, perms)\n                    used[i] = False\n                    perm.pop()\n\n    nums = list(range(1, n+1))\n    used = [False] * n\n    perm = []\n    perms = []\n    backtrack(nums, used, perm, perms)\n\n    return len(perms)\n\ndef g(n: int):\n    return n\n\nn = 3\nassert f(g(n)) == 6\n\n",
        "idx_generation": 377,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 2, 3, and 4.\n    Therefore, the function should return 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    # If all numbers are negative or all numbers are positive, the maximum product is the product of the three largest numbers\n    if nums[0] >= 0 or nums[n-1] <= 0:\n        return nums[n-1] * nums[n-2] * nums[n-3]\n\n    # Otherwise, the maximum product is the maximum of the product of the two smallest negative numbers and the largest positive number\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n",
        "idx_generation": 461,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    24\n\n    Explanation:\n    The maximum product of any three numbers in the list is obtained by multiplying 2, 3, and 4, which gives a product of 24.\n\n    \"\"\"\n\n    nums.sort()\n\n    n = len(nums)\n\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 172,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n    Explanation: The sum of all elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    total_sum = 0\n\n    for row in matrix:\n        for num in row:\n            total_sum += num\n\n    return total_sum\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Find the minimum number of steps required to reach the target element in the array.\n    The steps can be either moving left or right by the value at current position.\n    \"\"\"\n    n = len(arr)\n    dp = [float('inf')] * n\n    dp[0] = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if j + arr[j] >= i:\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[target]\n\ndef g():\n    arr = [2, 3, 1, 1, 4]\n    target = 4\n    return arr, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 116,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the value of the bitwise AND operation between all integers from 1 to n.\n\n    Args:\n    n (int): The upper limit.\n    k (int): The number of bits in the binary representation.\n\n    Returns:\n    int: The value of the bitwise AND operation.\n    \"\"\"\n    result = n\n    for i in range(n - 1, 0, -1):\n        result &= i\n    return result\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 5.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (10, 4)\n\nassert f(*g()) == 0\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 5\n\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph as an adjacency list, determine if it contains a cycle.\n\n    Example:\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    Output: True\n\n    Explanation: The graph contains a cycle: 0 -> 1 -> 2 -> 0.\n\n    \"\"\"\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n\n        return False\n\n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, -1):\n                return True\n\n    return False\n\ndef g():\n    graph = [[1, 2], [0, 2], [0, 1, 3], [2]]\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 316,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nimport heapq\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums and a target value, find the number of unique combinations that sum up to the target.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    The unique combinations that sum up to 4 are [1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2].\n    Therefore, the function should return 4.\n\n    Note:\n    - The length of the array will not exceed 20.\n    - The range of integers in the array is [1, 100].\n    - The target value is in the range [1, 1000].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if target == 0:\n            return 1\n        if index >= len(nums) or target < 0:\n            return 0\n\n        if (index, target) in memo:\n            return memo[(index, target)]\n\n        count = helper(nums, target - nums[index], index, memo) + helper(nums, target, index + 1, memo)\n        memo[(index, target)] = count\n        return count\n\n    return helper(nums, target, 0, {})\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 1 and 9 add up to the target number 10.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, start: int, end: int) -> bool:\n        if start > end:\n            return False\n\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, end)\n        else:\n            return binary_search(nums, target, start, mid - 1)\n\n    nums.sort()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums, complement, i + 1, len(nums) - 1):\n            return True\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, return the index of the target if it is found in the list, otherwise return -1.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return -1\n        \n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, low, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, high)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5, 6, 7, 8, 9], 6)\n\nassert f(*g()) == 5\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates from the list and return the modified list.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n\n    return unique_nums\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows:\n    - Fib(0) = 0\n    - Fib(1) = 1\n    - Fib(n) = Fib(n-1) + Fib(n-2)\n\n    Example:\n    n = 6\n\n    f(n) => 8\n    Explanation: The 6th number in the Fibonacci sequence is 8.\n    \"\"\"\n\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    return fibonacci(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, char: str) -> bool:\n    \"\"\"\n    Find if a given character is in the string at least twice and if the character immediately follows itself in the string.\n    \"\"\"\n    return string.count(char) >= 2 and char + char in string\n\ndef g():\n    return \"hello\"\n\nassert f(g(), 'l')\n",
        "idx_generation": 2,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise AND of all the numbers in the list.\n\n    Example:\n    Input: [5, 6, 7, 8]\n    Output: 0 (5 & 6 & 7 & 8 = 0)\n\n    Hint: Use bit manipulation to perform the AND operation.\n    \"\"\"\n    result = nums[0]\n    for num in nums[1:]:\n        result &= num\n\n    return result\n\ndef g():\n    return [5, 6, 7, 8]\n\nassert f(g()) == 0\n",
        "idx_generation": 307,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 120\n\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of directed edges, determine if there exists a cycle in the directed graph.\n\n    Example:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n    Output:\n    True\n\n    Explanation:\n    The directed graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    # Build the directed graph\n    for u, v in edges:\n        graph[u].append(v)\n\n    # Perform depth-first search to detect cycles\n    def dfs(node):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    # Check for cycles in each connected component\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False\n\n\ndef g():\n    return 4, [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n\nassert f(*g()) == True\n",
        "idx_generation": 322,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import itertools\nfrom typing import*\nfrom typing import *\nfrom itertools import combinations\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target value, find all unique combinations that sum up to the target.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    The unique combinations that sum up to 7 are [2, 2, 3] and [7].\n    Therefore, the function should return [[2, 2, 3], [7]].\n\n    Note:\n    - The length of the array will not exceed 30.\n    - The range of integers in the array is [1, 200].\n    - The target value is in the range [1, 500].\n    \"\"\"\n\n    def helper(nums: List[int], target: int, index: int, path: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(path[:])\n            return\n        if index >= len(nums) or target < 0:\n            return\n\n        for i in range(index, len(nums)):\n            path.append(nums[i])\n            helper(nums, target - nums[i], i, path, result)\n            path.pop()\n\n    result = []\n    helper(nums, target, 0, [], result)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple containing an array of integers nums and a target value.\n    \"\"\"\n    return ([2, 3, 6, 7], 7)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 394,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n",
        "idx_generation": 463,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence in the list is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where every element is the product of all the elements in the original list except for the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The product of all elements in the list is 1 * 2 * 3 * 4 * 5 = 120.\n\n    The new list should be [120, 60, 40, 30, 24], where each element is the product of all elements except for the corresponding element.\n\n    Therefore, the function should return [120, 60, 40, 30, 24].\n    \"\"\"\n    n = len(nums)\n    products = [1] * n\n    \n    left_product = 1\n    for i in range(n):\n        products[i] *= left_product\n        left_product *= nums[i]\n    \n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        products[i] *= right_product\n        right_product *= nums[i]\n    \n    return products\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n",
        "idx_generation": 491,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\n# Test case\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nassert f(g(nums)) == 6\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the string contains a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g(s: str) -> str:\n    \"\"\"Reverse the string.\"\"\"\n    return s[::-1]\n\nassert f(g('racecar'))\n",
        "idx_generation": 3,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, calculate the number of set bits in its binary representation.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g():\n    n = 15\n    return n\n\nassert f(g()) == 4\n",
        "idx_generation": 308,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of different ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    Return the number of distinct ways to climb the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return n\n\nassert f(g()) == 5\n",
        "idx_generation": 443,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if it is bipartite.\n    A graph is bipartite if it can be colored using two colors such that no two adjacent vertices have the same color.\n    Return True if the graph is bipartite, False otherwise.\n\n    Example:\n    Input: graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    Output: True\n\n    Explanation: The graph can be colored as follows:\n    0 - color A\n    1 - color B\n    2 - color A\n    3 - color B\n    No two adjacent vertices have the same color.\n\n    Note: You must use a depth-first search (DFS) algorithm to solve this problem.\n    \"\"\"\n\n    def dfs(node: int, color: int) -> bool:\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n\n    for i in range(n):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n\n    return True\n\n\ndef g() -> List[List[int]]:\n    graph = [[1, 3], [0, 2], [1, 3], [0, 2]]\n    return graph\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 327,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of unique binary strings of length n that do not contain consecutive 1s.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n    \n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 13\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the starting and ending position of a given target value in the array.\n\n    Example:\n    Input: nums = [5, 7, 7, 8, 8, 10], target = 8\n    Output: [3, 4]\n\n    Explanation:\n    The value 8 appears at indices 3 and 4 in the array, so the output is [3, 4].\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: bool) -> int:\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] > target or (left and nums[mid] == target):\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start\n\n    left_index = binary_search(nums, target, True)\n    right_index = binary_search(nums, target, False) - 1\n\n    if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n        return [left_index, right_index]\n    else:\n        return [-1, -1]\n\ndef g():\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [3, 4]\n\n",
        "idx_generation": 463,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that sum up to the target.\n    Return the indices of the two numbers.\n\n    You must write an algorithm with O(n) runtime complexity.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n    Output: [0, 1] (indices of the numbers 2 and 7)\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(arr=[2, 7, 11, 15], target=9):\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 177,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The even numbers in the list are [2, 4, 6].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 492,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subset of nums such that\n    the sum of the subset is divisible by 5.\n    \"\"\"\n    # Solution: We can use backtracking to solve this problem.\n    # Starting from the first element, we can either include it in the subset or exclude it.\n    # If we include it, we add it to the current sum. If the current sum is divisible by 5, we return True.\n    # If we exclude it, we move on to the next element.\n    # If we reach the end of the list without finding a subset with sum divisible by 5, we return False.\n    def backtrack(nums, curr_sum, index):\n        if index == len(nums):\n            return curr_sum % 5 == 0\n        return backtrack(nums, curr_sum + nums[index], index + 1) or backtrack(nums, curr_sum, index + 1)\n    \n    return backtrack(nums, 0, 0)\n    \ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a palindrome when represented in binary form.\n    \"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\n\ndef g(n: int):\n    \"\"\"\n    Find the next palindrome number after n in binary form.\n    \"\"\"\n    def is_palindrome(binary: str) -> bool:\n        return binary == binary[::-1]\n\n    next_palindrome = n + 1\n    while not is_palindrome(bin(next_palindrome)[2:]):\n        next_palindrome += 1\n    return next_palindrome\nassert f(g(9))\n",
        "idx_generation": 4,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the two numbers that appear only once and return them in a list.\n    \n    Example:\n    Input: [1, 2, 1, 3, 2, 5]\n    Output: [3, 5]\n    Explanation: The numbers 3 and 5 appear only once in the list.\n\n    Note:\n    - The list will always have exactly two numbers that appear only once, and all other numbers will appear twice.\n    \"\"\"\n    xor = 0\n    for num in nums:\n        xor ^= num\n    \n    # Find the rightmost set bit in the XOR result\n    rightmost_bit = xor & (-xor)\n    \n    # Divide the numbers into two groups based on the rightmost set bit\n    group1, group2 = 0, 0\n    for num in nums:\n        if num & rightmost_bit:\n            group1 ^= num\n        else:\n            group2 ^= num\n    \n    return [group1, group2]\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 1, 3, 2, 5]\n\nassert f(g()) == [3, 5]\n\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 0,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique binary strings of length n that do not contain consecutive ones.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: For n = 3, the unique binary strings are [\"000\", \"001\", \"010\", \"100\", \"101\"], where none of them contain consecutive ones.\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i-1] + dp[i-2]) % (10**9 + 7)\n\n    return dp[n]\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 445,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, check if the graph contains a cycle.\n\n    Example:\n    graph = [\n        [1, 2],\n        [0, 2],\n        [0, 1, 3],\n        [2]\n    ]\n\n    The function should return True, because the graph contains a cycle (0 -> 1 -> 2 -> 0).\n    \"\"\"\n    def has_cycle(node, visited, parent):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if has_cycle(neighbor, visited, node):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    n = len(graph)\n    visited = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if has_cycle(node, visited, -1):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    graph = [\n        [1, 2],\n        [0, 2],\n        [0, 1, 3],\n        [2]\n    ]\n    return graph\n\nassert f(g()) == True\n",
        "idx_generation": 330,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n    countAndSay(1) = \"1\"\n    countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\n    To determine how you \"say\" a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\n    Example:\n    n = 1\n    Output: \"1\"\n    Explanation: This is the base case.\n\n    n = 4\n    Output: \"1211\"\n    Explanation: countAndSay(1) = \"1\", countAndSay(2) = say \"1\" = one 1 = \"11\", countAndSay(3) = say \"11\" = two 1's = \"21\", countAndSay(4) = say \"21\" = one 2 + one 1 = \"1211\".\n    \"\"\"\n    if n == 1:\n        return \"1\"\n    prev = f(n-1)\n    result = \"\"\n    count = 1\n    for i in range(1, len(prev)):\n        if prev[i] == prev[i-1]:\n            count += 1\n        else:\n            result += str(count) + prev[i-1]\n            count = 1\n    result += str(count) + prev[-1]\n    return result\n\ndef g(n: int = 4):\n    return n\n\nassert f(g()) == \"1211\"\n",
        "idx_generation": 405,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 and greater than 10.\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num % 3 == 0 and num > 10:\n            total += num\n    return total\n\ndef g():\n    nums = [5, 12, 9, 7, 15, 20, 4]\n    return nums\n\nassert f(g()) == 27\n",
        "idx_generation": 464,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target value 'target',\n    return True if there exists three elements in the list whose sum is equal to the target.\n    Otherwise, return False.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 12\n    \n    The elements 3, 4, and 5 sum up to the target value 12.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    for i in range(len(arr)):\n        left = i + 1\n        right = len(arr) - 1\n\n        while left < right:\n            curr_sum = arr[i] + arr[left] + arr[right]\n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return arr\n\nassert f(g(), 12) == True\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix (2D list), return a list of the maximum elements in each row.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The maximum elements in each row are [3, 6, 9].\n\n    Therefore, the function should return [3, 6, 9].\n    \"\"\"\n    return [max(row) for row in matrix]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [3, 6, 9]\n\n",
        "idx_generation": 492,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that\n    no two elements in the subarray are adjacent. Return the maximum sum.\n\n    Example:\n    Input: [2, 7, 9, 3, 1]\n    Output: 12\n\n    Explanation: The maximum sum subarray without adjacent elements is [2, 9, 1], which sums up to 12.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[n - 1]\n\ndef g() -> List[int]:\n    nums = [2, 7, 9, 3, 1]\n    return nums\n\nassert f(g()) == 12\n\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a valid palindrome ignoring non-alphanumeric characters.\"\"\"\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef g(s=\"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 6,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer, count the number of bits set to 1 in its binary representation.\n    \"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 23\n\nassert f(g()) == 4\n",
        "idx_generation": 310,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it can be expressed as the sum of two square numbers.\n    Return True if it can be expressed as the sum of two square numbers, False otherwise.\n    \"\"\"\n    def is_square(num):\n        return int(num**0.5)**2 == num\n\n    for i in range(1, int(n**0.5) + 1):\n        if is_square(n - i*i):\n            return True\n    return False\n\n\ndef g():\n    n = 13\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 22,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct valid parentheses strings of length 2n.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: For n = 3, the distinct valid parentheses strings are [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"].\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n] % (10**9 + 7)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n",
        "idx_generation": 445,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    by only moving down or right. The path can only traverse cells with a value of 1.\n\n    Example:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n\n    There exists a path from (0, 0) to (3, 3): [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)].\n\n    Therefore, the function should return True.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i, j):\n        if i == m - 1 and j == n - 1:\n            return True\n\n        if i < m - 1 and grid[i + 1][j] == 1:\n            if dfs(i + 1, j):\n                return True\n\n        if j < n - 1 and grid[i][j + 1] == 1:\n            if dfs(i, j + 1):\n                return True\n\n        return False\n\n    return dfs(0, 0)\n\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 1, 1, 1],\n        [0, 0, 1, 1]\n    ]\n    return grid\n\n\nassert f(g()) == True\n",
        "idx_generation": 332,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\n\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])\n\n\nassert f(g(), 10) == True\n\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid-1)\n        else:\n            return binary_search(nums, target, mid+1, right)\n    \n    return binary_search(nums, target, 0, len(nums)-1)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 465,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    Output: 4\n\n    Explanation:\n    The longest increasing path is [1, 2, 6, 9], which has a length of 4.\n\n    Note:\n    - The path can start from any cell and can move in any of the four directions (up, down, left, or right).\n    - The path must be strictly increasing (each cell must be greater than the previous cell in the path).\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * cols for _ in range(rows)]\n    max_length = 0\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        length = 1\n\n        for direction in directions:\n            x = i + direction[0]\n            y = j + direction[1]\n            if 0 <= x < rows and 0 <= y < cols and matrix[x][y] > matrix[i][j]:\n                length = max(length, 1 + dfs(x, y))\n\n        dp[i][j] = length\n        return length\n\n    for i in range(rows):\n        for j in range(cols):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n\n",
        "idx_generation": 186,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the sum of each row.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The function should return [6, 15, 24] since the sum of each row is [1+2+3, 4+5+6, 7+8+9].\n    \"\"\"\n\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n\n    return row_sums\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [6, 15, 24]\n\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid, determine the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n\n    Output:\n    6\n\n    Explanation:\n    There are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    \"\"\"\n\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill in the DP table\n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n\n    return dp[m - 1][n - 1]\n\n\ndef g():\n    grid = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    return grid\n\n\nassert f(g()) == 6\n\n",
        "idx_generation": 129,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(expression: str) -> bool:\n    \"\"\"\n    Check if the parentheses in the given expression are balanced.\n\n    The expression is a string containing only parentheses '()' and possibly other characters.\n\n    Example:\n    expression = '(()())'\n    output: True\n    \"\"\"\n    stack = []\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\ndef g(expression = '(()())'):\n    return expression\n\nassert f(g()) == True\n",
        "idx_generation": 7,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2]\n\n    The maximum XOR value between any two elements in the list is 28 (obtained by XORing 5 and 25).\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 311,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n    \"\"\"\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate a power of two.\n    \"\"\"\n    return 16\n\nassert f(g()) == True\n",
        "idx_generation": 36,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3, m = 4\n    Output: 10\n    Explanation: There are 10 unique paths to reach the bottom-right corner.\n    \"\"\"\n\n    def unique_paths(n: int, m: int) -> int:\n        if n == 1 or m == 1:\n            return 1\n        return unique_paths(n - 1, m) + unique_paths(n, m - 1)\n\n    return unique_paths(n, m)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two integers n and m.\n    \"\"\"\n    return [3, 4]\n\nassert f(*g()) == 10\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, find the number of connected components in the graph.\n\n    Example:\n    graph = [\n        [1],\n        [0, 2],\n        [1],\n        [4],\n        [3]\n    ]\n\n    The graph has 2 connected components: {0, 1, 2} and {3, 4}. So the function should return 2.\n\n    Note:\n    - The graph will be given as a list of lists, where each inner list represents the neighbors of a given node.\n    - The nodes will be labeled from 0 to n-1, where n is the number of nodes in the graph.\n    \"\"\"\n\n    def dfs(node):\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    visited = set()\n    components = 0\n\n    for node in range(len(graph)):\n        if node not in visited:\n            dfs(node)\n            components += 1\n\n    return components\n\ndef g() -> List[List[int]]:\n    graph = [\n        [1],\n        [0, 2],\n        [1],\n        [4],\n        [3]\n    ]\n    return graph\n\nassert f(g()) == 2\n",
        "idx_generation": 333,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\n\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])\n\n\nassert f(g(), 10) == True\n\n",
        "idx_generation": 407,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list\n    that add up to the target value.\n\n    Return True if there are two numbers that add up to the target, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    The list will contain at least two numbers that add up to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\nassert f(*g([1, 2, 3, 4, 5], 6))\n",
        "idx_generation": 198,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it by 90 degrees clockwise.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Input: matrix = [[1, 2], [3, 4]]\n    Output: [[3, 1], [4, 2]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Subset Sum\n\n    Given a list of integers, determine if there is a subset of the numbers that sums up to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 3, 4] sums up to the target value of 9.\n    \"\"\"\n\n    def subset_sum(nums, target, index, curr_sum, memo):\n        if curr_sum == target:\n            return True\n        if index >= len(nums) or curr_sum > target:\n            return False\n        if (index, curr_sum) in memo:\n            return memo[(index, curr_sum)]\n        include = subset_sum(nums, target, index + 1, curr_sum + nums[index], memo)\n        exclude = subset_sum(nums, target, index + 1, curr_sum, memo)\n        memo[(index, curr_sum)] = include or exclude\n        return memo[(index, curr_sum)]\n\n    return subset_sum(nums, target, 0, 0, {})\n\ndef g(nums = [1, 2, 3, 4, 5], target = 9):\n    return (nums, target)\n\nassert f(*g()) == True\n\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the binary representation of the corresponding element in the input list.\n    \"\"\"\n    result = []\n    for num in nums:\n        binary = bin(num)[2:]\n        result.append(binary)\n    return result\n\ndef g():\n    nums = [5, 10, 15, 20]\n    return nums\n\nassert f(g()) == ['101', '1010', '1111', '10100']\n",
        "idx_generation": 9,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there are two numbers in the given list whose XOR is equal to the target value\n    \"\"\"\n    seen = set()\n    for num in arr:\n        complement = target ^ num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g():\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == True\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if two numbers n and m are co-prime, i.e., their greatest common divisor is 1.\n    \"\"\"\n    def gcd(a: int, b: int) -> int:\n        while b != 0:\n            a, b = b, a % b\n        return a\n    \n    return gcd(n, m) == 1\n\ndef g(n=15, m=28):\n    return n, m\n\nassert f(*g()) == True\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer value for the number of steps in the staircase.\n    \"\"\"\n    return 3\n\nassert f(g()) == 3\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(adjacency_matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, determine if the graph contains a cycle.\n\n    The adjacency matrix is a square matrix where adjacency_matrix[i][j] = 1 if there is an edge from vertex i to vertex j,\n    and adjacency_matrix[i][j] = 0 otherwise.\n\n    For example, given the adjacency matrix [[0, 1, 0], [0, 0, 1], [1, 0, 0]], the graph contains a cycle and the function\n    should return True.\n    \"\"\"\n    def dfs(graph, visited, current, parent):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if visited[neighbor] and neighbor != parent:\n                return True\n            if not visited[neighbor] and dfs(graph, visited, neighbor, current):\n                return True\n        return False\n\n    n = len(adjacency_matrix)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if adjacency_matrix[i][j] == 1:\n                graph[i].append(j)\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i] and dfs(graph, visited, i, -1):\n            return True\n    return False\ndef g(adjacency_matrix = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]):\n    return adjacency_matrix\nassert f(g())\n",
        "idx_generation": 343,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid combinations of parentheses that can be formed using n pairs of parentheses.\n\n    Example:\n    n = 3\n    Output: 5\n\n    Explanation: The valid combinations are \"((()))\", \"(()())\", \"(())()\", \"()(())\", and \"()()()\".\n    \"\"\"\n    def backtrack(s: str, left: int, right: int):\n        nonlocal count\n        if left == 0 and right == 0:\n            count += 1\n            return\n        if left > 0:\n            backtrack(s + '(', left - 1, right)\n        if right > left:\n            backtrack(s + ')', left, right - 1)\n    \n    count = 0\n    backtrack('', n, n)\n    return count\n\ndef g(n: int = 3):\n    return (n,)\n\nassert f(*g()) == 5\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum product of any three numbers from the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 120\n\n",
        "idx_generation": 467,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr, check if there are two numbers in the list that sum up to the target.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number for testing.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 10\n\nassert f(*g()) == True\n",
        "idx_generation": 204,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix 90 degrees clockwise in-place.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    After rotating the matrix 90 degrees clockwise, the new matrix should be:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Return the rotated matrix.\n\n    Hint: Use the transpose and reverse row operations.\n    \"\"\"\n    n = len(matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n\n    return matrix\n\ndef g():\n    \"\"\"\n    Generate an n x n matrix.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n\n",
        "idx_generation": 496,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Island Perimeter\n\n    You are given a map in form of a two-dimensional grid where 1 represents land and 0 represents water.\n    Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water,\n    and there is exactly one island (i.e., one or more connected land cells).\n    The island doesn't have \"lakes\" (water inside that isn't connected to the water around the island).\n    One cell is a square with side length 1.\n    The grid is rectangular, width and height don't exceed 100.\n    Determine the perimeter of the island.\n\n    Example:\n    grid = [\n        [\"0\", \"1\", \"0\", \"0\"],\n        [\"1\", \"1\", \"1\", \"0\"],\n        [\"0\", \"1\", \"0\", \"0\"],\n        [\"1\", \"1\", \"0\", \"0\"]\n    ]\n    output: 16\n    \"\"\"\n\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \"0\":\n            return 1\n        if grid[i][j] == \"#\":\n            return 0\n        grid[i][j] = \"#\"\n        perimeter = 0\n        perimeter += dfs(i - 1, j)\n        perimeter += dfs(i + 1, j)\n        perimeter += dfs(i, j - 1)\n        perimeter += dfs(i, j + 1)\n        return perimeter\n\n    perimeter = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == \"1\":\n                perimeter += dfs(i, j)\n    return perimeter\n\ndef g():\n    grid = [\n        [\"0\", \"1\", \"0\", \"0\"],\n        [\"1\", \"1\", \"1\", \"0\"],\n        [\"0\", \"1\", \"0\", \"0\"],\n        [\"1\", \"1\", \"0\", \"0\"]\n    ]\n    return (grid,)\n\nassert f(*g()) == 16\n",
        "idx_generation": 132,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are palindromes.\n    \"\"\"\n    def is_palindrome(word: str) -> bool:\n        return word == word[::-1]\n\n    queue = []\n    for word in words:\n        if is_palindrome(word):\n            queue.append(word)\n\n    return queue\n\ndef g():\n    words = [\"level\", \"hello\", \"madam\", \"python\", \"radar\"]\n    return words\n\nassert f(g()) == [\"level\", \"madam\", \"radar\"]\n",
        "idx_generation": 12,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be obtained by XORing 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n",
        "idx_generation": 315,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if a number n is a perfect square of another number m.\n    \"\"\"\n    return n == m * m\n\ndef g(n=81, m=9):\n    return n, m\n\nassert f(*g()) == True\n",
        "idx_generation": 37,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    You are given an array prices where prices[i] is the price of a given stock on the ith day.\n    You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n    Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n    Example:\n    Input: prices = [7, 1, 5, 3, 6, 4]\n    Output: 5\n\n    Explanation: The maximum profit is 5 (buying at day 2 (price = 1) and selling at day 5 (price = 6)).\n\n    Hint: Use dynamic programming to keep track of the minimum price and maximum profit.\n    \"\"\"\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return max_profit\n\ndef g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices\n\nassert f(g()) == 5\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine if the graph is bipartite.\n\n    A graph is bipartite if it can be divided into two sets of vertices, such that no two vertices in the same set are adjacent.\n\n    Example:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    output: True\n    Explanation: The given graph is bipartite as it can be divided into two sets {0, 2} and {1}.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    n = len(graph)\n    colors = [-1] * n\n\n    def is_bipartite(node, color):\n        colors[node] = color\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == '1':\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == -1 and not is_bipartite(neighbor, 1 - color):\n                    return False\n\n        return True\n\n    for node in range(n):\n        if colors[node] == -1 and not is_bipartite(node, 0):\n            return False\n\n    return True\n\n\ndef g() -> List[List[str]]:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    return graph\n\n\nassert f(g()) == True\n\n",
        "idx_generation": 345,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers from the list that add up to the target value.\n    \"\"\"\n    def find_combinations(nums: List[int], target: int, index: int, current_combination: List[int], combinations: List[List[int]]) -> None:\n        if target == 0:\n            combinations.append(current_combination)\n            return\n        if target < 0 or index >= len(nums):\n            return\n        find_combinations(nums, target-nums[index], index, current_combination + [nums[index]], combinations)\n        find_combinations(nums, target, index+1, current_combination, combinations)\n    \n    combinations = []\n    find_combinations(nums, target, 0, [], combinations)\n    return combinations\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, return a list of all pairs of numbers from the list that add up to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 6\n    Output: [(1, 5), (2, 4)]\n\n    Hint: Use two pointers to iterate through the list and find the pairs that add up to the target.\n    \"\"\"\n    pairs = []\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            pairs.append((arr[left], arr[right]))\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return pairs\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 6) == [(1, 5), (2, 4)]\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    Given a list of stock prices, find the maximum profit that can be obtained by buying and selling at most two transactions.\n\n    Example:\n    Input: [3, 3, 5, 0, 0, 3, 1, 4]\n    Output: 6\n\n    Explanation: The maximum profit can be achieved by buying on day 4 (price = 0) and selling on day 6 (price = 3), then buying on day 7 (price = 1) and selling on day 8 (price = 4).\n    \"\"\"\n    n = len(prices)\n    if n < 2:\n        return 0\n\n    max_profit = 0\n    min_price = prices[0]\n    max_price = prices[-1]\n    left_profit = [0] * n\n    right_profit = [0] * n\n\n    for i in range(1, n):\n        min_price = min(min_price, prices[i])\n        left_profit[i] = max(left_profit[i-1], prices[i] - min_price)\n\n    for i in range(n-2, -1, -1):\n        max_price = max(max_price, prices[i])\n        right_profit[i] = max(right_profit[i+1], max_price - prices[i])\n\n    for i in range(n):\n        max_profit = max(max_profit, left_profit[i] + right_profit[i])\n\n    return max_profit\n\ndef g() -> List[int]:\n    prices = [3, 3, 5, 0, 0, 3, 1, 4]\n    return prices\n\nassert f(g()) == 6\n\n",
        "idx_generation": 209,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subsequence that forms an arithmetic progression.\n\n    Example:\n    nums = [1, 2, 3, 5, 8, 13]\n\n    The subsequence [1, 3, 8] forms an arithmetic progression, with a common difference of 2.\n\n    Therefore, the function should return True.\n\n    Hint: Use a set to store the differences between consecutive elements.\n    \"\"\"\n    diffs = set()\n\n    for i in range(len(nums) - 1):\n        diff = nums[i+1] - nums[i]\n        if diff in diffs:\n            return True\n        diffs.add(diff)\n\n    return False\n\ndef g(nums=[1, 2, 3, 5, 8, 13]):\n    return nums\n\nassert f(g()) == True\n\n\n",
        "idx_generation": 496,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the minimum number of elements from the list that sum up to the target.\n    Return the minimum number of elements, or -1 if it is not possible to sum up to the target using any combination of elements from the list.\n    \"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    \n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] = min(dp[i], dp[i - num] + 1)\n    \n    return dp[target] if dp[target] != float('inf') else -1\n\ndef g():\n    nums = [2, 4, 6]\n    target = 10\n    return nums, target\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 136,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing all non-alphanumeric characters and ignoring case.\n\n    Sample Input:\n    s = \"A man, a plan, a canal, Panama!\"\n\n    Sample Output:\n    True\n    Explanation: After removing non-alphanumeric characters and ignoring case, the string becomes \"amanaplanacanalpanama\", which is a palindrome.\n\n    Sample Input:\n    s = \"Hello, World!\"\n\n    Sample Output:\n    False\n    Explanation: After removing non-alphanumeric characters and ignoring case, the string becomes \"Helloworld\", which is not a palindrome.\n    \"\"\"\n    alphanumeric = ''.join(c.lower() for c in s if c.isalnum())\n    return alphanumeric == alphanumeric[::-1]\ndef g(s = \"A man, a plan, a canal, Panama!\"):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 15,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the number of distinct values that can be obtained by performing\n    bitwise XOR operation on any two numbers in the list.\n\n    Example:\n    nums = [3, 4, 5, 4, 3, 6]\n\n    The distinct values that can be obtained by performing bitwise XOR operation are [0, 1, 3, 4, 5, 6, 7].\n\n    Therefore, the function should return 7.\n    \"\"\"\n\n    distinct_values = set()\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            distinct_values.add(xor)\n\n    return len(distinct_values)\n\ndef g() -> List[int]:\n    nums = [3, 4, 5, 4, 3, 6]\n    return nums\n\nassert f(g()) == 7\n",
        "idx_generation": 315,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a power of 4.\"\"\"\n    if n == 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1\n\ndef g() -> int:\n    \"\"\"Generate a positive integer n that is a power of 4.\"\"\"\n    return 64\n\nassert f(g()) == True\n",
        "idx_generation": 46,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[str]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine the number of connected components in the graph.\n\n    A connected component is a subgraph in which every pair of vertices is connected by a path.\n\n    Example:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    output: 1\n    Explanation: The given graph has only one connected component.\n\n    Note: The input graph will be a square matrix.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n\n        for neighbor in range(n):\n            if graph[node][neighbor] == '1' and not visited[neighbor]:\n                dfs(neighbor)\n\n    for node in range(n):\n        if not visited[node]:\n            count += 1\n            dfs(node)\n\n    return count\n\n\ndef g() -> List[List[str]]:\n    graph = [\n        ['0', '1', '0'],\n        ['1', '0', '1'],\n        ['0', '1', '0']\n    ]\n    return graph\n\n\nassert f(g()) == 1\n\n",
        "idx_generation": 345,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The function should return [\n        [1, 2, 3],\n        [1, 3, 2],\n        [2, 1, 3],\n        [2, 3, 1],\n        [3, 1, 2],\n        [3, 2, 1]\n    ]\n\n    Note:\n    - The input list may have duplicates.\n    - The order of the permutations does not matter.\n    \"\"\"\n    def backtrack(nums, path, result):\n        if not nums:\n            result.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], result)\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == [\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n]\n\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if the target exists in the array.\n    Use binary search to find the target in the array.\n    Return True if the target exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    return arr\n\nassert f(g(), 9) == True\n\n",
        "idx_generation": 468,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target value exists in the list.\n\n    Return True if the target value exists in the list, False otherwise.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> bool:\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, right)\n    \n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 4, 6, 8, 10, 12]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 211,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group the anagrams together and return the grouped anagrams.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n    The anagrams in the list are:\n    [\"eat\", \"tea\", \"ate\"]\n    [\"tan\", \"nat\"]\n    [\"bat\"]\n\n    Therefore, the function should return:\n    [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n    \"\"\"\n    anagrams = {}\n    \n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        \n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n    \n    return list(anagrams.values())\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n",
        "idx_generation": 496,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 2, 7, 10]\n\nassert f(g()) == 13\n",
        "idx_generation": 136,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(word: str) -> str:\n    \"\"\"\n    Reverse the order of letters in each word of a given string.\n    Return the modified string.\n    \"\"\"\n    words = word.split()\n    \n    for i in range(len(words)):\n        words[i] = words[i][::-1]\n    \n    return \" \".join(words)\n\n\ndef g():\n    word = \"Hello World\"\n    return word\n\nassert f(g()) == \"olleH dlroW\"\n\n",
        "idx_generation": 16,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, check if there exists a pair of numbers (num1, num2) such that num1 ^ num2 = num1 + num2.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == nums[i] + nums[j]:\n                return True\n    \n    return False\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine whether an integer n is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    return 97\n\nassert f(g()) == True\n",
        "idx_generation": 47,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down, right, or diagonally.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output: 29\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            dp[i][j] = matrix[i-1][j-1] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[rows][cols]\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == 29\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed acyclic graph (DAG), find the longest path in the graph.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The longest path in the graph is [0, 1, 2, 3], which has a length of 3.\n    \"\"\"\n    n = len(graph)\n    dp = [0] * n\n\n    for i in range(n):\n        for j in range(i):\n            if graph[j][i] == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[List[int]]:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == 3\n",
        "idx_generation": 347,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible subsets of the list.\n    \"\"\"\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n    return subsets\n\ndef g(nums=[1, 2, 3]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 6\n\n    The XOR of any two numbers in the list is calculated by performing a bitwise XOR operation.\n    For example, the XOR of 3 and 5 is 6 (3 ^ 5 = 6).\n\n    In the given example, there exists a pair of numbers (2, 4) whose XOR is equal to the target value 6.\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g(), 6) == True\n\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the index of the target if it is found in the array,\n    or the index where it would be inserted in order if it is not found.\n\n    Example:\n    Input: [1, 3, 5, 6], 5\n    Output: 2\n\n    Input: [1, 3, 5, 6], 2\n    Output: 1\n\n    Input: [1, 3, 5, 6], 7\n    Output: 4\n\n    Input: [1, 3, 5, 6], 0\n    Output: 0\n\n    Hint: Use binary search to find the target or the index where it would be inserted.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\ndef g():\n    return [1, 3, 5, 6], 5\n\nassert f(*g()) == 2\n",
        "idx_generation": 215,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    The function should return 30, as the sum of all the even numbers in the list is 30 (2 + 4 + 6 + 8 + 10).\n\n    Note:\n    - The list may contain negative numbers.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n",
        "idx_generation": 498,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Example:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6 (the maximum sum of a contiguous subarray is [4, -1, 2, 1])\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    \n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return arr\n\nassert f(g()) == 6\n\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target='bye') -> bool:\n    \"\"\"\n    Given a string, determine if it contains the target substring.\n    Return True if the target substring is found, False otherwise.\n\n    Sample input:\n    'goodbye'\n\n    Sample output:\n    True\n\n    Explanation:\n    The target substring 'bye' is found in the string 'goodbye'.\n    \"\"\"\n    return target in s\n\ndef g():\n    return 'goodbye'\n\nassert f(g()) == True\n",
        "idx_generation": 17,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer k, determine if there exists a pair of integers in the list\n    such that their XOR is equal to k.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1, 6], k = 3\n    Output: True\n    Explanation: The pair (4, 7) has XOR equal to 3.\n\n    Note:\n    - The length of the list will not exceed 1000.\n    - The range of integers in the list and the value of k will be in the range [-10^9, 10^9].\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k ^ num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums: List[int], k: int) -> Tuple[int, int]:\n    \"\"\"\n    Find a pair of integers in the list nums such that their XOR is equal to k.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1, 6], k = 3\n    Output: (4, 7)\n\n    Note:\n    - The length of the list will not exceed 1000.\n    - The range of integers in the list and the value of k will be in the range [-10^9, 10^9].\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if k ^ num in seen:\n            return (num, k ^ num)\n        seen.add(num)\n    return (-1, -1)\n\nassert f(g([4, 7, 2, 9, 5, 1, 6], 3), 3)\n",
        "idx_generation": 320,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n=3) -> bool:\n    \"\"\"Check if the sum of the first n natural numbers is equal to s.\"\"\"\n    return sum(range(1, n+1)) == int(s)\ndef g(n = 3):\n    return str(sum(range(1, n+1)))\nassert f(g()) == True\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Given two integers m and n, return the number of unique paths to reach the bottom-right corner of a m x n grid\n    starting from the top-left corner. You can only move down or right.\n\n    Example:\n    f(3, 2) => 3\n    \"\"\"\n\n    if m == 1 or n == 1:\n        return 1\n\n    return f(m-1, n) + f(m, n-1)\n\ndef g(m=3, n=2):\n    return m, n\n\nassert f(*g()) == 3\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], n=5) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine if it is a tree.\n    A tree is a connected acyclic graph, i.e., there are no cycles and every pair of vertices is connected.\n\n    Sample input:\n    [\n      [0, 1, 0, 0, 1],\n      [1, 0, 1, 1, 0],\n      [0, 1, 0, 0, 0],\n      [0, 1, 0, 0, 0],\n      [1, 0, 0, 0, 0]\n    ]\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    # Check if the graph has n-1 edges and is connected\n    if sum(sum(row) for row in graph) != 2 * (n - 1):\n        return False\n\n    # Check if the graph contains any cycles\n    visited = [False] * n\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in range(n):\n            if graph[node][neighbor]:\n                if visited[neighbor] and neighbor != parent:\n                    return True\n                if not visited[neighbor] and dfs(neighbor, node):\n                    return True\n        return False\n\n    if dfs(0, -1):\n        return False\n\n    return True\n\ndef g(n=5):\n    # Generate a tree with n nodes\n    graph = [[0] * n for _ in range(n)]\n    \n    # Connect the nodes to form a tree\n    for i in range(1, n):\n        graph[i][i-1] = 1\n        graph[i-1][i] = 1\n    \n    return graph\n\nassert f(g())\n",
        "idx_generation": 357,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers nums and a target integer, return all unique combinations of nums where the\n    chosen numbers sum to target.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [[2, 2, 3], [7]]\n\n    Sample Input:\n    nums = [2, 3, 5]\n    target = 8\n\n    Sample Output:\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n    \"\"\"\n    def backtrack(curr: List[int], remain: int, start: int):\n        if remain < 0:\n            return\n        if remain == 0:\n            output.append(curr[:])\n            return\n        for i in range(start, len(nums)):\n            curr.append(nums[i])\n            backtrack(curr, remain - nums[i], i)\n            curr.pop()\n\n    output = []\n    backtrack([], target, 0)\n    return output\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 416,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7] since nums[0] + nums[1] == 9.\n\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        else:\n            num_dict[num] = i\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple of a list of integers and a target integer.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence.\n\n    Sample Input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        low, high = 0, len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low\n    \n    dp = []\n    for num in nums:\n        index = binary_search(dp, num)\n        if index == len(dp):\n            dp.append(num)\n        else:\n            dp[index] = num\n    \n    return len(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the sum of each row in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    The sum of each row is [6, 15, 24].\n    Return [6, 15, 24].\n    \"\"\"\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [6, 15, 24]\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the minimum number of jumps required to reach the target.\n    Each element in the list represents the maximum number of steps that can be jumped from that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n    target = 5\n    Output: 2\n    Explanation: The minimum number of jumps required to reach the target is 2. Jump from index 0 to index 2, then jump from index 2 to index 4.\n\n    Note:\n    - It is assumed that you can always reach the target.\n    \"\"\"\n\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n\n    return jumps[-1]\n\ndef g(nums=[2, 3, 1, 1, 4], target=5):\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 141,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import itertools\nfrom typing import*\ndef f(s: str, pattern=\"ABC\") -> bool:\n    \"\"\"\n    Check if the given string s contains the given pattern. The pattern can be formed by rearranging the characters of s.\n    \"\"\"\n    from itertools import permutations\n    \n    perms = [''.join(p) for p in permutations(s)]\n    \n    for perm in perms:\n        if pattern in perm:\n            return True\n    \n    return False\n\ndef g(pattern=\"ABC\"):\n    return \"BAC\"\n\nassert f(g()) == True\n",
        "idx_generation": 18,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all numbers that can be obtained by bitwise OR-ing any subset of nums.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: 7\n\n    Explanation:\n    The possible subsets and their bitwise OR sums are:\n    - [1] -> 1\n    - [2] -> 2\n    - [3] -> 3\n    - [1, 2] -> 3\n    - [1, 3] -> 3\n    - [2, 3] -> 3\n    - [1, 2, 3] -> 3\n    The sum of all these numbers is 1 + 2 + 3 + 3 + 3 + 3 + 3 = 18.\n    \"\"\"\n\n    total_sum = 0\n    n = len(nums)\n\n    for i in range(1, (1 << n)):\n        subset_sum = 0\n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                subset_sum |= nums[j]\n        total_sum += subset_sum\n\n    return total_sum\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 18\n\n",
        "idx_generation": 328,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if n is a perfect square.\n\n    Sample input:\n    n = 16\n\n    Sample output:\n    True\n    \"\"\"\n    if n < 0:\n        return False\n    \n    sqrt = math.isqrt(n)\n    \n    return sqrt * sqrt == n\n\ndef g(n = 16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 64,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Args:\n    n (int): The position of the Fibonacci number.\n\n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n",
        "idx_generation": 489,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as a dictionary of nodes and their corresponding list of neighbors,\n    determine if there exists a path from the start node to the end node.\n    \"\"\"\n\n    def dfs(node: int, visited: Set[int]) -> bool:\n        if node == end:\n            return True\n        \n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        \n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[Dict[int, List[int]], int, int]:\n    \"\"\"\n    Generate a graph represented as a dictionary, and randomly choose a start and end node.\n    \"\"\"\n    graph = {1: [2, 3], 2: [3, 4], 3: [4, 5], 4: [5]}\n    start = 1\n    end = 5\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 366,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate the first n rows of Pascal's triangle.\n\n    Example:\n    Input: n = 5\n    Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    if n == 0:\n        return []\n    \n    triangle = [[1]]\n    \n    for i in range(1, n):\n        prev_row = triangle[i-1]\n        curr_row = [1]\n        \n        for j in range(1, i):\n            curr_row.append(prev_row[j-1] + prev_row[j])\n        \n        curr_row.append(1)\n        triangle.append(curr_row)\n    \n    return triangle\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that \n    sum up to the target value. Return the indices of the two numbers.\n    \n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Sample Output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 470,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the number of inversions in the array.\n    An inversion occurs when two elements in the array are out of order.\n\n    Return the count of inversions.\n\n    Example:\n    arr = [2, 4, 1, 3, 5]\n    The inversions are: (2, 1), (4, 1), (4, 3)\n    Return 3\n    \"\"\"\n\n    def merge_sort(arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        count = merge_sort(left) + merge_sort(right)\n\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                count += len(left) - i\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n        return count\n\n    return merge_sort(arr)\n\ndef g():\n    arr = [2, 4, 1, 3, 5]\n    return (arr,)\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 233,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid crossword puzzle solution.\n    \"\"\"\n    # Check rows\n    for row in grid:\n        # Check for consecutive blocks of filled cells\n        if 0 not in row and len(set(row)) != len(row):\n            return False\n    \n    # Check columns\n    for j in range(len(grid[0])):\n        column = [grid[i][j] for i in range(len(grid))]\n        # Check for consecutive blocks of filled cells\n        if 0 not in column and len(set(column)) != len(column):\n            return False\n    \n    return True\n\ndef g():\n    grid = [\n        [0, 0, 0, 1, 0],\n        [1, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 15,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Return the maximum product.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The maximum product is 6 (2 * 3), so the function should return 6.\n    \"\"\"\n    max_product = float('-inf')\n    current_max = 1\n    current_min = 1\n    \n    for num in nums:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        \n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        \n        max_product = max(max_product, current_max)\n    \n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, -2, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome.\n    \"\"\"\n    return string == string[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 19,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise XOR value of any two elements.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum bitwise XOR value is obtained by XORing 5 (binary 101) and 25 (binary 11001), which gives 28.\n\n    Note:\n    - The length of the input array is between 1 and 2 * 10^4.\n    - Each element in the input array is between 0 and 2^31 - 1.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        max_possible_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if max_possible_xor ^ prefix in prefix_set:\n                max_xor = max_possible_xor\n                break\n\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 329,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number can be expressed as the sum of two prime numbers\"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    for i in range(2, n // 2 + 1):\n        if is_prime(i) and is_prime(n - i):\n            return True\n    return False\n\ndef g(n=20):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 90,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n\n",
        "idx_generation": 497,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of distinct binary trees that can be formed with n nodes.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n+1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n+1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n    \n    return dp[n]\n\ndef g() -> int:\n    n = 4\n    return n\n\nassert f(g()) == 14\n",
        "idx_generation": 369,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return a list of all combinations.\n\n    Example:\n    n = 4\n    k = 2\n\n    The possible combinations of 2 numbers from the range [1, 4] are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    The function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n        for i in range(start, n + 1):\n            curr_comb.append(i)\n            backtrack(i + 1, curr_comb)\n            curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g() -> Tuple[int, int]:\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 425,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9], target = 5\n\n    The target value 5 is present at index 2 in the list.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Check if there are two elements in the given array that sum up to the target value, using the sliding window technique.\n    \"\"\"\n    n = len(arr)\n    arr.sort()\n    left = 0\n    right = n - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == k:\n            return True\n        elif curr_sum < k:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    arr = [1, 4, 2, 7, 5, 3, 9]\n    k = 10\n    return arr, k\n\nassert f(*g()) == True\n",
        "idx_generation": 242,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all the even numbers from 1 to n (inclusive).\n    \"\"\"\n    stack = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            stack.append(i)\n    return sum(stack)\n\ndef g():\n    return 10\n\nassert f(g()) == 30\n",
        "idx_generation": 17,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subset whose sum is equal to the target sum.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    There exists a subset [3, 7] whose sum is equal to the target sum 10.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def dp(i, target):\n        if target == 0:\n            return True\n        if i == 0:\n            return False\n        if nums[i - 1] <= target:\n            return dp(i - 1, target - nums[i - 1]) or dp(i - 1, target)\n        return dp(i - 1, target)\n    \n    return dp(len(nums), sum(nums) // 2)\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 7, 9]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(text: str, pattern: str, replacement: str) -> bool:\n    \"\"\"Replace all occurrences of a pattern with a replacement string\"\"\"\n    modified_text = text.replace(pattern, replacement)\n    return modified_text != text\ndef g(text='The quick brown fox jumps over the lazy dog', pattern='fox', replacement='cat'):\n    return text, pattern, replacement\nassert f(*g())\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 7 (3 ^ 4 = 7)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root: TrieNode, num: int):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root: TrieNode, num: int) -> int:\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit]:\n                xor_val |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor_val\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 331,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of digits in the factorial of n.\n\n    Example:\n    Input: 5\n    Output: 3 (The factorial of 5 is 120, which has 3 digits)\n\n    Hint: Use the mathematical property that log10(x) gives the number of digits in x.\n    \"\"\"\n    import math\n    if n < 0:\n        return 0\n    if n <= 1:\n        return 1\n    digits = math.floor((n * math.log10(n / math.e)) + math.log10(2 * math.pi * n) / 2) + 1\n    return digits\n\ndef g():\n    return 5\n\nassert f(g()) == 3\n",
        "idx_generation": 92,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"Determine if it is possible to color n nodes of a graph with m colors such that no two adjacent nodes have the same color, given k pairs of nodes that must have different colors.\"\"\"\n    # function to check if coloring is valid\n    def is_valid(graph, color, node, c):\n        for neighbor in graph[node]:\n            if color[neighbor] == c:\n                return False\n        return True\n\n    # recursive function to color the graph\n    def color_graph(graph, color, node, m, k):\n        # base case: all nodes colored\n        if node == n:\n            return True\n\n        # try all possible colors for current node\n        for c in range(1, m+1):\n            # check if color is valid\n            if is_valid(graph, color, node, c):\n                # assign color to node\n                color[node] = c\n\n                # check if k pairs of nodes have different colors\n                if node < k:\n                    u, v = k_pairs[node]\n                    if color[u] == color[v]:\n                        color[node] = 0\n                        continue\n\n                # recursively color next node\n                if color_graph(graph, color, node+1, m, k):\n                    return True\n\n                # backtrack if coloring is not valid\n                color[node] = 0\n\n        return False\n\n    # create graph\n    graph = [[] for _ in range(n)]\n    k_pairs = []\n\n    # generate k pairs of nodes that must have different colors\n    for i in range(k):\n        u, v = i, i + k\n        graph[u].append(v)\n        graph[v].append(u)\n        k_pairs.append((u, v))\n\n    # initialize color array\n    color = [0] * n\n\n    # color the graph starting from the first node\n    return color_graph(graph, color, 0, m, k)\n\ndef g(n=4, m=3, k=2):\n    return n, m, k\n\nassert f(*g())\n",
        "idx_generation": 370,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the number of permutations of n objects taken r at a time.\n    Return the result.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    permutations = factorial(n) // factorial(n - r)\n    return permutations\n\ndef g():\n    n = 5\n    r = 3\n    return n, r\n\nassert f(*g()) == 60\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The even numbers in the list are 2, 4, and 6.\n    Therefore, the function should return 12.\n    \"\"\"\n\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n\n",
        "idx_generation": 471,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Note:\n    - The subarray must contain at least one element.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 245,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, which is the sum of a contiguous subarray with the largest sum.\n    Return True if the maximum subarray sum is positive, and False otherwise.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum > 0\n\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers such that the maximum subarray sum is positive.\n    \"\"\"\n    return [1, 2, -3, 4, -5, 6, -7]\n\n# Test case\nnums = [1, 2, -3, 4, -5, 6, -7]\nassert f(g(nums))\n",
        "idx_generation": 20,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1.\n\n    Return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    The Fibonacci sequence is: 0, 1, 1, 2, 3, 5\n\n    Therefore, the function should return 8.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        \n        return fib[n]\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 142,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"Check if s1 is a substring of s2 after removing all spaces.\"\"\"\n    return s1.replace(\" \", \"\") in s2.replace(\" \", \"\")\ndef g():\n    return \"apple\", \"the quick brown fox jumps over the lazy apple\"\nassert f(*g())\n",
        "idx_generation": 23,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number that appears only once in the list.\n    All other numbers in the list appear exactly twice.\n\n    Example:\n    Input: [2, 4, 6, 4, 2]\n    Output: 6 (The number 6 appears only once, while all other numbers appear twice)\n\n    Hint: Use the concept of bitwise XOR to find the number that appears only once.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    nums = [2, 4, 6, 4, 2]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a perfect square and has an odd number of divisors.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Explanation:\n    16 is a perfect square (4^2 = 16) and has an odd number of divisors (1, 2, 4, 8, 16).\n    \"\"\"\n    import math\n    if n < 0:\n        return False\n    root = int(math.sqrt(n))\n    return root * root == n and root % 2 == 1\n\ndef g():\n    return 9\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, determine whether it is bipartite or not.\n\n    Example:\n    Input: graph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    Output: True\n\n    Explanation:\n    The graph can be divided into two sets {0, 2} and {1} such that there are no edges between nodes in the same set.\n\n    Input: graph = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\n    Output: False\n\n    Explanation:\n    The graph cannot be divided into two sets without having edges between nodes in the same set.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                    return False\n        \n        return True\n\n    colors = [0] * len(graph)\n\n    for node in range(len(graph)):\n        if colors[node] == 0 and not dfs(node, 1):\n            return False\n    \n    return True\n\ndef g(graph: List[List[int]]):\n    return graph\n\ngraph = [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\nassert f(g(graph)) == True\n\n",
        "idx_generation": 377,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Input: n = 3, k = 3\n    Output: [[1, 2, 3]]\n    \"\"\"\n\n    # Initialize a list to store the combinations\n    combinations = []\n\n    def backtrack(start, current):\n        if len(current) == k:\n            combinations.append(current[:])\n        else:\n            for i in range(start, n + 1):\n                current.append(i)\n                backtrack(i + 1, current)\n                current.pop()\n\n    # Start backtracking from 1 and an empty current list\n    backtrack(1, [])\n\n    # Return the list of combinations\n    return combinations\n\ndef g() -> Tuple[int, int]:\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n",
        "idx_generation": 429,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value k, find the index of the first occurrence of k in the array.\n    If k is not found in the array, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == k:\n            if mid == 0 or arr[mid - 1] < k:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return ([1, 2, 2, 3, 4, 5, 5, 5, 7, 8, 9], 5)\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 473,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subset of the list that adds up to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    Explanation: The subset [2, 5] adds up to the target value of 7.\n\n    \"\"\"\n    def backtrack(nums, target, start, path):\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if backtrack(nums, target-nums[i], i+1, path+[nums[i]]):\n                return True\n        return False\n\n    nums.sort()\n    return backtrack(nums, target, 0, [])\n\ndef g(nums = [1, 2, 3, 4, 5], target = 7):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 247,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Rotate Image\n\n    Given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\n    Example:\n    matrix = [[1,2,3],[4,5,6],[7,8,9]]\n    output: [[7,4,1],[8,5,2],[9,6,3]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g():\n    matrix = [[1,2,3],[4,5,6],[7,8,9]]\n    return (matrix,)\n\nassert f(*g()) == [[7,4,1],[8,5,2],[9,6,3]]\n\n",
        "idx_generation": 27,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right. Each cell has a cost associated with it.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of positive integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 142,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return \" \".join(reversed_words)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with multiple words.\n    \"\"\"\n    return \"Hello world! I am learning Python.\"\n\n# Test case\ns = \"Hello world! I am learning Python.\"\nreversed_s = \"Python. learning am I world! Hello\"\nassert f(g()) == reversed_s\n\n",
        "idx_generation": 24,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, find the maximum possible XOR value between any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by taking the XOR of 5 and 25, which gives 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a Fibonacci number.\n\n    Sample Input:\n    n = 13\n\n    Sample Output:\n    True\n\n    Explanation:\n    13 is a Fibonacci number.\n    \"\"\"\n    def is_perfect_square(x: int) -> bool:\n        return int(x ** 0.5) ** 2 == x\n\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)\n\ndef g():\n    return 13\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, edges: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return the number of connected components in the graph.\n\n    Example:\n    n = 5\n    m = 3\n    edges = [[0, 1], [1, 2], [3, 4]]\n    Output: 2\n\n    Explanation:\n    The graph can be visualized as follows:\n    0 -- 1 -- 2\n    3 -- 4\n\n    The connected components are [0, 1, 2] and [3, 4].\n    \"\"\"\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    components = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            components += 1\n\n    return components\n\ndef g() -> List:\n    return [5, 3, [[0, 1], [1, 2], [3, 4]]]\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 381,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        count += f(i) * f(n-i-1)\n    \n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate the number of pairs of parentheses.\n    \"\"\"\n    return n\n\nassert f(g(3)) == 5\n",
        "idx_generation": 431,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the index of the target if it exists in the array.\n    If the target is not found, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers in the list that add up to the target value using binary search.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14\n    Output: [4, 10]\n\n    Explanation: The numbers 4 and 10 add up to 14.\n    \"\"\"\n\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        left = i + 1\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == complement:\n                return [nums[i], nums[mid]]\n            elif nums[mid] < complement:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return []\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n    return nums, target\n\nassert f(*g()) == [4, 10]\n",
        "idx_generation": 248,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, find if there exists a pair of elements such that their sum is equal to the given target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr=[1, 2, 3, 4, 5], target=8):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, s: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 's', determine if there exists a subset of size n whose sum is divisible by n.\n\n    Return True if such a subset exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int, count: int) -> bool:\n        if count == n and curr_sum % n == 0:\n            return True\n        if count > n or start >= len(s):\n            return False\n        for i in range(start, len(s)):\n            if backtrack(i + 1, curr_sum + s[i], count + 1):\n                return True\n        return False\n\n    return backtrack(0, 0, 0)\n\n\ndef g(n=3, s=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]):\n    \"\"\"\n    Generate a list of integers 's' such that there exists a subset of size n whose sum is divisible by n.\n    \"\"\"\n    return s\n\n\nassert f(3, g()) == True\n\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Find whether there are k non-overlapping occurrences of the string 'abc' in the given string s\n    \"\"\"\n    count = 0\n    i = 0\n    while i < len(s) - 2:\n        if s[i:i+3] == 'abc':\n            count += 1\n            i += 3\n        else:\n            i += 1\n        if count == k:\n            return True\n    return False\n\ndef g(s = \"abcabcabcabcabc\", k = 3):\n    return s\n\nassert f(g(), 3)\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums, determine if there exists a subsequence such that the bitwise XOR of the subsequence is equal to 0.\n    Return True if such subsequence exists, otherwise return False.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: True\n\n    Explanation:\n    The subsequence [1, 5] has a bitwise XOR of 0 (1 ^ 5 = 4 ^ 4 = 0).\n    \"\"\"\n\n    n = len(nums)\n\n    for i in range(1, 2**n):\n        subsequence = []\n        for j in range(n):\n            if i & (1 << j):\n                subsequence.append(nums[j])\n        xor_value = subsequence[0]\n        for k in range(1, len(subsequence)):\n            xor_value ^= subsequence[k]\n        if xor_value == 0:\n            return True\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == True\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(arr: List[int], n=6) -> bool:\n    \"\"\"Check if the sum of the nth powers of the elements in the array is a perfect square.\"\"\"\n    return sum([math.pow(i, n) for i in arr]) % 1 == 0\ndef g(n = 6):\n    return [i for i in range(1, n+1)]\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(g: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed acyclic graph represented as an adjacency matrix, determine if there exists a topological ordering of the nodes.\n    \"\"\"\n    n = len(g)\n    incomings = [0] * n\n    for row in g:\n        for col in range(n):\n            if row[col] == 1:\n                incomings[col] += 1\n    queue = []\n    for i in range(n):\n        if incomings[i] == 0:\n            queue.append(i)\n    order = []\n    while queue:\n        node = queue.pop(0)\n        order.append(node)\n        for col in range(n):\n            if g[node][col] == 1:\n                incomings[col] -= 1\n                if incomings[col] == 0:\n                    queue.append(col)\n    return len(order) == n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 0, 1, 1, 0],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 1],\n            [0, 0, 0, 0, 0]]\nassert f(g())\n",
        "idx_generation": 385,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of k-combinations that can be formed from a set of n elements.\n    A k-combination is a selection of k distinct elements from a set of n elements, where the order does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    The set of elements is {1, 2, 3, 4, 5}.\n    The 3-combinations that can be formed are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    Therefore, the function should return 10.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3\n\nassert f(*g()) == 10\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 7, 1, 3]\n\n    The sorted list should be [1, 2, 3, 5, 7].\n\n    Therefore, the function should return [1, 2, 3, 5, 7].\n    \"\"\"\n    nums.sort()\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 7, 1, 3]\n\nassert f(g()) == [1, 2, 3, 5, 7]\n",
        "idx_generation": 474,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr\n\nassert f(g()) == 4\n\n",
        "idx_generation": 248,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, perform the XOR operation on them and return the result.\n    \"\"\"\n    return num1 ^ num2\n\ndef g():\n    \"\"\"\n    Generate two integers for the XOR operation.\n    \"\"\"\n    num1 = 10\n    num2 = 7\n    \n    return num1, num2\n\nassert f(*g()) == 13\n",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 5, 7, 18], so the function should return 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\n\nassert f(g()) == 4\n\n",
        "idx_generation": 144,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, substr: str) -> bool:\n    \"\"\"\n    Given a string and a substring, return True if the substring is present in the string, otherwise return False.\n    \"\"\"\n    return substr in s\n\ndef g(s: str, substr: str):\n    return s\n\ns = \"Hello, World!\"\nsubstr = \"World\"\nassert f(g(s, substr), substr)\n",
        "idx_generation": 25,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, arr, find the maximum XOR value of any two elements in arr.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    The maximum XOR value is 28 (25 ^ 3).\n\n    Return the maximum XOR value.\n\n    Note:\n    - The length of the input list arr will be at least 2.\n    - The maximum value of the elements in arr will not exceed 10^9.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    def insert(num, root):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(num, root):\n        node = root\n        maxXOR = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                maxXOR |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return maxXOR\n\n    root = TrieNode()\n    for num in arr:\n        insert(num, root)\n\n    maxXOR = 0\n    for num in arr:\n        maxXOR = max(maxXOR, findMaxXOR(num, root))\n\n    return maxXOR\n\ndef g(arr: List[int]):\n    \"\"\"\n    Find the maximum XOR value of any two elements in arr.\n    \"\"\"\n    return arr\n\narr = [3, 10, 5, 25, 2, 8]\nassert f(g(arr)) == 28\n\n",
        "idx_generation": 335,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing only the prime numbers.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [num for num in nums if is_prime(num)]\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return nums\n\nassert f(g()) == [2, 3, 5, 7]\n",
        "idx_generation": 112,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of a directed graph, find the number of paths from the source node to the destination node.\n    Return the number of paths.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    The number of paths from node 0 to node 3 is 2.\n    Therefore, the function should return 2.\n    \"\"\"\n    def dfs(node: int, destination: int) -> int:\n        if node == destination:\n            return 1\n        count = 0\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                count += dfs(neighbor, destination)\n        return count\n\n    source = 0\n    destination = len(graph) - 1\n\n    return dfs(source, destination)\n\ndef g() -> List[List[int]]:\n    return [\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 386,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers nums and a target integer target, return a list of all unique combinations of nums where the chosen numbers sum to target.\n\n    The combinations should be sorted in lexicographic order and each combination should not contain duplicate numbers.\n\n    Example:\n    Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n    \"\"\"\n    def backtrack(start, combination, current_sum):\n        # Base case: if the current sum is equal to the target, add the combination to the result\n        if current_sum == target:\n            result.append(combination[:])\n            return\n\n        # Try all possible numbers starting from 'start'\n        for i in range(start, len(nums)):\n            # If the current number exceeds the target, skip it\n            if current_sum + nums[i] > target:\n                break\n\n            combination.append(nums[i])\n            # Recursively backtrack with the next number and updated current sum\n            backtrack(i, combination, current_sum + nums[i])\n            combination.pop()\n\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 438,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the maximum and minimum elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum element is 5 and the minimum element is 1.\n\n    Therefore, the function should return [5, 1].\n    \"\"\"\n    max_num = max(nums)\n    min_num = min(nums)\n    return [max_num, min_num]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [5, 1]\n",
        "idx_generation": 475,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and an integer target, determine if there are three numbers in nums that add up to the target.\n    \"\"\"\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g(nums: List[int] = [1, 2, 3, 4, 5], target: int = 10):\n    return nums\n\nassert f(g(), 10)\n",
        "idx_generation": 250,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(x: int, a: int, b: int) -> bool:\n    \"\"\"Check if the sum of two numbers is equal to a given value\"\"\"\n    return x == a + b\n\ndef g(a: int, b: int):\n    \"\"\"Compute the sum of two numbers\"\"\"\n    return a + b\n\nassert f(g(a=3, b=5), a=3, b=5)\n",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray where the subarray consists of consecutive elements from the original array.\n    Return the maximum sum.\n\n    Example:\n    arr = [1, -2, 3, 4, -5, 6]\n    The maximum sum of a subarray is 8, which can be obtained from the subarray [3, 4, -5, 6].\n    Therefore, the function should return 8.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    arr = [1, -2, 3, 4, -5, 6]\n    return arr\n\nassert f(g()) == 8\n\n",
        "idx_generation": 146,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string and a list of words, return True if all the words in the list are present in the string,\n    otherwise return False.\n    \"\"\"\n    for word in words:\n        if word not in s:\n            return False\n    return True\n\ndef g(words: List[str]) -> str:\n    \"\"\"\n    Generate a string by concatenating all the words in the list.\n    \"\"\"\n    return \"\".join(words)\n\nwords = [\"hello\", \"world\"]\nassert f(g(words), words)\n",
        "idx_generation": 30,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of bits that are set to 1 in its binary representation.\n\n    Example:\n    n = 5\n\n    The binary representation of 5 is '101'.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    return 5\n\nassert f(g()) == 2\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', compute the product of all the elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the elements in the list is 1 * 2 * 3 * 4 = 24.\n\n    Therefore, the function should return 24.\n    \"\"\"\n\n    product = 1\n\n    for num in nums:\n        product *= num\n\n    return product\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n",
        "idx_generation": 116,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as a list of edges, determine if the graph contains a cycle.\n\n    Example:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n\n    The graph contains a cycle, as there is a path that starts and ends at the same vertex.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def is_cycle(graph, curr, visited, parent):\n        visited[curr] = True\n\n        for neighbor in graph[curr]:\n            if not visited[neighbor]:\n                if is_cycle(graph, neighbor, visited, curr):\n                    return True\n            elif parent != neighbor:\n                return True\n\n        return False\n\n    graph = [[] for _ in range(n)]\n\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if is_cycle(graph, i, visited, -1):\n                return True\n\n    return False\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    n = 4\n    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list\n    that sum up to the target.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n\n    Note: The solution set must not contain duplicate combinations.\n\n    Hint: This problem can be solved using backtracking and recursion.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], remaining: int) -> None:\n        if remaining == 0:\n            result.append(path[:])\n            return\n        if remaining < 0:\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i, path, remaining - nums[i])\n            path.pop()\n\n    result = []\n    nums.sort()\n    backtrack(0, [], target)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The target value 3 is located at index 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 3) == 2\n",
        "idx_generation": 475,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of any contiguous subarray in the list.\n    Return the maximum sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which has a sum of 6.\n    So the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 252,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(num1: int, num2: int) -> int:\n    \"\"\"\n    Given two integers, find their greatest common divisor (GCD).\n    The GCD of two integers is the largest positive integer that divides both numbers without leaving a remainder.\n    \"\"\"\n    while num2:\n        num1, num2 = num2, num1 % num2\n    return num1\n\ndef g():\n    num1 = 36\n    num2 = 48\n    return (num1, num2)\n\nassert f(*g()) == 12\n\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, count the number of unique paths from the top-left corner to the bottom-right corner.\n    The path can only move down or right.\n\n    Example:\n    Input: n = 3, m = 7\n           grid = [[0, 0, 0, 0, 0, 0, 0],\n                   [0, 0, 0, 0, 0, 0, 0],\n                   [0, 0, 0, 0, 0, 0, 0]]\n\n    Output: 28\n\n    Explanation:\n    There are 28 unique paths from the top-left corner to the bottom-right corner in the given grid.\n\n    \"\"\"\n\n    dp = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][m-1]\n\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    n = 3\n    m = 7\n    grid = [[0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0]]\n    return n, m, grid\n\n\nassert f(*g()) == 28\n\n",
        "idx_generation": 147,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, numbers=[5, 10, 15, 20, 25]) -> bool:\n    \"\"\"\n    Check if the given string s is a concatenation of the numbers in the list, with each number represented as its square.\n    \"\"\"\n    return s == ''.join(str(n ** 2) for n in numbers)\n\ndef g(numbers=[5, 10, 15, 20, 25]):\n    return ''.join(str(n ** 2) for n in numbers)\n\nassert f(g()) == True\n",
        "idx_generation": 31,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum value that can be obtained by XORing any two elements in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum XOR value between any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n",
        "idx_generation": 342,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    root = int(n**0.5)\n    return root * root == n\n\ndef g():\n    \"\"\"\n    Generate a perfect square number.\n    \"\"\"\n    i = 0\n    while True:\n        yield i * i\n        i += 1\n\nassert f(next(g())) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Find whether there exists a subsequence of the given list of numbers whose sum is equal to the target.\n    \"\"\"\n    def subset_sum(nums: List[int], target: int, index: int, current_sum: int) -> bool:\n        if current_sum == target:\n            return True\n        if current_sum > target or index >= len(nums):\n            return False\n        include = subset_sum(nums, target, index + 1, current_sum + nums[index])\n        exclude = subset_sum(nums, target, index + 1, current_sum)\n        return include or exclude\n    \n    return subset_sum(nums, target, 0, 0)\n\ndef g(nums = [1, 2, 3, 4, 5, 6], target = 9):\n    return nums\n\nassert f(g(), 9)\n",
        "idx_generation": 399,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    \"\"\"\n\n    def backtrack(nums: List[int], path: List[int], result: List[List[int]]) -> None:\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(nums, path, result)\n                path.pop()\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', return True if the list is sorted in non-decreasing order, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: True\n    \"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    return True\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n\n",
        "idx_generation": 476,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target value exists in the list.\n\n    Return True if the target value exists in the list, False otherwise.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> bool:\n        if left > right:\n            return False\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, right)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 252,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a subarray in nums such that the sum of all its elements is equal to 0.\n    \"\"\"\n    prefix_sum = 0\n    sum_set = {0}\n    for num in nums:\n        prefix_sum += num\n        sum_set.add(prefix_sum)\n    return any(prefix_sum - s in sum_set for s in sum_set)\n\ndef g():\n    return [1, -2, 3, 4, -5]\nassert f(g()) == True\n",
        "idx_generation": 56,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of ways to climb to the top of a staircase by taking steps of 1 or 2 at a time. Return the count.\n    \"\"\"\n    if n <= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 4\n\nassert f(g()) == 5\n\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome string. A palindrome string is one that remains the same when its\n    characters are reversed.\n    \"\"\"\n    # Function to check if a string is a palindrome string\n    def is_palindrome_string(s):\n        # Reverse the string and compare it with the original string\n        return s == s[::-1]\n\n    # Check if the string is a palindrome string\n    return is_palindrome_string(s)\n\ndef g():\n    # The string\n    s = 'level'\n    \n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 32,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there exists a subset of nums such that the sum of its elements is equal to the target.\n    \"\"\"\n    n = len(nums)\n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        if len(subset) > 0 and sum(subset) == target:\n            return True\n    return False\n\ndef g(target=7):\n    \"\"\"\n    Find a list of distinct positive integers that have a sum equal to the target.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g(), 7)\n",
        "idx_generation": 343,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n    Return True if n is a power of two, otherwise return False.\n\n    Sample Input:\n    n = 8\n\n    Sample Output:\n    True\n\n    Explanation: \n    8 is a power of two because 2^3 = 8.\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n=8):\n    return n > 0 and (n & (n - 1)) == 0\n\nassert f(g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right. However, there are some cells in the grid that are blocked (denoted by 1).\n\n    Example:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    output: 2\n\n    Explanation: There are two unique paths from the top-left cell to the bottom-right cell.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or col < 0 or grid[row][col] == 1:\n            return 0\n        if row == 0 and col == 0:\n            return 1\n        return dfs(row-1, col) + dfs(row, col-1)\n\n    return dfs(len(grid)-1, len(grid[0])-1)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 2\n",
        "idx_generation": 408,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all unique combinations in the list where the selected numbers sum to the target.\n    The same number can be chosen from the list multiple times.\n    The combinations should be in ascending order.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, path: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(path[:])\n            return\n        if target < 0:\n            return\n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(nums[i:], target - nums[i], path, result)\n            path.pop()\n\n    result = []\n    backtrack(nums, target, [], result)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n",
        "idx_generation": 452,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is the sum of [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 477,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a subarray that can be obtained by rearranging the elements in the subarray.\n    The subarray must contain at least one element.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 15\n    Explanation: The maximum sum can be obtained by rearranging the subarray to [5, 4, 3, 2, 1], which gives a sum of 15.\n\n    \"\"\"\n    nums.sort(reverse=True)\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 15\n\n",
        "idx_generation": 252,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find if there are three numbers in the list that sum up to the target value\"\"\"\n    for i in range(len(nums)-2):\n        for j in range(i+1, len(nums)-1):\n            for k in range(j+1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == target:\n                    return True\n    return False\n\ndef g(nums = [1, 2, 3, 4, 5], target = 9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 58,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given list of integers.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a valid email address.\n    \"\"\"\n    if len(s) < 5 or len(s) > 320:\n        return False\n\n    if s.count('@') != 1 or s.count('.') < 1:\n        return False\n\n    username, domain = s.split('@')\n    if len(username) < 1 or len(domain) < 1:\n        return False\n\n    if len(username) > 64 or len(domain) > 255:\n        return False\n\n    if '.' in domain:\n        tld = domain.split('.')[-1]\n        if len(tld) < 2 or len(tld) > 63:\n            return False\n    else:\n        return False\n\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a valid email address.\n    \"\"\"\n    return \"test@example.com\"\n\nassert f(g()) == True\n",
        "idx_generation": 33,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value can be achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value between any two numbers is known to be 28.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 344,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique strings of length n that can be formed using only '0' and '1'.\n    \"\"\"\n    return 2 ** n\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 4\n\nassert f(g()) == 16\n\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is bipartite.\n\n    A graph is bipartite if we can split its set of nodes into two independent subsets A and B, such that\n    every edge in the graph connects a node in set A to a node in set B.\n\n    Example:\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2]\n    ]\n\n    The function should return True, as the graph can be split into two subsets: [0, 2] and [1, 3].\n\n    Note:\n    - The graph will have at most 100 nodes.\n    - The graph is undirected and does not contain self-loops or parallel edges.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n    for i in range(n):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representing an undirected graph.\n    \"\"\"\n    return [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2]\n    ]\n\nassert f(g()) == True\n\n",
        "idx_generation": 410,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k elements from a set of n elements.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g():\n    \"\"\"\n    Generate two integers n and k such that the number of ways to choose k elements from a set of n elements is greater than 0.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) > 0\n\n",
        "idx_generation": 458,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value 9, and their indices are 0 and 1 respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 477,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of non-negative integers and a target value, determine if it is\n    possible to divide the array into two subsets such that the sum of elements in\n    both subsets is equal to the target value.\n    \"\"\"\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    return dp[target_sum]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of non-negative integers.\n    \"\"\"\n    return [1, 5, 11, 5]\n\nassert f(g(), 11) == True\n\n",
        "idx_generation": 255,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number n is a perfect square.\n    \"\"\"\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n\n    start = 1\n    end = n\n\n    while start <= end:\n        mid = (start + end) // 2\n        square = mid * mid\n\n        if square == n:\n            return True\n        elif square < n:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return False\n\ndef g(n=25):\n    \"\"\"\n    Generate a number n.\n    \"\"\"\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 60,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, find the longest palindromic substring in s.\n\n    Example:\n    Input: \"babad\"\n    Output: \"bab\" (The longest palindromic substring is \"bab\")\n\n    Hint: Use dynamic programming to find the longest palindromic substring.\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n\n    start = 0\n    max_length = 1\n\n    for i in range(n):\n        dp[i][i] = True\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                if length == 2 or dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    if length > max_length:\n                        start = i\n                        max_length = length\n\n    return s[start:start + max_length]\n\ndef g():\n    return \"babad\"\n\nassert f(g()) == \"bab\"\n",
        "idx_generation": 151,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome\n\n    Given a string s, determine if it is a palindrome.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward as forward.\n\n    Example:\n    s = \"level\"\n    output: True\n    \"\"\"\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return False\n    return True\n\ndef g(s = \"level\"):\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 33,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the maximum XOR value between two numbers in the list\n    such that the XOR value is less than or equal to n.\n\n    Example:\n    n = 5\n    nums = [1, 2, 3, 4, 5]\n    f(n, nums) => 5\n    Explanation: The maximum XOR value is achieved by taking XOR of 2 and 5 (2 XOR 5 = 7), which is less than or equal to n.\n\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor <= n and xor > max_xor:\n                max_xor = xor\n\n    return max_xor\n\ndef g():\n    n = 5\n    nums = [1, 2, 3, 4, 5]\n    return n, nums\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 348,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number. Return True if n is prime,\n    otherwise return False.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n: int):\n    \"\"\"\n    Given an integer n, find the largest prime number smaller than n. Return the largest prime number.\n    \"\"\"\n    for i in range(n - 1, 1, -1):\n        if f(i):\n            return i\n\n    return None\n\nassert f(g(20))\n",
        "idx_generation": 129,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph with n nodes and a list of edges, determine if the graph is a tree.\n    Return True if it is a tree, False otherwise.\n    \"\"\"\n    if len(edges) != n - 1:\n        return False\n    \n    graph = {i: [] for i in range(n)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    def dfs(node: int, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    if dfs(0, -1):\n        return False\n    \n    return all(visited)\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate a graph with n nodes and a list of edges.\n    \"\"\"\n    n = 5\n    edges = [(0, 1), (0, 2), (0, 3), (1, 4)]\n    return n, edges\n\nassert f(*g()) == True\n\n",
        "idx_generation": 416,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 1]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum sum can be obtained by selecting subarray [1, 3].\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g():\n    return [1, 2, 3, 1]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 462,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 3, 5, 7, 9, 11, 13], 7\n\nassert f(*g()) == 3\n",
        "idx_generation": 478,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target value, determine if there are three integers in the array that sum up to the target value.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target value.\n    \"\"\"\n    arr = [2, 7, 5, 3, 1, 6]\n    target = 11\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 260,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of integers, return the sum of all the even numbers in the grid.\n    \n    Sample Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    Sample Output:\n    20\n    \"\"\"\n    return sum(num for row in grid for num in row if num % 2 == 0)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 20\n",
        "idx_generation": 62,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers, find a subset of numbers that sum up to the target value.\n    \"\"\"\n\n    def subset_sum(nums, target, idx, current_sum):\n        if current_sum == target:\n            return True\n        if idx == len(nums):\n            return False\n        include = subset_sum(nums, target, idx + 1, current_sum + nums[idx])\n        exclude = subset_sum(nums, target, idx + 1, current_sum)\n        return include or exclude\n\n    return subset_sum(nums, target, 0, 0)\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\nassert f(*g())\n",
        "idx_generation": 152,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport itertools\n\ndef f(s: str, target='abc') -> bool:\n    \"\"\"Find the minimum number of operations needed to convert s into the target string\"\"\"\n    operations = 0\n    i = 0\n    for char in s:\n        if char != target[i]:\n            operations += 1\n        i = (i + 1) % len(target)\n    return operations <= len(s) // 2\n\ndef g(target='abc'):\n    s = 'abacabadabacaba' * (len(target) // 12 + 1)\n    return s[:len(target)]\n\nassert f(g()) == True\n",
        "idx_generation": 34,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, count the total number of set bits in all numbers from 1 to n (inclusive).\n\n    Example:\n    n = 5\n\n    Output:\n    7\n\n    Explanation:\n    The numbers from 1 to 5 (inclusive) are 1, 2, 3, 4, 5.\n    The total number of set bits in these numbers is 7.\n    \"\"\"\n\n    def count_set_bits(num):\n        count = 0\n        while num:\n            count += 1\n            num = num & (num - 1)\n        return count\n\n    total_set_bits = 0\n    for i in range(1, n + 1):\n        total_set_bits += count_set_bits(i)\n\n    return total_set_bits\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 7\n\n",
        "idx_generation": 354,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> bool:\n    \"\"\"Check if n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n=37):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, check if the graph contains a cycle.\n\n    Example:\n    matrix = [[0, 1, 1, 1],\n              [1, 0, 0, 0],\n              [1, 0, 0, 1],\n              [1, 0, 1, 0]]\n\n    The graph has 4 nodes and the adjacency matrix represents the following edges:\n    - Nodes 0, 1, 2, and 3 are all connected to each other.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def has_cycle(matrix: List[List[int]], visited: List[bool], curr_node: int, parent: int) -> bool:\n        visited[curr_node] = True\n        for neighbor in range(len(matrix)):\n            if matrix[curr_node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if has_cycle(matrix, visited, neighbor, curr_node):\n                        return True\n                elif parent != neighbor:\n                    return True\n        return False\n\n    visited = [False] * len(matrix)\n    for node in range(len(matrix)):\n        if not visited[node]:\n            if has_cycle(matrix, visited, node, -1):\n                return True\n    return False\n\n\ndef g() -> List[List[int]]:\n    matrix = [[0, 1, 1, 1],\n              [1, 0, 0, 0],\n              [1, 0, 0, 1],\n              [1, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 426,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of unique combinations of the list elements that add up to the target value.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    There are 2 unique combinations of the list elements that add up to the target value:\n    - [2, 2, 3]\n    - [7]\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def count_combinations(nums, target):\n        \"\"\"\n        Count the number of unique combinations of the list elements that add up to the target value.\n        \"\"\"\n        combinations = []\n\n        def backtrack(remain, current_combination, start):\n            if remain == 0:\n                combinations.append(list(current_combination))\n                return\n            elif remain < 0:\n                return\n\n            for i in range(start, len(nums)):\n                current_combination.append(nums[i])\n                backtrack(remain - nums[i], current_combination, i)\n                current_combination.pop()\n\n        backtrack(target, [], 0)\n\n        return len(combinations)\n\n    return count_combinations(nums, target)\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 469,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list.\n\n    Example:\n    nums = [1, 2, 2, 3, 3, 3, 4, 5]\n    target = 3\n\n    The function should return 3 since the target value 3 appears 3 times in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n            i = mid + 1\n            while i < len(nums) and nums[i] == target:\n                count += 1\n                i += 1\n            return count\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return 0\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 2, 3, 3, 3, 4, 5]\n\nassert f(g(), 3) == 3\n\n",
        "idx_generation": 479,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of occurrences of the target in the list.\n\n    Example:\n    Input: nums = [1, 2, 2, 3, 4, 4, 4, 5, 5], target = 4\n    Output: 3\n    Explanation: The target number 4 appears 3 times in the list.\n    \"\"\"\n    def binary_search(nums: List[int], target: int, start: int, end: int) -> int:\n        if start > end:\n            return 0\n        \n        mid = (start + end) // 2\n        \n        if nums[mid] == target:\n            left = binary_search(nums, target, start, mid - 1)\n            right = binary_search(nums, target, mid + 1, end)\n            return 1 + left + right\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, end)\n        else:\n            return binary_search(nums, target, start, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    return ([1, 2, 2, 3, 4, 4, 4, 5, 5], 4)\n\nassert f(*g()) == 3\n",
        "idx_generation": 261,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target sum, find the number of subarrays that have a sum equal to the target.\n\n    Sample Input:\n    nums = [1, 1, 1]\n    k = 2\n\n    Sample Output:\n    2\n\n    Explanation: The subarrays with a sum of 2 are [1, 1] and [1, 1].\n\n    \"\"\"\n\n    prefix_sum = 0\n    count = 0\n    prefix_sum_count = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        count += prefix_sum_count.get(prefix_sum - k, 0)\n        prefix_sum_count[prefix_sum] = prefix_sum_count.get(prefix_sum, 0) + 1\n\n    return count\n\n\ndef g():\n    nums = [1, 1, 1]\n    k = 2\n    return nums, k\n\n\nassert f(*g()) == 2\n",
        "idx_generation": 63,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a combination of numbers in nums that sums up to the target value.\"\"\"\n    def backtrack(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i >= len(nums) or curr_sum > target:\n            return False\n        if backtrack(i + 1, curr_sum + nums[i]):\n            return True\n        return backtrack(i + 1, curr_sum)\n\n    return backtrack(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums, target\n\nassert f(*g())\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome, ignoring non-alphanumeric characters and case.\n    \"\"\"\n    def is_alphanumeric(char):\n        return char.isalpha() or char.isdigit()\n\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    alphanumeric_string = ''.join(filter(is_alphanumeric, s)).lower()\n    return is_palindrome(alphanumeric_string)\n\ndef g():\n    string = \"A man, a plan, a canal: Panama\"\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 36,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    n = 12\n\n    f(n) => 2\n    Explanation: The binary representation of 12 is 1100, which contains 2 1 bits.\n\n    n = 23\n\n    f(n) => 4\n    Explanation: The binary representation of 23 is 10111, which contains 4 1 bits.\n    \"\"\"\n\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int = 12):\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 175,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given the number of nodes in a graph and a list of edges, find the number of connected components in the graph.\n\n    Example:\n    Input: n = 5\n           edges = [(0, 1), (1, 2), (3, 4)]\n    Output: 2\n\n    Explanation: There are two connected components: [0, 1, 2] and [3, 4].\n\n    Note: The edges will not have duplicates and will not have self-loops.\n    \"\"\"\n\n    parent = [-1] * n\n\n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        x_root = find(x)\n        y_root = find(y)\n        if x_root != y_root:\n            parent[x_root] = y_root\n\n    for u, v in edges:\n        union(u, v)\n\n    return sum(1 for i in range(n) if parent[i] == -1)\n\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    n = 5\n    edges = [(0, 1), (1, 2), (3, 4)]\n    return n, edges\n\n\nassert f(*g()) == 2\n\n",
        "idx_generation": 427,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[str]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of well-formed parentheses with n pairs.\n\n    Example:\n    Input: n = 3\n    Output: [\n        \"((()))\",\n        \"(()())\",\n        \"(())()\",\n        \"()(())\",\n        \"()()()\"\n    ]\n\n    Constraints:\n    - n is a positive integer.\n    - The number of combinations is at most 10^4.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    combinations = []\n    backtrack('', 0, 0)\n    return combinations\n\ndef g(n=3) -> int:\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n",
        "idx_generation": 475,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two sorted lists of integers, return a new sorted list that contains all the elements from both lists,\n    in ascending order.\n\n    Example:\n    nums1 = [1, 3, 5, 7]\n    nums2 = [2, 4, 6, 8]\n\n    The function should return [1, 2, 3, 4, 5, 6, 7, 8].\n    \"\"\"\n    merged = []\n    i, j = 0, 0\n\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n\n    while i < len(nums1):\n        merged.append(nums1[i])\n        i += 1\n\n    while j < len(nums2):\n        merged.append(nums2[j])\n        j += 1\n\n    return merged\n\ndef g() -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Generate two sorted lists of integers.\n    \"\"\"\n    return ([1, 3, 5, 7], [2, 4, 6, 8])\n\nassert f(*g()) == [1, 2, 3, 4, 5, 6, 7, 8]\n\n",
        "idx_generation": 479,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the number of occurrences of a target number.\n\n    Example:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n\n    Output:\n    3\n\n    Explanation:\n    The target number 2 occurs 3 times in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    # Perform binary search to find the leftmost and rightmost occurrence of the target number\n    leftmost = binary_search_left(nums, target, left, right)\n    rightmost = binary_search_right(nums, target, left, right)\n\n    # Calculate the number of occurrences\n    count = rightmost - leftmost + 1\n\n    return count\n\n\ndef binary_search_left(nums: List[int], target: int, left: int, right: int) -> int:\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\n\ndef binary_search_right(nums: List[int], target: int, left: int, right: int) -> int:\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return right\n\n\ndef g():\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return nums, target\n\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 266,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if n is a prime number.\n\n    Sample input:\n    n = 13\n\n    Sample output:\n    True\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g(n = 13):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 64,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n    The Fibonacci sequence is defined as follows:\n    - Fibonacci(0) = 0\n    - Fibonacci(1) = 1\n    - Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2), for n > 1\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        fib = [0] * (n + 1)\n        fib[1] = 1\n\n        for i in range(2, n + 1):\n            fib[i] = fib[i-1] + fib[i-2]\n\n        return fib[n]\n\ndef g() -> int:\n    n = 6\n    return n\n\nassert f(g()) == 8\n",
        "idx_generation": 154,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Check if the given string can be formed by concatenating elements of a list in a specific order.\n    Each element of the list can be used multiple times.\n    \"\"\"\n    def dfs(start: int) -> bool:\n        nonlocal target\n\n        if start == len(target):\n            return True\n\n        for i in range(start, len(target)):\n            if target[start:i+1] in s and dfs(i+1):\n                return True\n\n        return False\n\n    return dfs(0)\n\ndef g():\n    s = \"abcde\"\n    target = \"abecdeab\"\n    return (s, target)\n\nassert f(*g())\n",
        "idx_generation": 39,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 7\n",
        "idx_generation": 359,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a given number n is a prime number\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(n = 17):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 178,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, determine whether there is a path from the start node to the end node.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    \"\"\"\n\n    def dfs(graph: List[List[int]], node: int, visited: List[bool], end: int) -> bool:\n        if node == end:\n            return True\n        \n        visited[node] = True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, visited, end):\n                    return True\n        \n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, start, visited, end)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n",
        "idx_generation": 434,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers in the list that add up to the target.\n    Return a list of lists containing the combinations.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    \"\"\"\n\n    def backtrack(start, target, path, combinations):\n        if target == 0:\n            combinations.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(nums)):\n            backtrack(i, target - nums[i], path + [nums[i]], combinations)\n    \n    combinations = []\n    backtrack(0, target, [], combinations)\n    return combinations\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n",
        "idx_generation": 488,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum absolute difference between any two elements in the list.\n\n    The maximum absolute difference is defined as the absolute value of the difference between two elements.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    The maximum absolute difference is |9 - 1| = 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    min_num = float('inf')\n    max_num = float('-inf')\n\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n\n    return abs(max_num - min_num)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == 8\n",
        "idx_generation": 480,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The sum of nums[0] + nums[1] equals 2 + 7 = 9, which is the target.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 269,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers contains a subarray whose sum is equal to zero.\n    \"\"\"\n    prefix_sum = 0\n    sum_set = set()\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum == 0 or prefix_sum in sum_set:\n            return True\n        \n        sum_set.add(prefix_sum)\n    \n    return False\n\ndef g():\n    nums = [4, 2, -3, 1, 6]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 66,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    The Fibonacci sequence is defined as follows:\n    F(0) = 0, F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n\n    Example:\n    Input: 6\n    Output: 8 (F(6) = F(5) + F(4) = 5 + 3 = 8)\n\n    Hint: Use dynamic programming to optimize the recursive solution.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n+1):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 155,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, convert all lowercase characters to uppercase and vice versa.\n\n    Sample Input:\n    s = \"Hello World\"\n\n    Sample Output:\n    \"hELLO wORLD\"\n\n    Sample Input:\n    s = \"Python\"\n\n    Sample Output:\n    \"pYTHON\"\n    \"\"\"\n\n    result = \"\"\n    for char in s:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result\n\ndef g():\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello World\"\n\nassert f(g()) == \"hELLO wORLD\"\n",
        "idx_generation": 41,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: arr = [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is achieved by taking the XOR of 5 and 25, resulting in 28.\n\n    Input: arr = [0, 1, 2, 3, 4, 5]\n    Output: 7\n    Explanation: The maximum XOR value is achieved by taking the XOR of 3 and 4, resulting in 7.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 362,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of ways to arrange n distinct objects in a circle.\n\n    Example:\n    n = 3\n\n    The three distinct objects can be arranged in a circle in the following ways:\n    - Object 1, Object 2, Object 3\n    - Object 1, Object 3, Object 2\n    - Object 2, Object 1, Object 3\n    - Object 2, Object 3, Object 1\n    - Object 3, Object 1, Object 2\n    - Object 3, Object 2, Object 1\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def factorial(n: int) -> int:\n        \"\"\"\n        Helper function to calculate the factorial of a number.\n        \"\"\"\n\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    return factorial(n - 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 4\n\nassert f(g()) == 6\n",
        "idx_generation": 178,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if the graph contains a cycle.\n    Return True if the graph contains a cycle, otherwise return False.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(adjacency_list)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return [[1, 2], [2, 3], [3], []]\n\nassert f(g()) == False\n",
        "idx_generation": 443,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct combinations that sum up to a target value.\n    Return the count of distinct combinations.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    The distinct combinations that sum up to 5 are [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 4], [2, 3], [5].\n    Therefore, the function should return 6.\n    \"\"\"\n    def count_combinations(nums, target, idx, memo):\n        if target == 0:\n            return 1\n        if target < 0 or idx >= len(nums):\n            return 0\n        if (idx, target) in memo:\n            return memo[(idx, target)]\n        \n        count = count_combinations(nums, target - nums[idx], idx, memo) + count_combinations(nums, target, idx + 1, memo)\n        memo[(idx, target)] = count\n        \n        return count\n    \n    memo = {}\n    return count_combinations(nums, 5, 0, memo)\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 491,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True\n    Explanation: The numbers 2 and 7 add up to 9.\n\n    Input: nums = [2, 7, 11, 15], target = 10\n    Output: False\n    Explanation: There are no two numbers in the list that add up to 10.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g()) == True\n\n",
        "idx_generation": 480,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence in the list.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence in nums is [2, 3, 7, 101], so the function should return 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 269,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return a list containing the maximum value from each column.\n    \"\"\"\n    max_values = []\n\n    for j in range(len(matrix[0])):\n        column_max = float('-inf')\n\n        for i in range(len(matrix)):\n            if matrix[i][j] > column_max:\n                column_max = matrix[i][j]\n\n        max_values.append(column_max)\n\n    return max_values\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [7, 8, 9]\n",
        "idx_generation": 68,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n    Example:\n    Input: \"racecar\"\n    Output: True (The string \"racecar\" is a valid palindrome)\n\n    Hint: Use recursion to check if the first and last characters of the string are the same.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        if len(s) <= 1:\n            return True\n        elif s[0] == s[-1]:\n            return is_palindrome(s[1:-1])\n        else:\n            return False\n\n    return is_palindrome(s)\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 155,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, rotate the string k positions to the right.\n    \"\"\"\n    n = len(s)\n    k %= n\n    return s[-k:] + s[:-k]\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer k.\n    \"\"\"\n    s = \"abcdefgh\"\n    k = 3\n    return s, k\n\nassert f(*g()) == \"fghabcde\"\n",
        "idx_generation": 42,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value that can be obtained by taking the XOR of any two elements in the list.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    f(nums) => 28\n    Explanation: The maximum XOR value can be obtained by taking the XOR of 5 and 25, which is 28.\n\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if target_xor ^ prefix in prefixes:\n                max_xor = target_xor\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 365,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Sample Input:\n    n = 6\n\n    Sample Output:\n    8\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return f(n-1) + f(n-2)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 184,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, determine if there exists a cycle in the graph.\n\n    Sample Input:\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n\n    Sample Output:\n    True\n\n    Explanation: The graph has a cycle: 1->2->3->4->1.\n    \"\"\"\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    visited = [False] * (n + 1)\n    stack = [False] * (n + 1)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a random graph with a certain number of nodes and edges.\n    \"\"\"\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, edges\n\nassert f(*g()) == True\n",
        "idx_generation": 450,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, find two distinct numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    The function should return True since 4 + 10 = 14.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value such that there exists two distinct numbers in the list whose sum is equal to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [2, 4, 6, 8, 10]\ntarget = 14\nassert f(*g(nums, target)) == True\n\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Sample Input:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Sample Input:\n    nums = [0, 1, 0, 3, 2, 3]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], which has a length of 4.\n\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 271,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, return a new array where each element at index i is the product of all the numbers in the original array except the one at i.\n    \"\"\"\n    n = len(arr)\n    prefix_product = [1] * n\n    suffix_product = [1] * n\n    result = []\n    \n    # Calculate prefix product\n    for i in range(1, n):\n        prefix_product[i] = prefix_product[i-1] * arr[i-1]\n    \n    # Calculate suffix product\n    for i in range(n-2, -1, -1):\n        suffix_product[i] = suffix_product[i+1] * arr[i+1]\n    \n    # Calculate the product of prefix and suffix products\n    for i in range(n):\n        result.append(prefix_product[i] * suffix_product[i])\n    \n    return result\n\ndef g(arr=[1, 2, 3, 4, 5]):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return arr\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n",
        "idx_generation": 77,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target=0) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', find if there exists a combination of numbers that sum up to 'target'.\n\n    Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def dp(curr_sum, index):\n        if curr_sum == target:\n            return True\n        if index >= len(nums):\n            return False\n        \n        # Exclude current number\n        if dp(curr_sum, index + 1):\n            return True\n        \n        # Include current number\n        if dp(curr_sum + nums[index], index + 1):\n            return True\n        \n        return False\n    \n    return dp(0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a list of numbers from 'nums' that sum up to 'target'.\n    \"\"\"\n    if sum(nums) < target:\n        return []\n    \n    nums.sort(reverse=True)\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 157,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string and an integer n, return a new string where each character in the original string is repeated n times.\n    \n    Sample Input:\n    s = \"hello\"\n    n = 3\n    \n    Sample Output:\n    \"hhheeellllllooo\"\n    \"\"\"\n    return ''.join([char * n for char in s])\n\ndef g():\n    s = \"hello\"\n    n = 3\n    return s, n\n\nassert f(*g()) == \"hhheeellllllooo\"\n",
        "idx_generation": 43,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value between two elements in the list is 28 (3 ^ 25).\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 380,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers arr, return True if there exists a subarray such that the sum of its elements is a perfect square,\n    otherwise return False.\n    \"\"\"\n    def is_perfect_square(n: int) -> bool:\n        \"\"\"\n        Helper function to check if a number is a perfect square.\n        \"\"\"\n        return int(n**0.5)**2 == n\n    \n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)+1):\n            subarray_sum = prefix_sum[j] - prefix_sum[i]\n            if is_perfect_square(subarray_sum):\n                return True\n    \n    return False\n\ndef g() -> List[int]:\n    arr = [2, 4, -1, 5, 6]\n    return arr\n\nassert f(g()) == True\n",
        "idx_generation": 189,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output: 7\n    Explanation: The minimum sum of a path is 1 + 3 + 1 + 1 + 1 = 7.\n\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 455,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value,\n    find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 6\n    Output: 2\n\n    Explanation: The target value 6 is found at index 2 in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 482,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of numbers is a sorted list of distinct positive even numbers.\n    \"\"\"\n    if not nums or any(num <= 0 or num % 2 != 0 for num in nums):\n        return False\n    return sorted(nums) == nums\n\ndef g():\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == True\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find two numbers in the given list that add up to the target value.\n    Return the indices of the two numbers in a list.\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if num in complement:\n            return [complement[num], i]\n        complement[target - num] = i\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 82,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n\n    Example:\n    n = 6\n\n    Output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n\n    def fibonacci(n, memo):\n        if n <= 1:\n            return n\n        if memo[n] is not None:\n            return memo[n]\n        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n        return memo[n]\n\n    memo = [None] * (n + 1)\n    return fibonacci(n, memo)\n\ndef g():\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 157,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target: str) -> bool:\n    \"\"\"\n    Given a string and a target substring, check if the target substring is present in the string.\n    \"\"\"\n    return target in s\n\ndef g():\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    s = \"Hello, world!\"\n    target = \"world\"\n    \n    return s, target\n\nassert f(*g()) == True\n",
        "idx_generation": 45,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the k-th digit from the right in the binary representation of n.\n    \"\"\"\n    binary = bin(n)[2:]\n    if k > len(binary):\n        return -1\n    return int(binary[-k])\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a positive integer n and a positive integer k for Puzzle 3.\n    \"\"\"\n    return (42, 2)\n\nassert f(*g()) == 1\n",
        "idx_generation": 383,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(x: int, y: int, z: int, a=100, b=200) -> bool:\n    \"\"\"Find three numbers x, y, and z such that x * y * z = a * b.\"\"\"\n    return x * y * z == a * b\ndef g(a=100, b=200):\n    x = a\n    y = b\n    z = 1\n    return x, y, z\nassert f(*g())\n",
        "idx_generation": 194,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two vertices 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\n\n    Example:\n    Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from 'A' to 'D' in the graph: A -> B -> D.\n    \"\"\"\n\n    def dfs(node: str, visited: set) -> bool:\n        if node == end:\n            return True\n\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, along with 'start' and 'end' vertices, such that there is a path from 'start' to 'end' in the graph.\n    \"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g()) == True\n",
        "idx_generation": 460,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] + nums[1] = 2 + 7 = 9, which is the target value.\n    Therefore, the indices of the two numbers are [0, 1].\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 483,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) and return its length.\n    \"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 276,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum using Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -3, 5, -2, 9, -8, 3, -1]\n\nassert f(g()) == 12\n",
        "idx_generation": 83,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally (down-right).\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    output: 29 (path: 1->4->7->8->9)\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 29\n",
        "idx_generation": 159,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return the corresponding roman numeral as a string.\n    \"\"\"\n    roman_numerals = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n\n    result = ''\n    for value, symbol in roman_numerals:\n        while n >= value:\n            result += symbol\n            n -= value\n    return result\n\ndef g():\n    n = 1984\n    return n\n\nassert f(g()) == 'MCMLXXXIV'\n",
        "idx_generation": 45,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Count the number of set bits in a binary representation of a given integer n.\n\n    Example:\n    n = 10\n\n    The binary representation of 10 is 1010, which contains 2 set bits.\n\n    Therefore, the function should return 2.\n\n    Hint: Use bitwise operations to count the set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 387,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(num: int) -> int:\n    \"\"\"\n    Find the smallest perfect square number that is greater than or equal to the given number.\n\n    Example:\n    Input: 10\n    Output: 16\n    Explanation:\n    - The smallest perfect square number that is greater than or equal to 10 is 16.\n    \"\"\"\n\n    def find_smallest_perfect_square(num):\n        if num < 0:\n            return None\n\n        # Find the square root of the given number\n        sqrt = math.isqrt(num)\n\n        # Check if the square of the square root is equal to the given number\n        if sqrt * sqrt == num:\n            return num\n\n        # Increment the square root until a perfect square is found\n        while True:\n            sqrt += 1\n            square = sqrt * sqrt\n            if square >= num:\n                return square\n\n    return find_smallest_perfect_square(num)\n\ndef g():\n    num = 10\n    return num\n\nassert f(g()) == 16\n\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two vertices start and end, return the number of distinct paths from start to end.\n    A path is considered distinct if it does not contain any repeated vertices.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 1, 1],\n             [1, 1, 0, 1],\n             [0, 1, 1, 0]]\n\n    start = 0, end = 3\n\n    The number of distinct paths from vertex 0 to vertex 3 is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def dfs(v: int, visited: List[bool]) -> int:\n        if v == end:\n            return 1\n        count = 0\n        visited[v] = True\n        for neighbor in range(len(graph[v])):\n            if graph[v][neighbor] == 1 and not visited[neighbor]:\n                count += dfs(neighbor, visited)\n        visited[v] = False\n        return count\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)\n\ndef g() -> (List[List[int]], int, int):\n    \"\"\"\n    Generate a graph and two vertices for Puzzle 3.\n    \"\"\"\n    graph = [[0, 1, 1, 0],\n             [1, 0, 1, 1],\n             [1, 1, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == 4\n\n",
        "idx_generation": 471,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return a list of the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n    The output should be [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n\n    Return the list of indices as the result.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 483,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers, find the kth largest element in the list.\n\n    Example:\n    arr = [3, 2, 1, 5, 6, 4]\n    k = 2\n\n    The 2nd largest element in the list is 5.\n    Therefore, the function should return 5.\n    \"\"\"\n\n    def quick_select(left: int, right: int, k_smallest: int) -> int:\n        pivot_index = partition(left, right)\n        if pivot_index == k_smallest:\n            return arr[pivot_index]\n        elif pivot_index < k_smallest:\n            return quick_select(pivot_index + 1, right, k_smallest)\n        else:\n            return quick_select(left, pivot_index - 1, k_smallest)\n\n    def partition(left: int, right: int) -> int:\n        pivot_index = choose_pivot(left, right)\n        pivot_value = arr[pivot_index]\n        arr[pivot_index], arr[right] = arr[right], arr[pivot_index]\n        store_index = left\n        for i in range(left, right):\n            if arr[i] < pivot_value:\n                arr[i], arr[store_index] = arr[store_index], arr[i]\n                store_index += 1\n        arr[store_index], arr[right] = arr[right], arr[store_index]\n        return store_index\n\n    def choose_pivot(left: int, right: int) -> int:\n        return right\n\n    k_smallest = len(arr) - k\n    return quick_select(0, len(arr) - 1, k_smallest)\n\ndef g():\n    return [3, 2, 1, 5, 6, 4], 2\n\nassert f(*g()) == 5\n",
        "idx_generation": 279,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The maximum subarray sum is [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 87,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    output: 4 (longest increasing subsequence: 2, 3, 7, 101)\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 159,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list that contains only the strings that contain the given substring.\n    \n    Sample Input:\n    strings = ['apple', 'banana', 'cherry', 'orange']\n    substring = 'an'\n    \n    Sample Output:\n    ['banana', 'orange']\n    \"\"\"\n    result = []\n    \n    for string in strings:\n        if substring in string:\n            result.append(string)\n    \n    return result\n\ndef g():\n    strings = ['apple', 'banana', 'cherry', 'orange']\n    substring = 'an'\n    return strings, substring\n\nassert f(*g()) == ['banana', 'orange']\n",
        "idx_generation": 50,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the number of set bits (1s) in its binary representation.\n\n    Example:\n    Input: n = 12\n    Output: 2\n\n    Explanation:\n    The binary representation of 12 is 1100.\n    It contains two set bits (1s) at positions 2 and 3.\n    Hence, the output is 2.\n    \"\"\"\n\n    count = 0\n\n    while n > 0:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n: int = 12):\n    return n\n\nassert f(g()) == 2\n\n",
        "idx_generation": 390,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all the prime numbers less than or equal to n.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    17\n\n    Explanation: The prime numbers less than or equal to 10 are 2, 3, 5, and 7. Their sum is 2 + 3 + 5 + 7 = 17.\n    \"\"\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes_sum = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            primes_sum += i\n    \n    return primes_sum\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 17\n",
        "idx_generation": 228,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the length of the shortest cycle in the graph.\n    A cycle is a path that starts and ends at the same vertex and visits all other vertices exactly once.\n\n    Return the length of the shortest cycle. If there is no cycle in the graph, return -1.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\n    The shortest cycle is 4, which follows the path: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n    def dfs(node, visited, parent, length):\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, node, length + 1):\n                        return True\n                elif neighbor != parent and length >= 3:\n                    return True\n\n        visited[node] = False\n        return False\n\n    for i in range(len(graph)):\n        visited = [False] * len(graph)\n        if dfs(i, visited, -1, 1):\n            return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n\n",
        "idx_generation": 472,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7] since 2 + 7 = 9.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 484,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, check if the target value is present in the list using binary search.\n\n    Example:\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    target = 9\n\n    The function should return True, since 9 is present in the list.\n\n    If the target value is not present, the function should return False.\n\n    \"\"\"\n    start = 0\n    end = len(arr) - 1\n\n    while start <= end:\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            start = mid + 1\n        else:\n            end = mid - 1\n\n    return False\n\ndef g(arr: List[int], target: int):\n    arr.sort()\n    return arr, target\n\nassert f(*g([1, 3, 5, 7, 9, 11, 13, 15], 9)) == True\n\n",
        "idx_generation": 281,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all the elements in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output:\n    45\n\n    Explanation:\n    The sum of all the elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    total_sum = 0\n    for row in matrix:\n        for element in row:\n            total_sum += element\n    return total_sum\n\ndef g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == 45\n",
        "idx_generation": 89,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    \"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 5\n\nassert f(g()) == 8\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, n=10) -> bool:\n    \"\"\"Check if the reverse of the string s is equal to s.\"\"\"\n    return s == s[::-1]\ndef g(s = \"racecar\"):\n    return s\nassert f(g()) == True\n",
        "idx_generation": 50,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a power of two.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Explanation: 16 is a power of 2 because 2^4 = 16.\n    \"\"\"\n    if n <= 0:\n        return False\n\n    return (n & (n - 1)) == 0\n\ndef g() -> int:\n    \"\"\"\n    Generate a random power of two.\n    \"\"\"\n    n = 8\n    return 2 ** n\n\nassert f(g())\n",
        "idx_generation": 391,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    The function should return 15, as the sum of all positive integers less than or equal to 5 is 1 + 2 + 3 + 4 + 5 = 15.\n\n    Hint: Use the formula for the sum of an arithmetic series.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g(n=5):\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 229,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a wall and 0 represents an empty space, find the minimum number of steps required to reach the target cell from the starting cell.\n    You can only move up, down, left, or right and cannot move through walls.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int, steps: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 1:\n            return\n\n        if row == rows - 1 and col == cols - 1:\n            nonlocal min_steps\n            min_steps = min(min_steps, steps)\n            return\n\n        grid[row][col] = 1\n\n        dfs(row - 1, col, steps + 1)\n        dfs(row + 1, col, steps + 1)\n        dfs(row, col - 1, steps + 1)\n        dfs(row, col + 1, steps + 1)\n\n        grid[row][col] = 0\n\n    min_steps = float('inf')\n    dfs(0, 0, 0)\n\n    return min_steps\n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g()) == 8\n",
        "idx_generation": 478,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the first occurrence of the target in the list.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 3, 4, 4, 5, 6]\n    target = 3\n    return [nums, target]\n\nassert f(*g()) == 2\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers arr and a target value, find the first occurrence of the target value in the list.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: arr = [1, 2, 2, 3, 4, 5, 5, 6, 7], target = 5\n    Output: 5\n\n    Explanation: The first occurrence of the target value 5 is at index 5.\n\n    Note:\n    - The list arr is guaranteed to be sorted in non-decreasing order.\n    - The list arr may contain duplicates.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\ndef g() -> (List[int], int):\n    return [1, 2, 2, 3, 4, 5, 5, 6, 7], 5\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 284,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum product of a subarray that consists of only positive integers.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The maximum product of a subarray consisting of only positive integers is 6, which can be obtained from the subarray [2, 3].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_product = 0\n    current_product = 1\n\n    for num in nums:\n        if num > 0:\n            current_product *= num\n            max_product = max(max_product, current_product)\n        else:\n            current_product = 1\n\n    return max_product\n\n\ndef g() -> List[int]:\n    nums = [2, 3, -2, 4]\n    return nums\n\n\nassert f(g()) == 6\n",
        "idx_generation": 91,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence is defined as follows: F(0) = 0, F(1) = 1, and F(n) = F(n - 1) + F(n - 2) for n > 1.\n    \"\"\"\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, lst=['python', 'programming', 'puzzle', 'skills', 'sorting', 'searching', 'string', 'manipulation', 'optimization', 'algorithms']) -> bool:\n    \"\"\"Find the longest string in the list that starts with the given character.\"\"\"\n    return max((word for word in lst if word.startswith(s)), key=len) == s\ndef g(lst=['python', 'programming', 'puzzle', 'skills', 'sorting', 'searching', 'string', 'manipulation', 'optimization', 'algorithms']):\n    return max(lst, key=len)\nassert f(g()) == True\n",
        "idx_generation": 51,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two different numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value is 28, which can be obtained by selecting 5 and 25.\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n    \n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    \n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 15\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a perfect number.\n\n    Sample Input:\n    n = 28\n\n    Sample Output:\n    True\n\n    Explanation:\n    28 is a perfect number since the sum of its proper divisors (1, 2, 4, 7, 14) is equal to the number itself.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    divisors_sum = 1\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n\n            if i != n // i:\n                divisors_sum += n // i\n\n    return divisors_sum == n\n\ndef g():\n    return 28\n\nassert f(g()) == True\n",
        "idx_generation": 230,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(graph: List[List[int]], visited: List[bool], current_node: int) -> bool:\n        if visited[current_node]:\n            return True\n        \n        visited[current_node] = True\n        for neighbor in range(len(graph[current_node])):\n            if graph[current_node][neighbor] == 1 and has_cycle(graph, visited, neighbor):\n                return True\n        \n        visited[current_node] = False\n        return False\n    \n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if has_cycle(graph, visited, node):\n            return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n",
        "idx_generation": 484,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product can be obtained by multiplying 4 and 5, which gives 20.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n",
        "idx_generation": 487,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], so the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n",
        "idx_generation": 284,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the sum of all numbers in the grid.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n",
        "idx_generation": 91,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Count the number of ways to climb n stairs by taking 1 or 2 steps at a time.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 4\n\nassert f(g()) == 5\n",
        "idx_generation": 162,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if it is a palindrome sequence.\n    A palindrome sequence is a sequence that reads the same forwards and backwards.\n    \"\"\"\n    stack = []\n    for num in nums:\n        stack.append(num)\n    while nums:\n        if nums.pop() != stack.pop():\n            return False\n    return True\n\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == True\n",
        "idx_generation": 55,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of numbers, return a new list where each element is the bitwise XOR of the two adjacent numbers in the original list.\n\n    Example:\n    Input: numbers = [1, 2, 3, 4, 5]\n    Output: [3, 1, 7, 1]\n\n    Explanation:\n    The XOR of 1 and 2 is 3.\n    The XOR of 2 and 3 is 1.\n    The XOR of 3 and 4 is 7.\n    The XOR of 4 and 5 is 1.\n    \"\"\"\n    xor_list = []\n    for i in range(len(numbers) - 1):\n        xor_list.append(numbers[i] ^ numbers[i + 1])\n    return xor_list\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of numbers to be used as input for the function f.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [3, 1, 7, 1]\n",
        "idx_generation": 398,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Sample input:\n    n = 6\n\n    Sample output:\n    8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    \n    fib = [0, 1]\n    for i in range(2, n+1):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n]\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n\n",
        "idx_generation": 251,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2 since the target number 5 is at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), target=5) == 2\n\n",
        "idx_generation": 487,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Determine if there exists a subset of the given list of integers such that the sum of its elements is equal to 0.\n    \"\"\"\n    def subset_sum(nums, target_sum, index, cache):\n        if target_sum == 0:\n            return True\n        if index >= len(nums) or target_sum < 0:\n            return False\n        if (index, target_sum) in cache:\n            return cache[(index, target_sum)]\n        \n        include = subset_sum(nums, target_sum - nums[index], index + 1, cache)\n        exclude = subset_sum(nums, target_sum, index + 1, cache)\n        cache[(index, target_sum)] = include or exclude\n        return cache[(index, target_sum)]\n    \n    return subset_sum(nums, 0, 0, {})\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -2, 3, 4, -5, 6]\n\nassert f(g()) == True\n",
        "idx_generation": 286,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a prime number.\n\n    Sample Input:\n    n = 17\n\n    Sample Output:\n    True\n\n    Explanation:\n    17 is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef g():\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where no two elements are adjacent.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[-1]\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n\n",
        "idx_generation": 162,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n    \"\"\"\n    return ' '.join(s.split()[::-1])\n\ndef g():\n    # The string\n    s = \"Hello World\"\n    \n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 59,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers arr and a target integer, check if there exists a pair of numbers in the list\n    whose bitwise XOR is equal to the target.\n    \"\"\"\n    stack = []\n    for num in arr:\n        complement = num ^ target\n        if complement in stack:\n            return True\n        stack.append(num)\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    target = 4\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 401,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given number n is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g(n: int):\n    \"\"\"\n    Find the n-th prime number.\n    \"\"\"\n    primes = []\n    num = 2\n\n    while len(primes) < n:\n        if f(num):\n            primes.append(num)\n        num += 1\n\n    return primes[-1]\n\nassert f(g(10))\n",
        "idx_generation": 263,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target value.\n\n    Return True if there exists a pair of numbers that sum up to the target, and False otherwise.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6], target = 9\n    Output: True\n    Explanation: There exists a pair (3, 6) in the list that sums up to 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 490,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target in the array.\n    If the target is not found, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the array.\n\n    \"\"\"\n    return binary_search(arr, target, 0, len(arr) - 1)\n\n\ndef binary_search(arr: List[int], target: int, left: int, right: int) -> int:\n    \"\"\"\n    Recursive helper function to perform binary search.\n    \"\"\"\n    if left > right:\n        return -1\n\n    mid = (left + right) // 2\n\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search(arr, target, mid + 1, right)\n    else:\n        return binary_search(arr, target, left, mid - 1)\n\n\ndef g() -> List[int]:\n    arr = [1, 3, 5, 7, 9]\n    return arr\n\n\nassert f(g(), 5) == 2\n\n",
        "idx_generation": 288,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Find the maximum profit that can be obtained by buying and selling stocks from nums.\"\"\"\n    if not nums:\n        return False\n    n = len(nums)\n    if n == 1:\n        return True\n    min_price = nums[0]\n    max_profit = 0\n    for i in range(1, n):\n        if nums[i] < min_price:\n            min_price = nums[i]\n        elif nums[i] - min_price > max_profit:\n            max_profit = nums[i] - min_price\n    return max_profit\ndef g():\n    return [7, 1, 5, 3, 6, 4]\nassert f(g()) == 5\n",
        "idx_generation": 95,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subsequence of non-adjacent elements.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    \n    if n == 1:\n        return nums[0]\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 163,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"Check if the string 's' follows the given pattern string\"\"\"\n    mapping = {}\n    words = s.split()\n    if len(words) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in mapping:\n            mapping[pattern[i]] = words[i]\n        elif mapping[pattern[i]] != words[i]:\n            return False\n    return True\n\ndef g(s = 'cat dog cat', pattern = 'aba'):\n    return s\n\nassert f(g(), 'aba')\n",
        "idx_generation": 61,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the maximum XOR value between any two elements in the list such that the XOR value is less than or equal to the target.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val <= target:\n                max_xor = max(max_xor, xor_val)\n    return max_xor\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value for Puzzle 5.\n    \"\"\"\n    return ([2, 5, 8, 3, 6], 7)\n\nassert f(*g()) == 7\n\n",
        "idx_generation": 405,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            count += 1\n    \n    return count\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 20\n\nassert f(g()) == 8\n",
        "idx_generation": 276,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the closest element to the target.\n\n    Example:\n    nums = [1, 2, 4, 6, 8]\n    target = 5\n    Output: 4\n\n    nums = [-2, 0, 5, 9, 12]\n    target = 10\n    Output: 9\n\n    Note:\n    - The input list nums is sorted in ascending order.\n    - The length of the input list nums will be at most 10^4.\n    - The target integer can be any integer.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return nums[mid]\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if abs(nums[left] - target) < abs(nums[right] - target):\n        return nums[left]\n    else:\n        return nums[right]\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers nums and a target integer.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 4\n\nassert f(*g()) == 3\n",
        "idx_generation": 491,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target sum, find the minimum number of elements from the array\n    that are needed to add up to the target sum. Each number in the array can be used multiple times.\n\n    Example:\n    nums = [2, 3, 5]\n    target = 10\n\n    The minimum number of elements needed is 2 (5 + 5 = 10), so the function should return 2.\n\n    \"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] = min(dp[i], dp[i - num] + 1)\n\n    return dp[target]\n\ndef g() -> List[int]:\n    nums = [2, 3, 5]\n    return nums\n\nassert f(g(), 10) == 2\n",
        "idx_generation": 289,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Find the longest consecutive subsequence in the given list.\n    Return the length of the longest consecutive subsequence.\n    \"\"\"\n    s = set(arr)\n    max_length = 0\n    \n    for num in s:\n        if num - 1 not in s:\n            current_length = 1\n            while num + 1 in s:\n                num += 1\n                current_length += 1\n            max_length = max(max_length, current_length)\n    \n    return max_length\n\n\ndef g():\n    arr = [100, 4, 200, 1, 3, 2]\n    return arr\n\nassert f(g()) == 4\n\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n    \"\"\"\n    memo = [[0] * n for _ in range(n)]\n    \n    def count_paths(row: int, col: int) -> int:\n        if row == n-1 and col == n-1:\n            return 1\n        if row >= n or col >= n:\n            return 0\n        if memo[row][col] != 0:\n            return memo[row][col]\n        \n        memo[row][col] = count_paths(row+1, col) + count_paths(row, col+1)\n        return memo[row][col]\n    \n    return count_paths(0, 0)\n\ndef g(n: int):\n    return n\n\nassert f(g(3)) == 6\n",
        "idx_generation": 167,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, nums=[15, 23, 8, 10, 5, 18, 13, 20, 3, 12]) -> bool:\n    \"\"\"Find the sum of all numbers in a list that are divisible by 3 and contain the letter 'a'.\"\"\"\n    return sum(num for num in nums if num % 3 == 0 and 'a' in str(num)) == s\ndef g(nums=[15, 23, 8, 10, 5, 18, 13, 20, 3, 12]):\n    return sum(num for num in nums if num % 3 == 0 and 'a' in str(num))\nassert f(g()) == True\n",
        "idx_generation": 63,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits in its binary representation.\n\n    Example:\n    Input: 9\n    Output: 2 (binary representation of 9 is 1001, which has 2 set bits)\n\n    Hint: Use bit manipulation to count the number of set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    return 9\n\nassert f(g()) == 2\n\n",
        "idx_generation": 406,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given positive integer n is a multiple of 3.\n\n    Example:\n    n = 15\n\n    15 is a multiple of 3 since 15 % 3 = 0.\n\n    Therefore, the function should return True.\n\n    Hint: Use mathematical properties of multiples of 3.\n    \"\"\"\n    return n % 3 == 0\n\ndef g(n = 15):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 293,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    nums (List[int]): The list of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target value.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 493,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a matrix of integers and a target number, determine if the target number exists in the matrix.\n    The matrix is sorted in non-decreasing order from left to right and top to bottom.\n\n    Example:\n    matrix = [\n      [1,   4,  7, 11, 15],\n      [2,   5,  8, 12, 19],\n      [3,   6,  9, 16, 22],\n      [10, 13, 14, 17, 24],\n      [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    Output: True\n    Explanation: The number 5 is present in the matrix.\n\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n\n    while row < rows and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g() -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a matrix of integers and a target number, where the target number exists in the matrix.\n    \"\"\"\n    matrix = [\n      [1,   4,  7, 11, 15],\n      [2,   5,  8, 12, 19],\n      [3,   6,  9, 16, 22],\n      [10, 13, 14, 17, 24],\n      [18, 21, 23, 26, 30]\n    ]\n    target = 5\n    return matrix, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 289,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of integers and a target number, check if the target number exists in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\n\ndef g(target=5):\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g(), target=5) == True\n\n",
        "idx_generation": 98,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n (inclusive) that are divisible by 3 or 5.\n    Return the sum.\n\n    Example:\n    n = 10\n\n    f(n) => 33\n    Explanation: Numbers divisible by 3 or 5 from 1 to 10 are 3, 5, 6, and 9. Their sum is 3 + 5 + 6 + 9 = 33.\n    \"\"\"\n\n    def dp(i):\n        if i == 0:\n            return 0\n        if i % 3 == 0 or i % 5 == 0:\n            return i + dp(i-1)\n        return dp(i-1)\n\n    return dp(n)\n\ndef g():\n    return (10,)\n\nassert f(*g()) == 33\n\n",
        "idx_generation": 167,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the binary representation of n is a palindrome.\"\"\"\n    binary = bin(n)[2:]\n    return binary == binary[::-1]\ndef g():\n    for i in range(100, 1000):\n        if f(i):\n            return i\nassert f(g()) == True\n",
        "idx_generation": 68,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the bitwise OR of all the elements in the list.\n    Return the result.\n\n    Example:\n    arr = [5, 3, 2, 8]\n\n    The bitwise OR of 5, 3, 2, and 8 is 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    result = 0\n    for num in arr:\n        result |= num\n    return result\n\ndef g():\n    return [5, 3, 2, 8]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 407,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an m x n matrix, return its transpose.\n\n    The transpose of a matrix is obtained by exchanging the elements of each row with the elements of the corresponding column.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [\n        [1, 4, 7],\n        [2, 5, 8],\n        [3, 6, 9]\n    ]\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    transpose = [[0] * m for _ in range(n)]\n\n    for i in range(m):\n        for j in range(n):\n            transpose[j][i] = matrix[i][j]\n\n    return transpose\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return [matrix]\n\nassert f(*g()) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n",
        "idx_generation": 295,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with the words sorted in lexicographic order.\n\n    Example:\n    Input:\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n\n    Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\"]\n    \"\"\"\n    return sorted(words)\n\ndef g():\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n    return words\n\nassert f(g()) == [\"apple\", \"banana\", \"cherry\", \"date\"]\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n    A subsequence is a sequence that can be derived from another sequence by deleting some\n    or no elements without changing the order of the remaining elements. The LIS is the\n    longest subsequence in which the elements are in increasing order.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return (nums,)\n\nassert f(g()) == True\n",
        "idx_generation": 292,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(arr):\n        if num in complement:\n            return [complement[num], i]\n        complement[target - num] = i\n    return []\n\ndef g():\n    arr = [2, 7, 11, 15]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Find the nth Fibonacci number.\"\"\"\n    def fibonacci(n):\n        if n <= 1:\n            return n\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n) % 2 == 0\n\ndef g():\n    n = 1\n    while True:\n        if f(n):\n            return n\n        n += 1\n\nassert f(g()) == True\n",
        "idx_generation": 169,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, target_length=5) -> bool:\n    \"\"\"\n    Given a string s, find a substring of length target_length that has the most distinct characters.\n    \"\"\"\n    def count_distinct_chars(substring):\n        return len(set(substring))\n\n    def find_max_distinct_chars(s, target_length):\n        max_distinct_chars = 0\n        max_substring = \"\"\n        for i in range(len(s) - target_length + 1):\n            substring = s[i:i+target_length]\n            distinct_chars = count_distinct_chars(substring)\n            if distinct_chars > max_distinct_chars:\n                max_distinct_chars = distinct_chars\n                max_substring = substring\n        return max_substring\n\n    return len(find_max_distinct_chars(s, target_length)) == target_length\n\ndef g(s=\"abracadabra\", target_length=5):\n    return s, target_length\n\nassert f(*g())\n",
        "idx_generation": 71,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_result = nums[i] ^ nums[j]\n            if xor_result > max_xor:\n                max_xor = xor_result\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n",
        "idx_generation": 410,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the value of the binomial coefficient C(n, k) using the mathematical formula.\n\n    Args:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The value of the binomial coefficient C(n, k).\n    \"\"\"\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    return result\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate a tuple of two positive integers for Puzzle 4.\n\n    Returns:\n    Tuple[int, int]: A tuple of two positive integers.\n    \"\"\"\n    return (10, 3)\n\nassert f(*g()) == 120\n",
        "idx_generation": 307,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    Example:\n    Input:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n    \"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    s = \"listen\"\n    t = \"silent\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 494,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that sum up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int) -> bool:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[left] + nums[right]\n            \n            if current_sum == target:\n                return True\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return False\n    \n    return two_sum(nums, target)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\ntarget = 13\nassert f(g(), target) == True\n",
        "idx_generation": 294,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Sample Input:\n    s = \"racecar\"\n\n    Sample Output:\n    True\n    Explanation: The string \"racecar\" is a palindrome.\n\n    Sample Input:\n    s = \"hello\"\n\n    Sample Output:\n    False\n    Explanation: The string \"hello\" is not a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 105,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target=10) -> bool:\n    \"\"\"\n    Determine if there exists a subset of numbers in the given list that add up to the target number.\n    \"\"\"\n    def subset_sum(nums, target, n):\n        if target == 0:\n            return True\n        if n == 0:\n            return False\n        \n        if nums[n-1] > target:\n            return subset_sum(nums, target, n-1)\n        \n        return subset_sum(nums, target, n-1) or subset_sum(nums, target-nums[n-1], n-1)\n    \n    return subset_sum(nums, target, len(nums))\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Find a subset of numbers in the given list that add up to the target number.\n    \"\"\"\n    target = 10\n    \n    def find_subset(nums, target, n, subset):\n        if target == 0:\n            return subset\n        if n == 0 or target < 0:\n            return []\n        \n        if nums[n-1] > target:\n            return find_subset(nums, target, n-1, subset)\n        \n        return find_subset(nums, target, n-1, subset) or find_subset(nums, target-nums[n-1], n-1, subset + [nums[n-1]])\n    \n    return find_subset(nums, target, len(nums), [])\n\nassert f(g()) == True\n",
        "idx_generation": 170,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str, substring='abc', target_count=2) -> bool:\n    \"\"\"Determine if there exists a string that contains a specific substring a certain number of times\"\"\"\n    count = string.count(substring)\n    return count == target_count\n\n\ndef g(substring='abc', target_count=2):\n    return substring * target_count\n\n\nassert f(g()) == True\n",
        "idx_generation": 76,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number that appears only once while all other numbers appear twice.\n\n    Example:\n    Input: [1, 1, 2, 2, 3, 4, 4]\n    Output: 3\n\n    Hint: Use XOR operation to eliminate duplicate numbers.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    return [1, 1, 2, 2, 3, 4, 4]\n\nassert f(g()) == 3\n\n",
        "idx_generation": 411,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the sum of all prime numbers in the list.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    10\n\n    Explanation:\n    In the given list, the prime numbers are 2, 3, and 5.\n    Their sum is 2 + 3 + 5 = 10.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for num in arr:\n        if is_prime(num):\n            prime_sum += num\n    return prime_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that it contains at least one prime number.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 10\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers in ascending order, determine if there are two numbers in the array that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 10\n    The function should return True since 1 + 9 = 10.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 3, 5, 7, 9]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 494,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray where the subarray must contain at least one positive number.\n    Return the maximum sum.\n\n    Example:\n    Input:\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum += num\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n\n    return max_sum\n\ndef g():\n    arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return [arr]\n\nassert f(*g()) == 6\n\n",
        "idx_generation": 295,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "import math\nfrom typing import*\ndef f(arr: List[int], k=3) -> bool:\n    \"\"\"Check if the array has a subarray of length k with a sum equal to the product of its elements.\"\"\"\n    for i in range(len(arr) - k + 1):\n        subarray = arr[i:i + k]\n        if sum(subarray) == math.prod(subarray):\n            return True\n    return False\n\ndef g(k = 3):\n    return [1, 2, 3, 4, 5, 6, 7]\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if the given grid is a valid crossword puzzle solution.\n    \"\"\"\n    def is_valid_row(grid, row):\n        seen = set()\n        for num in grid[row]:\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    \n    def is_valid_column(grid, col):\n        seen = set()\n        for row in range(len(grid)):\n            num = grid[row][col]\n            if num != 0 and num in seen:\n                return False\n            seen.add(num)\n        return True\n    \n    def is_valid_box(grid, start_row, start_col):\n        seen = set()\n        for row in range(start_row, start_row+3):\n            for col in range(start_col, start_col+3):\n                num = grid[row][col]\n                if num != 0 and num in seen:\n                    return False\n                seen.add(num)\n        return True\n    \n    for row in range(len(grid)):\n        if not is_valid_row(grid, row):\n            return False\n    \n    for col in range(len(grid[0])):\n        if not is_valid_column(grid, col):\n            return False\n    \n    for start_row in range(0, len(grid), 3):\n        for start_col in range(0, len(grid[0]), 3):\n            if not is_valid_box(grid, start_row, start_col):\n                return False\n    \n    return True\n\ndef g(grid=[[5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]]):\n    \"\"\"\n    Solve the crossword puzzle and return the grid.\n    \"\"\"\n    def solve_crossword(grid, row, col):\n        if col == len(grid[0]):\n            col = 0\n            row += 1\n        \n        if row == len(grid):\n            return grid\n        \n        if grid[row][col] != 0:\n            return solve_crossword(grid, row, col+1)\n        \n        for num in range(1, 10):\n            if is_valid(grid, row, col, num):\n                grid[row][col] = num\n                if solve_crossword(grid, row, col+1):\n                    return grid\n                grid[row][col] = 0\n        \n        return None\n    \n    def is_valid(grid, row, col, num):\n        for i in range(len(grid)):\n            if grid[i][col] == num:\n                return False\n        \n        for j in range(len(grid[0])):\n            if grid[row][j] == num:\n                return False\n        \n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(3):\n            for j in range(3):\n                if grid[start_row+i][start_col+j] == num:\n                    return False\n        \n        return True\n    \n    return solve_crossword(grid, 0, 0)\n\nassert f(g()) == True\n",
        "idx_generation": 170,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string 'string', determine if it is a palindrome. A palindrome is a string that reads the same forwards\n    and backwards.\n\n    Example:\n    string = \"racecar\"\n    The string is a palindrome, so the function should return True.\n    \"\"\"\n    return string == string[::-1]\n\ndef g(string=\"racecar\"):\n    \"\"\"\n    Generate a palindrome string by appending the reverse of the input 'string' to itself.\n    \"\"\"\n    return string + string[::-1]\n\nassert f(g()) == True\n",
        "idx_generation": 81,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target value, find if there exists a subsequence of the given list such that the bitwise XOR\n    of all the elements in the subsequence is equal to the target value.\n\n    Args:\n    nums (List[int]): The list of numbers.\n    target (int): The target value.\n\n    Returns:\n    bool: True if there exists a subsequence whose bitwise XOR is equal to the target, False otherwise.\n    \"\"\"\n    n = len(nums)\n  \n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n  \n    for i in range(n + 1):\n        dp[i][0] = 1\n  \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n  \n            if nums[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n  \n    return dp[n][target]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, calculate the number of ways to arrange k items from a set of n items with repetition allowed.\n\n    Sample Input:\n    n = 3\n    k = 2\n\n    Sample Output:\n    9\n\n    Explanation:\n    In the given set of 3 items, the possible arrangements of 2 items with repetition allowed are:\n    (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3).\n    Hence, there are 9 ways to arrange 2 items from a set of 3 items with repetition allowed.\n    \"\"\"\n    return n ** k\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two integers n and k such that there are at least k ways to arrange k items from a set of n items with repetition allowed.\n    \"\"\"\n    n = 3\n    k = 2\n    return n, k\n\nassert f(*g()) == 9\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, return True if the target number is present in the list, \n    and False otherwise. Use binary search to optimize the search process.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11, 13, 15], target = 7\n    Output: True\n\n    Explanation:\n    The target number 7 is present in the list [1, 3, 5, 7, 9, 11, 13, 15], hence the output is True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 7)\n",
        "idx_generation": 494,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer,\n    determine if there are three numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 4, 5, 6, 8, 9]\n    target = 20\n\n    The numbers 5, 6, and 9 add up to 20, so the function should return True.\n\n    Hint: Use a combination of sorting and the two-pointer technique to search for the three numbers.\n    \"\"\"\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n        left = i + 1\n        right = len(nums) - 1\n\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            \n            if curr_sum == target:\n                return True\n            elif curr_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g(nums = [1, 4, 5, 6, 8, 9], target = 20):\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 298,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int, a=201717041833890, b=3585167190, upper_bound=731493653565433) -> bool:\n    \"\"\"Find the nth power of a number and check if it is divisible by another number.\"\"\"\n    return (a ** n) % b == 0 and (0 < n <= upper_bound)\n\ndef g(a = 201717041833890, b = 3585167190, upper_bound = 731493653565433):\n    return 2\n\nassert f(g()) == True\n",
        "idx_generation": 108,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(triangle: List[List[int]]) -> int:\n    \"\"\"\n    Given a triangle of integers, find the minimum path sum from the top to the bottom.\n    Each step, you may move to adjacent numbers on the row below.\n\n    Example:\n    triangle = [\n        [2],\n        [3,4],\n        [6,5,7],\n        [4,1,8,3]\n    ]\n\n    Output:\n    11\n\n    Explanation:\n    The minimum path sum from the top to the bottom is 2 + 3 + 5 + 1 = 11.\n\n    \"\"\"\n\n    n = len(triangle)\n    dp = triangle[-1]\n\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1):\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n\n    return dp[0]\n\ndef g():\n    triangle = [\n        [2],\n        [3,4],\n        [6,5,7],\n        [4,1,8,3]\n    ]\n    return triangle\n\nassert f(g()) == 11\n\n",
        "idx_generation": 171,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words.\n\n    Example:\n    s = \"Hello World\"\n\n    Output:\n    \"World Hello\"\n\n    Explanation:\n    The words \"Hello\" and \"World\" are reversed in order.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_sentence = \" \".join(reversed_words)\n    return reversed_sentence\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 84,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements.\n\n    XOR is a binary operation that takes two equal-length binary representations and returns their difference. It is commonly used in cryptography and computer science.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    The output should be 28, which is the maximum XOR value of any two elements in the array.\n\n    Hint: Use bit manipulation and mathematical properties to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in arr:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max_xor ^ prefix) in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 417,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray in the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of any subarray is 4 + (-1) + 2 + 1 = 6.\n    So the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 320,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target integer, determine if there are two numbers in the array that add up to the target.\n\n    Example:\n    Input: arr = [2, 4, 6, 8], target = 10\n    Output: True\n    Explanation: 2 + 8 = 10\n\n    Input: arr = [3, 5, 7, 9], target = 12\n    Output: False\n    Explanation: No two numbers add up to 12.\n    \"\"\"\n    complement_set = set()\n    for num in arr:\n        if num in complement_set:\n            return True\n        complement = target - num\n        complement_set.add(complement)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target integer.\n    \"\"\"\n    arr = [2, 4, 6, 8]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n",
        "idx_generation": 495,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, calculate the amount of water that can be trapped\n    between the buildings.\n\n    The width of each building is 1 and the buildings are assumed to be of equal width.\n\n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n\n    The amount of water that can be trapped is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    n = len(heights)\n    if n < 3:\n        return 0\n    \n    left = 0\n    right = n - 1\n    left_max = 0\n    right_max = 0\n    water = 0\n\n    while left < right:\n        if heights[left] < heights[right]:\n            if heights[left] > left_max:\n                left_max = heights[left]\n            else:\n                water += left_max - heights[left]\n            left += 1\n        else:\n            if heights[right] > right_max:\n                right_max = heights[right]\n            else:\n                water += right_max - heights[right]\n            right -= 1\n    \n    return water\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers representing the heights of buildings.\n    \"\"\"\n    return [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n\nassert f(g()) == 6\n",
        "idx_generation": 301,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Check if a given grid is a valid Sudoku solution.\n\n    A valid Sudoku solution must satisfy the following conditions:\n    1. Each row must contain the digits 1-9 without repetition.\n    2. Each column must contain the digits 1-9 without repetition.\n    3. Each of the 9 3x3 sub-grids (also known as boxes) must contain the digits 1-9 without repetition.\n\n    Example:\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    Output: True\n\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 0, 3, 4, 9],\n        [1, 0, 0, 3, 4, 2, 5, 6, 0],\n        [8, 5, 9, 7, 6, 1, 0, 2, 0],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 0, 1, 5, 3, 7, 2, 1, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 0, 0, 4, 8, 1, 1, 7, 9]\n    ]\n    Output: False\n    \"\"\"\n    def is_valid_row(row):\n        seen = set()\n        for num in row:\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_column(grid, col):\n        seen = set()\n        for row in grid:\n            num = row[col]\n            if num != 0:\n                if num in seen:\n                    return False\n                seen.add(num)\n        return True\n\n    def is_valid_box(grid, start_row, start_col):\n        seen = set()\n        for i in range(3):\n            for j in range(3):\n                num = grid[start_row + i][start_col + j]\n                if num != 0:\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        return True\n\n    for i in range(9):\n        if not is_valid_row(grid[i]):\n            return False\n\n    for j in range(9):\n        if not is_valid_column(grid, j):\n            return False\n\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not is_valid_box(grid, i, j):\n                return False\n\n    return True\n\ndef g():\n    grid = [\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ]\n    return grid\n\nassert f(g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Sample Input:\n    nums = [1, 2, 3, 1]\n\n    Sample Output:\n    4\n\n    Explanation:\n    The maximum sum of a subarray with no adjacent numbers is obtained by selecting [1, 3], which gives a sum of 4.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 1]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 172,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Sample Input:\n    s = \"Hello World\"\n\n    Sample Output:\n    \"World Hello\"\n\n    Explanation:\n    The words \"Hello\" and \"World\" are reversed in order.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 87,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the bitwise complement of the corresponding element in the original list.\n    \"\"\"\n    return [~x for x in arr]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [-2, -3, -4, -5, -6]\n\n",
        "idx_generation": 418,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if it is a magic square.\n    A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n\n    Example:\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n\n    Output:\n    True\n\n    Explanation:\n    The sum of each row, each column, and each diagonal is 15 (2 + 7 + 6 = 15, 9 + 5 + 1 = 15, 4 + 3 + 8 = 15, 2 + 5 + 8 = 15, 4 + 5 + 6 = 15).\n    Therefore, the matrix is a magic square.\n\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Checking rows\n    for i in range(n):\n        if sum(matrix[i]) != target_sum:\n            return False\n\n    # Checking columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Checking diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    matrix = [\n        [2, 7, 6],\n        [9, 5, 1],\n        [4, 3, 8]\n    ]\n    return matrix\n\nassert f(g()) == True\n\n",
        "idx_generation": 337,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if there are two numbers in the list that add up to the target, and False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14\n    Output: True\n\n    Explanation:\n    The numbers 4 and 10 add up to the target value of 14.\n    Hence, the output is True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where there are two numbers in the list that add up to the target.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g()) == True\n\n\n",
        "idx_generation": 495,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is found at index 2 in the list.\n    \"\"\"\n\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a list of words that match the given pattern.\n\n    A word matches the pattern if there exists a one-to-one mapping of letters in the word to letters in the pattern,\n    and the mapping is unique (i.e., no two letters in the word map to the same letter in the pattern).\n\n    Example:\n    words = [\"abc\", \"deq\", \"mee\", \"aqq\", \"dkd\", \"ccc\"]\n    pattern = \"abb\"\n    Output: [\"mee\", \"aqq\"]\n\n    words = [\"abc\", \"deq\", \"mee\", \"aqq\", \"dkd\", \"ccc\"]\n    pattern = \"ccd\"\n    Output: [\"ccc\"]\n    \"\"\"\n    def is_match(word, pattern):\n        if len(word) != len(pattern):\n            return False\n\n        mapping_word = {}\n        mapping_pattern = {}\n\n        for i in range(len(word)):\n            char_word = word[i]\n            char_pattern = pattern[i]\n\n            if char_word not in mapping_word:\n                mapping_word[char_word] = char_pattern\n            else:\n                if mapping_word[char_word] != char_pattern:\n                    return False\n\n            if char_pattern not in mapping_pattern:\n                mapping_pattern[char_pattern] = char_word\n            else:\n                if mapping_pattern[char_pattern] != char_word:\n                    return False\n\n        return True\n\n    result = []\n    for word in words:\n        if is_match(word, pattern):\n            result.append(word)\n\n    return result\n\ndef g():\n    words = [\"abc\", \"deq\", \"mee\", \"aqq\", \"dkd\", \"ccc\"]\n    pattern = \"abb\"\n    return words, pattern\n\nassert f(*g()) == [\"mee\", \"aqq\"]\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: [-2,1,-3,4,-1,2,1,-5,4]\n    Output: 6\n\n    Explanation:\n    The contiguous subarray [4,-1,2,1] has the largest sum = 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [-2,1,-3,4,-1,2,1,-5,4]\n\nassert f(g()) == 6\n",
        "idx_generation": 174,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words.\n\n    Example:\n    s = \"Hello, world!\"\n    Output: \"world! Hello,\"\"\n    \"\"\"\n    def reverse_words(s):\n        words = s.split()\n        reversed_words = words[::-1]\n        return ' '.join(reversed_words)\n\n    return reverse_words(s)\n\ndef g():\n    s = \"Hello, world!\"\n    return s\n\nassert f(g()) == \"world! Hello,\"\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the maximum XOR value between them.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between any two numbers in the array is 28, which can be obtained by XORing the numbers 25 and 5.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 420,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return a list of the first n prime numbers that have exactly k digits.\n\n    Sample Input:\n    n = 5\n    k = 3\n\n    Sample Output:\n    [101, 103, 107, 109, 113]\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    prime_nums = []\n    num = 10 ** (k - 1)  # Start with the first number that has k digits\n    while len(prime_nums) < n:\n        if is_prime(num):\n            prime_nums.append(num)\n        num += 1\n    return prime_nums\n\ndef g(n=5, k=3):\n    return n, k\n\nassert f(*g()) == [101, 103, 107, 109, 113]\n",
        "idx_generation": 357,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value between any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 7, 11, 15]\n    Output: 4\n\n    Explanation: The minimum XOR value is obtained by taking the XOR of 3 and 7, which is equal to 4.\n    \"\"\"\n\n    min_xor = float('inf')\n\n    nums.sort()\n\n    for i in range(len(nums) - 1):\n        xor_val = nums[i] ^ nums[i+1]\n        min_xor = min(min_xor, xor_val)\n\n    return min_xor\n\ndef g() -> List[int]:\n    nums = [3, 7, 11, 15]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 496,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 308,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a pair of numbers whose sum is equal to a power of 2.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    True\n    Explanation: The sum of 1 and 3 is 4, which is equal to 2^2.\n\n    Sample Input:\n    nums = [5, 6, 7, 8]\n\n    Sample Output:\n    False\n    Explanation: There is no pair of numbers whose sum is equal to a power of 2.\n    \"\"\"\n    powers_of_2 = set()\n    for i in range(32):\n        powers_of_2.add(2 ** i)\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + nums[j] in powers_of_2:\n                return True\n    return False\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == True\n",
        "idx_generation": 111,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n    \"\"\"\n    def max_subarray_sum(nums: List[int], start: int, end: int) -> int:\n        if start == end:\n            return nums[start]\n        \n        mid = (start + end) // 2\n        left_sum = max_subarray_sum(nums, start, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, end)\n        cross_sum = max_cross_sum(nums, start, mid, end)\n        \n        return max(left_sum, right_sum, cross_sum)\n    \n    def max_cross_sum(nums: List[int], start: int, mid: int, end: int) -> int:\n        left_sum = float('-inf')\n        curr_sum = 0\n        \n        for i in range(mid, start - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        \n        for i in range(mid + 1, end + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n\n    return max_subarray_sum(nums, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 176,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(string_list: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, return the longest string.\n\n    Example:\n    string_list = [\"apple\", \"banana\", \"cherry\", \"durian\"]\n\n    Output:\n    \"banana\"\n\n    Explanation:\n    The longest string in the list is \"banana\".\n    \"\"\"\n\n    longest_string = \"\"\n    for string in string_list:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string\n\ndef g():\n    string_list = [\"apple\", \"banana\", \"cherry\", \"durian\"]\n    return string_list\n\nassert f(g()) == \"banana\"\n",
        "idx_generation": 89,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists a pair of elements in the list whose bitwise OR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 2 and 4 have bitwise OR of 6, which is equal to the target value 6.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_or = nums[i] | nums[j]\n\n            if curr_or == target:\n                return True\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n\n",
        "idx_generation": 421,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element at index i of the new list is the product\n    of all the numbers in the original list except the one at i.\n\n    Example:\n    arr = [1, 2, 3, 4]\n\n    The function should return [24, 12, 8, 6], since\n    - 24 = 2 * 3 * 4\n    - 12 = 1 * 3 * 4\n    - 8 = 1 * 2 * 4\n    - 6 = 1 * 2 * 3\n    \"\"\"\n    n = len(arr)\n    prefix_products = [1] * n\n    suffix_products = [1] * n\n\n    for i in range(1, n):\n        prefix_products[i] = prefix_products[i-1] * arr[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix_products[i] = suffix_products[i+1] * arr[i+1]\n\n    result = [0] * n\n    for i in range(n):\n        result[i] = prefix_products[i] * suffix_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4]\n    return arr\n\nassert f(g()) == [24, 12, 8, 6]\n",
        "idx_generation": 360,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums, find the index of the target value using binary search.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 8\n    Output: 3\n    Explanation: The target value 8 is found at index 3 in the list.\n\n    Note:\n    - You may assume that the list is sorted in ascending order.\n    - If the target value is not found, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10], 8\n\nassert f(*g()) == 3\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n    \"\"\"\n    n = len(arr)\n    prefix_sums = [0] * n\n\n    prefix_sums[0] = arr[0]\n    for i in range(1, n):\n        prefix_sums[i] = prefix_sums[i - 1] + arr[i]\n\n    return prefix_sums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n",
        "idx_generation": 312,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the sum of each row in the given matrix and return the list of sums.\n    \"\"\"\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums\n\ndef g(matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == [6, 15, 24]\n\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 179,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Sample Input:\n    s = \"Hello World\"\n\n    Sample Output:\n    \"World Hello\"\n    \"\"\"\n    def reverse_words(s):\n        words = s.split()\n        words.reverse()\n        return \" \".join(words)\n    \n    return reverse_words(s)\n\ndef g():\n    return \"Hello World\"\n\nassert f(g()) == \"World Hello\"\n",
        "idx_generation": 94,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    False\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if the given number is a perfect square.\"\"\"\n\n    def is_perfect_square(n: int) -> bool:\n        sqrt_n = int(n ** 0.5)\n        return sqrt_n * sqrt_n == n\n\n    return is_perfect_square(n)\n\ndef g() -> int:\n    \"\"\"\n    Find the smallest perfect square greater than or equal to 1000.\n    \"\"\"\n\n    i = 32\n    while i * i < 1000:\n        i += 1\n\n    return i * i\n    \nassert f(g())\n",
        "idx_generation": 364,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list.\n    If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2, since the target number 5 is at index 2.\n\n    If the target number is not found in the list, for example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    The function should return -1, since the target number 10 is not found in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return (nums, target)\n\nassert f(*g()) == 2\n",
        "idx_generation": 497,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, calculate the number of inversions in the list.\n\n    An inversion occurs when there are two elements i and j such that i < j and arr[i] > arr[j].\n\n    Sample Input:\n    arr = [1, 3, 2, 4, 5]\n\n    Sample Output:\n    1\n\n    Explanation:\n    In the given list, the pair (3, 2) is an inversion since 3 > 2.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers such that it contains at least one inversion.\n    \"\"\"\n    return [1, 3, 2, 4, 5]\n\nassert f(g()) == 1\n",
        "idx_generation": 314,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum = 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and three integers n, m, and k, determine if it is possible to select n integers from nums\n    such that their sum is divisible by m and the number of selected integers is greater than or equal to k.\n\n    Args:\n    - n: the number of integers to select\n    - m: the divisor\n    - k: the minimum number of selected integers\n    - nums: the list of integers\n\n    Returns:\n    - True if it is possible to select n integers from nums such that their sum is divisible by m and the number of selected integers is greater than or equal to k, False otherwise\n    \"\"\"\n    def helper(nums, n, m, k, curr_sum, count):\n        if curr_sum % m == 0 and count >= k:\n            return True\n        if n == 0:\n            return False\n        if len(nums) == 0:\n            return False\n        \n        return helper(nums[1:], n-1, m, k, curr_sum+nums[0], count+1) or helper(nums[1:], n, m, k, curr_sum, count)\n    \n    return helper(nums, n, m, k, 0, 0)\n\ndef g():\n    n = 3\n    m = 5\n    k = 2\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return n, m, k, nums\n\nassert f(*g()) == True\n\n",
        "idx_generation": 181,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, pattern='abc') -> bool:\n    \"\"\"\n    Given a string s and a pattern, check if the pattern exists in s.\n    The pattern can contain any characters and can have multiple occurrences of the same character.\n\n    Sample input:\n    s = \"abacabadabacaba\"\n    pattern = \"aba\"\n\n    Sample output:\n    True\n\n    Explanation: The pattern \"aba\" exists in the string \"abacabadabacaba\".\n    \"\"\"\n    return pattern in s\ndef g(pattern='abc'):\n    return pattern\nassert f(g()) == True\n",
        "idx_generation": 96,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number that appears only once while all other numbers appear twice.\n    Return the number that appears only once.\n\n    Sample Input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample Output:\n    3\n\n    Explanation:\n    The number 3 appears only once while all other numbers (1, 2) appear twice.\n    \"\"\"\n\n    result = 0\n\n    for num in nums:\n        result ^= num\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == 3\n",
        "idx_generation": 430,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that is a prime number.\n    \"\"\"\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 375,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the indices of two numbers such that they add up to the target.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    The function should return (0, 1) since arr[0] + arr[1] = 2 + 7 = 9.\n    \"\"\"\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return (-1, -1)\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return (arr, target)\n\nassert f(*g()) == (0, 1)\n",
        "idx_generation": 499,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[n-1]\n\ndef g():\n    # The list of integers\n    nums = [1, 2, 3, 1, 5, 6, 7]\n    \n    return nums\n\nassert f(g()) == 16\n\n",
        "idx_generation": 316,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    # Create a dictionary to store the complement of each number\n    complement_dict = {}\n\n    # Iterate through the list of numbers\n    for i, num in enumerate(nums):\n        # Check if the complement of the current number exists in the dictionary\n        if num in complement_dict:\n            # Return the indices of the two numbers that add up to the target\n            return [complement_dict[num], i]\n        else:\n            # Calculate the complement of the current number\n            complement = target - num\n            # Store the complement and its index in the dictionary\n            complement_dict[complement] = i\n\n    # Return an empty list if no two numbers add up to the target\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 119,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    Input: [2, 3, -2, 4]\n    Output: 6\n    Explanation:\n    - The maximum product of a subarray in the given list is 6, which corresponds to the subarray [2, 3].\n    \"\"\"\n\n    def max_product_subarray(nums):\n        max_product = float('-inf')\n        curr_max = curr_min = 1\n\n        for num in nums:\n            if num < 0:\n                curr_max, curr_min = curr_min, curr_max\n\n            curr_max = max(num, curr_max * num)\n            curr_min = min(num, curr_min * num)\n\n            max_product = max(max_product, curr_max)\n\n        return max_product\n\n    return max_product_subarray(nums)\n\ndef g():\n    nums = [2, 3, -2, 4]\n    return nums\n\nassert f(g()) == 6\n\n",
        "idx_generation": 182,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string and an integer k, determine if it is possible to rearrange the characters of the string such that no two adjacent characters are the same and the string doesn't contain any substring of length k with all the same characters.\n    \"\"\"\n    if k == 1:\n        return True\n\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    max_freq = max(char_count.values())\n    max_possible_count = (len(s) + k - 1) // k\n\n    return max_freq <= max_possible_count\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return (\"aabbcc\", 2)\n\nassert f(*g()) == True\n",
        "idx_generation": 97,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Example:\n    n = 2\n    grid = [[1, 2], [3, 4]]\n\n    The maximum XOR value that can be obtained is 7 by selecting 1 from the first row, 2 from the second row, 3 from the first column, and 4 from the second column.\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(n):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 2, [[1, 2], [3, 4]]\n\nassert f(*g()) == 7\n",
        "idx_generation": 432,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all even numbers less than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n % 2 != 0:\n        n -= 1\n    return n * (n + 2) // 4\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n for finding the sum of all even numbers less than or equal to n.\n    \"\"\"\n    return 10\n\nassert f(g()) == 30\n",
        "idx_generation": 375,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers 'nums' in ascending order and a target value 'target',\n    find the index of the target value if it exists in the list. If it does not exist,\n    return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 7\n\n    The target value 7 is present in the list at index 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 7, 9]\n    return nums\n\nassert f(g(), 7) == 3\n",
        "idx_generation": 116,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exists a pair of numbers in the list that sum up to the target\"\"\"\n    def two_sum(nums: List[int], target: int, start: int, end: int) -> bool:\n        if start >= end:\n            return False\n        if nums[start] + nums[end] == target:\n            return True\n        if nums[start] + nums[end] < target:\n            return two_sum(nums, target, start + 1, end)\n        else:\n            return two_sum(nums, target, start, end - 1)\n    \n    nums.sort()\n    return two_sum(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"Generate a list of integers and a target sum\"\"\"\n    return ([3, 5, 1, 2, 4], 7)\n\nassert f(*g()) == True\n",
        "idx_generation": 317,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g(start=1):\n    \"\"\"\n    Generate the next prime number starting from a given number.\n    \"\"\"\n    i = start + 1\n    while True:\n        if f(i):\n            return i\n        i += 1\n        \nassert f(g()) == True\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a non-empty subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, -2, 3, -4, 5, -6]\n\nassert f(g()) == 5\n\n",
        "idx_generation": 185,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s\n    can be replaced to get t.\n\n    Example:\n    s = \"egg\"\n    t = \"add\"\n    output: True\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    mapping_s = {}\n    mapping_t = {}\n    for i in range(len(s)):\n        if s[i] in mapping_s:\n            if mapping_s[s[i]] != t[i]:\n                return False\n        else:\n            mapping_s[s[i]] = t[i]\n        if t[i] in mapping_t:\n            if mapping_t[t[i]] != s[i]:\n                return False\n        else:\n            mapping_t[t[i]] = s[i]\n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g()) == True\n",
        "idx_generation": 99,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    nums = [3, 5, 10, 8, 2]\n\n    The maximum XOR value that can be obtained is 15 by selecting 3 and 10.\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [3, 5, 10, 8, 2]\n\nassert f(g()) == 15\n",
        "idx_generation": 432,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "import math\nfrom typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if a given positive integer n is a perfect square.\n\n    Example:\n    n = 25\n\n    25 is a perfect square since 5^2 = 25.\n\n    Therefore, the function should return True.\n\n    Hint: Use mathematical properties of perfect squares.\n    \"\"\"\n    if n < 0:\n        return False\n\n    sqrt = int(n ** 0.5)\n    return sqrt * sqrt == n\n\ndef g():\n    n = 25\n    return n\n\nassert f(g())\n",
        "idx_generation": 387,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return the index where it would be if it were inserted in order.\n    \n    Sample Input:\n    nums = [1, 3, 5, 6]\n    target = 2\n    \n    Sample Output:\n    1\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n\ndef g():\n    nums = [1, 3, 5, 6]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 1\n",
        "idx_generation": 117,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers arr and a target value, check if there exists a pair of elements in the list whose sum is equal to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n    Explanation: The sum of arr[2] = 3 and arr[4] = 5 is equal to the target value of 7.\n\n    Input: arr = [1, 2, 3, 4, 5], target = 10\n    Output: False\n    Explanation: There are no two elements in the list whose sum is equal to the target value of 10.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 7)\n\nassert f(*g()) == True\n",
        "idx_generation": 323,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, transpose it.\n\n    Sample Input:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Sample Output:\n    [[1, 4, 7],\n     [2, 5, 8],\n     [3, 6, 9]]\n    \"\"\"\n    return [list(col) for col in zip(*matrix)]\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of ways to climb to the top of a staircase with n steps.\n    You can climb 1 or 2 steps at a time.\n\n    Example:\n    Input: 3\n    Output: 3\n    Explanation: There are three ways to climb to the top:\n    1) 1 step + 1 step + 1 step\n    2) 1 step + 2 steps\n    3) 2 steps + 1 step\n    \"\"\"\n    if n <= 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g():\n    return 3\n\nassert f(g()) == 3\n",
        "idx_generation": 192,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string of lowercase letters, determine if it is a palindrome when read both forwards and backwards.\n\n    Sample Input:\n    s = \"racecar\"\n\n    Sample Output:\n    True\n    Explanation: The string \"racecar\" is a palindrome.\n\n    Sample Input:\n    s = \"python\"\n\n    Sample Output:\n    False\n    Explanation: The string \"python\" is not a palindrome.\n    \"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 100,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 3.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Return a new list where each element is the product of all the elements in the original list except itself.\n    \"\"\"\n    n = len(nums)\n    output = [1] * n\n    left_product = 1\n    right_product = 1\n\n    for i in range(n):\n        output[i] *= left_product\n        left_product *= nums[i]\n\n    for i in range(n - 1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n\n    return output\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\n\nassert f(g()) == [120, 60, 40, 30, 24]\n",
        "idx_generation": 393,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the index if the target is found.\n    If not, return -1.\n    \n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 4\n    \n    Sample Output:\n    -1\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 4\n    return nums, target\n\nassert f(*g()) == -1\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the number of occurrences of the target in the list.\n    Return the count of occurrences.\n\n    Example:\n    Input: nums = [1, 2, 2, 3, 3, 3, 4, 5], target = 3\n    Output: 3\n\n    Explanation: The target value 3 appears 3 times in the list.\n\n    Note: You must use binary search to solve this problem.\n    \"\"\"\n\n    def binary_search_left(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return right\n\n    left_index = binary_search_left(nums, target)\n    right_index = binary_search_right(nums, target)\n\n    return right_index - left_index + 1\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 3, 3, 3, 4, 5]\n    target = 3\n    return (nums, target)\n\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 327,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n    \n    Sample Input:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    \n    Sample Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    result = []\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n            \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\ndef g():\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The maximum subarray sum is [4, -1, 2, 1], which gives a sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n",
        "idx_generation": 192,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome after removing the minimum number of characters.\"\"\"\n    stack = []\n    for c in s:\n        if stack and stack[-1] == c:\n            stack.pop()\n        else:\n            stack.append(c)\n    return len(stack) <= 1\ndef g():\n    return \"abccba\"\nassert f(g()) == True\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n    Explanation: The maximum XOR value is achieved by combining the numbers 5 and 25, which gives 28 (10101 ^ 11001 = 01100).\n\n    Sample Input:\n    nums = [0, 1, 2, 3, 4, 5]\n\n    Sample Output:\n    7\n    Explanation: The maximum XOR value is achieved by combining the numbers 3 and 4, which gives 7 (0011 ^ 0100 = 0111).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if temp_max ^ prefix in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor\n\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == 28\n",
        "idx_generation": 436,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the sum of all positive integers less than or equal to n.\n\n    Example:\n    n = 5\n\n    Output: 15 (1 + 2 + 3 + 4 + 5 = 15)\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == 15\n\n",
        "idx_generation": 395,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target value.\n\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    Sample Output:\n    True\n    Explanation: The numbers 2 and 10 add up to the target value 12.\n\n    Sample Input:\n    nums = [1, 3, 5, 7, 9]\n    target = 12\n\n    Sample Output:\n    False\n    Explanation: There are no two numbers in the list that add up to the target value 12.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return False\ndef g(nums = [2, 4, 6, 8, 10], target = 12):\n    return sorted(nums), target\nassert f(*g())\n",
        "idx_generation": 117,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any rectangle submatrix. The submatrix can be of any size and must be contiguous.\n\n    Return the maximum sum.\n\n    Example:\n    matrix = [[1, 2, -1, -4, -20],\n              [-8, -3, 4, 2, 1],\n              [3, 8, 10, 1, 3],\n              [-4, -1, 1, 7, -6]]\n\n    The maximum sum of any rectangle submatrix is 29, which can be obtained from the submatrix [[10, 1, 3],\n                                                                                              [1, 7, -6]].\n\n    Therefore, the function should return 29.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        temp = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                temp[i] += matrix[i][right]\n            curr_sum = kadane(temp)\n            max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef kadane(arr: List[int]) -> int:\n    max_sum = arr[0]\n    curr_sum = arr[0]\n    for i in range(1, len(arr)):\n        curr_sum = max(arr[i], curr_sum + arr[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [[1, 2, -1, -4, -20],\n            [-8, -3, 4, 2, 1],\n            [3, 8, 10, 1, 3],\n            [-4, -1, 1, 7, -6]]\n\nassert f(g()) == 29\n",
        "idx_generation": 327,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 128,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindromic substring in s.\n    A palindromic substring is a substring that reads the same forwards and backwards.\n\n    Example:\n    s = \"babad\"\n\n    Output:\n    3\n\n    Explanation:\n    The longest palindromic substring in \"babad\" is \"bab\" or \"aba\", which has a length of 3.\n    \"\"\"\n\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    longest_palindrome = 1\n\n    for i in range(n):\n        dp[i][i] = True\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if length == 2:\n                dp[i][j] = (s[i] == s[j])\n            else:\n                dp[i][j] = (s[i] == s[j] and dp[i + 1][j - 1])\n\n            if dp[i][j]:\n                longest_palindrome = max(longest_palindrome, length)\n\n    return longest_palindrome\n\ndef g():\n    s = \"babad\"\n    return s\n\nassert f(g()) == 3\n",
        "idx_generation": 193,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom collections import deque\n\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome when ignoring spaces and punctuation.\"\"\"\n    s = ''.join(char.lower() for char in s if char.isalpha())\n    return s == s[::-1]\n\ndef g():\n    return 'A man, a plan, a canal, Panama!'\n\nassert f(g()) == True\n",
        "idx_generation": 103,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums, every element appears twice except for one. Find that single one.\n\n    Example:\n    Input: nums = [4,1,2,1,2]\n    Output: 4\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g() -> List[int]:\n    nums = [4, 1, 2, 1, 2]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 440,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of trailing zeroes in n!.\n\n    Example:\n    Input: n = 10\n    Output: 2\n\n    Explanation: 10! = 3628800, which has 2 trailing zeroes.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == 2\n",
        "idx_generation": 396,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of two numbers from nums that add up to the target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    Output: [2, 7]\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [nums[left], nums[right]]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [2, 7]\n",
        "idx_generation": 119,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\n    If target is not found in the array, return [-1, -1].\n    You must write an algorithm with O(log n) runtime complexity.\n    \n    Example:\n    Input: nums = [5,7,7,8,8,10], target = 8\n    Output: [3,4]\n    \"\"\"\n    def find_leftmost(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] == target:\n            return left\n        else:\n            return -1\n    \n    def find_rightmost(nums, target):\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        if nums[right] == target:\n            return right\n        else:\n            return -1\n    \n    leftmost = find_leftmost(nums, target)\n    rightmost = find_rightmost(nums, target)\n    \n    return [leftmost, rightmost]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return (nums, target)\n\nassert f(*g()) == [1, 3]\n",
        "idx_generation": 328,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return their indices in ascending order.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g(arr = [2, 7, 11, 15], target = 9):\n    return arr, target\n\nassert f(*g()) == [0, 1]\n",
        "idx_generation": 131,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n    An increasing subsequence is a subsequence where the elements are in increasing order.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence in [10, 9, 2, 5, 3, 7, 101, 18] is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 193,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(x: str, n=3, s='abc') -> bool:\n    \"\"\"Check if the given string is a palindrome after removing all occurrences of the character 's' and reversing the remaining string.\"\"\"\n    x = x.replace(s, \"\")\n    return x == x[::-1]\n\ndef g(n = 3, s = 'abc'):\n    return s * int(math.pow(n, 2))\n\nassert f(g()) == True\n",
        "idx_generation": 106,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum bitwise XOR value can be achieved by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum bitwise XOR value of any two elements is known.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n",
        "idx_generation": 440,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n    Return the sum.\n\n    Example:\n    n = 5\n    The first 5 natural numbers are 1, 2, 3, 4, 5.\n    The sum is 1 + 2 + 3 + 4 + 5 = 15.\n    Therefore, the function should return 15.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 415,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, find if there exists two numbers in the array such that their sum is equal to k.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        \n        if curr_sum == k:\n            return True\n        elif curr_sum < k:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(arr = [1, 3, 5, 7, 9], k = 12):\n    return arr, k\n\nassert f(*g())\n",
        "idx_generation": 120,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 328,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with at most two elements.\n    Return the maximum sum.\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        return 0\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            current_sum = nums[i] + nums[j]\n            max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef g(nums: List[int]) -> int:\n    \"\"\"\n    Generate a list of integers such that the maximum sum of a subarray with at most two elements is achieved.\n    \"\"\"\n    return nums\n\n# Test case\nnums = [1, 2, 3, 4, 5]\nassert f(g(nums)) == 9\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of distinct binary strings of length n\n    that do not contain consecutive 1s.\n\n    Example:\n    f(3) = 5\n    \"\"\"\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3\n\n    dp = [0] * (n + 1)\n    dp[1] = 2\n    dp[2] = 3\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return n\n\nassert f(g(4)) == 8\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Check if two strings s and t are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n    Each character in s can be replaced with any other character (including itself) in t,\n    but the replacement must be one-to-one, and no two characters in s can be replaced by the same character in t.\n\n    Example:\n    s = \"egg\", t = \"add\"\n    Output: True\n\n    s = \"foo\", t = \"bar\"\n    Output: False\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    mapping_s = {}\n    mapping_t = {}\n\n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n\n        if char_s not in mapping_s:\n            mapping_s[char_s] = char_t\n        else:\n            if mapping_s[char_s] != char_t:\n                return False\n\n        if char_t not in mapping_t:\n            mapping_t[char_t] = char_s\n        else:\n            if mapping_t[char_t] != char_s:\n                return False\n\n    return True\n\ndef g():\n    s = \"egg\"\n    t = \"add\"\n    return s, t\n\nassert f(*g())\n",
        "idx_generation": 107,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of elements that have their binary representation\n    ending with the digit 1.\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num & 1 == 1:\n            count += 1\n    return count\n\ndef g():\n    numbers = [5, 6, 7, 8, 9]\n    return numbers\n\nassert f(g()) == 3\n\n",
        "idx_generation": 446,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(lst: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the input list.\n\n    Example:\n    lst = [1, 2, 3, 4, 5]\n\n    The output should be [1, 3, 6, 10, 15] since the first element remains the same, the second element is the sum of the first element (1) and the second element (2), the third element is the sum of the first three elements (1 + 2 + 3), and so on.\n\n    Hint: Use the concept of prefix sum and a stack or queue to store the previous elements.\n    \"\"\"\n    prefix_sum = []\n    total = 0\n    for num in lst:\n        total += num\n        prefix_sum.append(total)\n    return prefix_sum\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n",
        "idx_generation": 417,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, check if there exists a pair of numbers whose sum is equal to the target.\n\n    Sample Input:\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 8\n\n    Sample Output:\n    True\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            low += 1\n        else:\n            high -= 1\n\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5, 6], target = 8):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 121,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums, and a target value, find the index of the target in the list using binary search.\n    If the target is not found in the list, return -1.\n\n    Example:\n    Input: nums = [-2, 0, 5, 9, 12, 15], target = 9\n    Output: 3 (The target value 9 is found at index 3)\n\n    Hint: Use the binary search algorithm to divide the search space in half at each step.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [-2, 0, 5, 9, 12, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 332,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, calculate the sum of all even numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5, 6]\n    Output: 12\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num % 2 == 0:\n            total += num\n    return total\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n",
        "idx_generation": 133,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the length of the longest snake sequence.\n    A snake sequence is a sequence of adjacent cells in the grid that are in either increasing or decreasing order.\n\n    Return the length of the longest snake sequence.\n\n    Example:\n    f([\n        ['1', '2', '3'],\n        ['2', '3', '4'],\n        ['3', '2', '1']\n    ]) => 5\n    \"\"\"\n    if not grid:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[1] * n for _ in range(m)]\n\n    max_length = 1\n\n    for i in range(m):\n        for j in range(n):\n            if i > 0 and abs(ord(grid[i][j]) - ord(grid[i - 1][j])) == 1:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n                max_length = max(max_length, dp[i][j])\n            if j > 0 and abs(ord(grid[i][j]) - ord(grid[i][j - 1])) == 1:\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n                max_length = max(max_length, dp[i][j])\n\n    return max_length\n\ndef g(grid: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Generate a grid of characters.\n    \"\"\"\n    return grid\n\nassert f(g([\n    ['1', '2', '3'],\n    ['2', '3', '4'],\n    ['3', '2', '1']\n])) == 5\n",
        "idx_generation": 198,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the number of vowels (a, e, i, o, u) present in the string.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    \n    return count\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that contains a certain number of vowels.\n    \"\"\"\n    return \"aeiouaeiou\"\n\nassert f(g()) == 10\n",
        "idx_generation": 112,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the missing number in the range from 0 to n.\n    The list contains all the numbers from 0 to n except for one.\n\n    Example:\n    Input: [3, 0, 1]\n    Output: 2 (The missing number is 2)\n\n    Hint: Use the XOR operator to find the missing number efficiently.\n    \"\"\"\n    missing = len(nums)\n\n    for i, num in enumerate(nums):\n        missing ^= i ^ num\n\n    return missing\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [3, 0, 1]\n\nassert f(g()) == 2\n\n",
        "idx_generation": 453,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n using the formula (n * (n + 1)) / 2.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 55\n\n",
        "idx_generation": 418,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if there exists a pair of numbers in the given list, whose sum is equal to the target number.\n    The given list is sorted in ascending order.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g(nums=[1, 3, 5, 7, 9], target=10):\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and an integer k, rotate the list to the right by k steps.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3\n    Output: [5, 6, 7, 1, 2, 3, 4]\n\n    Hint: Use the concept of cyclic rotations and modular arithmetic to optimize the solution.\n    \"\"\"\n    n = len(nums)\n    k %= n\n    nums[:] = nums[n-k:] + nums[:n-k]\n    return nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7]\n    k = 3\n    return nums, k\n\nassert f(*g()) == [5, 6, 7, 1, 2, 3, 4]\n\n",
        "idx_generation": 332,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"Check if the given string can be divided into k equal parts.\"\"\"\n    if len(s) % k != 0:\n        return False\n    part_length = len(s) // k\n    for i in range(0, len(s), part_length):\n        if s[i:i+part_length] != s[:part_length]:\n            return False\n    return True\n\ndef g():\n    return \"abcabcabc\", 3\n\nassert f(*g())\n",
        "idx_generation": 135,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest arithmetic subsequence in nums.\n    An arithmetic subsequence is a subsequence where the difference between consecutive elements is the same.\n\n    Return the length of the longest arithmetic subsequence.\n\n    Example:\n    nums = [3, 6, 9, 12]\n\n    f(nums) => 4\n    Explanation: The longest arithmetic subsequence is [3, 6, 9, 12].\n    \"\"\"\n\n    dp = {}  # store the length of longest arithmetic subsequence ending at each index\n\n    for i in range(len(nums)):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            dp[i, diff] = dp.get((j, diff), 1) + 1\n\n    return max(dp.values())\n\ndef g():\n    nums = [3, 6, 9, 12]\n    return (nums,)\n\nassert f(*g()) == 4\n",
        "idx_generation": 201,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, determine if it is a palindrome.\n    \"\"\"\n    s = s.lower()\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting three numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value that can be obtained by selecting three numbers from the list is 31, which can be obtained by XORing the numbers 25, 5, and 1.\n\n    Therefore, the function should return 31.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                xor = nums[i] ^ nums[j] ^ nums[k]\n                max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 31\n",
        "idx_generation": 461,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [1, 3, 6, 10, 15]\n\n    Explanation:\n    The output list is obtained by taking the cumulative sum of the elements in the input list.\n    The first element in the output list is the same as the first element in the input list.\n    The second element in the output list is the sum of the first two elements in the input list.\n    The third element in the output list is the sum of the first three elements in the input list.\n    And so on...\n    \"\"\"\n\n    cumulative_sum = []\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        cumulative_sum.append(current_sum)\n\n    return cumulative_sum\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return (nums,)\n\nassert f(*g()) == [1, 3, 6, 10, 15]\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list in ascending order using the insertion sort algorithm.\n    \"\"\"\n    for i in range(1, len(nums)):\n        key = nums[i]\n        j = i - 1\n        while j >= 0 and nums[j] > key:\n            nums[j + 1] = nums[j]\n            j -= 1\n        nums[j + 1] = key\n    \n    return nums\n\ndef g(nums=[9, 5, 7, 3, 1]):\n    return nums\n\nassert f(g()) == [1, 3, 5, 7, 9]\n",
        "idx_generation": 122,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list.\n\n    Args:\n        arr: A sorted list of integers.\n        target: The target value to search for.\n\n    Returns:\n        The number of occurrences of the target value in the list.\n\n    Example:\n        Input: arr = [1, 2, 2, 2, 3, 4, 5, 5, 6], target = 2\n        Output: 3\n    \"\"\"\n\n    def binary_search_left(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def binary_search_right(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n\n    left_index = binary_search_left(arr, target)\n    right_index = binary_search_right(arr, target)\n\n    return right_index - left_index + 1\n\ndef g():\n    return [1, 2, 2, 2, 3, 4, 5, 5, 6], 2\n\nassert f(*g()) == 3\n\n",
        "idx_generation": 334,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of pairs in the list that add up to the target.\n    \"\"\"\n    count = 0\n    num_dict = {}\n    for num in nums:\n        complement = target - num\n        if complement in num_dict:\n            count += num_dict[complement]\n        num_dict[num] = num_dict.get(num, 0) + 1\n    return count\n\ndef g(target=10):\n    nums = [1, 5, 7, 3, 9, 5, 2]\n    return nums\n\nassert f(g(), target=10) == 3\n",
        "idx_generation": 138,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of non-negative integers and a target integer, determine if it is possible to split the array\n    into two non-empty subarrays such that the sum of the elements in the first subarray is equal to the sum of the\n    elements in the second subarray. The elements in each subarray must be contiguous.\n\n    Example:\n    arr = [1, 5, 7, 3, 2, 6]\n    target = 8\n\n    Output:\n    True\n\n    Explanation:\n    The array can be split into [1, 5, 2] and [7, 3, 6] such that their sums are both equal to the target value of 8.\n    \"\"\"\n\n    def can_split(start: int, sum1: int, sum2: int) -> bool:\n        if sum1 == sum2 == target:\n            return True\n        if start >= len(arr):\n            return False\n\n        return can_split(start + 1, sum1 + arr[start], sum2) or can_split(start + 1, sum1, sum2 + arr[start])\n\n    return can_split(0, 0, 0)\n\n\ndef g():\n    arr = [1, 5, 7, 3, 2, 6]\n    target = 8\n    return arr, target\n\n\nassert f(*g()) == True\n",
        "idx_generation": 204,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome when the spaces and special characters are removed.\n\n    Sample Input:\n    s = \"A man, a plan, a canal: Panama\"\n\n    Sample Output:\n    True\n\n    Explanation:\n    After removing spaces and special characters, the string becomes \"amanaplanacanalpanama\" which is a palindrome.\n    \"\"\"\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n    return s == s[::-1]\n\ndef g():\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n",
        "idx_generation": 112,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number 'n' is a power of 2.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a power of 2.\n\n    \"\"\"\n    if n <= 0:\n        return False\n\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n\n    return True\n\ndef g(n=16) -> int:\n    return n\n\nassert f(g()) == True\n",
        "idx_generation": 466,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two positive integers n and m, return a matrix of size n x m where each element is the product of its row and column indices.\n\n    Sample Input:\n    n = 3\n    m = 4\n\n    Sample Output:\n    [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n\n    Explanation:\n    The output matrix is obtained by multiplying each element with its row and column indices.\n    For example, the element at index (1, 1) in the output matrix is 1 * 1 = 1.\n    The element at index (1, 2) is 1 * 2 = 2, and so on.\n    \"\"\"\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = i * j\n\n    return matrix\n\ndef g(n=3, m=4):\n    return (n, m)\n\nassert f(*g()) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n",
        "idx_generation": 423,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the index of two numbers in the list that sum up to the target.\n\n    Return the indices of the two numbers if found, otherwise return an empty list.\n    \"\"\"\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g(nums: List[int], target: int) -> int:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return nums, target\n\n# Test case\nnums = [2, 7, 11, 15]\ntarget = 9\nassert f(*g(nums, target)) == [0, 1]\n",
        "idx_generation": 123,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 338,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer k, find the maximum sum of a contiguous subarray with length k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    k = 3\n    Output: 12\n    Explanation: The maximum sum of a contiguous subarray with length 3 is 12, which can be achieved by selecting the subarray [3, 4, 5].\n\n    Note:\n    - The list can contain both positive and negative integers.\n    - You may assume that the length of the list is greater than or equal to k.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if i >= k:\n            current_sum -= nums[i - k]\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    return max_sum\n\ndef g(nums=[1, 2, 3, 4, 5], k=3):\n    return nums, k\n\nassert f(*g()) == 12\n",
        "idx_generation": 141,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right, and the cost of each cell is represented by the integer value in that cell.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Initialize the first row\n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    \n    # Initialize the first column\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    \n    # Calculate the rest of the grid\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    \n    return grid[-1][-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n",
        "idx_generation": 205,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a palindrome.\n\n    Sample Input:\n    string = \"racecar\"\n\n    Sample Output:\n    True\n    \"\"\"\n    return string == string[::-1]\n\ndef g(string = \"racecar\"):\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise AND of all the numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 0 (1 & 2 & 3 & 4 & 5 = 0)\n\n    Hint: Use bit manipulation to perform the AND operation.\n    \"\"\"\n    result = nums[0]\n    for i in range(1, len(nums)):\n        result &= nums[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 0\n",
        "idx_generation": 467,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the number that appears more than n/2 times, where n is the length of the list.\n\n    Example:\n    nums = [3, 3, 4, 2, 4, 4, 2, 4, 4]\n\n    The number 4 appears more than 9/2 = 4.5 times.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        if num == candidate:\n            count += 1\n        else:\n            count -= 1\n\n    return candidate\n\ndef g():\n    return [3, 3, 4, 2, 4, 4, 2, 4, 4]\n\nassert f(g()) == 4\n",
        "idx_generation": 433,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, determine if there exist two numbers in the list such that\n    their sum is equal to the target.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The sum of 2 and 7 is equal to the target value 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == True\n\n",
        "idx_generation": 124,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there is a subsequence of elements in the list that adds up to the target.\n    Return True if such subsequence exists, False otherwise.\n    \"\"\"\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][target]\n\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return (nums, target)\n\n\nassert f(*g()) == True\n",
        "idx_generation": 345,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target number, determine if the target number exists in the grid.\n    The grid is sorted in non-decreasing order from left to right and top to bottom.\n\n    Return True if the target number exists in the grid, False otherwise.\n\n    Example:\n    grid = [\n        [1, 3, 5, 7],\n        [2, 4, 6, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n    target = 10\n\n    The target number 10 exists in the grid.\n\n    Therefore, the function should return True.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row = 0\n    col = cols - 1\n\n    while row < rows and col >= 0:\n        if grid[row][col] == target:\n            return True\n        elif grid[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n\n    return False\n\ndef g():\n    grid = [\n        [1, 3, 5, 7],\n        [2, 4, 6, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n    target = 10\n    return grid, target\n\nassert f(*g()) == True\n",
        "idx_generation": 143,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by combining non-adjacent elements.\n    Adjacent elements cannot be included in the sum.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Non-adjacent elements: [1, 3, 5]\n    Maximum sum = 1 + 3 + 5 = 9\n\n    Therefore, the function should return 9.\n    \"\"\"\n    n = len(nums)\n\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[n-1]\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 9\n",
        "idx_generation": 206,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, check if it is a pangram.\n\n    Sample Input:\n    string = \"The quick brown fox jumps over the lazy dog\"\n\n    Sample Output:\n    True\n    \"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return set(alphabet) <= set(string.lower())\n\ndef g(string = \"The quick brown fox jumps over the lazy dog\"):\n    return string\n\nassert f(g()) == True\n",
        "idx_generation": 121,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two numbers in the list is 28 (5 ^ 25 = 28).\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n",
        "idx_generation": 469,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(x: float, n=100) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if x < 2:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\ndef g(n = 100):\n    return n + 1\nassert f(g())\n",
        "idx_generation": 435,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport numpy as np\n\ndef f(grid: np.ndarray, target: int) -> bool:\n    \"\"\"\n    Given a 2D grid of integers and a target number, check if the target number exists in the grid.\n\n    Args:\n    - grid: A 2D grid of integers.\n    - target: The target number to search for.\n\n    Returns:\n    - True if the target number exists in the grid, False otherwise.\n    \"\"\"\n    rows, cols = grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == target:\n                return True\n    return False\n\ndef g(target=5):\n    grid = np.array([\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ])\n    return grid\n\nassert f(g(), target=5) == True\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers, check if there exists two integers in the array such that their sum is equal to the target.\n\n    Return True if there exists such integers, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(arr = [1, 2, 3, 4, 5], target = 8):\n    return arr, target\n\nassert f(*g())\n",
        "idx_generation": 346,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there exists a subarray of the given list whose sum is equal to the target value.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n\n    There exists a subarray [2, 3, 4] whose sum is equal to the target value.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        curr_sum = 0\n        for j in range(i, n):\n            curr_sum += nums[j]\n            if curr_sum == target:\n                return True\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 145,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subarray within the list.\n    Return the maximum sum.\n\n    Example:\n    Input:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return [nums]\n\nassert f(*g()) == 6\n",
        "idx_generation": 208,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome. A valid palindrome is a string that reads the same forwards and backwards, ignoring case, punctuation, and spaces.\n\n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    Explanation: The string is a valid palindrome.\n    \"\"\"\n\n    def isAlphanumeric(c: str) -> bool:\n        return c.isalnum()\n\n    s = ''.join(filter(isAlphanumeric, s)).lower()\n\n    return s == s[::-1]\n\ndef g():\n    s = \"A man, a plan, a canal: Panama\"\n    return s\n\nassert f(g()) == True\n",
        "idx_generation": 124,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, every element appears twice except for one.\n    Find that single one.\n    \n    Sample Input:\n    nums = [2, 2, 1]\n    \n    Sample Output:\n    1\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    nums = [2, 2, 1]\n    return nums\n\nassert f(g()) == 1\n\n",
        "idx_generation": 470,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Example:\n    n = 5\n    The factorial of 5 is 5! = 5 x 4 x 3 x 2 x 1 = 120.\n    Return 120.\n    \"\"\"\n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n    return factorial\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 120\n",
        "idx_generation": 439,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there are two numbers in the list that add up to the target.\n\n    Sample Input:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    Sample Output:\n    True\n\n    Explanation:\n    4 + 8 = 12, so the function should return True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n",
        "idx_generation": 125,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation:\n    - The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n",
        "idx_generation": 349,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine if it is a prime number.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef g():\n    \"\"\"\n    Generate a prime number.\n    \"\"\"\n    return 17\n\nassert f(g()) == True\n",
        "idx_generation": 147,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the length of the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 209,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, char: str) -> str:\n    \"\"\"\n    Given a string and a character, remove all occurrences of the character from the string.\n    Return the modified string.\n    \"\"\"\n    return s.replace(char, '')\n\ndef g():\n    s = \"Hello World\"\n    char = \"o\"\n    return s, char\n\nassert f(*g()) == \"Hell Wrld\"\n",
        "idx_generation": 128,
        "target_skills": [
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', return the number of set bits in all the elements of the list.\n\n    Example:\n    nums = [2, 3, 4, 5, 6]\n\n    Output: 8\n    \"\"\"\n    count = 0\n    for num in nums:\n        count += bin(num).count('1')\n    return count\n\ndef g() -> List[int]:\n    nums = [2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 8\n\n",
        "idx_generation": 476,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all the numbers from 1 to n.\n\n    Example:\n    n = 5\n    Output: 15\n\n    \"\"\"\n\n    return sum(range(1, n+1))\n\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 15\n",
        "idx_generation": 441,
        "target_skills": [
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] and nums[1] is 2 + 7 = 9, which is the target.\n    \"\"\"\n\n    if not nums:\n        return []\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence within the list.\n    Return the length of the longest increasing subsequence.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all the elements in the matrix.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    45\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            total_sum += num\n    return total_sum\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 45\n",
        "idx_generation": 148,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest palindromic subsequence.\n\n    Example:\n    Input: \"babad\"\n    Output: 3\n\n    Explanation: The longest palindromic subsequence is \"bab\" or \"aba\", therefore the length is 3.\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n    return dp[0][n-1]\n\ndef g() -> str:\n    s = \"babad\"\n    return s\n\nassert f(g()) == 3\n\n",
        "idx_generation": 209,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str, pattern: str) -> bool:\n    \"\"\"\n    Given a string s and a pattern string, determine if s matches the pattern.\n\n    The pattern consists of lowercase letters and a dot (.). The dot matches any single character.\n\n    Return True if s matches the pattern, otherwise return False.\n\n    Example:\n    s = \"apple\"\n    pattern = \"a..le\"\n\n    The pattern \"a..le\" matches the string \"apple\", so the function should return True.\n\n    s = \"apple\"\n    pattern = \"a..e\"\n\n    The pattern \"a..e\" does not match the string \"apple\", so the function should return False.\n    \"\"\"\n    if len(s) != len(pattern):\n        return False\n\n    for i in range(len(s)):\n        if pattern[i] != '.' and s[i] != pattern[i]:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate a string and a pattern string.\n    \"\"\"\n    return (\"apple\", \"a..le\")\n\nassert f(*g()) == True\n",
        "idx_generation": 133,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise XOR is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == n:\n                return True\n    return False\n\ndef g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise XOR equal to n.\n    \"\"\"\n    arr.append(n)\n    arr.append(n+1)\n    return n\n\nn = 5\nassert f(g([]), [1, 2, 3, 4]) == True\n",
        "idx_generation": 481,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if n is divisible by k using the modulo operator.\"\"\"\n    return n % k == 0\n\ndef g(n=24, k=6):\n    \"\"\"Generate two integers n and k\"\"\"\n    return n, k\n\nassert f(*g())\n",
        "idx_generation": 443,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Check if there exist two numbers in the given list that adds up to the target.\"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [7, 2, 11, 15, 5]\n    \nassert f(g(), 9) == True\n",
        "idx_generation": 126,
        "target_skills": [
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n\n    return max(dp)\n\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\n\nassert f(g()) == 4\n\n",
        "idx_generation": 352,
        "target_skills": [
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nimport math\n\ndef f(n: int, primes: List[int]) -> bool:\n    \"\"\"\n    Check if a given number n is a prime number, considering a list of primes.\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for prime in primes:\n        if prime > math.isqrt(n):\n            return True\n        \n        if n % prime == 0:\n            return False\n    \n    return True\n\ndef g():\n    n = 17\n    primes = [2, 3, 5, 7, 11, 13]\n    return (n, primes)\n\nassert f(*g()) == True\n",
        "idx_generation": 153,
        "target_skills": [
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence.\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4 (The longest increasing subsequence is [2, 3, 7, 101])\n\n    Hint: Use dynamic programming to keep track of the lengths of increasing subsequences.\n    \"\"\"\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n",
        "idx_generation": 215,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"Check if the given string is a palindrome.\"\"\"\n    return s == s[::-1]\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n",
        "idx_generation": 135,
        "target_skills": [
            0,
            0,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            0
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value can be obtained by XORing the elements 5 and 25: 5 XOR 25 = 28.\n\n    Hint: Use the property of XOR operation to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n",
        "idx_generation": 481,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself.\n\n    \"\"\"\n    def sum_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        \n        return sum(divisors)\n    \n    return sum_divisors(n) == n\n\ndef g():\n    n = 28\n    return n\n\nassert f(g())\n",
        "idx_generation": 444,
        "target_skills": [
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408,
            0,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": null,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find the index of the target number in the given sorted list using binary search.\"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef g():\n    return [2, 5, 7, 11, 15]\n    \nassert f(g(), 7) == True\n",
        "idx_generation": 126,
        "target_skills": [
            0,
            4607182418800017408,
            0,
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            4607182418800017408,
            4607182418800017408
        ]
    },
    {
        "fitness": 1.0,
        "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the index of the target in the list using binary search.\n    If the target is not present in the list, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n\n    Output:\n    5\n\n    Explanation:\n    The target value 6 is located at index 5 in the list.\n    \"\"\"\n\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, right)\n        else:\n            return binary_search(nums, target, left, mid - 1)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n",
        "idx_generation": 354,
        "target_skills": [
            4607182418800017408,
            0,
            0,
            0,
            4607182418800017408,
            0,
            0,
            4607182418800017408,
            0,
            4607182418800017408
        ]
    }
]
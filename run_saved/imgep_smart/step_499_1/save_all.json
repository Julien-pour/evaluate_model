[{"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers arr, check if the elements of the list form a binary heap.\n\n    A binary heap is a complete binary tree where each parent node is smaller (or larger) than its child nodes.\n    The elements of the list can be rearranged to form a binary heap if the heap property is satisfied.\n\n    Example:\n    Input: [3, 7, 8, 10, 15, 20]\n    Output: True\n\n    Hint: Use the properties of a binary heap to determine if the list forms a heap.\n    \"\"\"\n\n    def is_heap(arr: List[int], n: int, i: int) -> bool:\n        # Check if the given index i is a valid index in the heap\n        if i >= n:\n            return True\n\n        # Check if the current node has a left child\n        left = 2 * i + 1\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the current node has a right child\n        right = 2 * i + 2\n        if right < n and arr[i] > arr[right]:\n            return False\n\n        # Recursively check the left and right subtrees\n        return is_heap(arr, n, left) and is_heap(arr, n, right)\n\n    n = len(arr)\n    return is_heap(arr, n, 0)\n\ndef g() -> List[int]:\n    return [3, 7, 8, 10, 15, 20]\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 406, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers arr, check if the elements of the list form a binary heap.\n\n    A binary heap is a complete binary tree where each parent node is smaller (or larger) than its child nodes.\n    The elements of the list can be rearranged to form a binary heap if the heap property is satisfied.\n\n    Example:\n    Input: [3, 7, 8, 10, 15, 20]\n    Output: True\n\n    Hint: Use the properties of a binary heap to determine if the list forms a heap.\n    \"\"\"\n\n    def is_heap(arr: List[int], n: int, i: int) -> bool:\n        # Check if the given index i is a valid index in the heap\n        if i >= n:\n            return True\n\n        # Check if the current node has a left child\n        left = 2 * i + 1\n        if left < n and arr[i] > arr[left]:\n            return False\n\n        # Check if the current node has a right child\n        right = 2 * i + 2\n        if right < n and arr[i] > arr[right]:\n            return False\n\n        # Recursively check the left and right subtrees\n        return is_heap(arr, n, left) and is_heap(arr, n, right)\n\n    n = len(arr)\n    return is_heap(arr, n, 0)", "solution_func": "def g() -> List[int]:\n    return [3, 7, 8, 10, 15, 20]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits in its binary representation.\n\n    Example:\n    Input: 9\n    Output: 2 (binary representation of 9 is 1001, which has 2 set bits)\n\n    Hint: Use bit manipulation to count the number of set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g() -> int:\n    return 9\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 406, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of set bits in its binary representation.\n\n    Example:\n    Input: 9\n    Output: 2 (binary representation of 9 is 1001, which has 2 set bits)\n\n    Hint: Use bit manipulation to count the number of set bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g() -> int:\n    return 9", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, calculate the next greater element for each element in the list.\n    The next greater element of an element in the list is the first element to its right that is greater than it.\n\n    Example:\n    Input: [4, 5, 2, 25, 10]\n    Output: [5, 25, 25, -1, -1]\n\n    Hint: Use a stack to keep track of the next greater elements.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(arr)\n\n    for i in range(len(arr)-1, -1, -1):\n        while stack and stack[-1] <= arr[i]:\n            stack.pop()\n\n        if stack:\n            result[i] = stack[-1]\n\n        stack.append(arr[i])\n\n    return result\n\ndef g() -> List[int]:\n    return [4, 5, 2, 25, 10]\n\nassert f(g()) == [5, 25, 25, -1, -1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 406, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers arr, calculate the next greater element for each element in the list.\n    The next greater element of an element in the list is the first element to its right that is greater than it.\n\n    Example:\n    Input: [4, 5, 2, 25, 10]\n    Output: [5, 25, 25, -1, -1]\n\n    Hint: Use a stack to keep track of the next greater elements.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(arr)\n\n    for i in range(len(arr)-1, -1, -1):\n        while stack and stack[-1] <= arr[i]:\n            stack.pop()\n\n        if stack:\n            result[i] = stack[-1]\n\n        stack.append(arr[i])\n\n    return result", "solution_func": "def g() -> List[int]:\n    return [4, 5, 2, 25, 10]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 406, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target value 9.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value between any two numbers in the list is 5 XOR 25 = 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in arr:\n            prefix_set.add(num & mask)\n\n        expected_xor = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if (prefix ^ expected_xor) in prefix_set:\n                max_xor = expected_xor\n                break\n\n    return max_xor\n\ndef g():\n    arr = [3, 10, 5, 25, 2, 8]\n    return arr\n\nassert f(g()) == 28\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 406, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value between any two numbers in the list is 5 XOR 25 = 28.\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in arr:\n            prefix_set.add(num & mask)\n\n        expected_xor = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if (prefix ^ expected_xor) in prefix_set:\n                max_xor = expected_xor\n                break\n\n    return max_xor", "solution_func": "def g():\n    arr = [3, 10, 5, 25, 2, 8]\n    return arr", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"World Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 406, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Example:\n    Input: \"Hello World\"\n    Output: \"World Hello\"\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: str):\n        self.val = val\n        self.children = []\n\ndef f(root: Node, target: str) -> List[str]:\n    \"\"\"\n    Given a tree with string values in each node, return a list of all paths from the root to the nodes that contain the target string.\n    \"\"\"\n    def dfs(node: Node, path: str, target: str, result: List[str]):\n        if node.val == target:\n            result.append(path + node.val)\n        path += node.val + \" -> \"\n        for child in node.children:\n            dfs(child, path, target, result)\n\n    result = []\n    dfs(root, \"\", target, result)\n    return result\n\ndef g():\n    \"\"\"\n    Generate a tree with string values.\n    \"\"\"\n    root = Node(\"A\")\n    node1 = Node(\"B\")\n    node2 = Node(\"C\")\n    node3 = Node(\"D\")\n    node4 = Node(\"E\")\n    node5 = Node(\"B\")\n    node6 = Node(\"F\")\n    node7 = Node(\"G\")\n    node8 = Node(\"B\")\n\n    root.children = [node1, node2, node3]\n    node1.children = [node4]\n    node2.children = [node5]\n    node3.children = [node6, node7]\n    node4.children = [node8]\n\n    return root\n\nassert f(g(), \"B\") == [\"A -> B\", \"C -> B\", \"D -> E -> B\", \"A -> B -> F\", \"A -> B -> G\"]\n", "emb": null, "idx_generation": 406, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass Node:\n    def __init__(self, val: str):\n        self.val = val\n        self.children = []\n\ndef f(root: Node, target: str) -> List[str]:\n    \"\"\"\n    Given a tree with string values in each node, return a list of all paths from the root to the nodes that contain the target string.\n    \"\"\"\n    def dfs(node: Node, path: str, target: str, result: List[str]):\n        if node.val == target:\n            result.append(path + node.val)\n        path += node.val + \" -> \"\n        for child in node.children:\n            dfs(child, path, target, result)\n\n    result = []\n    dfs(root, \"\", target, result)\n    return result", "solution_func": "def g():\n    \"\"\"\n    Generate a tree with string values.\n    \"\"\"\n    root = Node(\"A\")\n    node1 = Node(\"B\")\n    node2 = Node(\"C\")\n    node3 = Node(\"D\")\n    node4 = Node(\"E\")\n    node5 = Node(\"B\")\n    node6 = Node(\"F\")\n    node7 = Node(\"G\")\n    node8 = Node(\"B\")\n\n    root.children = [node1, node2, node3]\n    node1.children = [node4]\n    node2.children = [node5]\n    node3.children = [node6, node7]\n    node4.children = [node8]\n\n    return root", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all the numbers that can be formed by traversing any path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    def dfs(i: int, j: int, path: int, result: List[int]):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            result.append(path + grid[i][j])\n        path += grid[i][j] * 10\n        if i < len(grid) - 1:\n            dfs(i + 1, j, path, result)\n        if j < len(grid[0]) - 1:\n            dfs(i, j + 1, path, result)\n\n    result = []\n    dfs(0, 0, 0, result)\n    return sum(result)\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 1234\n", "emb": null, "idx_generation": 406, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all the numbers that can be formed by traversing any path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    def dfs(i: int, j: int, path: int, result: List[int]):\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            result.append(path + grid[i][j])\n        path += grid[i][j] * 10\n        if i < len(grid) - 1:\n            dfs(i + 1, j, path, result)\n        if j < len(grid[0]) - 1:\n            dfs(i, j + 1, path, result)\n\n    result = []\n    dfs(0, 0, 0, result)\n    return sum(result)", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that start with the given prefix.\n    \"\"\"\n    result = []\n    for word in words:\n        if word.startswith(prefix):\n            result.append(word)\n    return result\n\ndef g():\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\"]\n\nassert f(g(), \"b\") == [\"banana\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 406, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that start with the given prefix.\n    \"\"\"\n    result = []\n    for word in words:\n        if word.startswith(prefix):\n            result.append(word)\n    return result", "solution_func": "def g():\n    \"\"\"\n    Generate a list of words.\n    \"\"\"\n    return [\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that position.\n    The solution should be implemented without using division.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    f(nums) => [120, 60, 40, 30, 24]\n    \"\"\"\n\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    # Calculate the product of all numbers to the left of each position\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    # Calculate the product of all numbers to the right of each position\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    # Multiply the left and right products to get the final result\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 406, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that position.\n    The solution should be implemented without using division.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    f(nums) => [120, 60, 40, 30, 24]\n    \"\"\"\n\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    # Calculate the product of all numbers to the left of each position\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    # Calculate the product of all numbers to the right of each position\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    # Multiply the left and right products to get the final result\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a path from start to end that passes through all nodes in the graph exactly once.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There is a path from vertex 0 to vertex 3 that passes through all nodes exactly once.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    visited[start] = True\n\n    return dfs(graph, start, end, visited, 1)\n\ndef dfs(graph: List[List[int]], node: int, end: int, visited: List[bool], count: int) -> bool:\n    if count == len(graph):\n        return node == end\n    \n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            visited[neighbor] = True\n            if dfs(graph, neighbor, end, visited, count + 1):\n                return True\n            visited[neighbor] = False\n    \n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 407, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix and two vertices start and end,\n    determine if there is a path from start to end that passes through all nodes in the graph exactly once.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There is a path from vertex 0 to vertex 3 that passes through all nodes exactly once.\n\n    Therefore, the function should return True.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    visited[start] = True\n\n    return dfs(graph, start, end, visited, 1)\n\ndef dfs(graph: List[List[int]], node: int, end: int, visited: List[bool], count: int) -> bool:\n    if count == len(graph):\n        return node == end\n    \n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            visited[neighbor] = True\n            if dfs(graph, neighbor, end, visited, count + 1):\n                return True\n            visited[neighbor] = False\n    \n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the bitwise OR of all the elements in the list.\n    Return the result.\n\n    Example:\n    arr = [5, 3, 2, 8]\n\n    The bitwise OR of 5, 3, 2, and 8 is 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    result = 0\n    for num in arr:\n        result |= num\n    return result\n\ndef g():\n    return [5, 3, 2, 8]\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the bitwise OR of all the elements in the list.\n    Return the result.\n\n    Example:\n    arr = [5, 3, 2, 8]\n\n    The bitwise OR of 5, 3, 2, and 8 is 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    result = 0\n    for num in arr:\n        result |= num\n    return result", "solution_func": "def g():\n    return [5, 3, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path\n    from the start vertex to the target vertex where the sum of the weights along the path is a power of 2.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n\n    There is a path from vertex 0 to vertex 3 where the sum of the weights along the path is 2.\n\n    Therefore, the function should return True.\n    \"\"\"\n    return dfs(graph, start, target, 0, set())\n\ndef dfs(graph: List[List[int]], node: int, target: int, weight: int, visited: set) -> bool:\n    if node == target and weight > 0 and is_power_of_2(weight):\n        return True\n    \n    visited.add(node)\n    \n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] != 0 and neighbor not in visited:\n            if dfs(graph, neighbor, target, weight + graph[node][neighbor], visited):\n                return True\n    \n    visited.remove(node)\n    return False\n\ndef is_power_of_2(n: int) -> bool:\n    return n != 0 and (n & (n - 1)) == 0\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    return graph, start, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 407, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, target: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there is a path\n    from the start vertex to the target vertex where the sum of the weights along the path is a power of 2.\n    Return True if such a path exists, otherwise return False.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n\n    There is a path from vertex 0 to vertex 3 where the sum of the weights along the path is 2.\n\n    Therefore, the function should return True.\n    \"\"\"\n    return dfs(graph, start, target, 0, set())\n\ndef dfs(graph: List[List[int]], node: int, target: int, weight: int, visited: set) -> bool:\n    if node == target and weight > 0 and is_power_of_2(weight):\n        return True\n    \n    visited.add(node)\n    \n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] != 0 and neighbor not in visited:\n            if dfs(graph, neighbor, target, weight + graph[node][neighbor], visited):\n                return True\n    \n    visited.remove(node)\n    return False\n\ndef is_power_of_2(n: int) -> bool:\n    return n != 0 and (n & (n - 1)) == 0", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    target = 3\n    return graph, start, target", "map_ix": [0, 0, 1, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of numbers and two integers n and k, determine if there exists a combination of exactly k numbers\n    from the list that adds up to n. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int, count: int) -> bool:\n        if curr_sum == n and count == k:\n            return True\n        if curr_sum > n or count > k:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i], count + 1):\n                return True\n        return False\n\n    return backtrack(0, 0, 0)\n\n\ndef g(n=10, k=3, nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a combination of exactly k numbers from the given list nums that adds up to n.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, count: int, combination: List[int]) -> List[int]:\n        if curr_sum == n and count == k:\n            return combination\n        if curr_sum > n or count > k:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], count + 1, combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, 0, [])\n\n\nassert f(g(), 10, 3) == True\n\n", "emb": null, "idx_generation": 407, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of numbers and two integers n and k, determine if there exists a combination of exactly k numbers\n    from the list that adds up to n. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int, count: int) -> bool:\n        if curr_sum == n and count == k:\n            return True\n        if curr_sum > n or count > k:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i], count + 1):\n                return True\n        return False\n\n    return backtrack(0, 0, 0)", "solution_func": "def g(n=10, k=3, nums=[1, 2, 3, 4, 5]):\n    \"\"\"\n    Generate a combination of exactly k numbers from the given list nums that adds up to n.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, count: int, combination: List[int]) -> List[int]:\n        if curr_sum == n and count == k:\n            return combination\n        if curr_sum > n or count > k:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], count + 1, combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, 0, [])", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\n\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])\n\n\nassert f(g(), 10) == True\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)\n\n\ndef g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])\n\n\nassert f(g(), 10) == True\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target number, determine if there exists a combination of numbers from the list\n    that adds up to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(start: int, curr_sum: int) -> bool:\n        if curr_sum == target:\n            return True\n        if curr_sum > target:\n            return False\n        for i in range(start, len(nums)):\n            if backtrack(i + 1, curr_sum + nums[i]):\n                return True\n        return False\n\n    return backtrack(0, 0)", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=10):\n    \"\"\"\n    Generate a combination of numbers from the given list nums that adds up to the target.\n    \"\"\"\n    def generate_combination(start: int, curr_sum: int, combination: List[int]) -> List[int]:\n        if curr_sum == target:\n            return combination\n        if curr_sum > target:\n            return []\n        for i in range(start, len(nums)):\n            combination.append(nums[i])\n            result = generate_combination(i + 1, curr_sum + nums[i], combination)\n            if result:\n                return result\n            combination.pop()\n        return []\n\n    return generate_combination(0, 0, [])", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], which sums up to 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next permutation in lexicographic order.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The next permutation is [1, 3, 2].\n\n    Therefore, the function should return [1, 3, 2].\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n    \n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    \n    if i >= 0:\n        j = n - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    \n    left = i + 1\n    right = n - 1\n    \n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    \n    return nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next permutation in lexicographic order.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The next permutation is [1, 3, 2].\n\n    Therefore, the function should return [1, 3, 2].\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n    \n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    \n    if i >= 0:\n        j = n - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    \n    left = i + 1\n    right = n - 1\n    \n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n    \n    return nums", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid combinations of parentheses that can be formed using n pairs of parentheses.\n\n    Example:\n    n = 3\n    Output: 5\n\n    Explanation: The valid combinations are \"((()))\", \"(()())\", \"(())()\", \"()(())\", and \"()()()\".\n    \"\"\"\n    def backtrack(s: str, left: int, right: int):\n        nonlocal count\n        if left == 0 and right == 0:\n            count += 1\n            return\n        if left > 0:\n            backtrack(s + '(', left - 1, right)\n        if right > left:\n            backtrack(s + ')', left, right - 1)\n    \n    count = 0\n    backtrack('', n, n)\n    return count\n\ndef g(n: int = 3):\n    return (n,)\n\nassert f(*g()) == 5\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 407, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of valid combinations of parentheses that can be formed using n pairs of parentheses.\n\n    Example:\n    n = 3\n    Output: 5\n\n    Explanation: The valid combinations are \"((()))\", \"(()())\", \"(())()\", \"()(())\", and \"()()()\".\n    \"\"\"\n    def backtrack(s: str, left: int, right: int):\n        nonlocal count\n        if left == 0 and right == 0:\n            count += 1\n            return\n        if left > 0:\n            backtrack(s + '(', left - 1, right)\n        if right > left:\n            backtrack(s + ')', left, right - 1)\n    \n    count = 0\n    backtrack('', n, n)\n    return count", "solution_func": "def g(n: int = 3):\n    return (n,)", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right. However, there are some cells in the grid that are blocked (denoted by 1).\n\n    Example:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    output: 2\n\n    Explanation: There are two unique paths from the top-left cell to the bottom-right cell.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or col < 0 or grid[row][col] == 1:\n            return 0\n        if row == 0 and col == 0:\n            return 1\n        return dfs(row-1, col) + dfs(row, col-1)\n\n    return dfs(len(grid)-1, len(grid[0])-1)\n\ndef g() -> List[List[int]]:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 408, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right. However, there are some cells in the grid that are blocked (denoted by 1).\n\n    Example:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    output: 2\n\n    Explanation: There are two unique paths from the top-left cell to the bottom-right cell.\n    \"\"\"\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or col < 0 or grid[row][col] == 1:\n            return 0\n        if row == 0 and col == 0:\n            return 1\n        return dfs(row-1, col) + dfs(row, col-1)\n\n    return dfs(len(grid)-1, len(grid[0])-1)", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which has a sum of 12.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 408, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 12\n\n    Explanation: The maximum sum path is 1 -> 3 -> 5 -> 2 -> 1, which has a sum of 12.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right. Each cell has a cost associated with it.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 7\n\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a cost of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 408, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move down or right. Each cell has a cost associated with it.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    output: 7\n\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a cost of 7.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], k: int = 3) -> bool:\n    \"\"\"\n    Given an array of integers, determine if there exists a subarray with a length of at least k\n    such that the bitwise OR of all elements in the subarray is zero.\n    \"\"\"\n    n = len(arr)\n    if n < k:\n        return False\n    dp = [0] * n\n    dp[0] = arr[0]\n    for i in range(1, n):\n        dp[i] = dp[i - 1] | arr[i]\n        if i >= k - 1 and dp[i] == 0:\n            return True\n    return False\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    return arr\n\nassert f(g())\n", "emb": null, "idx_generation": 408, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int], k: int = 3) -> bool:\n    \"\"\"\n    Given an array of integers, determine if there exists a subarray with a length of at least k\n    such that the bitwise OR of all elements in the subarray is zero.\n    \"\"\"\n    n = len(arr)\n    if n < k:\n        return False\n    dp = [0] * n\n    dp[0] = arr[0]\n    for i in range(1, n):\n        dp[i] = dp[i - 1] | arr[i]\n        if i >= k - 1 and dp[i] == 0:\n            return True\n    return False", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner\n    starting from the top-left corner, by only moving down or right, where the sum of the\n    digits of the binary representation of the numbers encountered along the path is a multiple of 3.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1] % 3 == 0\n\ndef g():\n    grid = [\n        [1, 0, 1, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g())\n", "emb": null, "idx_generation": 408, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid of 0s and 1s, determine if it is possible to reach the bottom-right corner\n    starting from the top-left corner, by only moving down or right, where the sum of the\n    digits of the binary representation of the numbers encountered along the path is a multiple of 3.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1] % 3 == 0", "solution_func": "def g():\n    grid = [\n        [1, 0, 1, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 1, 1, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, determine the length of the longest increasing subarray\n    where the bitwise OR of all elements in the subarray is zero.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        if arr[i] | arr[i - 1] == 0:\n            dp[i] = dp[i - 1] + 1\n    return max(dp)\n\ndef g():\n    arr = [1, 2, 4, 8, 16, 32, 64]\n    return arr\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 408, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, determine the length of the longest increasing subarray\n    where the bitwise OR of all elements in the subarray is zero.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        if arr[i] | arr[i - 1] == 0:\n            dp[i] = dp[i - 1] + 1\n    return max(dp)", "solution_func": "def g():\n    arr = [1, 2, 4, 8, 16, 32, 64]\n    return arr", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there are two distinct indices i and j in the list\n    such that nums[i] - nums[j] = k.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 1\n\n    The function should return True, since nums[1] - nums[4] = 5 - 2 = 3.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 2\n\n    The function should return False, since there are no two distinct indices in the list such that nums[i] - nums[j] = 2.\n\n    Note: The indices i and j must be distinct.\n\n    \"\"\"\n\n    seen = set()\n    for num in nums:\n        if num - k in seen:\n            return True\n        seen.add(num)\n    return False\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 5, 3, 4, 2]\n    k = 1\n    return nums, k\n\n\nassert f(*g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 408, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value k, determine if there are two distinct indices i and j in the list\n    such that nums[i] - nums[j] = k.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 1\n\n    The function should return True, since nums[1] - nums[4] = 5 - 2 = 3.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 2\n\n    The function should return False, since there are no two distinct indices in the list such that nums[i] - nums[j] = 2.\n\n    Note: The indices i and j must be distinct.\n\n    \"\"\"\n\n    seen = set()\n    for num in nums:\n        if num - k in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 5, 3, 4, 2]\n    k = 1\n    return nums, k", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 408, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace\n    and initial word order.\n\n    Example:\n    s = \"Let's solve puzzles!\"\n\n    The function should return \"s'teL evlos selzzup!\"\n\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\n\ndef g() -> str:\n    s = \"Let's solve puzzles!\"\n    return s\n\n\nassert f(g()) == \"s'teL evlos selzzup!\"\n", "emb": null, "idx_generation": 408, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace\n    and initial word order.\n\n    Example:\n    s = \"Let's solve puzzles!\"\n\n    The function should return \"s'teL evlos selzzup!\"\n\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)", "solution_func": "def g() -> str:\n    s = \"Let's solve puzzles!\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number.\n    If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 408, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number.\n    If the target number is not in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representation of a mathematical expression, determine if it is valid or not.\n    The expression can contain the following operators: +, -, *, /, (, and ).\n    The expression is considered valid if the parentheses are balanced and the operators are used correctly.\n    Return True if the expression is valid, False otherwise.\n    \"\"\"\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n        elif char in '+-*/':\n            if not stack or stack[-1] != '(':\n                return False\n    return len(stack) == 0\n\ndef g() -> str:\n    return \"(2+3*(5-2))/4\"\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 409, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(expression: str) -> bool:\n    \"\"\"\n    Given a string representation of a mathematical expression, determine if it is valid or not.\n    The expression can contain the following operators: +, -, *, /, (, and ).\n    The expression is considered valid if the parentheses are balanced and the operators are used correctly.\n    Return True if the expression is valid, False otherwise.\n    \"\"\"\n    stack = []\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n        elif char in '+-*/':\n            if not stack or stack[-1] != '(':\n                return False\n    return len(stack) == 0", "solution_func": "def g() -> str:\n    return \"(2+3*(5-2))/4\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the maximum number of connected 1s in the grid.\n    Two adjacent 1s are considered connected if they are adjacent horizontally or vertically.\n    Return the maximum number of connected 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return 0\n\n        count = 1\n        grid[row][col] = -1\n\n        count += dfs(row + 1, col)\n        count += dfs(row - 1, col)\n        count += dfs(row, col + 1)\n        count += dfs(row, col - 1)\n\n        return count\n\n    max_count = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                count = dfs(i, j)\n                max_count = max(max_count, count)\n\n    return max_count\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 0, 1, 0, 1],\n        [0, 1, 0, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 0],\n        [1, 0, 0, 0, 1]\n    ]\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 409, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the maximum number of connected 1s in the grid.\n    Two adjacent 1s are considered connected if they are adjacent horizontally or vertically.\n    Return the maximum number of connected 1s.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int) -> int:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] != 1:\n            return 0\n\n        count = 1\n        grid[row][col] = -1\n\n        count += dfs(row + 1, col)\n        count += dfs(row - 1, col)\n        count += dfs(row, col + 1)\n        count += dfs(row, col - 1)\n\n        return count\n\n    max_count = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                count = dfs(i, j)\n                max_count = max(max_count, count)\n\n    return max_count", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 0, 1, 0, 1],\n        [0, 1, 0, 1, 0],\n        [1, 1, 1, 1, 1],\n        [0, 0, 1, 0, 0],\n        [1, 0, 0, 0, 1]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of characters representing a maze, where 'S' represents the starting point, 'E' represents the ending point,\n    '#' represents a wall, and '.' represents an empty space, find the minimum number of steps required to reach the ending point\n    from the starting point. You can only move up, down, left, or right, and you cannot pass through walls.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\n    The minimum number of steps required to reach the ending point from the starting point is 6, following the path: S -> right -> right -> down -> down -> down -> E.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n            if grid[row][col] == 'E':\n                return steps\n\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#':\n                    queue.append((new_row, new_col, steps+1))\n\n        return -1\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                return bfs(i, j)\n\n    return -1\n\ndef g() -> List[List[str]]:\n    return [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 409, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a 2D grid of characters representing a maze, where 'S' represents the starting point, 'E' represents the ending point,\n    '#' represents a wall, and '.' represents an empty space, find the minimum number of steps required to reach the ending point\n    from the starting point. You can only move up, down, left, or right, and you cannot pass through walls.\n\n    Return the minimum number of steps required.\n\n    Example:\n    grid = [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]\n\n    The minimum number of steps required to reach the ending point from the starting point is 6, following the path: S -> right -> right -> down -> down -> down -> E.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def bfs(start_row: int, start_col: int) -> int:\n        queue = [(start_row, start_col, 0)]\n        visited = set()\n\n        while queue:\n            row, col, steps = queue.pop(0)\n            if grid[row][col] == 'E':\n                return steps\n\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row = row + dx\n                new_col = col + dy\n                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#':\n                    queue.append((new_row, new_col, steps+1))\n\n        return -1\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 'S':\n                return bfs(i, j)\n\n    return -1", "solution_func": "def g() -> List[List[str]]:\n    return [\n        ['S', '.', '.', '#', '#'],\n        ['#', '#', '.', '#', '#'],\n        ['.', '.', '.', '.', '#'],\n        ['#', '#', '#', 'E', '#']\n    ]", "map_ix": [0, 0, 1, 0, 0, 1, 1, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that XOR to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that XOR to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        xor = numbers[left] ^ numbers[right]\n        if xor == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 14\n    substring = \"46\"\n    return numbers, target, substring\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 409, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that XOR to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that XOR to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        xor = numbers[left] ^ numbers[right]\n        if xor == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 14\n    substring = \"46\"\n    return numbers, target, substring", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that AND to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that AND to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        and_value = numbers[left] & numbers[right]\n        if and_value == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif and_value < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 0\n    substring = \"28\"\n    return numbers, target, substring\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 409, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that AND to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that AND to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        and_value = numbers[left] & numbers[right]\n        if and_value == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif and_value < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 0\n    substring = \"28\"\n    return numbers, target, substring", "map_ix": [1, 0, 0, 0, 1, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that OR to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that OR to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        or_value = numbers[left] | numbers[right]\n        if or_value == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif or_value < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 14\n    substring = \"26\"\n    return numbers, target, substring\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 409, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(numbers: List[int], target: int, substring: str) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that OR to the target value.\n    Then, check if the substring is present in the concatenation of the two numbers.\n\n    Args:\n    numbers (List[int]): The list of numbers.\n    target (int): The target value.\n    substring (str): The substring to check.\n\n    Returns:\n    bool: True if the substring is present in the concatenation of two numbers that OR to the target value, False otherwise.\n    \"\"\"\n    numbers.sort()\n\n    left = 0\n    right = len(numbers) - 1\n\n    while left < right:\n        or_value = numbers[left] | numbers[right]\n        if or_value == target:\n            concatenated = str(numbers[left]) + str(numbers[right])\n            if substring in concatenated:\n                return True\n            else:\n                return False\n        elif or_value < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    numbers = [2, 4, 6, 8, 10]\n    target = 14\n    substring = \"26\"\n    return numbers, target, substring", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28 (The maximum XOR value is obtained by XORing 5 and 25)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)\n\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == 28\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 409, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28 (The maximum XOR value is obtained by XORing 5 and 25)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [3, 7, 10, 5]\n    Output: 15 (The maximum XOR value is obtained by XORing 7 and 10)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)\n\n\ndef g() -> List[int]:\n    return [3, 7, 10, 5]\n\n\nassert f(g()) == 15\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 409, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [3, 7, 10, 5]\n    Output: 15 (The maximum XOR value is obtained by XORing 7 and 10)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)", "solution_func": "def g() -> List[int]:\n    return [3, 7, 10, 5]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [1, 2, 4, 8, 16]\n    Output: 31 (The maximum XOR value is obtained by XORing 15 and 16)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)\n\n\ndef g() -> List[int]:\n    return [1, 2, 4, 8, 16]\n\n\nassert f(g()) == 31\n\n", "emb": null, "idx_generation": 409, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of two numbers in the list.\n\n    Example:\n    Input: [1, 2, 4, 8, 16]\n    Output: 31 (The maximum XOR value is obtained by XORing 15 and 16)\n\n    Hint: Use a Trie data structure to efficiently find the maximum XOR value.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def findMaxXOR(root, nums):\n        max_xor = 0\n        for num in nums:\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit ^ 1]:\n                    xor_val += (1 << i)\n                    node = node.children[bit ^ 1]\n                else:\n                    node = node.children[bit]\n            max_xor = max(max_xor, xor_val)\n        return max_xor\n\n    root = TrieNode()\n    for num in nums:\n        insert(root, num)\n\n    return findMaxXOR(root, nums)", "solution_func": "def g() -> List[int]:\n    return [1, 2, 4, 8, 16]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 0 to n, where n is the length of the list.\n    \n    Example:\n    nums = [0, 1, 3, 4, 5]\n    \n    Output: 2\n    \"\"\"\n    nums.sort()\n    \n    for i in range(len(nums)):\n        if nums[i] != i:\n            return i\n    \n    return len(nums)\n\ndef g() -> List[int]:\n    nums = [0, 1, 3, 4, 5]\n    return nums\n\nassert f(g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 409, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the missing number in the range from 0 to n, where n is the length of the list.\n    \n    Example:\n    nums = [0, 1, 3, 4, 5]\n    \n    Output: 2\n    \"\"\"\n    nums.sort()\n    \n    for i in range(len(nums)):\n        if nums[i] != i:\n            return i\n    \n    return len(nums)", "solution_func": "def g() -> List[int]:\n    nums = [0, 1, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to 9, which is the target.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    return [[2, 7, 11, 15], 9]\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output:\n    [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 (2 and 7) add up to 9, which is the target.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    return [[2, 7, 11, 15], 9]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output:\n    6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find three numbers in the list that add up to the target.\n    Return the indices of the three numbers.\n\n    Example:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n\n    Output:\n    [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    Explanation:\n    The combinations of three numbers that add up to 0 are: [-2, -1, 1, 2], [-2, 0, 0, 2], and [-1, 0, 0, 1].\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    result = []\n\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum < target:\n                left += 1\n            elif curr_sum > target:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n\n    return result\n\ndef g():\n    return [[1, 0, -1, 0, -2, 2], 0]\n\nassert f(*g()) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n", "emb": null, "idx_generation": 410, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find three numbers in the list that add up to the target.\n    Return the indices of the three numbers.\n\n    Example:\n    nums = [1, 0, -1, 0, -2, 2]\n    target = 0\n\n    Output:\n    [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n\n    Explanation:\n    The combinations of three numbers that add up to 0 are: [-2, -1, 1, 2], [-2, 0, 0, 2], and [-1, 0, 0, 1].\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    result = []\n\n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left = i + 1\n        right = n - 1\n\n        while left < right:\n            curr_sum = nums[i] + nums[left] + nums[right]\n            if curr_sum < target:\n                left += 1\n            elif curr_sum > target:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n\n    return result", "solution_func": "def g():\n    return [[1, 0, -1, 0, -2, 2], 0]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, count the number of unique subsets that can be XORed to the target value.\n    \"\"\"\n    def subset_xor(nums: List[int], target: int, index: int, xor_result: int) -> int:\n        if xor_result == target:\n            return 1\n        if index >= len(nums):\n            return 0\n        return subset_xor(nums, target, index+1, xor_result ^ nums[index]) + subset_xor(nums, target, index+1, xor_result)\n    \n    return subset_xor(nums, target, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7\n\nassert f(*g()) == 2\n\n", "emb": null, "idx_generation": 410, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, count the number of unique subsets that can be XORed to the target value.\n    \"\"\"\n    def subset_xor(nums: List[int], target: int, index: int, xor_result: int) -> int:\n        if xor_result == target:\n            return 1\n        if index >= len(nums):\n            return 0\n        return subset_xor(nums, target, index+1, xor_result ^ nums[index]) + subset_xor(nums, target, index+1, xor_result)\n    \n    return subset_xor(nums, target, 0, 0)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 7", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_result = nums[i] ^ nums[j]\n            if xor_result > max_xor:\n                max_xor = xor_result\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_result = nums[i] ^ nums[j]\n            if xor_result > max_xor:\n                max_xor = xor_result\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers from the list that add up to the target value.\n    \"\"\"\n    def find_combinations(nums: List[int], target: int, index: int, current_combination: List[int], combinations: List[List[int]]) -> None:\n        if target == 0:\n            combinations.append(current_combination)\n            return\n        if target < 0 or index >= len(nums):\n            return\n        find_combinations(nums, target-nums[index], index, current_combination + [nums[index]], combinations)\n        find_combinations(nums, target, index+1, current_combination, combinations)\n    \n    combinations = []\n    find_combinations(nums, target, 0, [], combinations)\n    return combinations\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers from the list that add up to the target value.\n    \"\"\"\n    def find_combinations(nums: List[int], target: int, index: int, current_combination: List[int], combinations: List[List[int]]) -> None:\n        if target == 0:\n            combinations.append(current_combination)\n            return\n        if target < 0 or index >= len(nums):\n            return\n        find_combinations(nums, target-nums[index], index, current_combination + [nums[index]], combinations)\n        find_combinations(nums, target, index+1, current_combination, combinations)\n    \n    combinations = []\n    find_combinations(nums, target, 0, [], combinations)\n    return combinations", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 3, 6, 7], 7", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The function should return [\n        [1, 2, 3],\n        [1, 3, 2],\n        [2, 1, 3],\n        [2, 3, 1],\n        [3, 1, 2],\n        [3, 2, 1]\n    ]\n\n    Note:\n    - The input list may have duplicates.\n    - The order of the permutations does not matter.\n    \"\"\"\n    def backtrack(nums, path, result):\n        if not nums:\n            result.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], result)\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == [\n    [1, 2, 3],\n    [1, 3, 2],\n    [2, 1, 3],\n    [2, 3, 1],\n    [3, 1, 2],\n    [3, 2, 1]\n]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The function should return [\n        [1, 2, 3],\n        [1, 3, 2],\n        [2, 1, 3],\n        [2, 3, 1],\n        [3, 1, 2],\n        [3, 2, 1]\n    ]\n\n    Note:\n    - The input list may have duplicates.\n    - The order of the permutations does not matter.\n    \"\"\"\n    def backtrack(nums, path, result):\n        if not nums:\n            result.append(path)\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], result)\n\n    result = []\n    backtrack(nums, [], result)\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is bipartite.\n\n    A graph is bipartite if we can split its set of nodes into two independent subsets A and B, such that\n    every edge in the graph connects a node in set A to a node in set B.\n\n    Example:\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2]\n    ]\n\n    The function should return True, as the graph can be split into two subsets: [0, 2] and [1, 3].\n\n    Note:\n    - The graph will have at most 100 nodes.\n    - The graph is undirected and does not contain self-loops or parallel edges.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n    for i in range(n):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n    return True\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representing an undirected graph.\n    \"\"\"\n    return [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2]\n    ]\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, determine if the graph is bipartite.\n\n    A graph is bipartite if we can split its set of nodes into two independent subsets A and B, such that\n    every edge in the graph connects a node in set A to a node in set B.\n\n    Example:\n    graph = [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2]\n    ]\n\n    The function should return True, as the graph can be split into two subsets: [0, 2] and [1, 3].\n\n    Note:\n    - The graph will have at most 100 nodes.\n    - The graph is undirected and does not contain self-loops or parallel edges.\n    \"\"\"\n    def dfs(node, color):\n        colors[node] = color\n        for neighbor in graph[node]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] == 0 and not dfs(neighbor, -color):\n                return False\n        return True\n\n    n = len(graph)\n    colors = [0] * n\n    for i in range(n):\n        if colors[i] == 0 and not dfs(i, 1):\n            return False\n    return True", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency list representing an undirected graph.\n    \"\"\"\n    return [\n        [1, 3],\n        [0, 2],\n        [1, 3],\n        [0, 2]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix with the constraint that\n    no two elements of the submatrix are adjacent vertically or horizontally.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The function should return 20, as the maximum sum of a submatrix is obtained by selecting the submatrix\n    [[1, 3], [7, 9]].\n\n    Note:\n    - The matrix will have at most 200 rows and columns.\n    - Each element in the matrix is a non-negative integer.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = max(dp[i - 1][0], matrix[i][0])\n\n    for j in range(1, cols):\n        dp[0][j] = max(dp[0][j - 1], matrix[0][j])\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 20\n\n", "emb": null, "idx_generation": 410, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix with the constraint that\n    no two elements of the submatrix are adjacent vertically or horizontally.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The function should return 20, as the maximum sum of a submatrix is obtained by selecting the submatrix\n    [[1, 3], [7, 9]].\n\n    Note:\n    - The matrix will have at most 200 rows and columns.\n    - Each element in the matrix is a non-negative integer.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = max(dp[i - 1][0], matrix[i][0])\n\n    for j in range(1, cols):\n        dp[0][j] = max(dp[0][j - 1], matrix[0][j])\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Find if a given substring appears in the string s\"\"\"\n    return substr in s\ndef g(substr = 'abc'):\n    return 'abcdefg'\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 410, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, substr='abc') -> bool:\n    \"\"\"Find if a given substring appears in the string s\"\"\"\n    return substr in s", "solution_func": "def g(substr = 'abc'):\n    return 'abcdefg'", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in ascending order.\n\n    Example:\n    Input: [4, 2, 7, 1, 5]\n    Output: [1, 2, 4, 5, 7]\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[0]\n    lesser = [x for x in nums[1:] if x <= pivot]\n    greater = [x for x in nums[1:] if x > pivot]\n\n    return f(lesser) + [pivot] + f(greater)\n\ndef g() -> List[int]:\n    return [4, 2, 7, 1, 5]\n\nassert f(g()) == [1, 2, 4, 5, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', sort the list in ascending order.\n\n    Example:\n    Input: [4, 2, 7, 1, 5]\n    Output: [1, 2, 4, 5, 7]\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n\n    pivot = nums[0]\n    lesser = [x for x in nums[1:] if x <= pivot]\n    greater = [x for x in nums[1:] if x > pivot]\n\n    return f(lesser) + [pivot] + f(greater)", "solution_func": "def g() -> List[int]:\n    return [4, 2, 7, 1, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of bits that are set to 1 in the binary representation of 'n'.\n\n    Example:\n    Input: 7\n    Output: 3\n\n    Explanation:\n    The binary representation of 7 is 111, which has 3 bits set to 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return (n & 1) + f(n >> 1)\n\ndef g() -> int:\n    return 7\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer 'n', return the number of bits that are set to 1 in the binary representation of 'n'.\n\n    Example:\n    Input: 7\n    Output: 3\n\n    Explanation:\n    The binary representation of 7 is 111, which has 3 bits set to 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return (n & 1) + f(n >> 1)", "solution_func": "def g() -> int:\n    return 7", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings 's' and 't', determine if 't' is an anagram of 's'.\n\n    Example:\n    Input: s = \"anagram\", t = \"nagaram\"\n    Output: True\n\n    Explanation:\n    The strings \"anagram\" and \"nagaram\" are anagrams of each other.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    count = [0] * 26\n\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for num in count:\n        if num != 0:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    return (\"anagram\", \"nagaram\")\n\nassert f(*g())\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings 's' and 't', determine if 't' is an anagram of 's'.\n\n    Example:\n    Input: s = \"anagram\", t = \"nagaram\"\n    Output: True\n\n    Explanation:\n    The strings \"anagram\" and \"nagaram\" are anagrams of each other.\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    \n    count = [0] * 26\n\n    for i in range(len(s)):\n        count[ord(s[i]) - ord('a')] += 1\n        count[ord(t[i]) - ord('a')] -= 1\n\n    for num in count:\n        if num != 0:\n            return False\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    return (\"anagram\", \"nagaram\")", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the position of the target element using binary search.\n\n    Return the index of the target element if found, otherwise return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=4):\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the position of the target element using binary search.\n\n    Return the index of the target element if found, otherwise return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6], target=4):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number that appears only once while all other numbers appear twice.\n\n    Example:\n    Input: [1, 1, 2, 2, 3, 4, 4]\n    Output: 3\n\n    Hint: Use XOR operation to eliminate duplicate numbers.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    return [1, 1, 2, 2, 3, 4, 4]\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number that appears only once while all other numbers appear twice.\n\n    Example:\n    Input: [1, 1, 2, 2, 3, 4, 4]\n    Output: 3\n\n    Hint: Use XOR operation to eliminate duplicate numbers.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "solution_func": "def g():\n    return [1, 1, 2, 2, 3, 4, 4]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list using the bubble sort algorithm.\n\n    Return the sorted list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n\ndef g():\n    return [5, 2, 9, 1, 7]\n\nassert f(g()) == [1, 2, 5, 7, 9]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 411, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list using the bubble sort algorithm.\n\n    Return the sorted list.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums", "solution_func": "def g():\n    return [5, 2, 9, 1, 7]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    \"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_s = \"\"\n    while stack:\n        reversed_s += stack.pop()\n    if s == reversed_s:\n        return True\n    else:\n        return False\n\ndef g(s=\"racecar\") -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 411, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    \"\"\"\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_s = \"\"\n    while stack:\n        reversed_s += stack.pop()\n    if s == reversed_s:\n        return True\n    else:\n        return False", "solution_func": "def g(s=\"racecar\") -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible subsets of the list.\n    \"\"\"\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n    return subsets\n\ndef g(nums=[1, 2, 3]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible subsets of the list.\n    \"\"\"\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n    return subsets", "solution_func": "def g(nums=[1, 2, 3]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 5\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 411, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the n-th Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, target: str) -> bool:\n    \"\"\"\n    Given a string target, find the number of distinct subsequences of length k that can be formed from the string.\n    A subsequence of a string is obtained by deleting zero or more characters from the original string without\n    changing the order of the remaining characters.\n\n    For example, if the string is \"hello\" and k is 3, the distinct subsequences of length 3 that can be formed are:\n    - \"hel\"\n    - \"hlo\"\n    - \"elo\"\n    - \"hll\"\n    - \"hle\"\n    - \"ell\"\n    So the answer would be 6.\n    \"\"\"\n    memo = [[0] * (len(target)+1) for _ in range(k+1)]\n    for i in range(len(target)+1):\n        memo[0][i] = 1\n    for i in range(1, k+1):\n        for j in range(1, len(target)+1):\n            memo[i][j] = memo[i][j-1] + memo[i-1][j-1]\n    return memo[k][len(target)] == n\n\ndef g(n = 6, k = 3, target = \"hello\"):\n    return n\nassert f(g())\n", "emb": null, "idx_generation": 411, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int, target: str) -> bool:\n    \"\"\"\n    Given a string target, find the number of distinct subsequences of length k that can be formed from the string.\n    A subsequence of a string is obtained by deleting zero or more characters from the original string without\n    changing the order of the remaining characters.\n\n    For example, if the string is \"hello\" and k is 3, the distinct subsequences of length 3 that can be formed are:\n    - \"hel\"\n    - \"hlo\"\n    - \"elo\"\n    - \"hll\"\n    - \"hle\"\n    - \"ell\"\n    So the answer would be 6.\n    \"\"\"\n    memo = [[0] * (len(target)+1) for _ in range(k+1)]\n    for i in range(len(target)+1):\n        memo[0][i] = 1\n    for i in range(1, k+1):\n        for j in range(1, len(target)+1):\n            memo[i][j] = memo[i][j-1] + memo[i-1][j-1]\n    return memo[k][len(target)] == n", "solution_func": "def g(n = 6, k = 3, target = \"hello\"):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list contains a number that is a power of two.\n    \"\"\"\n    for num in arr:\n        if num > 0 and (num & (num - 1)) == 0:\n            return True\n    return False\n\ndef g(n: int) -> List[int]:\n    \"\"\"\n    Generate a list of numbers from 1 to n.\n    \"\"\"\n    return list(range(1, n+1))\n\nassert f(g(10))\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 412, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Check if the given list contains a number that is a power of two.\n    \"\"\"\n    for num in arr:\n        if num > 0 and (num & (num - 1)) == 0:\n            return True\n    return False", "solution_func": "def g(n: int) -> List[int]:\n    \"\"\"\n    Generate a list of numbers from 1 to n.\n    \"\"\"\n    return list(range(1, n+1))", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the bitwise XOR of all numbers from 1 to n.\n    \"\"\"\n    if n % 4 == 0:\n        return n\n    if n % 4 == 1:\n        return 1\n    if n % 4 == 2:\n        return n + 1\n    return 0\n\ndef g(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all numbers from 1 to n.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\nassert f(g(10)) == 10\n", "emb": null, "idx_generation": 412, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the bitwise XOR of all numbers from 1 to n.\n    \"\"\"\n    if n % 4 == 0:\n        return n\n    if n % 4 == 1:\n        return 1\n    if n % 4 == 2:\n        return n + 1\n    return 0", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all numbers from 1 to n.\n    \"\"\"\n    return (n * (n + 1)) // 2", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of trailing zeros in the binary representation of n!\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number n.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    return n * g(n-1)\n\nassert f(g(5)) == 1\n", "emb": null, "idx_generation": 412, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the number of trailing zeros in the binary representation of n!\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number n.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    return n * g(n-1)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return a string representation of its binary form.\n\n    Example:\n    Input: 10\n    Output: \"1010\"\n\n    Hint: Use recursion to convert the decimal number to binary.\n    If n is 0, return an empty string.\n    Otherwise, recursively calculate the binary representation of n // 2 and append the remainder n % 2 as a string.\n    Finally, return the binary representation.\n    \"\"\"\n\n    if n == 0:\n        return \"\"\n    else:\n        return f(n // 2) + str(n % 2)\n\ndef g():\n    n = 10\n    return n\n\nassert f(g()) == \"1010\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 412, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> str:\n    \"\"\"\n    Given a positive integer n, return a string representation of its binary form.\n\n    Example:\n    Input: 10\n    Output: \"1010\"\n\n    Hint: Use recursion to convert the decimal number to binary.\n    If n is 0, return an empty string.\n    Otherwise, recursively calculate the binary representation of n // 2 and append the remainder n % 2 as a string.\n    Finally, return the binary representation.\n    \"\"\"\n\n    if n == 0:\n        return \"\"\n    else:\n        return f(n // 2) + str(n % 2)", "solution_func": "def g():\n    n = 10\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct substrings of s.\n\n    Example:\n    Input: \"abc\"\n    Output: 6\n\n    Explanation: The distinct substrings of \"abc\" are \"\", \"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\".\n\n    Hint: Use dynamic programming and recursion to calculate the distinct substrings.\n    Create a set to store the distinct substrings.\n    Iterate through each character in the string, and recursively find all substrings starting from that character.\n    Add each substring to the set.\n    Finally, return the size of the set.\n\n    Note: This solution has a time complexity of O(n^3), where n is the length of the string.\n    \"\"\"\n\n    def find_substrings(s: str, start: int, end: int, substrings: set):\n        if start > end:\n            return\n\n        substrings.add(s[start:end+1])\n\n        find_substrings(s, start+1, end, substrings)\n        find_substrings(s, start, end-1, substrings)\n\n    substrings = set()\n    find_substrings(s, 0, len(s)-1, substrings)\n\n    return len(substrings)\n\ndef g():\n    s = \"abc\"\n    return s\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 412, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct substrings of s.\n\n    Example:\n    Input: \"abc\"\n    Output: 6\n\n    Explanation: The distinct substrings of \"abc\" are \"\", \"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\".\n\n    Hint: Use dynamic programming and recursion to calculate the distinct substrings.\n    Create a set to store the distinct substrings.\n    Iterate through each character in the string, and recursively find all substrings starting from that character.\n    Add each substring to the set.\n    Finally, return the size of the set.\n\n    Note: This solution has a time complexity of O(n^3), where n is the length of the string.\n    \"\"\"\n\n    def find_substrings(s: str, start: int, end: int, substrings: set):\n        if start > end:\n            return\n\n        substrings.add(s[start:end+1])\n\n        find_substrings(s, start+1, end, substrings)\n        find_substrings(s, start, end-1, substrings)\n\n    substrings = set()\n    find_substrings(s, 0, len(s)-1, substrings)\n\n    return len(substrings)", "solution_func": "def g():\n    s = \"abc\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally (down-right).\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n\n    Explanation: The maximum sum path from the top-left cell (1) to the bottom-right cell (1) is 1 + 3 + 1 + 5 + 2 = 12.\n\n    Hint: Use dynamic programming to calculate the maximum sum path for each cell in the grid.\n    Start by initializing a new grid with the same size as the input grid.\n    Then, iterate through each cell in the new grid, calculating the maximum sum path based on the adjacent cells.\n    Finally, return the value in the bottom-right cell of the new grid.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 412, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down, right, or diagonally (down-right).\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n\n    Explanation: The maximum sum path from the top-left cell (1) to the bottom-right cell (1) is 1 + 3 + 1 + 5 + 2 = 12.\n\n    Hint: Use dynamic programming to calculate the maximum sum path for each cell in the grid.\n    Start by initializing a new grid with the same size as the input grid.\n    Then, iterate through each cell in the new grid, calculating the maximum sum path based on the adjacent cells.\n    Finally, return the value in the bottom-right cell of the new grid.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm and return the sorted list.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums\n\ndef g() -> List[int]:\n    return [5, 2, 8, 6, 1, 9, 3]\n\nassert f(g()) == [1, 2, 3, 5, 6, 8, 9]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 412, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm and return the sorted list.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n\n    return nums", "solution_func": "def g() -> List[int]:\n    return [5, 2, 8, 6, 1, 9, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string and return the count.\n    \"\"\"\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    for char in string:\n        if char.lower() in vowels:\n            count += 1\n\n    return count\n\ndef g() -> str:\n    return \"Hello, World!\"\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 412, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string and return the count.\n    \"\"\"\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    for char in string:\n        if char.lower() in vowels:\n            count += 1\n\n    return count", "solution_func": "def g() -> str:\n    return \"Hello, World!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using the Kadane's algorithm and return the maximum sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6, -7]\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 412, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray using the Kadane's algorithm and return the maximum sum.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6, -7]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target sum.\n    Return the indices of the two numbers in ascending order.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == [1, 3]\n", "emb": null, "idx_generation": 412, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target sum.\n    Return the indices of the two numbers in ascending order.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the bitwise AND of all possible pairs of elements.\n\n    Example:\n    arr = [3, 5, 6]\n    Output: 2 (bitwise AND of (3, 5) = 1, bitwise AND of (3, 6) = 2, bitwise AND of (5, 6) = 4)\n\n    Explanation:\n    The sum of the bitwise AND of all possible pairs is 1 + 2 + 4 = 7.\n    \"\"\"\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            result += arr[i] & arr[j]\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [3, 5, 6]\n\nassert f(g()) == 7\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 413, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of the bitwise AND of all possible pairs of elements.\n\n    Example:\n    arr = [3, 5, 6]\n    Output: 2 (bitwise AND of (3, 5) = 1, bitwise AND of (3, 6) = 2, bitwise AND of (5, 6) = 4)\n\n    Explanation:\n    The sum of the bitwise AND of all possible pairs is 1 + 2 + 4 = 7.\n    \"\"\"\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            result += arr[i] & arr[j]\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [3, 5, 6]", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value between any two elements in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    Output: 1 (minimum XOR value is between 3 and 2)\n\n    Explanation:\n    The minimum XOR value between any two elements is 1.\n    \"\"\"\n    min_xor = float('inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor < min_xor:\n                min_xor = xor\n    return min_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 1\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 413, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value between any two elements in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    Output: 1 (minimum XOR value is between 3 and 2)\n\n    Explanation:\n    The minimum XOR value between any two elements is 1.\n    \"\"\"\n    min_xor = float('inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor = arr[i] ^ arr[j]\n            if xor < min_xor:\n                min_xor = xor\n    return min_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum number that can be formed by concatenating the elements in the list.\n\n    Example:\n    arr = [10, 5, 8, 3, 4]\n    Output: 854310 (maximum number formed by concatenating 10, 5, 8, 3, and 4)\n\n    Explanation:\n    The maximum number that can be formed is 854310.\n    \"\"\"\n    arr.sort(reverse=True)\n    result = \"\"\n    for num in arr:\n        result += str(num)\n    return int(result)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 5.\n    \"\"\"\n    return [10, 5, 8, 3, 4]\n\nassert f(g()) == 854310\n\n", "emb": null, "idx_generation": 413, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum number that can be formed by concatenating the elements in the list.\n\n    Example:\n    arr = [10, 5, 8, 3, 4]\n    Output: 854310 (maximum number formed by concatenating 10, 5, 8, 3, and 4)\n\n    Explanation:\n    The maximum number that can be formed is 854310.\n    \"\"\"\n    arr.sort(reverse=True)\n    result = \"\"\n    for num in arr:\n        result += str(num)\n    return int(result)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 5.\n    \"\"\"\n    return [10, 5, 8, 3, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(s: str, words: List[str]) -> List[int]:\n    \"\"\"\n    Given a string s and a list of words, find all the starting indices of the substrings in s that are a concatenation of all the words in the list.\n    The words in the list may appear in any order and multiple times.\n    \"\"\"\n\n    def is_concatenation(s: str, words: List[str], start: int) -> bool:\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        substring = s[start:start+total_len]\n        substring_words = [substring[i:i+word_len] for i in range(0, total_len, word_len)]\n\n        count = {}\n        for word in substring_words:\n            count[word] = count.get(word, 0) + 1\n\n        for word in words:\n            if count.get(word, 0) != words.count(word):\n                return False\n\n        return True\n\n    result = []\n    if not s or not words:\n        return result\n\n    word_len = len(words[0])\n    total_len = word_len * len(words)\n    n = len(s)\n\n    for i in range(n - total_len + 1):\n        if is_concatenation(s, words, i):\n            result.append(i)\n\n    return result\n\ndef g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words, where the starting indices of the substrings in s that are a concatenation of all the words in the list can be found.\n    \"\"\"\n    return \"barfoothefoobarman\", [\"foo\", \"bar\"]\n\nassert f(*g()) == [0, 9]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 413, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(s: str, words: List[str]) -> List[int]:\n    \"\"\"\n    Given a string s and a list of words, find all the starting indices of the substrings in s that are a concatenation of all the words in the list.\n    The words in the list may appear in any order and multiple times.\n    \"\"\"\n\n    def is_concatenation(s: str, words: List[str], start: int) -> bool:\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n\n        substring = s[start:start+total_len]\n        substring_words = [substring[i:i+word_len] for i in range(0, total_len, word_len)]\n\n        count = {}\n        for word in substring_words:\n            count[word] = count.get(word, 0) + 1\n\n        for word in words:\n            if count.get(word, 0) != words.count(word):\n                return False\n\n        return True\n\n    result = []\n    if not s or not words:\n        return result\n\n    word_len = len(words[0])\n    total_len = word_len * len(words)\n    n = len(s)\n\n    for i in range(n - total_len + 1):\n        if is_concatenation(s, words, i):\n            result.append(i)\n\n    return result", "solution_func": "def g() -> Tuple[str, List[str]]:\n    \"\"\"\n    Generate a string s and a list of words, where the starting indices of the substrings in s that are a concatenation of all the words in the list can be found.\n    \"\"\"\n    return \"barfoothefoobarman\", [\"foo\", \"bar\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    zero_rows = set()\n    zero_cols = set()\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                zero_rows.add(i)\n                zero_cols.add(j)\n\n    for i in range(rows):\n        for j in range(cols):\n            if i in zero_rows or j in zero_cols:\n                matrix[i][j] = 0\n\n    return matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an m x n matrix where an element is 0, and its entire row and column should be set to 0.\n    \"\"\"\n    return [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n\nassert f(*g()) == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n", "emb": null, "idx_generation": 413, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    zero_rows = set()\n    zero_cols = set()\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                zero_rows.add(i)\n                zero_cols.add(j)\n\n    for i in range(rows):\n        for j in range(cols):\n            if i in zero_rows or j in zero_cols:\n                matrix[i][j] = 0\n\n    return matrix", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an m x n matrix where an element is 0, and its entire row and column should be set to 0.\n    \"\"\"\n    return [[1, 1, 1], [1, 0, 1], [1, 1, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find all unique combinations of four elements in the array whose sum is equal to the target.\n    \"\"\"\n\n    def backtrack(combination: List[int], start: int, target: int) -> None:\n        if len(combination) == 4 and sum(combination) == target:\n            result.append(tuple(combination))\n            return\n\n        if len(combination) >= 4:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            combination.append(nums[i])\n            backtrack(combination, i+1, target)\n            combination.pop()\n\n    result = []\n    nums.sort()\n    backtrack([], 0, target)\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers nums and an integer target, where there are unique combinations of four elements in the array whose sum is equal to the target.\n    \"\"\"\n    return [1, 0, -1, 0, -2, 2], 0\n\nassert f(*g()) == [(-2, -1, 1, 2), (-2, 0, 0, 2), (-1, 0, 0, 1)]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 413, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find all unique combinations of four elements in the array whose sum is equal to the target.\n    \"\"\"\n\n    def backtrack(combination: List[int], start: int, target: int) -> None:\n        if len(combination) == 4 and sum(combination) == target:\n            result.append(tuple(combination))\n            return\n\n        if len(combination) >= 4:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n\n            combination.append(nums[i])\n            backtrack(combination, i+1, target)\n            combination.pop()\n\n    result = []\n    nums.sort()\n    backtrack([], 0, target)\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers nums and an integer target, where there are unique combinations of four elements in the array whose sum is equal to the target.\n    \"\"\"\n    return [1, 0, -1, 0, -2, 2], 0", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    The even numbers in the list are [2, 4, 6], and their sum is 12.\n    Return 12.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 413, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    The even numbers in the list are [2, 4, 6], and their sum is 12.\n    Return 12.\n    \"\"\"\n    even_sum = 0\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n    return even_sum", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, generate the first n Fibonacci numbers.\n\n    Example:\n    n = 6\n    The first 6 Fibonacci numbers are [0, 1, 1, 2, 3, 5].\n    Return [0, 1, 1, 2, 3, 5].\n    \"\"\"\n    fibonacci = [0, 1]\n    for i in range(2, n):\n        fibonacci.append(fibonacci[i-1] + fibonacci[i-2])\n    return fibonacci[:n]\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == [0, 1, 1, 2, 3, 5]\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 413, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, generate the first n Fibonacci numbers.\n\n    Example:\n    n = 6\n    The first 6 Fibonacci numbers are [0, 1, 1, 2, 3, 5].\n    Return [0, 1, 1, 2, 3, 5].\n    \"\"\"\n    fibonacci = [0, 1]\n    for i in range(2, n):\n        fibonacci.append(fibonacci[i-1] + fibonacci[i-2])\n    return fibonacci[:n]", "solution_func": "def g() -> int:\n    return 6", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all duplicates from the list and return a new list with the unique elements.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    The unique elements in the list are [1, 2, 3, 4, 5].\n    Return [1, 2, 3, 4, 5].\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 413, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all duplicates from the list and return a new list with the unique elements.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    The unique elements in the list are [1, 2, 3, 4, 5].\n    Return [1, 2, 3, 4, 5].\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums", "solution_func": "def g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\ndef f(num: int, target: int) -> bool:\n    \"\"\"\n    Given a number num, determine if it is possible to obtain the target number by performing a series of mathematical operations on the digits of the number.\n    The operations allowed are addition, subtraction, multiplication, and division.\n    The order of the digits cannot be changed.\n    \"\"\"\n    num_str = str(num)\n    stack = []\n    stack.append(int(num_str[0]))\n    for digit in num_str[1:]:\n        temp_stack = []\n        while stack:\n            temp = stack.pop()\n            temp_stack.append(temp + int(digit))\n            temp_stack.append(temp - int(digit))\n            temp_stack.append(temp * int(digit))\n            if int(digit) != 0:\n                temp_stack.append(temp / int(digit))\n        stack = temp_stack\n    return target in stack\n\ndef g(num = 1234, target = 5):\n    return num\n\nassert f(g(), 5)\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 413, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "import math\nfrom typing import*\ndef f(num: int, target: int) -> bool:\n    \"\"\"\n    Given a number num, determine if it is possible to obtain the target number by performing a series of mathematical operations on the digits of the number.\n    The operations allowed are addition, subtraction, multiplication, and division.\n    The order of the digits cannot be changed.\n    \"\"\"\n    num_str = str(num)\n    stack = []\n    stack.append(int(num_str[0]))\n    for digit in num_str[1:]:\n        temp_stack = []\n        while stack:\n            temp = stack.pop()\n            temp_stack.append(temp + int(digit))\n            temp_stack.append(temp - int(digit))\n            temp_stack.append(temp * int(digit))\n            if int(digit) != 0:\n                temp_stack.append(temp / int(digit))\n        stack = temp_stack\n    return target in stack", "solution_func": "def g(num = 1234, target = 5):\n    return num", "map_ix": [1, 0, 0, 1, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the first occurrence of the target number.\n    If the target number does not exist in the list, return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g(nums=[1, 2, 2, 3, 4, 5, 5, 5, 6, 7], target=5):\n    return nums\n\nassert f(g(), target=5) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 414, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the first occurrence of the target number.\n    If the target number does not exist in the list, return -1.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] != target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g(nums=[1, 2, 2, 3, 4, 5, 5, 5, 6, 7], target=5):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing the indices of all occurrences of the target number.\n    If the target number does not exist in the list, return an empty list.\n    \"\"\"\n    indices = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            indices.append(i)\n    return indices\n\ndef g(nums=[1, 2, 3, 2, 4, 5, 2, 6, 2, 7], target=2):\n    return nums\n\nassert f(g(), target=2) == [1, 3, 6, 8]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 414, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list containing the indices of all occurrences of the target number.\n    If the target number does not exist in the list, return an empty list.\n    \"\"\"\n    indices = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            indices.append(i)\n    return indices", "solution_func": "def g(nums=[1, 2, 3, 2, 4, 5, 2, 6, 2, 7], target=2):\n    return nums", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list containing all words that start with the given prefix.\n    If no words start with the prefix, return an empty list.\n    \"\"\"\n    matching_words = []\n    for word in words:\n        if word.startswith(prefix):\n            matching_words.append(word)\n    return matching_words\n\ndef g(words=[\"apple\", \"banana\", \"apricot\", \"avocado\", \"blueberry\"], prefix=\"ap\"):\n    return words\n\nassert f(g(), prefix=\"ap\") == [\"apple\", \"apricot\"]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 414, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list containing all words that start with the given prefix.\n    If no words start with the prefix, return an empty list.\n    \"\"\"\n    matching_words = []\n    for word in words:\n        if word.startswith(prefix):\n            matching_words.append(word)\n    return matching_words", "solution_func": "def g(words=[\"apple\", \"banana\", \"apricot\", \"avocado\", \"blueberry\"], prefix=\"ap\"):\n    return words", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum number of edges\n    to remove in order to make the graph a tree.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\n    In this example, we can remove one edge (e.g., edge between node 0 and node 1) to form a tree.\n\n    Therefore, the function should return 1.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(graph, i, visited)\n            count += 1\n\n    return count - 1\n\ndef dfs(graph: List[List[int]], node: int, visited: List[bool]) -> None:\n    visited[node] = True\n\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            dfs(graph, neighbor, visited)\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 414, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the minimum number of edges\n    to remove in order to make the graph a tree.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\n    In this example, we can remove one edge (e.g., edge between node 0 and node 1) to form a tree.\n\n    Therefore, the function should return 1.\n    \"\"\"\n    n = len(graph)\n    visited = [False] * n\n    count = 0\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(graph, i, visited)\n            count += 1\n\n    return count - 1\n\ndef dfs(graph: List[List[int]], node: int, visited: List[bool]) -> None:\n    visited[node] = True\n\n    for neighbor in range(len(graph)):\n        if graph[node][neighbor] == 1 and not visited[neighbor]:\n            dfs(graph, neighbor, visited)", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    n = 5\n\n    The factorial of 5 is 5! = 5 * 4 * 3 * 2 * 1 = 120.\n\n    The number of trailing zeroes in 120 is 1.\n\n    Therefore, the function should return 1.\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n\n    return count\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 1\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 414, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of trailing zeroes in n!.\n\n    Example:\n    n = 5\n\n    The factorial of 5 is 5! = 5 * 4 * 3 * 2 * 1 = 120.\n\n    The number of trailing zeroes in 120 is 1.\n\n    Therefore, the function should return 1.\n    \"\"\"\n    count = 0\n    power_of_5 = 5\n\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n\n    return count", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 414, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(len(s)):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length", "solution_func": "def g():\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target number, count the number of unique combinations in the list that sum up to the target.\n\n    Each number in the list can be used unlimited times.\n\n    Return the count of unique combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n\n    nums = [2, 5, 9]\n    target = 10\n    Output: 56\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 414, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of numbers and a target number, count the number of unique combinations in the list that sum up to the target.\n\n    Each number in the list can be used unlimited times.\n\n    Return the count of unique combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n\n    nums = [2, 5, 9]\n    target = 10\n    Output: 56\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, return the number of all possible unique combinations of positive integers that add up to num.\n\n    Example:\n    num = 5\n    Output: 7\n\n    Explanation:\n    There are 7 possible combinations: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 2, 1, 1], [1, 2, 2], [2, 1, 1, 1], [2, 2, 1]\n\n    num = 10\n    Output: 42\n    \"\"\"\n    dp = [0] * (num + 1)\n    dp[0] = 1\n\n    for i in range(1, num + 1):\n        for j in range(i):\n            dp[i] += dp[j]\n\n    return dp[num]\n\ndef g(num: int = 5):\n    return num\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 414, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, return the number of all possible unique combinations of positive integers that add up to num.\n\n    Example:\n    num = 5\n    Output: 7\n\n    Explanation:\n    There are 7 possible combinations: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 2, 1, 1], [1, 2, 2], [2, 1, 1, 1], [2, 2, 1]\n\n    num = 10\n    Output: 42\n    \"\"\"\n    dp = [0] * (num + 1)\n    dp[0] = 1\n\n    for i in range(1, num + 1):\n        for j in range(i):\n            dp[i] += dp[j]\n\n    return dp[num]", "solution_func": "def g(num: int = 5):\n    return num", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct palindromic subsequences.\n\n    A subsequence is obtained by deleting some characters (possibly none) from the original string without changing the order of the remaining characters.\n\n    Example:\n    s = \"bccb\"\n    Output: 6\n\n    Explanation:\n    There are 6 distinct palindromic subsequences: \"b\", \"c\", \"bb\", \"cc\", \"bcb\", \"bccb\".\n\n    s = \"aaaa\"\n    Output: 15\n    \"\"\"\n    n = len(s)\n    MOD = 10**9 + 7\n\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n\n                while left <= right and s[left] != s[i]:\n                    left += 1\n\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n\n                if left > right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n\n            dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]\n\ndef g(s: str = \"bccb\"):\n    return s\n\nassert f(g()) == 6\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 414, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of distinct palindromic subsequences.\n\n    A subsequence is obtained by deleting some characters (possibly none) from the original string without changing the order of the remaining characters.\n\n    Example:\n    s = \"bccb\"\n    Output: 6\n\n    Explanation:\n    There are 6 distinct palindromic subsequences: \"b\", \"c\", \"bb\", \"cc\", \"bcb\", \"bccb\".\n\n    s = \"aaaa\"\n    Output: 15\n    \"\"\"\n    n = len(s)\n    MOD = 10**9 + 7\n\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n\n                while left <= right and s[left] != s[i]:\n                    left += 1\n\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n\n                if left > right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n\n            dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]", "solution_func": "def g(s: str = \"bccb\"):\n    return s", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the two numbers that sum up to the target.\n    Return the indices of these two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The pair of numbers that sum up to 9 is [2, 7].\n    The indices of these numbers in the list are 0 and 1.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 414, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the two numbers that sum up to the target.\n    Return the indices of these two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The pair of numbers that sum up to 9 is [2, 7].\n    The indices of these numbers in the list are 0 and 1.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a number of nodes and a list of edges, return the adjacency list representation of the graph.\n    The edges list contains pairs of nodes that are connected by an edge.\n    Example: n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    In this case, the function should return [[1], [0, 2], [1, 3], [2, 0]]\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    \n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    return graph\n\ndef g(n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]):\n    return n, edges\n\nassert f(*g()) == [[1], [0, 2], [1, 3], [2, 0]]\n", "emb": null, "idx_generation": 415, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a number of nodes and a list of edges, return the adjacency list representation of the graph.\n    The edges list contains pairs of nodes that are connected by an edge.\n    Example: n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]\n    In this case, the function should return [[1], [0, 2], [1, 3], [2, 0]]\n    \"\"\"\n    graph = [[] for _ in range(n)]\n    \n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    return graph", "solution_func": "def g(n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]):\n    return n, edges", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words and the characters within each word.\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            if word:\n                stack.append(word[::-1])\n                word = \"\"\n        else:\n            word += char\n    if word:\n        stack.append(word[::-1])\n    return \" \".join(stack[::-1])\n\ndef g():\n    \"\"\"\n    Generate a string with words in random order.\n    \"\"\"\n    return \"world hello my\"\n\nassert f(g()) == \"ym olleh dlrow\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 415, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words and the characters within each word.\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            if word:\n                stack.append(word[::-1])\n                word = \"\"\n        else:\n            word += char\n    if word:\n        stack.append(word[::-1])\n    return \" \".join(stack[::-1])", "solution_func": "def g():\n    \"\"\"\n    Generate a string with words in random order.\n    \"\"\"\n    return \"world hello my\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a matrix of characters, rotate it 90 degrees clockwise.\n    \"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    rotated_matrix = [['' for _ in range(rows)] for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_matrix[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated_matrix\n\ndef g():\n    \"\"\"\n    Generate a matrix of characters.\n    \"\"\"\n    return [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]\n\nassert f(g()) == [['g', 'd', 'a'], ['h', 'e', 'b'], ['i', 'f', 'c']]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 415, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Given a matrix of characters, rotate it 90 degrees clockwise.\n    \"\"\"\n    rows, cols = len(matrix), len(matrix[0])\n    rotated_matrix = [['' for _ in range(rows)] for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_matrix[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated_matrix", "solution_func": "def g():\n    \"\"\"\n    Generate a matrix of characters.\n    \"\"\"\n    return [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median element.\n    The median is the middle element if the list is sorted.\n    If the list has an even number of elements, the median is the average of the two middle elements.\n    Return the median.\n\n    Example:\n    nums = [1, 5, 3, 9, 7, 2, 4, 6, 8]\n    The middle elements after sorting the list are [4, 5, 6].\n    Therefore, the function should return 5.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 1:\n        return nums[n // 2]\n    else:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n\ndef g():\n    nums = [1, 5, 3, 9, 7, 2, 4, 6, 8]\n    return nums\n\nassert f(g()) == 5\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 415, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median element.\n    The median is the middle element if the list is sorted.\n    If the list has an even number of elements, the median is the average of the two middle elements.\n    Return the median.\n\n    Example:\n    nums = [1, 5, 3, 9, 7, 2, 4, 6, 8]\n    The middle elements after sorting the list are [4, 5, 6].\n    Therefore, the function should return 5.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 1:\n        return nums[n // 2]\n    else:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2", "solution_func": "def g():\n    nums = [1, 5, 3, 9, 7, 2, 4, 6, 8]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if there is a path from a given start vertex to a given end vertex.\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n\n    The graph can be represented as follows:\n    0 -- 1 -- 3 -- 4\n    |         |\n    2 -- 4\n\n    There is a path from vertex 0 to vertex 4: 0 -> 1 -> 3 -> 4.\n    Therefore, the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr, end, visited):\n    if curr == end:\n        return True\n    visited[curr] = True\n    for neighbor in graph[curr]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return (graph, start, end)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 415, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given an undirected graph, determine if there is a path from a given start vertex to a given end vertex.\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n\n    The graph can be represented as follows:\n    0 -- 1 -- 3 -- 4\n    |         |\n    2 -- 4\n\n    There is a path from vertex 0 to vertex 4: 0 -> 1 -> 3 -> 4.\n    Therefore, the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr, end, visited):\n    if curr == end:\n        return True\n    visited[curr] = True\n    for neighbor in graph[curr]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, end, visited):\n                return True\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0, 0],\n        [1, 0, 0, 1, 0],\n        [1, 0, 0, 1, 1],\n        [0, 1, 1, 0, 1],\n        [0, 0, 1, 1, 0]\n    ]\n    start = 0\n    end = 4\n    return (graph, start, end)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n    Return the sum.\n\n    Example:\n    n = 5\n    The first 5 natural numbers are 1, 2, 3, 4, 5.\n    The sum is 1 + 2 + 3 + 4 + 5 = 15.\n    Therefore, the function should return 15.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 415, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of the first n natural numbers.\n    Return the sum.\n\n    Example:\n    n = 5\n    The first 5 natural numbers are 1, 2, 3, 4, 5.\n    The sum is 1 + 2 + 3 + 4 + 5 = 15.\n    Therefore, the function should return 15.\n    \"\"\"\n    return (n * (n + 1)) // 2", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], and the sum is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    current_sum = 0\n    max_sum = float('-inf')\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 415, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], and the sum is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    current_sum = 0\n    max_sum = float('-inf')\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the indices of two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] because nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 415, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return the indices of two numbers such that they add up to the target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] because nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next permutation in-place.\n\n    If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\n    The function should modify the input list in-place and return nothing.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The next permutation is [1, 3, 2].\n\n    Therefore, the modified nums should be [1, 3, 2].\n    \"\"\"\n    i = len(nums) - 2\n\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    left = i + 1\n    right = len(nums) - 1\n\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nnums = g()\nf(nums)\nassert nums == [1, 3, 2]\n\nassert f(g()) == True", "emb": null, "idx_generation": 415, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next permutation in-place.\n\n    If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\n\n    The function should modify the input list in-place and return nothing.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The next permutation is [1, 3, 2].\n\n    Therefore, the modified nums should be [1, 3, 2].\n    \"\"\"\n    i = len(nums) - 2\n\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    left = i + 1\n    right = len(nums) - 1\n\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1", "solution_func": "def g():\n    nums = [1, 2, 3]\n    return nums\n\nnums = g()\nf(nums)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all substrings of length k that contain only unique characters.\n\n    Example:\n    s = \"abacab\"\n    k = 3\n    Output: [\"aba\", \"bac\"]\n\n    Explanation:\n    The substrings of length 3 that contain only unique characters are \"aba\" and \"bac\".\n\n    Note:\n    - The input string s will consist of lowercase English letters.\n    - It is guaranteed that there will be at least one substring of length k that contains only unique characters.\n    \"\"\"\n\n    result = []\n    for i in range(len(s) - k + 1):\n        substring = s[i:i+k]\n        if len(substring) == len(set(substring)):\n            result.append(substring)\n    return result\n\ndef g():\n    s = \"abacab\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"aba\", \"bac\"]\n\n", "emb": null, "idx_generation": 415, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all substrings of length k that contain only unique characters.\n\n    Example:\n    s = \"abacab\"\n    k = 3\n    Output: [\"aba\", \"bac\"]\n\n    Explanation:\n    The substrings of length 3 that contain only unique characters are \"aba\" and \"bac\".\n\n    Note:\n    - The input string s will consist of lowercase English letters.\n    - It is guaranteed that there will be at least one substring of length k that contains only unique characters.\n    \"\"\"\n\n    result = []\n    for i in range(len(s) - k + 1):\n        substring = s[i:i+k]\n        if len(substring) == len(set(substring)):\n            result.append(substring)\n    return result", "solution_func": "def g():\n    s = \"abacab\"\n    k = 3\n    return s, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in non-decreasing order using merge sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = f(arr[:mid])\n    right = f(arr[mid:])\n    \n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    \n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    \n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    \n    return arr\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers to be sorted.\n    \"\"\"\n    return [5, 2, 8, 1, 9, 3]\n\nassert f(g()) == [1, 2, 3, 5, 8, 9]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the given list of integers in non-decreasing order using merge sort algorithm.\n    Return the sorted list.\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = f(arr[:mid])\n    right = f(arr[mid:])\n    \n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    \n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    \n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    \n    return arr", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers to be sorted.\n    \"\"\"\n    return [5, 2, 8, 1, 9, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph with n nodes and a list of edges, determine if the graph is a tree.\n    Return True if it is a tree, False otherwise.\n    \"\"\"\n    if len(edges) != n - 1:\n        return False\n    \n    graph = {i: [] for i in range(n)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    def dfs(node: int, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    if dfs(0, -1):\n        return False\n    \n    return all(visited)\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate a graph with n nodes and a list of edges.\n    \"\"\"\n    n = 5\n    edges = [(0, 1), (0, 2), (0, 3), (1, 4)]\n    return n, edges\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Given an undirected graph with n nodes and a list of edges, determine if the graph is a tree.\n    Return True if it is a tree, False otherwise.\n    \"\"\"\n    if len(edges) != n - 1:\n        return False\n    \n    graph = {i: [] for i in range(n)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    def dfs(node: int, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n    \n    if dfs(0, -1):\n        return False\n    \n    return all(visited)", "solution_func": "def g() -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Generate a graph with n nodes and a list of edges.\n    \"\"\"\n    n = 5\n    edges = [(0, 1), (0, 2), (0, 3), (1, 4)]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of n using recursion.\n    Return the factorial.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n to calculate its factorial.\n    \"\"\"\n    return 6\n\nassert f(g()) == 720\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of n using recursion.\n    Return the factorial.\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * f(n-1)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n to calculate its factorial.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, determine if it is possible to select k elements from the list\n    such that their sum is equal to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total == target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort(reverse=True)\n    return backtrack(0, 0, 0)\n\n\ndef g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and an integer k, such that it is possible to select k elements from the list\n    such that their sum is equal to the target.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums, target, k\n\n# Test case\nnums = [5, 4, 3, 2, 1]\ntarget = 10\nk = 3\nassert f(*g(nums, target, k))\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, determine if it is possible to select k elements from the list\n    such that their sum is equal to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total == target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort(reverse=True)\n    return backtrack(0, 0, 0)", "solution_func": "def g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and an integer k, such that it is possible to select k elements from the list\n    such that their sum is equal to the target.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums, target, k\n\n# Test case\nnums = [5, 4, 3, 2, 1]\ntarget = 10\nk = 3", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list that sum up to the target.\n    Each number in the list may be used multiple times in each combination.\n    Return a list of all unique combinations.\n    \"\"\"\n    result = []\n    nums.sort()\n    backtrack(nums, target, [], result)\n    return result\n\ndef backtrack(nums, target, combination, result):\n    if target == 0:\n        result.append(combination)\n        return\n    for i in range(len(nums)):\n        if nums[i] > target:\n            break\n        backtrack(nums[i:], target-nums[i], combination+[nums[i]], result)\n\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 2], [1, 1, 1, 3], [1, 1, 2, 2], [1, 2, 4], [1, 3, 3], [2, 2, 3], [5]]\n", "emb": null, "idx_generation": 416, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list that sum up to the target.\n    Each number in the list may be used multiple times in each combination.\n    Return a list of all unique combinations.\n    \"\"\"\n    result = []\n    nums.sort()\n    backtrack(nums, target, [], result)\n    return result\n\ndef backtrack(nums, target, combination, result):\n    if target == 0:\n        result.append(combination)\n        return\n    for i in range(len(nums)):\n        if nums[i] > target:\n            break\n        backtrack(nums[i:], target-nums[i], combination+[nums[i]], result)", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, determine if it is possible to select k elements from the list\n    such that their sum is less than or equal to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total <= target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort(reverse=True)\n    return backtrack(0, 0, 0)\n\n\ndef g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and an integer k, such that it is possible to select k elements from the list\n    such that their sum is less than or equal to the target.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums, target, k\n\n# Test case\nnums = [5, 4, 3, 2, 1]\ntarget = 10\nk = 3\nassert f(*g(nums, target, k))\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers, a target value, and an integer k, determine if it is possible to select k elements from the list\n    such that their sum is less than or equal to the target. Return True if such a combination exists, False otherwise.\n    \"\"\"\n    def backtrack(index: int, count: int, total: int) -> bool:\n        if count == k:\n            return total <= target\n        if index == len(nums):\n            return False\n        if total + nums[index] <= target and backtrack(index + 1, count + 1, total + nums[index]):\n            return True\n        return backtrack(index + 1, count, total)\n    \n    nums.sort(reverse=True)\n    return backtrack(0, 0, 0)", "solution_func": "def g(nums: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Generate a list of integers, a target value, and an integer k, such that it is possible to select k elements from the list\n    such that their sum is less than or equal to the target.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums, target, k\n\n# Test case\nnums = [5, 4, 3, 2, 1]\ntarget = 10\nk = 3", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, return all possible combinations of nums.\n\n    Sample Input:\n    nums = [1, 2, 3]\n\n    Sample Output:\n    [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Sample Input:\n    nums = [0, 1]\n\n    Sample Output:\n    [[0], [1], [0, 1]]\n\n    \"\"\"\n    def backtrack(first: int, curr: List[int]):\n        output.append(curr[:])\n        for i in range(first, n):\n            curr.append(nums[i])\n            backtrack(i + 1, curr)\n            curr.pop()\n\n    n = len(nums)\n    output = []\n    backtrack(0, [])\n    return output\n\ndef g(nums=[1, 2, 3]):\n    return nums\n\nassert f(g()) == [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 416, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, return all possible combinations of nums.\n\n    Sample Input:\n    nums = [1, 2, 3]\n\n    Sample Output:\n    [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n    Sample Input:\n    nums = [0, 1]\n\n    Sample Output:\n    [[0], [1], [0, 1]]\n\n    \"\"\"\n    def backtrack(first: int, curr: List[int]):\n        output.append(curr[:])\n        for i in range(first, n):\n            curr.append(nums[i])\n            backtrack(i + 1, curr)\n            curr.pop()\n\n    n = len(nums)\n    output = []\n    backtrack(0, [])\n    return output", "solution_func": "def g(nums=[1, 2, 3]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only the characters '(' and ')', determine if the input string is valid.\n\n    A string is valid if:\n    - Open brackets must be closed by the same type of brackets.\n    - Open brackets must be closed in the correct order.\n\n    Sample Input:\n    s = \"()\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"()[]{}\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"(]\"\n\n    Sample Output:\n    False\n\n    \"\"\"\n    stack = []\n    for char in s:\n        if char in \"({[\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            if char == \")\" and stack[-1] != \"(\":\n                return False\n            if char == \"]\" and stack[-1] != \"[\":\n                return False\n            if char == \"}\" and stack[-1] != \"{\":\n                return False\n            stack.pop()\n\n    return len(stack) == 0\n\ndef g(s=\"()\"):\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 416, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s containing only the characters '(' and ')', determine if the input string is valid.\n\n    A string is valid if:\n    - Open brackets must be closed by the same type of brackets.\n    - Open brackets must be closed in the correct order.\n\n    Sample Input:\n    s = \"()\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"()[]{}\"\n\n    Sample Output:\n    True\n\n    Sample Input:\n    s = \"(]\"\n\n    Sample Output:\n    False\n\n    \"\"\"\n    stack = []\n    for char in s:\n        if char in \"({[\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            if char == \")\" and stack[-1] != \"(\":\n                return False\n            if char == \"]\" and stack[-1] != \"[\":\n                return False\n            if char == \"}\" and stack[-1] != \"{\":\n                return False\n            stack.pop()\n\n    return len(stack) == 0", "solution_func": "def g(s=\"()\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers nums and a target integer, return all unique combinations of nums where the\n    chosen numbers sum to target.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [[2, 2, 3], [7]]\n\n    Sample Input:\n    nums = [2, 3, 5]\n    target = 8\n\n    Sample Output:\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n    \"\"\"\n    def backtrack(curr: List[int], remain: int, start: int):\n        if remain < 0:\n            return\n        if remain == 0:\n            output.append(curr[:])\n            return\n        for i in range(start, len(nums)):\n            curr.append(nums[i])\n            backtrack(curr, remain - nums[i], i)\n            curr.pop()\n\n    output = []\n    backtrack([], target, 0)\n    return output\n\ndef g(nums=[2, 3, 6, 7], target=7):\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers nums and a target integer, return all unique combinations of nums where the\n    chosen numbers sum to target.\n\n    Sample Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Sample Output:\n    [[2, 2, 3], [7]]\n\n    Sample Input:\n    nums = [2, 3, 5]\n    target = 8\n\n    Sample Output:\n    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n    \"\"\"\n    def backtrack(curr: List[int], remain: int, start: int):\n        if remain < 0:\n            return\n        if remain == 0:\n            output.append(curr[:])\n            return\n        for i in range(start, len(nums)):\n            curr.append(nums[i])\n            backtrack(curr, remain - nums[i], i)\n            curr.pop()\n\n    output = []\n    backtrack([], target, 0)\n    return output", "solution_func": "def g(nums=[2, 3, 6, 7], target=7):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items.\n\n    Input: n = 8, k = 2\n    Output: 28\n    Explanation: There are 28 ways to choose 2 items from a set of 8 items.\n    \"\"\"\n    def combinations(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n\n    return combinations(n, k)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of two positive integers.\n    \"\"\"\n    return [6, 4]\n\nassert f(*g()) == 15\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 416, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the number of ways to choose k items from a set of n items.\n\n    Example:\n    Input: n = 5, k = 3\n    Output: 10\n    Explanation: There are 10 ways to choose 3 items from a set of 5 items.\n\n    Input: n = 8, k = 2\n    Output: 28\n    Explanation: There are 28 ways to choose 2 items from a set of 8 items.\n    \"\"\"\n    def combinations(n: int, k: int) -> int:\n        if k == 0 or k == n:\n            return 1\n        return combinations(n - 1, k - 1) + combinations(n - 1, k)\n\n    return combinations(n, k)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of two positive integers.\n    \"\"\"\n    return [6, 4]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target value, find if there exists a subsequence of the given list such that the bitwise XOR\n    of all the elements in the subsequence is equal to the target value.\n\n    Args:\n    nums (List[int]): The list of numbers.\n    target (int): The target value.\n\n    Returns:\n    bool: True if there exists a subsequence whose bitwise XOR is equal to the target, False otherwise.\n    \"\"\"\n    n = len(nums)\n  \n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n  \n    for i in range(n + 1):\n        dp[i][0] = 1\n  \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n  \n            if nums[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n  \n    return dp[n][target]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 417, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of numbers and a target value, find if there exists a subsequence of the given list such that the bitwise XOR\n    of all the elements in the subsequence is equal to the target value.\n\n    Args:\n    nums (List[int]): The list of numbers.\n    target (int): The target value.\n\n    Returns:\n    bool: True if there exists a subsequence whose bitwise XOR is equal to the target, False otherwise.\n    \"\"\"\n    n = len(nums)\n  \n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n  \n    for i in range(n + 1):\n        dp[i][0] = 1\n  \n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n  \n            if nums[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - nums[i - 1]]\n  \n    return dp[n][target]", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is a subsequence of s.\n\n    Args:\n    s (str): The input string.\n    t (str): The subsequence to check.\n\n    Returns:\n    bool: True if t is a subsequence of s, False otherwise.\n    \"\"\"\n    m = len(s)\n    n = len(t)\n  \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n  \n    for i in range(m + 1):\n        dp[i][0] = 1\n  \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i - 1][j]\n  \n    return dp[m][n]\n\ndef g():\n    s = \"abcde\"\n    t = \"ace\"\n    return s, t\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 417, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is a subsequence of s.\n\n    Args:\n    s (str): The input string.\n    t (str): The subsequence to check.\n\n    Returns:\n    bool: True if t is a subsequence of s, False otherwise.\n    \"\"\"\n    m = len(s)\n    n = len(t)\n  \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n  \n    for i in range(m + 1):\n        dp[i][0] = 1\n  \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i - 1][j]\n  \n    return dp[m][n]", "solution_func": "def g():\n    s = \"abcde\"\n    t = \"ace\"\n    return s, t", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, find the length of the longest subsequence that consists of only vowels.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    bool: True if the length of the longest subsequence of vowels is equal to 5, False otherwise.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n  \n    n = len(s)\n  \n    dp = [0] * (n + 1)\n  \n    for i in range(1, n + 1):\n        if s[i - 1] in vowels:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = dp[i - 1]\n  \n    return dp[n] == 5\n\ndef g():\n    s = \"aeioubcdfg\"\n    return s\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 417, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, find the length of the longest subsequence that consists of only vowels.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    bool: True if the length of the longest subsequence of vowels is equal to 5, False otherwise.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n  \n    n = len(s)\n  \n    dp = [0] * (n + 1)\n  \n    for i in range(1, n + 1):\n        if s[i - 1] in vowels:\n            dp[i] = dp[i - 1] + 1\n        else:\n            dp[i] = dp[i - 1]\n  \n    return dp[n] == 5", "solution_func": "def g():\n    s = \"aeioubcdfg\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of pairs of integers in the list whose bitwise XOR is equal to the target number.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: 2\n\n    Explanation:\n    2 ^ 4 = 6 and 3 ^ 5 = 6, which are equal to the target number.\n    Therefore, there are two pairs of integers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    count = 0\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number, where there exists pairs of integers in the list whose bitwise XOR is equal to the target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 417, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the number of pairs of integers in the list whose bitwise XOR is equal to the target number.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 6\n    Output: 2\n\n    Explanation:\n    2 ^ 4 = 6 and 3 ^ 5 = 6, which are equal to the target number.\n    Therefore, there are two pairs of integers whose bitwise XOR is equal to the target number.\n    \"\"\"\n    count = 0\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number, where there exists pairs of integers in the list whose bitwise XOR is equal to the target number.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine whether the graph contains a cycle.\n\n    Example:\n    Input: graph = [[0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]\n    Output: True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] and parent != neighbor:\n                    return True\n                elif not visited[neighbor] and dfs(neighbor, visited, node):\n                    return True\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representation of a graph that contains a cycle.\n    \"\"\"\n    return [[0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 417, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, determine whether the graph contains a cycle.\n\n    Example:\n    Input: graph = [[0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]\n    Output: True\n\n    Explanation:\n    The graph contains a cycle: 0 -> 1 -> 2 -> 0\n    \"\"\"\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] and parent != neighbor:\n                    return True\n                elif not visited[neighbor] and dfs(neighbor, visited, node):\n                    return True\n        return False\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, -1):\n                return True\n    \n    return False", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representation of a graph that contains a cycle.\n    \"\"\"\n    return [[0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n\n    Example:\n    Input: strings = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n    \"\"\"\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    for string in strings[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of strings with a common prefix.\n    \"\"\"\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == \"fl\"\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 417, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n\n    Example:\n    Input: strings = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n    \"\"\"\n    if not strings:\n        return \"\"\n    \n    prefix = strings[0]\n    for string in strings[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of strings with a common prefix.\n    \"\"\"\n    return [\"flower\", \"flow\", \"flight\"]", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(lst: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the input list.\n\n    Example:\n    lst = [1, 2, 3, 4, 5]\n\n    The output should be [1, 3, 6, 10, 15] since the first element remains the same, the second element is the sum of the first element (1) and the second element (2), the third element is the sum of the first three elements (1 + 2 + 3), and so on.\n\n    Hint: Use the concept of prefix sum and a stack or queue to store the previous elements.\n    \"\"\"\n    prefix_sum = []\n    total = 0\n    for num in lst:\n        total += num\n        prefix_sum.append(total)\n    return prefix_sum\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 3, 6, 10, 15]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 417, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(lst: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the input list.\n\n    Example:\n    lst = [1, 2, 3, 4, 5]\n\n    The output should be [1, 3, 6, 10, 15] since the first element remains the same, the second element is the sum of the first element (1) and the second element (2), the third element is the sum of the first three elements (1 + 2 + 3), and so on.\n\n    Hint: Use the concept of prefix sum and a stack or queue to store the previous elements.\n    \"\"\"\n    prefix_sum = []\n    total = 0\n    for num in lst:\n        total += num\n        prefix_sum.append(total)\n    return prefix_sum", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if two strings are anagrams of each other.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    The output should be True since \"listen\" and \"silent\" are anagrams of each other.\n\n    Hint: Use bit manipulation and string manipulation techniques to solve this problem.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    s1_count = [0] * 26\n    s2_count = [0] * 26\n\n    for char in s1:\n        s1_count[ord(char) - ord('a')] += 1\n    for char in s2:\n        s2_count[ord(char) - ord('a')] += 1\n\n    for i in range(26):\n        if s1_count[i] != s2_count[i]:\n            return False\n\n    return True\n\ndef g():\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 417, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Check if two strings are anagrams of each other.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n    Example:\n    s1 = \"listen\"\n    s2 = \"silent\"\n\n    The output should be True since \"listen\" and \"silent\" are anagrams of each other.\n\n    Hint: Use bit manipulation and string manipulation techniques to solve this problem.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    s1_count = [0] * 26\n    s2_count = [0] * 26\n\n    for char in s1:\n        s1_count[ord(char) - ord('a')] += 1\n    for char in s2:\n        s2_count[ord(char) - ord('a')] += 1\n\n    for i in range(26):\n        if s1_count[i] != s2_count[i]:\n            return False\n\n    return True", "solution_func": "def g():\n    return (\"listen\", \"silent\")", "map_ix": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements.\n\n    XOR is a binary operation that takes two equal-length binary representations and returns their difference. It is commonly used in cryptography and computer science.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    The output should be 28, which is the maximum XOR value of any two elements in the array.\n\n    Hint: Use bit manipulation and mathematical properties to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in arr:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max_xor ^ prefix) in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor\n\ndef g():\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 417, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements.\n\n    XOR is a binary operation that takes two equal-length binary representations and returns their difference. It is commonly used in cryptography and computer science.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n\n    The output should be 28, which is the maximum XOR value of any two elements in the array.\n\n    Hint: Use bit manipulation and mathematical properties to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in arr:\n            prefix_set.add(num & mask)\n\n        temp_max_xor = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max_xor ^ prefix) in prefix_set:\n                max_xor = temp_max_xor\n                break\n\n    return max_xor", "solution_func": "def g():\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a number n, find the number of ways to select k distinct numbers from the range 1 to n (inclusive) such that\n    the sum of the selected numbers is divisible by k.\n    \"\"\"\n    def count_ways(n, k, curr_sum, selected):\n        if len(selected) == k:\n            if curr_sum % k == 0:\n                return 1\n            else:\n                return 0\n        if n == 0:\n            return 0\n        \n        # include current number\n        selected.append(n)\n        count1 = count_ways(n-1, k, curr_sum + n, selected)\n        selected.pop()\n        \n        # exclude current number\n        count2 = count_ways(n-1, k, curr_sum, selected)\n        \n        return count1 + count2\n    \n    return count_ways(n, k, 0, [])\n\ndef g():\n    return 5, 3\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 417, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given a number n, find the number of ways to select k distinct numbers from the range 1 to n (inclusive) such that\n    the sum of the selected numbers is divisible by k.\n    \"\"\"\n    def count_ways(n, k, curr_sum, selected):\n        if len(selected) == k:\n            if curr_sum % k == 0:\n                return 1\n            else:\n                return 0\n        if n == 0:\n            return 0\n        \n        # include current number\n        selected.append(n)\n        count1 = count_ways(n-1, k, curr_sum + n, selected)\n        selected.pop()\n        \n        # exclude current number\n        count2 = count_ways(n-1, k, curr_sum, selected)\n        \n        return count1 + count2\n    \n    return count_ways(n, k, 0, [])", "solution_func": "def g():\n    return 5, 3", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the elements of nums in non-decreasing order, with all duplicates removed.\n\n    Example:\n    Input: nums = [3, 1, 2, 2, 1, 4, 5, 4]\n    Output: [1, 2, 3, 4, 5]\n\n    Explanation:\n    The input list contains duplicates and is not sorted. The output list is a sorted version of the input list with duplicates removed.\n\n    Note:\n    - The input list may contain negative numbers.\n    - The output list should not contain any duplicates.\n    - The output list should be in non-decreasing order.\n    \"\"\"\n\n    nums = sorted(set(nums))\n    return nums\n\ndef g():\n    return [3, 1, 2, 2, 1, 4, 5, 4]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the elements of nums in non-decreasing order, with all duplicates removed.\n\n    Example:\n    Input: nums = [3, 1, 2, 2, 1, 4, 5, 4]\n    Output: [1, 2, 3, 4, 5]\n\n    Explanation:\n    The input list contains duplicates and is not sorted. The output list is a sorted version of the input list with duplicates removed.\n\n    Note:\n    - The input list may contain negative numbers.\n    - The output list should not contain any duplicates.\n    - The output list should be in non-decreasing order.\n    \"\"\"\n\n    nums = sorted(set(nums))\n    return nums", "solution_func": "def g():\n    return [3, 1, 2, 2, 1, 4, 5, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of two numbers from nums that add up to the target. \n    If there are multiple pairs that add up to the target, return any one of them.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [2, 7]\n\n    Explanation:\n    The input list contains the pair (2, 7) which adds up to the target 9.\n\n    Note:\n    - The input list may contain negative numbers.\n    - There will always be a solution in the input list.\n    \"\"\"\n\n    num_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return [num, complement]\n\ndef g():\n    return [3, 1, 5, 2, 7, 4, 6], 10\n\nassert f(*g()) == [3, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of two numbers from nums that add up to the target. \n    If there are multiple pairs that add up to the target, return any one of them.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [2, 7]\n\n    Explanation:\n    The input list contains the pair (2, 7) which adds up to the target 9.\n\n    Note:\n    - The input list may contain negative numbers.\n    - There will always be a solution in the input list.\n    \"\"\"\n\n    num_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return [num, complement]", "solution_func": "def g():\n    return [3, 1, 5, 2, 7, 4, 6], 10", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the elements of nums in non-decreasing order,\n    with all duplicates removed and all odd numbers removed.\n\n    Example:\n    Input: nums = [3, 1, 2, 2, 1, 4, 5, 4]\n    Output: [2, 4]\n\n    Explanation:\n    The input list contains duplicates and odd numbers. The output list is a sorted version of the input list\n    with duplicates and odd numbers removed.\n\n    Note:\n    - The input list may contain negative numbers.\n    - The output list should not contain any duplicates.\n    - The output list should only contain even numbers.\n    - The output list should be in non-decreasing order.\n    \"\"\"\n\n    nums = sorted(set(nums))\n    nums = [num for num in nums if num % 2 == 0]\n    return nums\n\ndef g():\n    return [3, 1, 2, 2, 1, 4, 5, 4]\n\nassert f(g()) == [2, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list that contains the elements of nums in non-decreasing order,\n    with all duplicates removed and all odd numbers removed.\n\n    Example:\n    Input: nums = [3, 1, 2, 2, 1, 4, 5, 4]\n    Output: [2, 4]\n\n    Explanation:\n    The input list contains duplicates and odd numbers. The output list is a sorted version of the input list\n    with duplicates and odd numbers removed.\n\n    Note:\n    - The input list may contain negative numbers.\n    - The output list should not contain any duplicates.\n    - The output list should only contain even numbers.\n    - The output list should be in non-decreasing order.\n    \"\"\"\n\n    nums = sorted(set(nums))\n    nums = [num for num in nums if num % 2 == 0]\n    return nums", "solution_func": "def g():\n    return [3, 1, 2, 2, 1, 4, 5, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if the target number is present in the list using binary search.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if the target number is present in the list using binary search.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n using the formula (n * (n + 1)) / 2.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10\n\nassert f(g()) == 55\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all numbers from 1 to n using the formula (n * (n + 1)) / 2.\n    \"\"\"\n    return (n * (n + 1)) // 2", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    return 10", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the bitwise complement of the corresponding element in the original list.\n    \"\"\"\n    return [~x for x in arr]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [-2, -3, -4, -5, -6]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the bitwise complement of the corresponding element in the original list.\n    \"\"\"\n    return [~x for x in arr]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers is 60 (4 * 5 * 3).\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers is 60 (4 * 5 * 3).\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to the target are 2 and 7.\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to the target are 2 and 7.\n\n    Therefore, the function should return [2, 7].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101].\n\n    Therefore, the function should return 4.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list with all duplicate elements removed and sorted in ascending order.\n\n    Example:\n    Input: [1, 3, 2, 2, 4, 1]\n    Output: [1, 2, 3, 4]\n    \"\"\"\n    nums = list(set(nums))  # Remove duplicates\n    nums.sort()  # Sort in ascending order\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 2, 2, 4, 1]\n\nassert f(g()) == [1, 2, 3, 4]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 418, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the list with all duplicate elements removed and sorted in ascending order.\n\n    Example:\n    Input: [1, 3, 2, 2, 4, 1]\n    Output: [1, 2, 3, 4]\n    \"\"\"\n    nums = list(set(nums))  # Remove duplicates\n    nums.sort()  # Sort in ascending order\n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 2, 2, 4, 1]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from a set of n items without repetition.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 5 items in the set: {1, 2, 3, 4, 5}.\n    The number of ways to choose 3 items from this set without repetition is 10: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    \"\"\"\n    factorial = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorial[i] = factorial[i - 1] * i\n\n    return factorial[n] // (factorial[k] * factorial[n - k])\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 419, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from a set of n items without repetition.\n\n    Example:\n    n = 5, k = 3\n\n    Output:\n    10\n\n    Explanation:\n    There are 5 items in the set: {1, 2, 3, 4, 5}.\n    The number of ways to choose 3 items from this set without repetition is 10: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    \"\"\"\n    factorial = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorial[i] = factorial[i - 1] * i\n\n    return factorial[n] // (factorial[k] * factorial[n - k])", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) such that i < j and nums[i] XOR nums[j] is even.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    6\n\n    Explanation:\n    The pairs (1, 3), (1, 5), (2, 4), (3, 5), (4, 5) have an even XOR value.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 419, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of pairs (i, j) such that i < j and nums[i] XOR nums[j] is even.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output:\n    6\n\n    Explanation:\n    The pairs (1, 3), (1, 5), (2, 4), (3, 5), (4, 5) have an even XOR value.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    15\n\n    Explanation:\n    The maximum XOR value is obtained by selecting the cell with value 3 in the first row, the cell with value 6 in the second row, and the cell with value 6 in the third row.\n    3 ^ 6 ^ 6 = 15\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    max_xor = 0\n    for i in range(m):\n        for j in range(n):\n            for k in range(i + 1, m):\n                for l in range(j + 1, n):\n                    max_xor = max(max_xor, grid[i][j] ^ grid[k][l])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of positive integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n", "emb": null, "idx_generation": 419, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size m x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Output:\n    15\n\n    Explanation:\n    The maximum XOR value is obtained by selecting the cell with value 3 in the first row, the cell with value 6 in the second row, and the cell with value 6 in the third row.\n    3 ^ 6 ^ 6 = 15\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    max_xor = 0\n    for i in range(m):\n        for j in range(n):\n            for k in range(i + 1, m):\n                for l in range(j + 1, n):\n                    max_xor = max(max_xor, grid[i][j] ^ grid[k][l])\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of positive integers.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists two elements in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The elements 1 and 2 have bitwise XOR of 3, which is equal to the target value 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_xor = nums[i] ^ nums[j]\n\n            if curr_xor == target:\n                return True\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 3) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 419, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists two elements in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The elements 1 and 2 have bitwise XOR of 3, which is equal to the target value 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_xor = nums[i] ^ nums[j]\n\n            if curr_xor == target:\n                return True\n\n    return False", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the XOR of all other elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The XOR of all other elements for each element in the list is:\n    [14, 15, 12, 13, 10]\n\n    Therefore, the function should return [14, 15, 12, 13, 10].\n    \"\"\"\n\n    n = len(nums)\n    xor_list = []\n\n    for i in range(n):\n        xor_result = 0\n\n        for j in range(n):\n            if i != j:\n                xor_result ^= nums[j]\n\n        xor_list.append(xor_result)\n\n    return xor_list\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [14, 15, 12, 13, 10]\n\n", "emb": null, "idx_generation": 419, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the XOR of all other elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The XOR of all other elements for each element in the list is:\n    [14, 15, 12, 13, 10]\n\n    Therefore, the function should return [14, 15, 12, 13, 10].\n    \"\"\"\n\n    n = len(nums)\n    xor_list = []\n\n    for i in range(n):\n        xor_result = 0\n\n        for j in range(n):\n            if i != j:\n                xor_result ^= nums[j]\n\n        xor_list.append(xor_result)\n\n    return xor_list", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine the number of pairs (i, j) such that nums[i] XOR nums[j] = target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    There are 2 pairs (1, 2) and (2, 1) where the XOR is equal to the target value 3.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if nums[i] ^ nums[j] == target:\n                count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 3) == 2\n\n", "emb": null, "idx_generation": 419, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine the number of pairs (i, j) such that nums[i] XOR nums[j] = target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    There are 2 pairs (1, 2) and (2, 1) where the XOR is equal to the target value 3.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if nums[i] ^ nums[j] == target:\n                count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the largest subarray sum.\n    The subarray must contain consecutive elements and the sum should be maximized.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    The largest subarray sum is 9, which is obtained by the subarray [3, 4, -1, 2, 1].\n\n    Therefore, the function should return 9.\n\n    Note:\n    - The length of the list will be at least 1 and at most 10^5.\n    - The range of integers in the list is -10^4 <= nums[i] <= 10^4.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 9\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 419, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the largest subarray sum.\n    The subarray must contain consecutive elements and the sum should be maximized.\n\n    Example:\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\n    The largest subarray sum is 9, which is obtained by the subarray [3, 4, -1, 2, 1].\n\n    Therefore, the function should return 9.\n\n    Note:\n    - The length of the list will be at least 1 and at most 10^5.\n    - The range of integers in the list is -10^4 <= nums[i] <= 10^4.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest subsequence where the difference between consecutive\n    elements is the same.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 2, 4, 6]\n\n    The longest subsequence with the same difference between consecutive elements is [1, 3, 5, 7, 9],\n    with a difference of 2 between each element.\n\n    Therefore, the function should return 5.\n\n    Note:\n    - The length of the list will be at least 1 and at most 10^3.\n    - The range of integers in the list is -10^3 <= nums[i] <= 10^3.\n    \"\"\"\n    if len(nums) < 2:\n        return len(nums)\n\n    max_length = 0\n    differences = {}\n\n    for num in nums:\n        if num in differences:\n            differences[num] += 1\n        else:\n            differences[num] = 1\n\n    for num in nums:\n        curr_length = 1\n        diff = num - differences[num]\n\n        while diff in differences:\n            curr_length += 1\n            diff -= differences[diff]\n\n        max_length = max(max_length, curr_length)\n\n    return max_length\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 2, 4, 6]\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 419, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest subsequence where the difference between consecutive\n    elements is the same.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 2, 4, 6]\n\n    The longest subsequence with the same difference between consecutive elements is [1, 3, 5, 7, 9],\n    with a difference of 2 between each element.\n\n    Therefore, the function should return 5.\n\n    Note:\n    - The length of the list will be at least 1 and at most 10^3.\n    - The range of integers in the list is -10^3 <= nums[i] <= 10^3.\n    \"\"\"\n    if len(nums) < 2:\n        return len(nums)\n\n    max_length = 0\n    differences = {}\n\n    for num in nums:\n        if num in differences:\n            differences[num] += 1\n        else:\n            differences[num] = 1\n\n    for num in nums:\n        curr_length = 1\n        diff = num - differences[num]\n\n        while diff in differences:\n            curr_length += 1\n            diff -= differences[diff]\n\n        max_length = max(max_length, curr_length)\n\n    return max_length", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 2, 4, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (not necessarily contiguous).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 18], with a length of 4.\n\n    Therefore, the function should return 4.\n\n    Note:\n    - The length of the list will be at least 1 and at most 2500.\n    - The range of integers in the list is -10^4 <= nums[i] <= 10^4.\n    \"\"\"\n    if len(nums) < 2:\n        return len(nums)\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 419, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence (not necessarily contiguous).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 18], with a length of 4.\n\n    Therefore, the function should return 4.\n\n    Note:\n    - The length of the list will be at least 1 and at most 2500.\n    - The range of integers in the list is -10^4 <= nums[i] <= 10^4.\n    \"\"\"\n    if len(nums) < 2:\n        return len(nums)\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers nums.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target_sum=100) -> bool:\n    \"\"\"Find a subset of numbers from the given list that adds up to the target sum\"\"\"\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - nums[i - 1] >= 0:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target_sum]\n    \ndef g(target_sum=100):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return [num for num in nums if num <= target_sum]\n  \nassert f(g())\n", "emb": null, "idx_generation": 419, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(nums: List[int], target_sum=100) -> bool:\n    \"\"\"Find a subset of numbers from the given list that adds up to the target sum\"\"\"\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - nums[i - 1] >= 0:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target_sum]", "solution_func": "def g(target_sum=100):\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return [num for num in nums if num <= target_sum]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return the indices of two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] equals 9, so the function should return [0, 1].\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 420, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return the indices of two numbers such that they add up to target.\n\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] equals 9, so the function should return [0, 1].\n    \"\"\"\n    complement_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_map:\n            return [complement_map[complement], i]\n        complement_map[num] = i\n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an m x n matrix, return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 420, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an m x n matrix, return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    if not matrix:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate the first n rows of Pascal's triangle.\n\n    Example:\n    Input: n = 5\n    Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    if n == 0:\n        return []\n    \n    triangle = [[1]]\n    \n    for i in range(1, n):\n        prev_row = triangle[i-1]\n        curr_row = [1]\n        \n        for j in range(1, i):\n            curr_row.append(prev_row[j-1] + prev_row[j])\n        \n        curr_row.append(1)\n        triangle.append(curr_row)\n    \n    return triangle\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 420, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate the first n rows of Pascal's triangle.\n\n    Example:\n    Input: n = 5\n    Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    \"\"\"\n    if n == 0:\n        return []\n    \n    triangle = [[1]]\n    \n    for i in range(1, n):\n        prev_row = triangle[i-1]\n        curr_row = [1]\n        \n        for j in range(1, i):\n            curr_row.append(prev_row[j-1] + prev_row[j])\n        \n        curr_row.append(1)\n        triangle.append(curr_row)\n    \n    return triangle", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique k-length strings that can be formed using n distinct characters.\n    \"\"\"\n    def count_strings(n: int, k: int, current: str, count: int) -> int:\n        if k == 0:\n            return count + 1\n        for i in range(n):\n            count = count_strings(n, k - 1, current + str(i), count)\n        return count\n    \n    return count_strings(n, k, \"\", 0)\n\ndef g(n = 3, k = 2):\n    return n, k\n\nassert f(*g()) == 9\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 420, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of unique k-length strings that can be formed using n distinct characters.\n    \"\"\"\n    def count_strings(n: int, k: int, current: str, count: int) -> int:\n        if k == 0:\n            return count + 1\n        for i in range(n):\n            count = count_strings(n, k - 1, current + str(i), count)\n        return count\n    \n    return count_strings(n, k, \"\", 0)", "solution_func": "def g(n = 3, k = 2):\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest palindromic subsequence in s.\n    \"\"\"\n    def longest_palindromic_subsequence(s: str, i: int, j: int, memo: dict) -> int:\n        if i == j:\n            return 1\n        if i > j:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if s[i] == s[j]:\n            memo[(i, j)] = longest_palindromic_subsequence(s, i + 1, j - 1, memo) + 2\n        else:\n            memo[(i, j)] = max(longest_palindromic_subsequence(s, i + 1, j, memo), longest_palindromic_subsequence(s, i, j - 1, memo))\n        return memo[(i, j)]\n    \n    return longest_palindromic_subsequence(s, 0, len(s) - 1, {})\n\ndef g(s = \"bbbab\"):\n    return s\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 420, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest palindromic subsequence in s.\n    \"\"\"\n    def longest_palindromic_subsequence(s: str, i: int, j: int, memo: dict) -> int:\n        if i == j:\n            return 1\n        if i > j:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if s[i] == s[j]:\n            memo[(i, j)] = longest_palindromic_subsequence(s, i + 1, j - 1, memo) + 2\n        else:\n            memo[(i, j)] = max(longest_palindromic_subsequence(s, i + 1, j, memo), longest_palindromic_subsequence(s, i, j - 1, memo))\n        return memo[(i, j)]\n    \n    return longest_palindromic_subsequence(s, 0, len(s) - 1, {})", "solution_func": "def g(s = \"bbbab\"):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of indices of two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int, start: int, end: int) -> List[int]:\n        num_set = set()\n        for i in range(start, end + 1):\n            complement = target - nums[i]\n            if complement in num_set:\n                return [nums.index(complement), i]\n            num_set.add(nums[i])\n        return []\n    \n    return two_sum(nums, target, 0, len(nums) - 1)\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 420, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return a list of indices of two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int, start: int, end: int) -> List[int]:\n        num_set = set()\n        for i in range(start, end + 1):\n            complement = target - nums[i]\n            if complement in num_set:\n                return [nums.index(complement), i]\n            num_set.add(nums[i])\n        return []\n    \n    return two_sum(nums, target, 0, len(nums) - 1)", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1)\n    where the path consists of only 0s and the neighboring cells are connected horizontally or vertically.\n\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    There exists a path from the top-left corner to the bottom-right corner consisting only of 0s.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def dfs(matrix, row, col, visited):\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return True\n\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]) or matrix[row][col] != 0 or visited[row][col]:\n            return False\n\n        visited[row][col] = True\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for direction in directions:\n            next_row = row + direction[0]\n            next_col = col + direction[1]\n\n            if dfs(matrix, next_row, next_col, visited):\n                return True\n\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n\n    return dfs(matrix, 0, 0, visited)\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0]\n    ]\n    return matrix\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 420, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, determine if there is a path from the top-left corner (0,0) to the bottom-right corner (m-1,n-1)\n    where the path consists of only 0s and the neighboring cells are connected horizontally or vertically.\n\n    Return True if a path exists, and False otherwise.\n\n    Example:\n    matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0]\n    ]\n\n    There exists a path from the top-left corner to the bottom-right corner consisting only of 0s.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def dfs(matrix, row, col, visited):\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return True\n\n        if row < 0 or row >= len(matrix) or col < 0 or col >= len(matrix[0]) or matrix[row][col] != 0 or visited[row][col]:\n            return False\n\n        visited[row][col] = True\n\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for direction in directions:\n            next_row = row + direction[0]\n            next_col = col + direction[1]\n\n            if dfs(matrix, next_row, next_col, visited):\n                return True\n\n        return False\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    visited = [[False] * cols for _ in range(rows)]\n\n    return dfs(matrix, 0, 0, visited)", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [0, 1, 0, 0],\n        [0, 0, 0, 1],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0]\n    ]\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the maximum XOR value between them.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between any two numbers in the array is 28, which can be obtained by XORing the numbers 25 and 5.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 420, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the two numbers that have the maximum XOR value between them.\n\n    Return the maximum XOR value.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between any two numbers in the array is 28, which can be obtained by XORing the numbers 25 and 5.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a subgrid where the subgrid is a rectangle.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a subgrid is 45, which can be obtained by selecting the entire grid.\n\n    Therefore, the function should return 45.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            subgrid_sum += grid[x][y]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of positive integers for Puzzle 5.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 420, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of positive integers, find the maximum sum of a subgrid where the subgrid is a rectangle.\n\n    Return the maximum sum.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a subgrid is 45, which can be obtained by selecting the entire grid.\n\n    Therefore, the function should return 45.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum = float('-inf')\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for x in range(i, k+1):\n                        for y in range(j, l+1):\n                            subgrid_sum += grid[x][y]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of positive integers for Puzzle 5.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, determine if it is possible to rotate the string by n times and obtain a palindrome.\n    Return True if a palindrome can be obtained, False otherwise.\n\n    Example:\n    s = \"abcde\"\n    n = 2\n\n    f(s, n) => True\n    Explanation: If we rotate the string \"abcde\" by 2 times, we get \"deabc\". By rearranging the letters, we can form a palindrome \"deed\".\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    rotated = s[n:] + s[:n]\n    return is_palindrome(rotated)\n\ndef g(s: str, n: int):\n    return (s, n)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 420, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string s and an integer n, determine if it is possible to rotate the string by n times and obtain a palindrome.\n    Return True if a palindrome can be obtained, False otherwise.\n\n    Example:\n    s = \"abcde\"\n    n = 2\n\n    f(s, n) => True\n    Explanation: If we rotate the string \"abcde\" by 2 times, we get \"deabc\". By rearranging the letters, we can form a palindrome \"deed\".\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    rotated = s[n:] + s[:n]\n    return is_palindrome(rotated)", "solution_func": "def g(s: str, n: int):\n    return (s, n)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique combinations that sum up to a target value.\n    The same number may be chosen from nums an unlimited number of times. The combinations should be returned in ascending order.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: There are 7 unique combinations that sum up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n\n    Note:\n    - All numbers in nums will be positive integers.\n    - The solution set must not contain duplicate combinations.\n    - The order of combinations does not matter.\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        count = 0\n        for i in range(len(nums)):\n            count += backtrack(nums[i:], target - nums[i])\n        return count\n\n    return backtrack(nums, target)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3]\n    return nums\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 421, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of unique combinations that sum up to a target value.\n    The same number may be chosen from nums an unlimited number of times. The combinations should be returned in ascending order.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: There are 7 unique combinations that sum up to 4: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n\n    Note:\n    - All numbers in nums will be positive integers.\n    - The solution set must not contain duplicate combinations.\n    - The order of combinations does not matter.\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        count = 0\n        for i in range(len(nums)):\n            count += backtrack(nums[i:], target - nums[i])\n        return count\n\n    return backtrack(nums, target)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list whose bitwise AND is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 4\n\n    The elements 1 and 4 have bitwise AND of 0, which is equal to the target value 4.\n\n    Therefore, the function should return [1, 4].\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_and = nums[i] & nums[j]\n\n            if curr_and == target:\n                return [nums[i], nums[j]]\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 4\n    return nums, target\n\nassert f(*g()) == [1, 4]\n\n", "emb": null, "idx_generation": 421, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list whose bitwise AND is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 4\n\n    The elements 1 and 4 have bitwise AND of 0, which is equal to the target value 4.\n\n    Therefore, the function should return [1, 4].\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_and = nums[i] & nums[j]\n\n            if curr_and == target:\n                return [nums[i], nums[j]]\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 4\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists a pair of elements in the list whose bitwise OR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 2 and 4 have bitwise OR of 6, which is equal to the target value 6.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_or = nums[i] | nums[j]\n\n            if curr_or == target:\n                return True\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 421, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    determine if there exists a pair of elements in the list whose bitwise OR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 2 and 4 have bitwise OR of 6, which is equal to the target value 6.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_or = nums[i] | nums[j]\n\n            if curr_or == target:\n                return True\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 3 and 5 have bitwise XOR of 6, which is equal to the target value 6.\n\n    Therefore, the function should return [3, 5].\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_xor = nums[i] ^ nums[j]\n\n            if curr_xor == target:\n                return [nums[i], nums[j]]\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == [3, 5]\n\n", "emb": null, "idx_generation": 421, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums' and a target value 'target',\n    find two numbers in the list whose bitwise XOR is equal to the target.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The elements 3 and 5 have bitwise XOR of 6, which is equal to the target value 6.\n\n    Therefore, the function should return [3, 5].\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            curr_xor = nums[i] ^ nums[j]\n\n            if curr_xor == target:\n                return [nums[i], nums[j]]\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Return True if s is a palindrome, False otherwise.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    return is_palindrome(s)\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 421, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Return True if s is a palindrome, False otherwise.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    return is_palindrome(s)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    s = \"racecar\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones,\n    usually starting with 0 and 1.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n)\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 5\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 421, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones,\n    usually starting with 0 and 1.\n    \"\"\"\n    def fibonacci(n: int) -> int:\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    return fibonacci(n)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer.\n    \"\"\"\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n\n    Return a list with the indices of the two numbers.\n\n    It is guaranteed that there are exactly two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        complement_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in complement_map:\n                return [complement_map[complement], i]\n            complement_map[num] = i\n        \n    return two_sum(nums, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 421, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n\n    Return a list with the indices of the two numbers.\n\n    It is guaranteed that there are exactly two numbers in the list that add up to the target.\n    \"\"\"\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        complement_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in complement_map:\n                return [complement_map[complement], i]\n            complement_map[num] = i\n        \n    return two_sum(nums, target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target integer.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subsequence with the following conditions:\n    1. The subsequence must be non-empty.\n    2. The subsequence must contain only positive integers.\n    3. The subsequence must contain at most two distinct integers.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    f(nums) => 45\n    Explanation: The maximum sum can be obtained by selecting the subsequence [1, 2, 3, 4, 5, 6, 7, 8, 9].\n    \"\"\"\n\n    distinct_nums = set(nums)\n    if len(distinct_nums) <= 2:\n        return sum(nums)\n\n    max_sum = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            subsequence = [num for num in nums[i:j+1] if num in distinct_nums]\n            if len(set(subsequence)) <= 2:\n                max_sum = max(max_sum, sum(subsequence))\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 45\n", "emb": null, "idx_generation": 421, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subsequence with the following conditions:\n    1. The subsequence must be non-empty.\n    2. The subsequence must contain only positive integers.\n    3. The subsequence must contain at most two distinct integers.\n\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    f(nums) => 45\n    Explanation: The maximum sum can be obtained by selecting the subsequence [1, 2, 3, 4, 5, 6, 7, 8, 9].\n    \"\"\"\n\n    distinct_nums = set(nums)\n    if len(distinct_nums) <= 2:\n        return sum(nums)\n\n    max_sum = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            subsequence = [num for num in nums[i:j+1] if num in distinct_nums]\n            if len(set(subsequence)) <= 2:\n                max_sum = max(max_sum, sum(subsequence))\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of integers, find the starting position (row, column) and the maximum sum of a path from the starting position to the bottom-right corner of the grid.\n    The path can only move down or right.\n\n    Return a tuple containing the starting position and the maximum sum.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    f(grid) => ((0, 0), 21)\n    Explanation: The maximum sum of a path from (0, 0) to (2, 2) is 21, following the path: 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum_grid = [[0] * cols for _ in range(rows)]\n    max_sum_grid[rows-1][cols-1] = grid[rows-1][cols-1]\n\n    for i in range(rows-2, -1, -1):\n        max_sum_grid[i][cols-1] = max_sum_grid[i+1][cols-1] + grid[i][cols-1]\n\n    for j in range(cols-2, -1, -1):\n        max_sum_grid[rows-1][j] = max_sum_grid[rows-1][j+1] + grid[rows-1][j]\n\n    for i in range(rows-2, -1, -1):\n        for j in range(cols-2, -1, -1):\n            max_sum_grid[i][j] = max(max_sum_grid[i+1][j], max_sum_grid[i][j+1]) + grid[i][j]\n\n    max_sum = max_sum_grid[0][0]\n    start_position = (0, 0)\n\n    return start_position, max_sum\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == ((0, 0), 21)\n", "emb": null, "idx_generation": 421, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Given a grid of integers, find the starting position (row, column) and the maximum sum of a path from the starting position to the bottom-right corner of the grid.\n    The path can only move down or right.\n\n    Return a tuple containing the starting position and the maximum sum.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    f(grid) => ((0, 0), 21)\n    Explanation: The maximum sum of a path from (0, 0) to (2, 2) is 21, following the path: 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_sum_grid = [[0] * cols for _ in range(rows)]\n    max_sum_grid[rows-1][cols-1] = grid[rows-1][cols-1]\n\n    for i in range(rows-2, -1, -1):\n        max_sum_grid[i][cols-1] = max_sum_grid[i+1][cols-1] + grid[i][cols-1]\n\n    for j in range(cols-2, -1, -1):\n        max_sum_grid[rows-1][j] = max_sum_grid[rows-1][j+1] + grid[rows-1][j]\n\n    for i in range(rows-2, -1, -1):\n        for j in range(cols-2, -1, -1):\n            max_sum_grid[i][j] = max(max_sum_grid[i+1][j], max_sum_grid[i][j+1]) + grid[i][j]\n\n    max_sum = max_sum_grid[0][0]\n    start_position = (0, 0)\n\n    return start_position, max_sum", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string s and a list of words, find all valid word break combinations of s using the words in the list.\n    A valid word break combination is a list of words that, when concatenated together, form the string s.\n\n    Return a list of all valid word break combinations.\n\n    Example:\n    s = \"applepenapple\"\n    words = [\"apple\", \"pen\"]\n\n    f(s, words) => [\"apple pen apple\"]\n    Explanation: The string \"apple pen apple\" can be formed by concatenating the words \"apple\", \"pen\", and \"apple\".\n\n    \"\"\"\n\n    word_set = set(words)\n    word_dict = {}\n\n    def word_break(s):\n        if s in word_dict:\n            return word_dict[s]\n        if s in word_set:\n            return [s]\n\n        result = []\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix in word_set:\n                suffixes = word_break(s[i:])\n                for suffix in suffixes:\n                    result.append(prefix + \" \" + suffix)\n\n        word_dict[s] = result\n        return result\n\n    return word_break(s)\n\ndef g() -> List[str]:\n    return \"applepenapple\", [\"apple\", \"pen\"]\n\nassert f(*g()) == [\"apple pen apple\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 421, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[str]:\n    \"\"\"\n    Given a string s and a list of words, find all valid word break combinations of s using the words in the list.\n    A valid word break combination is a list of words that, when concatenated together, form the string s.\n\n    Return a list of all valid word break combinations.\n\n    Example:\n    s = \"applepenapple\"\n    words = [\"apple\", \"pen\"]\n\n    f(s, words) => [\"apple pen apple\"]\n    Explanation: The string \"apple pen apple\" can be formed by concatenating the words \"apple\", \"pen\", and \"apple\".\n\n    \"\"\"\n\n    word_set = set(words)\n    word_dict = {}\n\n    def word_break(s):\n        if s in word_dict:\n            return word_dict[s]\n        if s in word_set:\n            return [s]\n\n        result = []\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix in word_set:\n                suffixes = word_break(s[i:])\n                for suffix in suffixes:\n                    result.append(prefix + \" \" + suffix)\n\n        word_dict[s] = result\n        return result\n\n    return word_break(s)", "solution_func": "def g() -> List[str]:\n    return \"applepenapple\", [\"apple\", \"pen\"]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, count the number of subarrays that have an odd sum.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        sub_sum = 0\n        for j in range(i, len(arr)):\n            sub_sum += arr[j]\n            if sub_sum % 2 != 0:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 12\n", "emb": null, "idx_generation": 422, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, count the number of subarrays that have an odd sum.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        sub_sum = 0\n        for j in range(i, len(arr)):\n            sub_sum += arr[j]\n            if sub_sum % 2 != 0:\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of non-negative integers, count the number of subarrays that have a sum less than or equal to a target number.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        sub_sum = 0\n        for j in range(i, len(arr)):\n            sub_sum += arr[j]\n            if sub_sum <= target:\n                count += 1\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target number for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 8\n\nassert f(*g()) == 18\n", "emb": null, "idx_generation": 422, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of non-negative integers, count the number of subarrays that have a sum less than or equal to a target number.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        sub_sum = 0\n        for j in range(i, len(arr)):\n            sub_sum += arr[j]\n            if sub_sum <= target:\n                count += 1\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target number for Puzzle 4.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 8", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the next smaller element for each element in the array. If there is no smaller element,\n    return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        while stack and stack[-1] >= arr[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(arr[i])\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 5.\n    \"\"\"\n    return [4, 5, 2, 9, 1, 7]\n\nassert f(g()) == [2, 2, 1, 1, -1, -1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 422, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, find the next smaller element for each element in the array. If there is no smaller element,\n    return -1 for that element.\n    \"\"\"\n    stack = []\n    result = [-1] * len(arr)\n    for i in range(len(arr) - 1, -1, -1):\n        while stack and stack[-1] >= arr[i]:\n            stack.pop()\n        if stack:\n            result[i] = stack[-1]\n        stack.append(arr[i])\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for Puzzle 5.\n    \"\"\"\n    return [4, 5, 2, 9, 1, 7]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindromic substring in s.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n\n    max_len = 1\n    for i in range(n):\n        dp[i][i] = True\n\n    start = 0\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i == 1 or dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    if j - i + 1 > max_len:\n                        max_len = j - i + 1\n                        start = i\n\n    return max_len\n\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with a palindromic substring.\n    \"\"\"\n    return \"babad\"\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 422, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest palindromic substring in s.\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n    \"\"\"\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n\n    max_len = 1\n    for i in range(n):\n        dp[i][i] = True\n\n    start = 0\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i == 1 or dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    if j - i + 1 > max_len:\n                        max_len = j - i + 1\n                        start = i\n\n    return max_len", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string with a palindromic substring.\n    \"\"\"\n    return \"babad\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the array, where index1 must be less than index2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 422, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers in the array, where index1 must be less than index2.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the first and last positions of the target in the list.\n    If the target is not found in the list, return [-1, -1].\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    start, end = -1, -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            start = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            end = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return [start, end]\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [3, 4]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 422, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the first and last positions of the target in the list.\n    If the target is not found in the list, return [-1, -1].\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    start, end = -1, -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            start = mid\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            end = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return [start, end]", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Given three positive integers n, m, and k, determine if it is possible to construct a rectangle with dimensions n x m\n    using exactly k squares. Return True if possible, False otherwise.\n    \"\"\"\n    if k > n * m:\n        return False\n    if k % n == 0 or k % m == 0:\n        return True\n    return False\n\ndef g(n=4, m=5, k=12):\n    \"\"\"\n    Construct a rectangle with dimensions n x m using exactly k squares.\n    \"\"\"\n    return n, m, k\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 422, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, k: int) -> bool:\n    \"\"\"\n    Given three positive integers n, m, and k, determine if it is possible to construct a rectangle with dimensions n x m\n    using exactly k squares. Return True if possible, False otherwise.\n    \"\"\"\n    if k > n * m:\n        return False\n    if k % n == 0 or k % m == 0:\n        return True\n    return False", "solution_func": "def g(n=4, m=5, k=12):\n    \"\"\"\n    Construct a rectangle with dimensions n x m using exactly k squares.\n    \"\"\"\n    return n, m, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of points in a 2D plane, determine if there exists a line that divides the plane into two halves,\n    such that the points on one side of the line are all to the left or all to the right of the line.\n    Return True if such a line exists, False otherwise.\n    \"\"\"\n    if len(points) < 2:\n        return False\n    \n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n    \n    x_min = min(x_coords)\n    x_max = max(x_coords)\n    y_min = min(y_coords)\n    y_max = max(y_coords)\n    \n    if x_min == x_max or y_min == y_max:\n        return True\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a list of points in a 2D plane.\n    \"\"\"\n    points = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    return points\n\nassert f(g())\n", "emb": null, "idx_generation": 422, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> bool:\n    \"\"\"\n    Given a list of points in a 2D plane, determine if there exists a line that divides the plane into two halves,\n    such that the points on one side of the line are all to the left or all to the right of the line.\n    Return True if such a line exists, False otherwise.\n    \"\"\"\n    if len(points) < 2:\n        return False\n    \n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n    \n    x_min = min(x_coords)\n    x_max = max(x_coords)\n    y_min = min(y_coords)\n    y_max = max(y_coords)\n    \n    if x_min == x_max or y_min == y_max:\n        return True\n    \n    return False", "solution_func": "def g():\n    \"\"\"\n    Generate a list of points in a 2D plane.\n    \"\"\"\n    points = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    return points", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest subarray with an equal number of even and odd elements.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    count = 0\n    max_length = 0\n    \n    prefix_sum = [0] * (len(nums) + 1)\n    prefix_sum[0] = 0\n    \n    for i in range(1, len(nums) + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    \n    prefix_sum_dict = {0: 0}\n    \n    for i in range(1, len(nums) + 1):\n        if prefix_sum[i] in prefix_sum_dict:\n            count = i - prefix_sum_dict[prefix_sum[i]]\n            max_length = max(max_length, count)\n        else:\n            prefix_sum_dict[prefix_sum[i]] = i\n    \n    return max_length >= 2\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g())\n", "emb": null, "idx_generation": 422, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, find the longest subarray with an equal number of even and odd elements.\n    Return True if such a subarray exists, False otherwise.\n    \"\"\"\n    count = 0\n    max_length = 0\n    \n    prefix_sum = [0] * (len(nums) + 1)\n    prefix_sum[0] = 0\n    \n    for i in range(1, len(nums) + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    \n    prefix_sum_dict = {0: 0}\n    \n    for i in range(1, len(nums) + 1):\n        if prefix_sum[i] in prefix_sum_dict:\n            count = i - prefix_sum_dict[prefix_sum[i]]\n            max_length = max(max_length, count)\n        else:\n            prefix_sum_dict[prefix_sum[i]] = i\n    \n    return max_length >= 2", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct combinations of elements that sum up to a target value.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: 3\n    Explanation: The distinct combinations that sum up to 7 are [1, 2, 4], [1, 3, 3], and [2, 2, 3].\n\n    Note:\n    - Each number in nums can be used multiple times.\n    - The order of the combinations does not matter.\n    \"\"\"\n\n    def count_combinations(target: int, nums: List[int]) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(target - num, nums)\n        \n        return count\n\n    return count_combinations(7, nums)\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 422, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct combinations of elements that sum up to a target value.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: 3\n    Explanation: The distinct combinations that sum up to 7 are [1, 2, 4], [1, 3, 3], and [2, 2, 3].\n\n    Note:\n    - Each number in nums can be used multiple times.\n    - The order of the combinations does not matter.\n    \"\"\"\n\n    def count_combinations(target: int, nums: List[int]) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n\n        count = 0\n        for num in nums:\n            count += count_combinations(target - num, nums)\n        \n        return count\n\n    return count_combinations(7, nums)", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    False\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0\n\ndef g(n=16):\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number n is a power of 2.\n\n    Sample Input:\n    n = 16\n\n    Sample Output:\n    True\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    False\n    \"\"\"\n    return n > 0 and (n & (n - 1)) == 0", "solution_func": "def g(n=16):\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    4\n    Explanation: The prime numbers less than or equal to 10 are 2, 3, 5, and 7.\n\n    Sample Input:\n    n = 20\n\n    Sample Output:\n    8\n    Explanation: The prime numbers less than or equal to 20 are 2, 3, 5, 7, 11, 13, 17, and 19.\n    \"\"\"\n    prime_count = 0\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_count += 1\n    return prime_count\n\ndef g(n=10):\n    return n\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of prime numbers less than or equal to n.\n\n    Sample Input:\n    n = 10\n\n    Sample Output:\n    4\n    Explanation: The prime numbers less than or equal to 10 are 2, 3, 5, and 7.\n\n    Sample Input:\n    n = 20\n\n    Sample Output:\n    8\n    Explanation: The prime numbers less than or equal to 20 are 2, 3, 5, 7, 11, 13, 17, and 19.\n    \"\"\"\n    prime_count = 0\n    for num in range(2, n + 1):\n        is_prime = True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            prime_count += 1\n    return prime_count", "solution_func": "def g(n=10):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive divisors of n.\n\n    Sample Input:\n    n = 12\n\n    Sample Output:\n    28\n    Explanation: The positive divisors of 12 are 1, 2, 3, 4, 6, and 12. Their sum is 1 + 2 + 3 + 4 + 6 + 12 = 28.\n\n    Sample Input:\n    n = 20\n\n    Sample Output:\n    42\n    Explanation: The positive divisors of 20 are 1, 2, 4, 5, 10, and 20. Their sum is 1 + 2 + 4 + 5 + 10 + 20 = 42.\n    \"\"\"\n    divisor_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum\n\ndef g(n=12):\n    return n\n\nassert f(g()) == 28\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all positive divisors of n.\n\n    Sample Input:\n    n = 12\n\n    Sample Output:\n    28\n    Explanation: The positive divisors of 12 are 1, 2, 3, 4, 6, and 12. Their sum is 1 + 2 + 3 + 4 + 6 + 12 = 28.\n\n    Sample Input:\n    n = 20\n\n    Sample Output:\n    42\n    Explanation: The positive divisors of 20 are 1, 2, 4, 5, 10, and 20. Their sum is 1 + 2 + 4 + 5 + 10 + 20 = 42.\n    \"\"\"\n    divisor_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum", "solution_func": "def g(n=12):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers from the array that add up to the target value.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Return a list containing the two numbers that add up to the target value.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The sum of 2 and 7 is 9, so the function should return [2, 7].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers and a target value for Puzzle 3.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 12\n\nassert f(*g()) == [2, 10]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of distinct integers and a target value, return the two numbers from the array that add up to the target value.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Return a list containing the two numbers that add up to the target value.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The sum of 2 and 7 is 9, so the function should return [2, 7].\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [nums[left], nums[right]]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers and a target value for Puzzle 3.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 12", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [3, 2, 4]\n    target = 6\n\n    The sum of 2 and 4 is 6, so the function should return [1, 2].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value for Puzzle 4.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g()) == [1, 3]\n\n", "emb": null, "idx_generation": 423, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [3, 2, 4]\n    target = 6\n\n    The sum of 2 and 4 is 6, so the function should return [1, 2].\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value for Puzzle 4.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [1, 3, 6, 10, 15]\n\n    Explanation:\n    The output list is obtained by taking the cumulative sum of the elements in the input list.\n    The first element in the output list is the same as the first element in the input list.\n    The second element in the output list is the sum of the first two elements in the input list.\n    The third element in the output list is the sum of the first three elements in the input list.\n    And so on...\n    \"\"\"\n\n    cumulative_sum = []\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        cumulative_sum.append(current_sum)\n\n    return cumulative_sum\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return (nums,)\n\nassert f(*g()) == [1, 3, 6, 10, 15]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of all the previous elements in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    [1, 3, 6, 10, 15]\n\n    Explanation:\n    The output list is obtained by taking the cumulative sum of the elements in the input list.\n    The first element in the output list is the same as the first element in the input list.\n    The second element in the output list is the sum of the first two elements in the input list.\n    The third element in the output list is the sum of the first three elements in the input list.\n    And so on...\n    \"\"\"\n\n    cumulative_sum = []\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        cumulative_sum.append(current_sum)\n\n    return cumulative_sum", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return (nums,)", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix represented as a list of lists, return a new matrix where each element is the sum of its corresponding row and column in the original matrix.\n\n    Sample Input:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Sample Output:\n    [[5, 7, 9], [9, 11, 13], [13, 15, 17]]\n\n    Explanation:\n    The output matrix is obtained by taking the sum of each element with its corresponding row and column in the input matrix.\n    For example, the element at index (0, 0) in the input matrix is 1. The sum of its row [1, 2, 3] and column [1, 4, 7] is [5, 7, 9].\n    So, the element at index (0, 0) in the output matrix is 5.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    new_matrix = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            new_matrix[i][j] = matrix[i][j] + sum(matrix[k][j] for k in range(rows)) + sum(matrix[i][k] for k in range(cols)) - matrix[i][j]\n\n    return new_matrix\n\ndef g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)\n\nassert f(*g()) == [[5, 7, 9], [9, 11, 13], [13, 15, 17]]\n", "emb": null, "idx_generation": 423, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix represented as a list of lists, return a new matrix where each element is the sum of its corresponding row and column in the original matrix.\n\n    Sample Input:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    Sample Output:\n    [[5, 7, 9], [9, 11, 13], [13, 15, 17]]\n\n    Explanation:\n    The output matrix is obtained by taking the sum of each element with its corresponding row and column in the input matrix.\n    For example, the element at index (0, 0) in the input matrix is 1. The sum of its row [1, 2, 3] and column [1, 4, 7] is [5, 7, 9].\n    So, the element at index (0, 0) in the output matrix is 5.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    new_matrix = [[0] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            new_matrix[i][j] = matrix[i][j] + sum(matrix[k][j] for k in range(rows)) + sum(matrix[i][k] for k in range(cols)) - matrix[i][j]\n\n    return new_matrix", "solution_func": "def g(matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return (matrix,)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two positive integers n and m, return a matrix of size n x m where each element is the product of its row and column indices.\n\n    Sample Input:\n    n = 3\n    m = 4\n\n    Sample Output:\n    [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n\n    Explanation:\n    The output matrix is obtained by multiplying each element with its row and column indices.\n    For example, the element at index (1, 1) in the output matrix is 1 * 1 = 1.\n    The element at index (1, 2) is 1 * 2 = 2, and so on.\n    \"\"\"\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = i * j\n\n    return matrix\n\ndef g(n=3, m=4):\n    return (n, m)\n\nassert f(*g()) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 423, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> List[List[int]]:\n    \"\"\"\n    Given two positive integers n and m, return a matrix of size n x m where each element is the product of its row and column indices.\n\n    Sample Input:\n    n = 3\n    m = 4\n\n    Sample Output:\n    [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n\n    Explanation:\n    The output matrix is obtained by multiplying each element with its row and column indices.\n    For example, the element at index (1, 1) in the output matrix is 1 * 1 = 1.\n    The element at index (1, 2) is 1 * 2 = 2, and so on.\n    \"\"\"\n\n    matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = i * j\n\n    return matrix", "solution_func": "def g(n=3, m=4):\n    return (n, m)", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Return the index of the target element if found, otherwise return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n\n    The target element 3 is found at index 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(arr, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 423, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Return the index of the target element if found, otherwise return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 3\n\n    The target element 3 is found at index 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left = 0\n        right = len(arr) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return -1\n\n    return binary_search(arr, target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target element for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 3", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 424, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs with a specific difference.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 2\n    Output: 3\n    Explanation: The unique pairs with a difference of 2 are (1, 3), (3, 5), and (2, 4).\n\n    nums = [3, 1, 4, 1, 5]\n    k = 0\n    Output: 2\n    Explanation: The unique pairs with a difference of 0 are (1, 1) and (3, 3).\n    \"\"\"\n    nums.sort()\n    unique_pairs = set()\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if abs(nums[i] - nums[j]) == k:\n                unique_pairs.add((nums[i], nums[j]))\n\n    return len(unique_pairs)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 5, 3, 4, 2]\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 424, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs with a specific difference.\n\n    Example:\n    nums = [1, 5, 3, 4, 2]\n    k = 2\n    Output: 3\n    Explanation: The unique pairs with a difference of 2 are (1, 3), (3, 5), and (2, 4).\n\n    nums = [3, 1, 4, 1, 5]\n    k = 0\n    Output: 2\n    Explanation: The unique pairs with a difference of 0 are (1, 1) and (3, 3).\n    \"\"\"\n    nums.sort()\n    unique_pairs = set()\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if abs(nums[i] - nums[j]) == k:\n                unique_pairs.add((nums[i], nums[j]))\n\n    return len(unique_pairs)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 5, 3, 4, 2]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n    Explanation: The maximum sum of a path is 12 (1 -> 3 -> 5 -> 2 -> 1).\n\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n    Explanation: The maximum sum of a path is 29 (1 -> 2 -> 3 -> 6 -> 9).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 424, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 12\n    Explanation: The maximum sum of a path is 12 (1 -> 3 -> 5 -> 2 -> 1).\n\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n    Explanation: The maximum sum of a path is 29 (1 -> 2 -> 3 -> 6 -> 9).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [1, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent to each other.\n\n    Example:\n    nums = [4, 1, 1, 9, 1]\n\n    Output:\n    13\n\n    Explanation:\n    The maximum sum subarray is [4, 9], with a sum of 13.\n    The subarray [4, 1, 1, 1] also has a sum of 13, but it contains adjacent numbers.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g():\n    return [4, 1, 1, 9, 1]\n\nassert f(g()) == 13\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 424, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent to each other.\n\n    Example:\n    nums = [4, 1, 1, 9, 1]\n\n    Output:\n    13\n\n    Explanation:\n    The maximum sum subarray is [4, 9], with a sum of 13.\n    The subarray [4, 1, 1, 1] also has a sum of 13, but it contains adjacent numbers.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]", "solution_func": "def g():\n    return [4, 1, 1, 9, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the longest increasing path in the matrix.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path in the matrix is [1, 2, 6, 9], with a length of 4.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    longest_path = 1\n    cache = [[0] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        if cache[row][col]:\n            return cache[row][col]\n\n        path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] > matrix[row][col]:\n                path = max(path, 1 + dfs(new_row, new_col))\n\n        cache[row][col] = path\n        return path\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\ndef g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 424, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the longest increasing path in the matrix.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n\n    Example:\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n\n    Output:\n    4\n\n    Explanation:\n    The longest increasing path in the matrix is [1, 2, 6, 9], with a length of 4.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    longest_path = 1\n    cache = [[0] * cols for _ in range(rows)]\n\n    def dfs(row, col):\n        if cache[row][col]:\n            return cache[row][col]\n\n        path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] > matrix[row][col]:\n                path = max(path, 1 + dfs(new_row, new_col))\n\n        cache[row][col] = path\n        return path\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path", "solution_func": "def g():\n    return [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move right, down, or diagonally right-down. Each cell has a cost associated with it.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The minimum cost path is 1 -> 1 -> 1, which has a total cost of 3.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n    dp[rows][cols-1] = 0\n\n    for i in range(rows-1, -1, -1):\n        for j in range(cols-1, -1, -1):\n            dp[i][j] = matrix[i][j] + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1])\n\n    return dp[0][0]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 424, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the minimum cost to reach the bottom-right cell from the top-left cell.\n    You can only move right, down, or diagonally right-down. Each cell has a cost associated with it.\n\n    Example:\n    matrix = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The minimum cost path is 1 -> 1 -> 1, which has a total cost of 3.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[float('inf')] * (cols + 1) for _ in range(rows + 1)]\n    dp[rows][cols-1] = 0\n\n    for i in range(rows-1, -1, -1):\n        for j in range(cols-1, -1, -1):\n            dp[i][j] = matrix[i][j] + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1])\n\n    return dp[0][0]", "solution_func": "def g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of combinations of k elements that sum up to the target value.\n    Return True if the count is equal to n, False otherwise.\n    \"\"\"\n    def count_combinations(nums, k, target):\n        if k == 0 and target == 0:\n            return 1\n        if k < 0 or target < 0:\n            return 0\n        if not nums:\n            return 0\n        return count_combinations(nums[1:], k - 1, target - nums[0]) + count_combinations(nums[1:], k, target)\n\n    nums = [2, 4, 6, 8, 10]\n    count = count_combinations(nums, k, target)\n    return count == n\n\ndef g(k = 3, target = 16):\n    return 5\n\nassert f(g())\n", "emb": null, "idx_generation": 424, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int, target: int) -> bool:\n    \"\"\"\n    Given a list of integers, find the number of combinations of k elements that sum up to the target value.\n    Return True if the count is equal to n, False otherwise.\n    \"\"\"\n    def count_combinations(nums, k, target):\n        if k == 0 and target == 0:\n            return 1\n        if k < 0 or target < 0:\n            return 0\n        if not nums:\n            return 0\n        return count_combinations(nums[1:], k - 1, target - nums[0]) + count_combinations(nums[1:], k, target)\n\n    nums = [2, 4, 6, 8, 10]\n    count = count_combinations(nums, k, target)\n    return count == n", "solution_func": "def g(k = 3, target = 16):\n    return 5", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, tree: List[List[int]]) -> bool:\n    \"\"\"\n    Given a tree represented as a list of edges, find the number of leaf nodes in the tree.\n    Return True if the number of leaf nodes is equal to n, False otherwise.\n    \"\"\"\n    def count_leaf_nodes(node, visited, tree):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        if sum(visited) == len(tree) - 1:\n            return 1\n        leaf_nodes = 0\n        for neighbor in tree[node]:\n            leaf_nodes += count_leaf_nodes(neighbor, visited, tree)\n        return leaf_nodes\n\n    visited = [False] * len(tree)\n    leaf_nodes = count_leaf_nodes(0, visited, tree)\n    return leaf_nodes == n\n\ndef g():\n    tree = [[1, 2], [3], [4], [], []]\n    return tree\n\nassert f(3, g())\n", "emb": null, "idx_generation": 424, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, tree: List[List[int]]) -> bool:\n    \"\"\"\n    Given a tree represented as a list of edges, find the number of leaf nodes in the tree.\n    Return True if the number of leaf nodes is equal to n, False otherwise.\n    \"\"\"\n    def count_leaf_nodes(node, visited, tree):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        if sum(visited) == len(tree) - 1:\n            return 1\n        leaf_nodes = 0\n        for neighbor in tree[node]:\n            leaf_nodes += count_leaf_nodes(neighbor, visited, tree)\n        return leaf_nodes\n\n    visited = [False] * len(tree)\n    leaf_nodes = count_leaf_nodes(0, visited, tree)\n    return leaf_nodes == n", "solution_func": "def g():\n    tree = [[1, 2], [3], [4], [], []]\n    return tree", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid represented as a list of lists, find the maximum sum of values starting from the top-left corner (0, 0)\n    and ending at the bottom-right corner (n-1, n-1), moving only down or right.\n    Return True if the maximum sum is equal to n, False otherwise.\n    \"\"\"\n    def max_sum(i, j, grid, memo):\n        if i >= len(grid) or j >= len(grid[0]):\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        right_sum = max_sum(i, j+1, grid, memo)\n        down_sum = max_sum(i+1, j, grid, memo)\n        current_sum = grid[i][j] + max(right_sum, down_sum)\n        memo[i][j] = current_sum\n        return current_sum\n\n    memo = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    max_sum = max_sum(0, 0, grid, memo)\n    return max_sum == n\n\ndef g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid\n\nassert f(15, g())\n", "emb": null, "idx_generation": 424, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a grid represented as a list of lists, find the maximum sum of values starting from the top-left corner (0, 0)\n    and ending at the bottom-right corner (n-1, n-1), moving only down or right.\n    Return True if the maximum sum is equal to n, False otherwise.\n    \"\"\"\n    def max_sum(i, j, grid, memo):\n        if i >= len(grid) or j >= len(grid[0]):\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n        right_sum = max_sum(i, j+1, grid, memo)\n        down_sum = max_sum(i+1, j, grid, memo)\n        current_sum = grid[i][j] + max(right_sum, down_sum)\n        memo[i][j] = current_sum\n        return current_sum\n\n    memo = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    max_sum = max_sum(0, 0, grid, memo)\n    return max_sum == n", "solution_func": "def g():\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a subsequence of length k, where the sum of the subsequence is equal to the target.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    for i in range(n):\n        curr_sum = arr[i]\n        if curr_sum == target:\n            count += 1\n\n        for j in range(i + 1, n):\n            curr_sum += arr[j]\n            if curr_sum == target:\n                count += 1\n\n    return count > 0\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 424, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a subsequence of length k, where the sum of the subsequence is equal to the target.\n    Return True if such a subsequence exists, False otherwise.\n    \"\"\"\n    n = len(arr)\n    count = 0\n\n    for i in range(n):\n        curr_sum = arr[i]\n        if curr_sum == target:\n            count += 1\n\n        for j in range(i + 1, n):\n            curr_sum += arr[j]\n            if curr_sum == target:\n                count += 1\n\n    return count > 0", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The maximum product of any two numbers in the list is 20 (4 * 5).\n    Return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 425, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The maximum product of any two numbers in the list is 20 (4 * 5).\n    Return 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if the target number is present using binary search.\n    Return True if the target is present, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> List[int, int]:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 425, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if the target number is present using binary search.\n    Return True if the target is present, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g() -> List[int, int]:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    return arr, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray in the list.\n\n    Example:\n    nums = [1, -2, 3, -4, 5]\n    The maximum sum of any contiguous subarray in the list is 6 (3 + (-4) + 5).\n    Return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -2, 3, -4, 5]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 425, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any contiguous subarray in the list.\n\n    Example:\n    nums = [1, -2, 3, -4, 5]\n    The maximum sum of any contiguous subarray in the list is 6 (3 + (-4) + 5).\n    Return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, -4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return a list of all combinations.\n\n    Example:\n    n = 4\n    k = 2\n\n    The possible combinations of 2 numbers from the range [1, 4] are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    The function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n        for i in range(start, n + 1):\n            curr_comb.append(i)\n            backtrack(i + 1, curr_comb)\n            curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g() -> Tuple[int, int]:\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 425, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, generate all possible combinations of k numbers out of the range [1, n].\n    Return a list of all combinations.\n\n    Example:\n    n = 4\n    k = 2\n\n    The possible combinations of 2 numbers from the range [1, 4] are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    The function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n    def backtrack(start, curr_comb):\n        if len(curr_comb) == k:\n            result.append(curr_comb[:])\n            return\n        for i in range(start, n + 1):\n            curr_comb.append(i)\n            backtrack(i + 1, curr_comb)\n            curr_comb.pop()\n\n    result = []\n    backtrack(1, [])\n    return result", "solution_func": "def g() -> Tuple[int, int]:\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a non-empty array of integers, every element appears twice except for one. Find that single number.\n    Return the single number.\n\n    Example:\n    nums = [2, 2, 1, 1, 4, 4, 5]\n\n    The number 5 appears only once in the array, so the function should return 5.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g() -> List[int]:\n    nums = [2, 2, 1, 1, 4, 4, 5]\n    return nums\n\nassert f(*g()) == 5\n", "emb": null, "idx_generation": 425, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a non-empty array of integers, every element appears twice except for one. Find that single number.\n    Return the single number.\n\n    Example:\n    nums = [2, 2, 1, 1, 4, 4, 5]\n\n    The number 5 appears only once in the array, so the function should return 5.\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [2, 2, 1, 1, 4, 4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    The function should return 3.\n    \"\"\"\n    start = 0\n    max_length = 0\n    char_to_index = {}\n    \n    for end in range(len(s)):\n        if s[end] in char_to_index:\n            start = max(start, char_to_index[s[end]] + 1)\n        char_to_index[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\ndef g() -> str:\n    s = \"abcabcbb\"\n    return s\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 425, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", which has a length of 3.\n    The function should return 3.\n    \"\"\"\n    start = 0\n    max_length = 0\n    char_to_index = {}\n    \n    for end in range(len(s)):\n        if s[end] in char_to_index:\n            start = max(start, char_to_index[s[end]] + 1)\n        char_to_index[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length", "solution_func": "def g() -> str:\n    s = \"abcabcbb\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be split into two non-empty substrings in such a way that both substrings\n    have the same number of vowels (a, e, i, o, u).\n\n    Return True if such a split is possible, False otherwise.\n\n    Example:\n    s = \"hello\"\n\n    Possible split: \"he\" and \"llo\"\n\n    So, f(s) should return True.\n    \"\"\"\n    def count_vowels(s: str) -> int:\n        vowels = \"aeiou\"\n        count = 0\n        for char in s:\n            if char.lower() in vowels:\n                count += 1\n        return count\n\n    def split_string(s: str, start: int, count1: int, count2: int) -> bool:\n        if start == len(s):\n            return count1 == count2\n\n        if s[start] in vowels:\n            return split_string(s, start + 1, count1 + 1, count2)\n        else:\n            return split_string(s, start + 1, count1, count2 + 1) or split_string(s, start + 1, count1 + 1, count2)\n\n    vowels = \"aeiou\"\n    count = count_vowels(s)\n\n    if count % 2 != 0:\n        return False\n\n    return split_string(s, 0, 0, 0)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with at least 4 characters.\n    \"\"\"\n    return \"hello\"\n\nassert f(g()) == True\n\n", "emb": null, "idx_generation": 425, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it can be split into two non-empty substrings in such a way that both substrings\n    have the same number of vowels (a, e, i, o, u).\n\n    Return True if such a split is possible, False otherwise.\n\n    Example:\n    s = \"hello\"\n\n    Possible split: \"he\" and \"llo\"\n\n    So, f(s) should return True.\n    \"\"\"\n    def count_vowels(s: str) -> int:\n        vowels = \"aeiou\"\n        count = 0\n        for char in s:\n            if char.lower() in vowels:\n                count += 1\n        return count\n\n    def split_string(s: str, start: int, count1: int, count2: int) -> bool:\n        if start == len(s):\n            return count1 == count2\n\n        if s[start] in vowels:\n            return split_string(s, start + 1, count1 + 1, count2)\n        else:\n            return split_string(s, start + 1, count1, count2 + 1) or split_string(s, start + 1, count1 + 1, count2)\n\n    vowels = \"aeiou\"\n    count = count_vowels(s)\n\n    if count % 2 != 0:\n        return False\n\n    return split_string(s, 0, 0, 0)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string with at least 4 characters.\n    \"\"\"\n    return \"hello\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the k-th digit in the decimal representation of the number obtained by\n    concatenating the positive integers from 1 to n.\n\n    Return the k-th digit as an integer.\n\n    Example:\n    n = 12, k = 15\n\n    Concatenated number: 123456789101112\n\n    The 15th digit is 2.\n\n    So, f(n, k) should return 2.\n    \"\"\"\n    def count_digits(num: int) -> int:\n        count = 0\n        while num > 0:\n            num //= 10\n            count += 1\n        return count\n\n    def get_digit(num: int, k: int) -> int:\n        digit = 0\n        while k > 0:\n            digit = num % 10\n            num //= 10\n            k -= 1\n        return digit\n\n    concatenated = \"\"\n    for i in range(1, n + 1):\n        concatenated += str(i)\n\n    num_digits = count_digits(int(concatenated))\n    if k > num_digits:\n        return -1\n\n    return get_digit(int(concatenated), k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 12, 15\n\nassert f(*g()) == 2\n\n", "emb": null, "idx_generation": 425, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the k-th digit in the decimal representation of the number obtained by\n    concatenating the positive integers from 1 to n.\n\n    Return the k-th digit as an integer.\n\n    Example:\n    n = 12, k = 15\n\n    Concatenated number: 123456789101112\n\n    The 15th digit is 2.\n\n    So, f(n, k) should return 2.\n    \"\"\"\n    def count_digits(num: int) -> int:\n        count = 0\n        while num > 0:\n            num //= 10\n            count += 1\n        return count\n\n    def get_digit(num: int, k: int) -> int:\n        digit = 0\n        while k > 0:\n            digit = num % 10\n            num //= 10\n            k -= 1\n        return digit\n\n    concatenated = \"\"\n    for i in range(1, n + 1):\n        concatenated += str(i)\n\n    num_digits = count_digits(int(concatenated))\n    if k > num_digits:\n        return -1\n\n    return get_digit(int(concatenated), k)", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 12, 15", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Return the maximum product as an integer.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Possible products: 1 * 2 * 3 = 6, 1 * 2 * 4 = 8, 1 * 3 * 4 = 12, 2 * 3 * 4 = 24\n\n    The maximum product is 24.\n\n    So, f(nums) should return 24.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of at least 4 integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 425, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Return the maximum product as an integer.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Possible products: 1 * 2 * 3 = 6, 1 * 2 * 4 = 8, 1 * 3 * 4 = 12, 2 * 3 * 4 = 24\n\n    The maximum product is 24.\n\n    So, f(nums) should return 24.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1])", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of at least 4 integers.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> (List[int], int):\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 9\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 425, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> (List[int], int):\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5], 9", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in ascending order using the merge sort algorithm.\n\n    Example:\n    Input: [4, 2, 1, 6, 3]\n    Output: [1, 2, 3, 4, 6]\n    \"\"\"\n\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n\n    return merge_sort(arr)\n\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an unsorted array of integers.\n    \"\"\"\n    return [4, 2, 1, 6, 3]\n\nassert f(g()) == [1, 2, 3, 4, 6]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 426, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, sort the array in ascending order using the merge sort algorithm.\n\n    Example:\n    Input: [4, 2, 1, 6, 3]\n    Output: [1, 2, 3, 4, 6]\n    \"\"\"\n\n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left: List[int], right: List[int]) -> List[int]:\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n\n    return merge_sort(arr)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an unsorted array of integers.\n    \"\"\"\n    return [4, 2, 1, 6, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, check if the graph contains a cycle.\n\n    Example:\n    matrix = [[0, 1, 1, 1],\n              [1, 0, 0, 0],\n              [1, 0, 0, 1],\n              [1, 0, 1, 0]]\n\n    The graph has 4 nodes and the adjacency matrix represents the following edges:\n    - Nodes 0, 1, 2, and 3 are all connected to each other.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def has_cycle(matrix: List[List[int]], visited: List[bool], curr_node: int, parent: int) -> bool:\n        visited[curr_node] = True\n        for neighbor in range(len(matrix)):\n            if matrix[curr_node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if has_cycle(matrix, visited, neighbor, curr_node):\n                        return True\n                elif parent != neighbor:\n                    return True\n        return False\n\n    visited = [False] * len(matrix)\n    for node in range(len(matrix)):\n        if not visited[node]:\n            if has_cycle(matrix, visited, node, -1):\n                return True\n    return False\n\n\ndef g() -> List[List[int]]:\n    matrix = [[0, 1, 1, 1],\n              [1, 0, 0, 0],\n              [1, 0, 0, 1],\n              [1, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 426, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing an undirected graph, check if the graph contains a cycle.\n\n    Example:\n    matrix = [[0, 1, 1, 1],\n              [1, 0, 0, 0],\n              [1, 0, 0, 1],\n              [1, 0, 1, 0]]\n\n    The graph has 4 nodes and the adjacency matrix represents the following edges:\n    - Nodes 0, 1, 2, and 3 are all connected to each other.\n\n    Therefore, the function should return True.\n    \"\"\"\n\n    def has_cycle(matrix: List[List[int]], visited: List[bool], curr_node: int, parent: int) -> bool:\n        visited[curr_node] = True\n        for neighbor in range(len(matrix)):\n            if matrix[curr_node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if has_cycle(matrix, visited, neighbor, curr_node):\n                        return True\n                elif parent != neighbor:\n                    return True\n        return False\n\n    visited = [False] * len(matrix)\n    for node in range(len(matrix)):\n        if not visited[node]:\n            if has_cycle(matrix, visited, node, -1):\n                return True\n    return False", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[0, 1, 1, 1],\n              [1, 0, 0, 0],\n              [1, 0, 0, 1],\n              [1, 0, 1, 0]]\n    return matrix", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value) -> None:\n        self.stack.append(value)\n\n    def pop(self) -> int:\n        if not self.is_empty():\n            return self.stack.pop()\n        return -1\n\n    def is_empty(self) -> bool:\n        return len(self.stack) == 0\n\n    def peek(self) -> int:\n        if not self.is_empty():\n            return self.stack[-1]\n        return -1\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two arrays nums1 and nums2, find the intersection of the two arrays.\n    The intersection is the set of elements that are common to both arrays and should be output in ascending order.\n\n    Example:\n    Input: nums1 = [1, 2, 2, 1], nums2 = [2, 2]\n    Output: [2]\n\n    Explanation:\n    The intersection of the two arrays is [2].\n    \"\"\"\n\n    stack1 = Stack()\n    stack2 = Stack()\n\n    for num in nums1:\n        stack1.push(num)\n    \n    for num in nums2:\n        stack2.push(num)\n\n    intersection = []\n    while not stack1.is_empty() and not stack2.is_empty():\n        num1 = stack1.pop()\n        num2 = stack2.pop()\n        if num1 == num2:\n            intersection.append(num1)\n    \n    intersection.sort()\n    return intersection\n\n\ndef g() -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Generate two arrays of integers with some overlapping elements.\n    \"\"\"\n    return ([1, 2, 2, 1], [2, 2])\n\nassert f(*g()) == [2]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 426, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value) -> None:\n        self.stack.append(value)\n\n    def pop(self) -> int:\n        if not self.is_empty():\n            return self.stack.pop()\n        return -1\n\n    def is_empty(self) -> bool:\n        return len(self.stack) == 0\n\n    def peek(self) -> int:\n        if not self.is_empty():\n            return self.stack[-1]\n        return -1\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two arrays nums1 and nums2, find the intersection of the two arrays.\n    The intersection is the set of elements that are common to both arrays and should be output in ascending order.\n\n    Example:\n    Input: nums1 = [1, 2, 2, 1], nums2 = [2, 2]\n    Output: [2]\n\n    Explanation:\n    The intersection of the two arrays is [2].\n    \"\"\"\n\n    stack1 = Stack()\n    stack2 = Stack()\n\n    for num in nums1:\n        stack1.push(num)\n    \n    for num in nums2:\n        stack2.push(num)\n\n    intersection = []\n    while not stack1.is_empty() and not stack2.is_empty():\n        num1 = stack1.pop()\n        num2 = stack2.pop()\n        if num1 == num2:\n            intersection.append(num1)\n    \n    intersection.sort()\n    return intersection", "solution_func": "def g() -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Generate two arrays of integers with some overlapping elements.\n    \"\"\"\n    return ([1, 2, 2, 1], [2, 2])", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, count the number of combinations of numbers that sum up to the target.\n    Return the count of combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    There are three combinations that sum up to 4: [1, 1, 1, 1], [1, 1, 2], [2, 2].\n\n    Therefore, the function should return 3.\n    \"\"\"\n    return dp(nums, target, 0, {})\n\ndef dp(nums: List[int], target: int, index: int, memo: dict) -> int:\n    if target == 0:\n        return 1\n    if target < 0 or index >= len(nums):\n        return 0\n    if (target, index) in memo:\n        return memo[(target, index)]\n    \n    count = dp(nums, target - nums[index], index, memo) + dp(nums, target, index + 1, memo)\n    memo[(target, index)] = count\n    return count\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 426, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, count the number of combinations of numbers that sum up to the target.\n    Return the count of combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    There are three combinations that sum up to 4: [1, 1, 1, 1], [1, 1, 2], [2, 2].\n\n    Therefore, the function should return 3.\n    \"\"\"\n    return dp(nums, target, 0, {})\n\ndef dp(nums: List[int], target: int, index: int, memo: dict) -> int:\n    if target == 0:\n        return 1\n    if target < 0 or index >= len(nums):\n        return 0\n    if (target, index) in memo:\n        return memo[(target, index)]\n    \n    count = dp(nums, target - nums[index], index, memo) + dp(nums, target, index + 1, memo)\n    memo[(target, index)] = count\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a combination of numbers that sum up to the target.\n    Return True if such combination exists, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    There is a combination that sums up to 10: [2, 4, 4].\n\n    Therefore, the function should return True.\n    \"\"\"\n    return dp(nums, target, 0, {})\n\ndef dp(nums: List[int], target: int, index: int, memo: dict) -> bool:\n    if target == 0:\n        return True\n    if target < 0 or index >= len(nums):\n        return False\n    if (target, index) in memo:\n        return memo[(target, index)]\n    \n    if dp(nums, target - nums[index], index, memo) or dp(nums, target, index + 1, memo):\n        memo[(target, index)] = True\n        return True\n    \n    memo[(target, index)] = False\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 426, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there exists a combination of numbers that sum up to the target.\n    Return True if such combination exists, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    There is a combination that sums up to 10: [2, 4, 4].\n\n    Therefore, the function should return True.\n    \"\"\"\n    return dp(nums, target, 0, {})\n\ndef dp(nums: List[int], target: int, index: int, memo: dict) -> bool:\n    if target == 0:\n        return True\n    if target < 0 or index >= len(nums):\n        return False\n    if (target, index) in memo:\n        return memo[(target, index)]\n    \n    if dp(nums, target - nums[index], index, memo) or dp(nums, target, index + 1, memo):\n        memo[(target, index)] = True\n        return True\n    \n    memo[(target, index)] = False\n    return False", "solution_func": "def g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers that sum up to the target.\n    Return a list of all combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    There are three combinations that sum up to 4: [1, 1, 1, 1], [1, 1, 2], [2, 2].\n\n    Therefore, the function should return [[1, 1, 1, 1], [1, 1, 2], [2, 2]].\n    \"\"\"\n    result = []\n    backtrack(nums, target, 0, [], result)\n    return result\n\ndef backtrack(nums: List[int], target: int, index: int, curr_comb: List[int], result: List[List[int]]) -> None:\n    if target == 0:\n        result.append(curr_comb)\n        return\n    if target < 0 or index >= len(nums):\n        return\n    \n    for i in range(index, len(nums)):\n        backtrack(nums, target - nums[i], i, curr_comb + [nums[i]], result)\n\ndef g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == [[1, 1, 1, 1], [1, 1, 2], [2, 2]]\n", "emb": null, "idx_generation": 426, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers that sum up to the target.\n    Return a list of all combinations.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n\n    There are three combinations that sum up to 4: [1, 1, 1, 1], [1, 1, 2], [2, 2].\n\n    Therefore, the function should return [[1, 1, 1, 1], [1, 1, 2], [2, 2]].\n    \"\"\"\n    result = []\n    backtrack(nums, target, 0, [], result)\n    return result\n\ndef backtrack(nums: List[int], target: int, index: int, curr_comb: List[int], result: List[List[int]]) -> None:\n    if target == 0:\n        result.append(curr_comb)\n        return\n    if target < 0 or index >= len(nums):\n        return\n    \n    for i in range(index, len(nums)):\n        backtrack(nums, target - nums[i], i, curr_comb + [nums[i]], result)", "solution_func": "def g():\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of random integers and a random target sum.\n    \"\"\"\n    import random\n    nums = random.sample(range(1, 101), 10)\n    target = random.randint(1, 100)\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": null, "idx_generation": 426, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target sum, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a list of random integers and a random target sum.\n    \"\"\"\n    import random\n    nums = random.sample(range(1, 101), 10)\n    target = random.randint(1, 100)\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, remove all duplicate characters and return the resulting string.\n    \"\"\"\n    unique_chars = []\n    seen = set()\n    for char in s:\n        if char not in seen:\n            unique_chars.append(char)\n            seen.add(char)\n    return ''.join(unique_chars)\n\ndef g():\n    \"\"\"\n    Generate a string with duplicate characters.\n    \"\"\"\n    import random\n    chars = 'abcdefghijklmnopqrstuvwxyz'\n    s = ''.join(random.choice(chars) for _ in range(10))\n    return s\n\nassert f(g()) == 'abcdefghij'\n", "emb": null, "idx_generation": 426, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, remove all duplicate characters and return the resulting string.\n    \"\"\"\n    unique_chars = []\n    seen = set()\n    for char in s:\n        if char not in seen:\n            unique_chars.append(char)\n            seen.add(char)\n    return ''.join(unique_chars)", "solution_func": "def g():\n    \"\"\"\n    Generate a string with duplicate characters.\n    \"\"\"\n    import random\n    chars = 'abcdefghijklmnopqrstuvwxyz'\n    s = ''.join(random.choice(chars) for _ in range(10))\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    import random\n    nums = random.sample(range(-10, 11), 7)\n    return nums\n\nassert f(g()) == 600\n", "emb": null, "idx_generation": 426, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g():\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    import random\n    nums = random.sample(range(-10, 11), 7)\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if there are two numbers in the array that add up to\n    the target. Return True if such a pair exists, and False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n\n    Explanation: The pair (2, 5) in the array adds up to the target number 7.\n\n    Note: The array is guaranteed to be sorted in ascending order.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 426, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target number, determine if there are two numbers in the array that add up to\n    the target. Return True if such a pair exists, and False otherwise.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n\n    Explanation: The pair (2, 5) in the array adds up to the target number 7.\n\n    Note: The array is guaranteed to be sorted in ascending order.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target number.\n    \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 60\n\n    Explanation: The maximum product can be obtained by multiplying 4, 5, and 3.\n\n    Note: The list will have at least three integers.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 60\n\n    Explanation: The maximum product can be obtained by multiplying 4, 5, and 3.\n\n    Note: The list will have at least three integers.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n    \n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3])", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input: matrix = [[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]\n    Output: 29\n\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    Note: The matrix will have at least one cell.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]\n\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\n\nassert f(g()) == 29\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of any path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input: matrix = [[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]\n    Output: 29\n\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    Note: The matrix will have at least one cell.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given the number of nodes in a graph and a list of edges, find the number of connected components in the graph.\n\n    Example:\n    Input: n = 5\n           edges = [(0, 1), (1, 2), (3, 4)]\n    Output: 2\n\n    Explanation: There are two connected components: [0, 1, 2] and [3, 4].\n\n    Note: The edges will not have duplicates and will not have self-loops.\n    \"\"\"\n\n    parent = [-1] * n\n\n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        x_root = find(x)\n        y_root = find(y)\n        if x_root != y_root:\n            parent[x_root] = y_root\n\n    for u, v in edges:\n        union(u, v)\n\n    return sum(1 for i in range(n) if parent[i] == -1)\n\n\ndef g() -> Tuple[int, List[Tuple[int, int]]]:\n    n = 5\n    edges = [(0, 1), (1, 2), (3, 4)]\n    return n, edges\n\n\nassert f(*g()) == 2\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Given the number of nodes in a graph and a list of edges, find the number of connected components in the graph.\n\n    Example:\n    Input: n = 5\n           edges = [(0, 1), (1, 2), (3, 4)]\n    Output: 2\n\n    Explanation: There are two connected components: [0, 1, 2] and [3, 4].\n\n    Note: The edges will not have duplicates and will not have self-loops.\n    \"\"\"\n\n    parent = [-1] * n\n\n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        x_root = find(x)\n        y_root = find(y)\n        if x_root != y_root:\n            parent[x_root] = y_root\n\n    for u, v in edges:\n        union(u, v)\n\n    return sum(1 for i in range(n) if parent[i] == -1)", "solution_func": "def g() -> Tuple[int, List[Tuple[int, int]]]:\n    n = 5\n    edges = [(0, 1), (1, 2), (3, 4)]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The function should return [24, 12, 8, 6] since the product of all numbers except 1 is 24, the product of all numbers except 2 is 12, the product of all numbers except 3 is 8, and the product of all numbers except 4 is 6.\n    \"\"\"\n\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 427, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The function should return [24, 12, 8, 6] since the product of all numbers except 1 is 24, the product of all numbers except 2 is 12, the product of all numbers except 3 is 8, and the product of all numbers except 4 is 6.\n    \"\"\"\n\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result", "solution_func": "def g():\n    return [1, 2, 3, 4]", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number. If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The function should return 2 since 5 is found at index 2 in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number. If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The function should return 2 since 5 is found at index 2 in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    return [1, 3, 5, 7, 9], 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The function should return 3 since the longest substring without repeating characters is \"abc\".\n\n    Note: The substring \"abcabc\" is longer, but it has repeating characters.\n    \"\"\"\n\n    n = len(s)\n    char_dict = {}\n    max_length = 0\n    start = 0\n\n    for end in range(n):\n        if s[end] in char_dict:\n            start = max(start, char_dict[s[end]] + 1)\n        char_dict[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, return the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n    The function should return 3 since the longest substring without repeating characters is \"abc\".\n\n    Note: The substring \"abcabc\" is longer, but it has repeating characters.\n    \"\"\"\n\n    n = len(s)\n    char_dict = {}\n    max_length = 0\n    start = 0\n\n    for end in range(n):\n        if s[end] in char_dict:\n            start = max(start, char_dict[s[end]] + 1)\n        char_dict[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length", "solution_func": "def g():\n    return \"abcabcbb\"", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D array to store the maximum sum at each cell\n    max_sum = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first cell with its own value\n    max_sum[0][0] = matrix[0][0]\n\n    # Update the maximum sum at each cell\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + matrix[i][j]\n\n    return max_sum[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 21\n", "emb": null, "idx_generation": 427, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D array to store the maximum sum at each cell\n    max_sum = [[0] * cols for _ in range(rows)]\n\n    # Initialize the first cell with its own value\n    max_sum[0][0] = matrix[0][0]\n\n    # Update the maximum sum at each cell\n    for i in range(1, rows):\n        max_sum[i][0] = max_sum[i-1][0] + matrix[i][0]\n    for j in range(1, cols):\n        max_sum[0][j] = max_sum[0][j-1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_sum[i][j] = max(max_sum[i-1][j], max_sum[i][j-1]) + matrix[i][j]\n\n    return max_sum[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome after removing a single character.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    if is_palindrome(string):\n        return True\n\n    for i in range(len(string)):\n        modified_string = string[:i] + string[i+1:]\n        if is_palindrome(modified_string):\n            return True\n\n    return False\n\ndef g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"\n\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 427, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Check if a string is a palindrome after removing a single character.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    if is_palindrome(string):\n        return True\n\n    for i in range(len(string)):\n        modified_string = string[:i] + string[i+1:]\n        if is_palindrome(modified_string):\n            return True\n\n    return False", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return \"racecar\"", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the array.\n\n    Args:\n    arr (List[int]): The sorted array of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return arr, target\n\nassert f(*g()) == [2, 4]\n\n", "emb": null, "idx_generation": 427, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the array.\n\n    Args:\n    arr (List[int]): The sorted array of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target value.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        sum = arr[left] + arr[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return arr, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the kth digit from the right in the decimal representation of 1/n.\n\n    Example:\n    Input: n = 7, k = 3\n    Output: 4\n\n    Explanation: The decimal representation of 1/7 is 0.14285714285714285. The 3rd digit from the right is 4.\n    \"\"\"\n\n    decimal = str(1 / n)[::-1]  # Reverse the decimal representation\n    return int(decimal[k - 1])\n\ndef g(n = 7, k = 3):\n    return n, k\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 428, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, find the kth digit from the right in the decimal representation of 1/n.\n\n    Example:\n    Input: n = 7, k = 3\n    Output: 4\n\n    Explanation: The decimal representation of 1/7 is 0.14285714285714285. The 3rd digit from the right is 4.\n    \"\"\"\n\n    decimal = str(1 / n)[::-1]  # Reverse the decimal representation\n    return int(decimal[k - 1])", "solution_func": "def g(n = 7, k = 3):\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing exactly one character.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: After removing the character 'e', the string becomes \"racar\", which is a palindrome.\n    \"\"\"\n\n    def is_palindrome(string: str, left: int, right: int, removed: bool) -> bool:\n        while left < right:\n            if string[left] != string[right]:\n                if removed:\n                    return False\n                # Try removing the character on the left or right side\n                return is_palindrome(string, left + 1, right, True) or is_palindrome(string, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing exactly one character.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: After removing the character 'e', the string becomes \"racar\", which is a palindrome.\n    \"\"\"\n\n    def is_palindrome(string: str, left: int, right: int, removed: bool) -> bool:\n        while left < right:\n            if string[left] != string[right]:\n                if removed:\n                    return False\n                # Try removing the character on the left or right side\n                return is_palindrome(string, left + 1, right, True) or is_palindrome(string, left, right - 1, True)\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(s, 0, len(s) - 1, False)", "solution_func": "def g():\n    s = \"racecar\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    Input: n = 10\n    Output: 23\n\n    Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. Their sum is 23.\n    \"\"\"\n\n    sum = 0\n    for num in range(n):\n        if num % 3 == 0 or num % 5 == 0:\n            sum += num\n    return sum\n\ndef g(n = 10):\n    return n\n\nassert f(g()) == 23\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    Input: n = 10\n    Output: 23\n\n    Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6, and 9. Their sum is 23.\n    \"\"\"\n\n    sum = 0\n    for num in range(n):\n        if num % 3 == 0 or num % 5 == 0:\n            sum += num\n    return sum", "solution_func": "def g(n = 10):\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: [4, 7, 2, 8, 9]\n    Output: 15 (4 ^ 11 = 15)\n\n    Hint: Use bit manipulation and dynamic programming to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    return [4, 7, 2, 8, 9]\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: [4, 7, 2, 8, 9]\n    Output: 15 (4 ^ 11 = 15)\n\n    Hint: Use bit manipulation and dynamic programming to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        temp = max_xor | (1 << i)\n        for prefix in prefix_set:\n            if temp ^ prefix in prefix_set:\n                max_xor = temp\n                break\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [4, 7, 2, 8, 9]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    output: 6\n\n    Explanation: There are 6 unique paths: RRDD, RDRD, RDDR, DRRD, DRDR, DDRR.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the number of unique paths from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    output: 6\n\n    Explanation: There are 6 unique paths: RRDD, RDRD, RDDR, DRRD, DRDR, DDRR.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = 1\n\n    for i in range(1, m):\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m-1][n-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a grid of integers, find a valid path from the start cell to the end cell by only moving down or right.\n    Return a list of tuples representing the path.\n\n    Example:\n    grid = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n\n    Explanation: The valid path is (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2).\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i-1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j-1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1 and (dp[i-1][j] or dp[i][j-1]):\n                dp[i][j] = True\n\n    if not dp[m-1][n-1]:\n        return []\n\n    path = []\n    x, y = end\n    while x != start[0] or y != start[1]:\n        path.append((x, y))\n        if x > 0 and dp[x-1][y]:\n            x -= 1\n        else:\n            y -= 1\n    path.append(start)\n    path.reverse()\n\n    return path\n\ndef g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    grid = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    return grid, start, end\n\nassert f(*g()) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a grid of integers, find a valid path from the start cell to the end cell by only moving down or right.\n    Return a list of tuples representing the path.\n\n    Example:\n    grid = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)]\n\n    Explanation: The valid path is (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2).\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[False] * n for _ in range(m)]\n    dp[0][0] = True\n\n    for i in range(1, m):\n        if grid[i][0] == 1 and dp[i-1][0]:\n            dp[i][0] = True\n\n    for j in range(1, n):\n        if grid[0][j] == 1 and dp[0][j-1]:\n            dp[0][j] = True\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 1 and (dp[i-1][j] or dp[i][j-1]):\n                dp[i][j] = True\n\n    if not dp[m-1][n-1]:\n        return []\n\n    path = []\n    x, y = end\n    while x != start[0] or y != start[1]:\n        path.append((x, y))\n        if x > 0 and dp[x-1][y]:\n            x -= 1\n        else:\n            y -= 1\n    path.append(start)\n    path.reverse()\n\n    return path", "solution_func": "def g() -> Tuple[List[List[int]], Tuple[int, int], Tuple[int, int]]:\n    grid = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [1, 1, 1]\n    ]\n    start = (0, 0)\n    end = (2, 2)\n    return grid, start, end", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output: 24  # (2 * 3 * 4)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 24\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output: 24  # (2 * 3 * 4)\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the product of all elements in the original list except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output: [24, 12, 8, 6]\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 428, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers 'nums', return a new list where each element is the product of all elements in the original list except itself.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    Output: [24, 12, 8, 6]\n    \"\"\"\n    n = len(nums)\n    left_product = [1] * n\n    right_product = [1] * n\n    result = [0] * n\n\n    for i in range(1, n):\n        left_product[i] = left_product[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        right_product[i] = right_product[i+1] * nums[i+1]\n\n    for i in range(n):\n        result[i] = left_product[i] * right_product[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output: 6  # (the subarray [4, -1, 2, 1] has the maximum sum of 6)\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 428, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray within the list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    Output: 6  # (the subarray [4, -1, 2, 1] has the maximum sum of 6)\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum distance between any two points.\n\n    Args:\n    - points: A list of lists representing the coordinates of the points. Each inner list contains two integers [x, y].\n\n    Returns:\n    - The minimum distance between any two points.\n\n    Example:\n    points = [[1, 2], [3, 4], [5, 6]]\n    Output: 2\n\n    Explanation: The minimum distance is between the points [1, 2] and [3, 4] with a distance of 2.\n    \"\"\"\n\n    def distance(p1: List[int], p2: List[int]) -> int:\n        \"\"\"\n        Helper function to calculate the distance between two points.\n        \"\"\"\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    min_distance = float('inf')\n    n = len(points)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = distance(points[i], points[j])\n            min_distance = min(min_distance, dist)\n\n    return min_distance\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a list of points in a 2D plane.\n    \"\"\"\n    points = [[1, 2], [3, 4], [5, 6]]\n    return points\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 428, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> int:\n    \"\"\"\n    Given a list of points in a 2D plane, find the minimum distance between any two points.\n\n    Args:\n    - points: A list of lists representing the coordinates of the points. Each inner list contains two integers [x, y].\n\n    Returns:\n    - The minimum distance between any two points.\n\n    Example:\n    points = [[1, 2], [3, 4], [5, 6]]\n    Output: 2\n\n    Explanation: The minimum distance is between the points [1, 2] and [3, 4] with a distance of 2.\n    \"\"\"\n\n    def distance(p1: List[int], p2: List[int]) -> int:\n        \"\"\"\n        Helper function to calculate the distance between two points.\n        \"\"\"\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    min_distance = float('inf')\n    n = len(points)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = distance(points[i], points[j])\n            min_distance = min(min_distance, dist)\n\n    return min_distance", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a list of points in a 2D plane.\n    \"\"\"\n    points = [[1, 2], [3, 4], [5, 6]]\n    return points", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct characters in the string.\n    Return the count.\n    \"\"\"\n    distinct_chars = set(s)\n    return len(distinct_chars)\n\ndef g():\n    s = \"abracadabra\"\n    return s\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 429, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the number of distinct characters in the string.\n    Return the count.\n    \"\"\"\n    distinct_chars = set(s)\n    return len(distinct_chars)", "solution_func": "def g():\n    s = \"abracadabra\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n    Return the sorted list.\n    \"\"\"\n    arr.sort()\n    return arr\n\ndef g():\n    arr = [4, 2, 7, 1, 5]\n    return arr\n\nassert f(g()) == [1, 2, 4, 5, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 429, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n    Return the sorted list.\n    \"\"\"\n    arr.sort()\n    return arr", "solution_func": "def g():\n    arr = [4, 2, 7, 1, 5]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the number of permutations of n objects taken r at a time.\n    Return the result.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    permutations = factorial(n) // factorial(n - r)\n    return permutations\n\ndef g():\n    n = 5\n    r = 3\n    return n, r\n\nassert f(*g()) == 60\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 429, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, r: int) -> int:\n    \"\"\"\n    Calculate the number of permutations of n objects taken r at a time.\n    Return the result.\n    \"\"\"\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        return num * factorial(num - 1)\n\n    permutations = factorial(n) // factorial(n - r)\n    return permutations", "solution_func": "def g():\n    n = 5\n    r = 3\n    return n, r", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The rotated matrix should be:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Therefore, the function should return [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n    return rotated_matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 429, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The rotated matrix should be:\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\n    Therefore, the function should return [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    rotated_matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n    return rotated_matrix", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    The maximum sum path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 429, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    The maximum sum path is: 1 -> 3 -> 1 -> 1 -> 1\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid.\n    \"\"\"\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the maximum length of a valid path from the top-left cell to the bottom-right cell.\n    A valid path consists of only 'A' and 'B' characters, and can only move down or right.\n\n    Example:\n    grid = [['A', 'B', 'A'],\n            ['A', 'A', 'B'],\n            ['B', 'A', 'A']]\n\n    The maximum length of a valid path is: A -> B -> A -> A -> B -> A\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    dp[0][0] = 1 if grid[0][0] in ['A', 'B'] else 0\n\n    for i in range(1, rows):\n        if grid[i][0] in ['A', 'B']:\n            dp[i][0] = dp[i-1][0] + 1\n    for j in range(1, cols):\n        if grid[0][j] in ['A', 'B']:\n            dp[0][j] = dp[0][j-1] + 1\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] in ['A', 'B']:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[str]]:\n    \"\"\"\n    Generate a grid.\n    \"\"\"\n    return [['A', 'B', 'A'], ['A', 'A', 'B'], ['B', 'A', 'A']]\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 429, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, find the maximum length of a valid path from the top-left cell to the bottom-right cell.\n    A valid path consists of only 'A' and 'B' characters, and can only move down or right.\n\n    Example:\n    grid = [['A', 'B', 'A'],\n            ['A', 'A', 'B'],\n            ['B', 'A', 'A']]\n\n    The maximum length of a valid path is: A -> B -> A -> A -> B -> A\n\n    Therefore, the function should return 6.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    dp[0][0] = 1 if grid[0][0] in ['A', 'B'] else 0\n\n    for i in range(1, rows):\n        if grid[i][0] in ['A', 'B']:\n            dp[i][0] = dp[i-1][0] + 1\n    for j in range(1, cols):\n        if grid[0][j] in ['A', 'B']:\n            dp[0][j] = dp[0][j-1] + 1\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] in ['A', 'B']:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[str]]:\n    \"\"\"\n    Generate a grid.\n    \"\"\"\n    return [['A', 'B', 'A'], ['A', 'A', 'B'], ['B', 'A', 'A']]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: [4, 10, 4, 3, 8, 9]\n    Output: 3\n    Explanation: The longest increasing subsequence is [4, 8, 9], therefore the length is 3.\n    \"\"\"\n\n    # Initialize an array to store the length of the LIS for each element in the input list\n    dp = [1] * len(nums)\n\n    # Iterate through the input list\n    for i in range(1, len(nums)):\n        # Check all previous elements to find the longest increasing subsequence\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Return the maximum length of the LIS\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 429, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    Input: [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: [4, 10, 4, 3, 8, 9]\n    Output: 3\n    Explanation: The longest increasing subsequence is [4, 8, 9], therefore the length is 3.\n    \"\"\"\n\n    # Initialize an array to store the length of the LIS for each element in the input list\n    dp = [1] * len(nums)\n\n    # Iterate through the input list\n    for i in range(1, len(nums)):\n        # Check all previous elements to find the longest increasing subsequence\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # Return the maximum length of the LIS\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n\n    You can only move down or to the right.\n\n    Example:\n    Input: [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The maximum sum of a path from (0, 0) to (2, 2) is 1 + 3 + 1 + 1 + 1 = 7.\n\n    Input: [[1, 2, 3], [4, 5, 6]]\n    Output: 12\n    Explanation: The maximum sum of a path from (0, 0) to (1, 2) is 1 + 2 + 3 + 6 = 12.\n    \"\"\"\n\n    # Get the number of rows and columns in the grid\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D array to store the maximum sum of a path for each cell in the grid\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Calculate the maximum sum of a path for each cell by choosing the maximum of the previous row or column\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    # Return the maximum sum of a path for the bottom-right cell\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 429, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n\n    You can only move down or to the right.\n\n    Example:\n    Input: [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The maximum sum of a path from (0, 0) to (2, 2) is 1 + 3 + 1 + 1 + 1 = 7.\n\n    Input: [[1, 2, 3], [4, 5, 6]]\n    Output: 12\n    Explanation: The maximum sum of a path from (0, 0) to (1, 2) is 1 + 2 + 3 + 6 = 12.\n    \"\"\"\n\n    # Get the number of rows and columns in the grid\n    rows = len(grid)\n    cols = len(grid[0])\n\n    # Initialize a 2D array to store the maximum sum of a path for each cell in the grid\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Calculate the maximum sum of a path for each cell by choosing the maximum of the previous row or column\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    # Return the maximum sum of a path for the bottom-right cell\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Input: n = 3, k = 3\n    Output: [[1, 2, 3]]\n    \"\"\"\n\n    # Initialize a list to store the combinations\n    combinations = []\n\n    def backtrack(start, current):\n        if len(current) == k:\n            combinations.append(current[:])\n        else:\n            for i in range(start, n + 1):\n                current.append(i)\n                backtrack(i + 1, current)\n                current.pop()\n\n    # Start backtracking from 1 and an empty current list\n    backtrack(1, [])\n\n    # Return the list of combinations\n    return combinations\n\ndef g() -> Tuple[int, int]:\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 429, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n    Input: n = 3, k = 3\n    Output: [[1, 2, 3]]\n    \"\"\"\n\n    # Initialize a list to store the combinations\n    combinations = []\n\n    def backtrack(start, current):\n        if len(current) == k:\n            combinations.append(current[:])\n        else:\n            for i in range(start, n + 1):\n                current.append(i)\n                backtrack(i + 1, current)\n                current.pop()\n\n    # Start backtracking from 1 and an empty current list\n    backtrack(1, [])\n\n    # Return the list of combinations\n    return combinations", "solution_func": "def g() -> Tuple[int, int]:\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, result: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the number of k-length strings that can be formed using only the digits 0 to 9,\n    such that the sum of the digits in each string is equal to the given result.\n\n    Example:\n    n = 3\n    k = 2\n    result = 5\n\n    Output:\n    15\n\n    Explanation:\n    The possible 2-length strings are [\"00\", \"01\", \"02\", ..., \"98\", \"99\"].\n    The sum of the digits in each string is [0, 1, 2, ..., 17, 18, 19].\n    There are 15 strings where the sum of the digits is equal to 5: [\"05\", \"14\", \"23\", \"32\", \"41\", \"50\", \"41\", \"32\", \"23\", \"14\", \"05\", \"50\", \"41\", \"32\", \"23\"].\n    \"\"\"\n    count = 0\n    for i in range(10 ** k):\n        digits = str(i).zfill(k)\n        if sum(int(d) for d in digits) == result:\n            count += 1\n    return count == n\ndef g(n=15, k=2, result=5):\n    return n\nassert f(g(), k=2, result=5)\n", "emb": null, "idx_generation": 429, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int, result: int) -> bool:\n    \"\"\"\n    Given a positive integer n, find the number of k-length strings that can be formed using only the digits 0 to 9,\n    such that the sum of the digits in each string is equal to the given result.\n\n    Example:\n    n = 3\n    k = 2\n    result = 5\n\n    Output:\n    15\n\n    Explanation:\n    The possible 2-length strings are [\"00\", \"01\", \"02\", ..., \"98\", \"99\"].\n    The sum of the digits in each string is [0, 1, 2, ..., 17, 18, 19].\n    There are 15 strings where the sum of the digits is equal to 5: [\"05\", \"14\", \"23\", \"32\", \"41\", \"50\", \"41\", \"32\", \"23\", \"14\", \"05\", \"50\", \"41\", \"32\", \"23\"].\n    \"\"\"\n    count = 0\n    for i in range(10 ** k):\n        digits = str(i).zfill(k)\n        if sum(int(d) for d in digits) == result:\n            count += 1\n    return count == n", "solution_func": "def g(n=15, k=2, result=5):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all pairs of numbers in the list whose bitwise XOR is equal to the target number.\n    Return a list of tuples representing the pairs.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    [(2, 4)]\n\n    Explanation:\n    The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    pairs = []\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            pairs.append((num, num ^ target))\n        \n        complements.add(num)\n\n    return pairs\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == [(2, 4)]\n", "emb": null, "idx_generation": 430, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all pairs of numbers in the list whose bitwise XOR is equal to the target number.\n    Return a list of tuples representing the pairs.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    [(2, 4)]\n\n    Explanation:\n    The pair (2, 4) has a bitwise XOR equal to 6 (2 ^ 4 = 6).\n    \"\"\"\n\n    pairs = []\n    complements = set()\n\n    for num in nums:\n        if num ^ target in complements:\n            pairs.append((num, num ^ target))\n        \n        complements.add(num)\n\n    return pairs", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number that appears only once while all other numbers appear twice.\n    Return the number that appears only once.\n\n    Sample Input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample Output:\n    3\n\n    Explanation:\n    The number 3 appears only once while all other numbers (1, 2) appear twice.\n    \"\"\"\n\n    result = 0\n\n    for num in nums:\n        result ^= num\n\n    return result\n\ndef g():\n    nums = [1, 2, 3, 2, 1]\n    return nums\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 430, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number that appears only once while all other numbers appear twice.\n    Return the number that appears only once.\n\n    Sample Input:\n    nums = [1, 2, 3, 2, 1]\n\n    Sample Output:\n    3\n\n    Explanation:\n    The number 3 appears only once while all other numbers (1, 2) appear twice.\n    \"\"\"\n\n    result = 0\n\n    for num in nums:\n        result ^= num\n\n    return result", "solution_func": "def g():\n    nums = [1, 2, 3, 2, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a weighted directed graph, find the shortest path between two nodes.\n    Return the length of the shortest path.\n\n    Sample Input:\n    matrix = [[0, 1, 3, 0],\n              [0, 0, 2, 0],\n              [0, 0, 0, 2],\n              [0, 0, 0, 0]]\n\n    Sample Output:\n    6\n\n    Explanation:\n    The shortest path from Node 0 to Node 3 is: 0 -> 2 -> 3, with a total length of 6.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Initialize the distance array with infinity\n    dist = [float('inf')] * n\n    dist[0] = 0\n\n    # Perform Dijkstra's algorithm\n    for _ in range(n - 1):\n        for u in range(n):\n            for v in range(n):\n                if matrix[u][v] > 0 and dist[u] + matrix[u][v] < dist[v]:\n                    dist[v] = dist[u] + matrix[u][v]\n\n    return dist[-1]\n\ndef g():\n    matrix = [[0, 1, 3, 0],\n              [0, 0, 2, 0],\n              [0, 0, 0, 2],\n              [0, 0, 0, 0]]\n    return matrix\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 430, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a weighted directed graph, find the shortest path between two nodes.\n    Return the length of the shortest path.\n\n    Sample Input:\n    matrix = [[0, 1, 3, 0],\n              [0, 0, 2, 0],\n              [0, 0, 0, 2],\n              [0, 0, 0, 0]]\n\n    Sample Output:\n    6\n\n    Explanation:\n    The shortest path from Node 0 to Node 3 is: 0 -> 2 -> 3, with a total length of 6.\n    \"\"\"\n\n    n = len(matrix)\n\n    # Initialize the distance array with infinity\n    dist = [float('inf')] * n\n    dist[0] = 0\n\n    # Perform Dijkstra's algorithm\n    for _ in range(n - 1):\n        for u in range(n):\n            for v in range(n):\n                if matrix[u][v] > 0 and dist[u] + matrix[u][v] < dist[v]:\n                    dist[v] = dist[u] + matrix[u][v]\n\n    return dist[-1]", "solution_func": "def g():\n    matrix = [[0, 1, 3, 0],\n              [0, 0, 2, 0],\n              [0, 0, 0, 2],\n              [0, 0, 0, 0]]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target sum, determine if there are two numbers in the list such that\n    their sum is equal to the target. Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef g(nums = [2, 4, 6, 8, 10], target = 12):\n    return nums, target\n\nassert f(*g())\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 430, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target sum, determine if there are two numbers in the list such that\n    their sum is equal to the target. Return True if such a pair exists, otherwise return False.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return True\n        seen.add(num)\n    return False", "solution_func": "def g(nums = [2, 4, 6, 8, 10], target = 12):\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of lowercase English letters, return the longest substring without repeating characters.\n    If there are multiple answers, return the substring with the smallest index.\n    \"\"\"\n    max_substring = \"\"\n    current_substring = \"\"\n    char_map = {}\n    start = 0\n    for i, char in enumerate(s):\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n            current_substring = s[start:i]\n        current_substring += char\n        char_map[char] = i\n        if len(current_substring) > len(max_substring):\n            max_substring = current_substring\n    return max_substring\n\ndef g(s = \"abcabcbb\"):\n    return s\n\nassert f(g()) == \"abc\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 430, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string of lowercase English letters, return the longest substring without repeating characters.\n    If there are multiple answers, return the substring with the smallest index.\n    \"\"\"\n    max_substring = \"\"\n    current_substring = \"\"\n    char_map = {}\n    start = 0\n    for i, char in enumerate(s):\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n            current_substring = s[start:i]\n        current_substring += char\n        char_map[char] = i\n        if len(current_substring) > len(max_substring):\n            max_substring = current_substring\n    return max_substring", "solution_func": "def g(s = \"abcabcbb\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an integer array nums and an integer target, return the number of non-empty subsequences of nums such that\n    the sum of the minimum and maximum element on it is less or equal to target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    count = 0\n    mod = 10 ** 9 + 7\n    while left <= right:\n        if nums[left] + nums[right] <= target:\n            count += pow(2, right - left, mod)\n            left += 1\n        else:\n            right -= 1\n    return count % mod\n\ndef g(nums = [3, 1, 2, 4], target = 6):\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 430, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an integer array nums and an integer target, return the number of non-empty subsequences of nums such that\n    the sum of the minimum and maximum element on it is less or equal to target.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    count = 0\n    mod = 10 ** 9 + 7\n    while left <= right:\n        if nums[left] + nums[right] <= target:\n            count += pow(2, right - left, mod)\n            left += 1\n        else:\n            right -= 1\n    return count % mod", "solution_func": "def g(nums = [3, 1, 2, 4], target = 6):\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome. A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring cases and non-alphanumeric characters.\n\n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    Explanation: \"amanaplanacanalpanama\" is a valid palindrome.\n\n    Constraints:\n    - 0 <= len(s) <= 2 * 10^5\n    - s consists only of printable ASCII characters.\n    \"\"\"\n\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n\n    return s == s[::-1]\n\ndef g() -> str:\n    return \"A man, a plan, a canal: Panama\"\n\nassert f(g()) == True\n\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 430, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid palindrome. A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring cases and non-alphanumeric characters.\n\n    Example:\n    Input: \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    Explanation: \"amanaplanacanalpanama\" is a valid palindrome.\n\n    Constraints:\n    - 0 <= len(s) <= 2 * 10^5\n    - s consists only of printable ASCII characters.\n    \"\"\"\n\n    s = ''.join(ch.lower() for ch in s if ch.isalnum())\n\n    return s == s[::-1]", "solution_func": "def g() -> str:\n    return \"A man, a plan, a canal: Panama\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.\n\n    Example:\n    Input: nums = [1, 1, 1], k = 2\n    Output: 2\n\n    Explanation: The subarrays [1, 1] and [1, 1] have a sum of 2.\n\n    Constraints:\n    - 1 <= nums.length <= 2 * 10^4\n    - -1000 <= nums[i] <= 1000\n    - -10^7 <= k <= 10^7\n    \"\"\"\n\n    count = 0\n    sum_so_far = 0\n    sum_counts = {0: 1}\n\n    for num in nums:\n        sum_so_far += num\n\n        if sum_so_far - k in sum_counts:\n            count += sum_counts[sum_so_far - k]\n\n        if sum_so_far in sum_counts:\n            sum_counts[sum_so_far] += 1\n        else:\n            sum_counts[sum_so_far] = 1\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 1, 1], 2)\n\nassert f(*g()) == 2\n\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 430, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.\n\n    Example:\n    Input: nums = [1, 1, 1], k = 2\n    Output: 2\n\n    Explanation: The subarrays [1, 1] and [1, 1] have a sum of 2.\n\n    Constraints:\n    - 1 <= nums.length <= 2 * 10^4\n    - -1000 <= nums[i] <= 1000\n    - -10^7 <= k <= 10^7\n    \"\"\"\n\n    count = 0\n    sum_so_far = 0\n    sum_counts = {0: 1}\n\n    for num in nums:\n        sum_so_far += num\n\n        if sum_so_far - k in sum_counts:\n            count += sum_counts[sum_so_far - k]\n\n        if sum_so_far in sum_counts:\n            sum_counts[sum_so_far] += 1\n        else:\n            sum_counts[sum_so_far] = 1\n\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 1, 1], 2)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation: The elements of the matrix are [1, 2, 3, 4, 5, 6, 7, 8, 9] in spiral order.\n\n    Constraints:\n    - m == matrix.length\n    - n == matrix[i].length\n    - 1 <= m, n <= 10\n    - -100 <= matrix[i][j] <= 100\n    \"\"\"\n\n    spiral_order = []\n\n    if not matrix:\n        return spiral_order\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 430, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation: The elements of the matrix are [1, 2, 3, 4, 5, 6, 7, 8, 9] in spiral order.\n\n    Constraints:\n    - m == matrix.length\n    - n == matrix[i].length\n    - 1 <= m, n <= 10\n    - -100 <= matrix[i][j] <= 100\n    \"\"\"\n\n    spiral_order = []\n\n    if not matrix:\n        return spiral_order\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of ways to arrange n items such that exactly k items are in the correct position.\n\n    Example:\n    Input:\n    n = 5\n    k = 2\n\n    Output:\n    20\n\n    Explanation:\n    There are 20 different ways to arrange 5 items such that exactly 2 items are in the correct position.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    return (factorial(n) // factorial(n - k)) * k\n\ndef g():\n    n = 5\n    k = 2\n    return [n, k]\n\nassert f(*g()) == 20\n", "emb": null, "idx_generation": 430, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, calculate the number of ways to arrange n items such that exactly k items are in the correct position.\n\n    Example:\n    Input:\n    n = 5\n    k = 2\n\n    Output:\n    20\n\n    Explanation:\n    There are 20 different ways to arrange 5 items such that exactly 2 items are in the correct position.\n    \"\"\"\n\n    def factorial(num: int) -> int:\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    return (factorial(n) // factorial(n - k)) * k", "solution_func": "def g():\n    n = 5\n    k = 2\n    return [n, k]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exist two distinct indices i and j in the list such that nums[i] + nums[j] == target.\n\n    Example:\n    Input: nums = [-2, 0, 3, 5, 7, 9, 12], target = 8\n    Output: True\n\n    Explanation:\n    The sum of nums[2] and nums[4] is equal to the target number 8.\n    Therefore, there exist two distinct indices i and j such that nums[i] + nums[j] == target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number, where there exist two distinct indices i and j such that nums[i] + nums[j] == target.\n    \"\"\"\n    return ([-2, 0, 3, 5, 7, 9, 12], 8)\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there exist two distinct indices i and j in the list such that nums[i] + nums[j] == target.\n\n    Example:\n    Input: nums = [-2, 0, 3, 5, 7, 9, 12], target = 8\n    Output: True\n\n    Explanation:\n    The sum of nums[2] and nums[4] is equal to the target number 8.\n    Therefore, there exist two distinct indices i and j such that nums[i] + nums[j] == target.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number, where there exist two distinct indices i and j such that nums[i] + nums[j] == target.\n    \"\"\"\n    return ([-2, 0, 3, 5, 7, 9, 12], 8)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (i, j) such that i < j and nums[i] & nums[j] == 0.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 6\n\n    Explanation:\n    The unique pairs (i, j) such that i < j and nums[i] & nums[j] == 0 are:\n    (1, 2), (1, 4), (1, 8), (2, 4), (2, 8), (4, 8).\n    Therefore, there are 6 unique pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                count += 1\n    return count\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the number of unique pairs (i, j) such that i < j and nums[i] & nums[j] == 0 is required to solve the puzzle.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 431, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (i, j) such that i < j and nums[i] & nums[j] == 0.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 6\n\n    Explanation:\n    The unique pairs (i, j) such that i < j and nums[i] & nums[j] == 0 are:\n    (1, 2), (1, 4), (1, 8), (2, 4), (2, 8), (4, 8).\n    Therefore, there are 6 unique pairs.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] & nums[j] == 0:\n                count += 1\n    return count", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the number of unique pairs (i, j) such that i < j and nums[i] & nums[j] == 0 is required to solve the puzzle.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order based on the number of 1's in the binary representation of each number. If two numbers have the same number of 1's, they should be sorted in non-decreasing order.\n\n    Example:\n    Input: nums = [3, 7, 10, 12, 5, 2]\n    Output: [10, 12, 2, 3, 5, 7]\n\n    Explanation:\n    The binary representation of the numbers in nums is:\n    3: 11\n    7: 111\n    10: 1010\n    12: 1100\n    5: 101\n    2: 10\n\n    The numbers sorted based on the number of 1's in their binary representation are:\n    10 (2 ones)\n    12 (2 ones)\n    2 (1 one)\n    3 (2 ones)\n    5 (2 ones)\n    7 (3 ones)\n    \"\"\"\n    def count_ones(num):\n        count = 0\n        while num > 0:\n            count += num & 1\n            num >>= 1\n        return count\n\n    nums.sort(key=lambda x: (count_ones(x), x))\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where sorting the list in non-decreasing order based on the number of 1's in the binary representation of each number is required to solve the puzzle.\n    \"\"\"\n    return [3, 7, 10, 12, 5, 2]\n\nassert f(g()) == [10, 12, 2, 3, 5, 7]\n", "emb": null, "idx_generation": 431, "target_skills": [0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, sort the list in non-decreasing order based on the number of 1's in the binary representation of each number. If two numbers have the same number of 1's, they should be sorted in non-decreasing order.\n\n    Example:\n    Input: nums = [3, 7, 10, 12, 5, 2]\n    Output: [10, 12, 2, 3, 5, 7]\n\n    Explanation:\n    The binary representation of the numbers in nums is:\n    3: 11\n    7: 111\n    10: 1010\n    12: 1100\n    5: 101\n    2: 10\n\n    The numbers sorted based on the number of 1's in their binary representation are:\n    10 (2 ones)\n    12 (2 ones)\n    2 (1 one)\n    3 (2 ones)\n    5 (2 ones)\n    7 (3 ones)\n    \"\"\"\n    def count_ones(num):\n        count = 0\n        while num > 0:\n            count += num & 1\n            num >>= 1\n        return count\n\n    nums.sort(key=lambda x: (count_ones(x), x))\n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where sorting the list in non-decreasing order based on the number of 1's in the binary representation of each number is required to solve the puzzle.\n    \"\"\"\n    return [3, 7, 10, 12, 5, 2]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        count += f(i) * f(n-i-1)\n    \n    return count\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate the number of pairs of parentheses.\n    \"\"\"\n    return n\n\nassert f(g(3)) == 5\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the number of ways to arrange n pairs of parentheses such that they are balanced.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        count += f(i) * f(n-i-1)\n    \n    return count", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Generate the number of pairs of parentheses.\n    \"\"\"\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g(s: str) -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s + s[::-1]\n\nassert f(g(\"abcba\")) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True", "solution_func": "def g(s: str) -> str:\n    \"\"\"\n    Generate a palindrome string.\n    \"\"\"\n    return s + s[::-1]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (LIS).\n    \"\"\"\n    if not arr:\n        return 0\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 2, 1, 20]\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (LIS).\n    \"\"\"\n    if not arr:\n        return 0\n\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 10, 2, 1, 20]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a window size k, find the maximum element in each window of size k.\n    \"\"\"\n    if not arr or k == 0:\n        return []\n\n    n = len(arr)\n    result = []\n\n    for i in range(n - k + 1):\n        result.append(max(arr[i:i + k]))\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, 3, 2, 1, 5]\n\nassert f(g(), 3) == [4, 3, 5]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a window size k, find the maximum element in each window of size k.\n    \"\"\"\n    if not arr or k == 0:\n        return []\n\n    n = len(arr)\n    result = []\n\n    for i in range(n - k + 1):\n        result.append(max(arr[i:i + k]))\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [4, 3, 2, 1, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray.\n    \"\"\"\n    if not arr:\n        return 0\n\n    current_sum = max_sum = arr[0]\n\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 431, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of a subarray.\n    \"\"\"\n    if not arr:\n        return 0\n\n    current_sum = max_sum = arr[0]\n\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    If the target is not found in the array, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 5\n\n    The target value 5 is found at index 2 in the array, so the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int, int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11], 5\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 431, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value, find the index of the target value in the array using binary search.\n    If the target is not found in the array, return -1.\n\n    Example:\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 5\n\n    The target value 5 is found at index 2 in the array, so the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> List[int, int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11], 5", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of k-combinations that can be formed from a set of n elements.\n    A k-combination is a selection of k distinct elements from a set of n elements, where the order does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    The set of elements is {1, 2, 3, 4, 5}.\n    The 3-combinations that can be formed are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    Therefore, the function should return 10.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 432, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two positive integers n and k, return the number of k-combinations that can be formed from a set of n elements.\n    A k-combination is a selection of k distinct elements from a set of n elements, where the order does not matter.\n\n    Example:\n    n = 5, k = 3\n\n    The set of elements is {1, 2, 3, 4, 5}.\n    The 3-combinations that can be formed are: {1, 2, 3}, {1, 2, 4}, {1, 2, 5}, {1, 3, 4}, {1, 3, 5}, {1, 4, 5}, {2, 3, 4}, {2, 3, 5}, {2, 4, 5}, {3, 4, 5}.\n    Therefore, the function should return 10.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two positive integers n and k.\n    \"\"\"\n    return 5, 3", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Example:\n    n = 2\n    grid = [[1, 2], [3, 4]]\n\n    The maximum XOR value that can be obtained is 7 by selecting 1 from the first row, 2 from the second row, 3 from the first column, and 4 from the second column.\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(n):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 2, [[1, 2], [3, 4]]\n\nassert f(*g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 432, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(n: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x n, where each cell contains an integer, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n\n    Example:\n    n = 2\n    grid = [[1, 2], [3, 4]]\n\n    The maximum XOR value that can be obtained is 7 by selecting 1 from the first row, 2 from the second row, 3 from the first column, and 4 from the second column.\n    Therefore, the function should return 7.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(n):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x n and a positive integer n.\n    \"\"\"\n    return 2, [[1, 2], [3, 4]]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    nums = [3, 5, 10, 8, 2]\n\n    The maximum XOR value that can be obtained is 15 by selecting 3 and 10.\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [3, 5, 10, 8, 2]\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 432, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two elements in the list.\n\n    Example:\n    nums = [3, 5, 10, 8, 2]\n\n    The maximum XOR value that can be obtained is 15 by selecting 3 and 10.\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers.\n    \"\"\"\n    return [3, 5, 10, 8, 2]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == 120\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 432, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nimport math\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the factorial of n.\n\n    Example:\n    n = 5\n\n    Output:\n    120\n\n    Explanation:\n    The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.\n    \"\"\"\n\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * f(n-1)", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the reversed string.\n\n    Sample Input:\n    s = \"hello\"\n\n    Sample Output:\n    \"olleh\"\n    \"\"\"\n\n    return s[::-1]\n\ndef g():\n    return \"hello\"\n\nassert f(g()) == \"olleh\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 432, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return the reversed string.\n\n    Sample Input:\n    s = \"hello\"\n\n    Sample Output:\n    \"olleh\"\n    \"\"\"\n\n    return s[::-1]", "solution_func": "def g():\n    return \"hello\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of characters representing a grid, count the number of specific characters in the grid.\n\n    Sample Input:\n    s = '''\n    XXO\n    OOX\n    XXX\n    '''\n\n    Sample Output:\n    7\n\n    Explanation:\n    The character 'X' appears 5 times and the character 'O' appears 2 times in the grid.\n    \"\"\"\n\n    count = 0\n\n    for char in s:\n        if char == 'X' or char == 'O':\n            count += 1\n\n    return count\n\ndef g():\n    return '''\n    XXO\n    OOX\n    XXX\n    '''\n\nassert f(g()) == 7\n\n", "emb": null, "idx_generation": 432, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of characters representing a grid, count the number of specific characters in the grid.\n\n    Sample Input:\n    s = '''\n    XXO\n    OOX\n    XXX\n    '''\n\n    Sample Output:\n    7\n\n    Explanation:\n    The character 'X' appears 5 times and the character 'O' appears 2 times in the grid.\n    \"\"\"\n\n    count = 0\n\n    for char in s:\n        if char == 'X' or char == 'O':\n            count += 1\n\n    return count", "solution_func": "def g():\n    return '''\n    XXO\n    OOX\n    XXX\n    '''", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if there are two numbers in the list whose sum is equal to the target.\n\n    Return True if there exists two numbers in the list that add up to the target, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    The sum of 2 and 5 is equal to the target, so the function should return True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g(), 7) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 432, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target integer, determine if there are two numbers in the list whose sum is equal to the target.\n\n    Return True if there exists two numbers in the list that add up to the target, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n\n    The sum of 2 and 5 is equal to the target, so the function should return True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (a, b) such that a^b is equal to the bitwise OR of a and b.\n\n    Return the number of unique pairs.\n\n    Example:\n    nums = [3, 4, 5, 6]\n\n    The unique pairs (3, 4) and (4, 6) satisfy the condition, as 3^4 = 7 and 3|4 = 7, similarly 4^6 = 2 and 4|6 = 6.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    unique_pairs = set()\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == nums[i] | nums[j]:\n                unique_pairs.add((nums[i], nums[j]))\n\n    return len(unique_pairs)\n\ndef g() -> List[int]:\n    nums = [3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 2\n\n", "emb": null, "idx_generation": 432, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (a, b) such that a^b is equal to the bitwise OR of a and b.\n\n    Return the number of unique pairs.\n\n    Example:\n    nums = [3, 4, 5, 6]\n\n    The unique pairs (3, 4) and (4, 6) satisfy the condition, as 3^4 = 7 and 3|4 = 7, similarly 4^6 = 2 and 4|6 = 6.\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    unique_pairs = set()\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] ^ nums[j] == nums[i] | nums[j]:\n                unique_pairs.add((nums[i], nums[j]))\n\n    return len(unique_pairs)", "solution_func": "def g() -> List[int]:\n    nums = [3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.stack:\n            return self.stack.pop()\n        return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only '(' and ')', determine if the string is balanced.\n    A balanced string is one in which all parentheses are properly closed and nested.\n\n    Return True if the string is balanced, otherwise return False.\n\n    Example:\n    s = \"((())())\"\n\n    The string is balanced as all parentheses are properly closed and nested, so the function should return True.\n    \"\"\"\n\n    stack = Stack()\n\n    for char in s:\n        if char == '(':\n            stack.push(char)\n        elif char == ')':\n            if stack.is_empty():\n                return False\n            stack.pop()\n\n    return stack.is_empty()\n\ndef g() -> str:\n    s = \"((())())\"\n    return s\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 432, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if self.stack:\n            return self.stack.pop()\n        return None\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string containing only '(' and ')', determine if the string is balanced.\n    A balanced string is one in which all parentheses are properly closed and nested.\n\n    Return True if the string is balanced, otherwise return False.\n\n    Example:\n    s = \"((())())\"\n\n    The string is balanced as all parentheses are properly closed and nested, so the function should return True.\n    \"\"\"\n\n    stack = Stack()\n\n    for char in s:\n        if char == '(':\n            stack.push(char)\n        elif char == ')':\n            if stack.is_empty():\n                return False\n            stack.pop()\n\n    return stack.is_empty()", "solution_func": "def g() -> str:\n    s = \"((())())\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a path is 1 + 3 + 4 + 5 + 6 + 9 = 28.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    # Fill the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    # Fill the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    # Fill the remaining cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 2],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 28\n\n", "emb": null, "idx_generation": 432, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 2],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum sum of a path is 1 + 3 + 4 + 5 + 6 + 9 = 28.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    # Fill the first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    # Fill the first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    # Fill the remaining cells\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 2],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is obtained from the subarray [4, -1, 2, 1].\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the median.\n\n    Example:\n    nums = [1, 5, 3, 2, 4]\n\n    The median of the numbers is 3.\n    Therefore, the function should return 3.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    if n % 2 == 0:\n        median = (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        median = nums[n // 2]\n\n    return median\n\ndef g():\n    return [1, 5, 3, 2, 4]\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the median.\n\n    Example:\n    nums = [1, 5, 3, 2, 4]\n\n    The median of the numbers is 3.\n    Therefore, the function should return 3.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    if n % 2 == 0:\n        median = (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        median = nums[n // 2]\n\n    return median", "solution_func": "def g():\n    return [1, 5, 3, 2, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the number that appears more than n/2 times, where n is the length of the list.\n\n    Example:\n    nums = [3, 3, 4, 2, 4, 4, 2, 4, 4]\n\n    The number 4 appears more than 9/2 = 4.5 times.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        if num == candidate:\n            count += 1\n        else:\n            count -= 1\n\n    return candidate\n\ndef g():\n    return [3, 3, 4, 2, 4, 4, 2, 4, 4]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the number that appears more than n/2 times, where n is the length of the list.\n\n    Example:\n    nums = [3, 3, 4, 2, 4, 4, 2, 4, 4]\n\n    The number 4 appears more than 9/2 = 4.5 times.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        if num == candidate:\n            count += 1\n        else:\n            count -= 1\n\n    return candidate", "solution_func": "def g():\n    return [3, 3, 4, 2, 4, 4, 2, 4, 4]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a directed graph has a cycle.\"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False\n\ndef g():\n    graph = [[1, 2], [2], [3, 4], [4], []]  # Example graph with a cycle\n    return graph\n\nassert f(g())\n", "emb": null, "idx_generation": 433, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"Check if a directed graph has a cycle.\"\"\"\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node):\n                return True\n\n    return False", "solution_func": "def g():\n    graph = [[1, 2], [2], [3, 4], [4], []]  # Example graph with a cycle\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n\n    left, right = 0, n\n\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n\n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    return 25  # Example perfect square\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    if n < 0:\n        return False\n\n    left, right = 0, n\n\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n\n        if square == n:\n            return True\n        elif square < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g():\n    return 25  # Example perfect square", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find a subset of numbers that add up to the target sum.\"\"\"\n    memo = {}\n\n    def dp(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n\n        if (i, curr_sum) not in memo:\n            memo[(i, curr_sum)] = dp(i + 1, curr_sum) or dp(i + 1, curr_sum + nums[i])\n\n        return memo[(i, curr_sum)]\n\n    return dp(0, 0)\n\ndef g():\n    nums = [2, 4, 6, 8, 10]  # Example list of numbers\n    target = 16  # Example target sum\n    return nums, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"Find a subset of numbers that add up to the target sum.\"\"\"\n    memo = {}\n\n    def dp(i, curr_sum):\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n\n        if (i, curr_sum) not in memo:\n            memo[(i, curr_sum)] = dp(i + 1, curr_sum) or dp(i + 1, curr_sum + nums[i])\n\n        return memo[(i, curr_sum)]\n\n    return dp(0, 0)", "solution_func": "def g():\n    nums = [2, 4, 6, 8, 10]  # Example list of numbers\n    target = 16  # Example target sum\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 3.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 3.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node\n    to the end node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There exists a path from the start node 0 to the end node 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr_node, end, visited):\n    if curr_node == end:\n        return True\n\n    visited[curr_node] = True\n\n    for i in range(len(graph[curr_node])):\n        if graph[curr_node][i] == 1 and not visited[i]:\n            if dfs(graph, i, end, visited):\n                return True\n\n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\nassert f(g(), 0, 3) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 433, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, determine if there exists a path from the start node\n    to the end node.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n    start = 0\n    end = 3\n\n    There exists a path from the start node 0 to the end node 3.\n\n    Therefore, the function should return True.\n    \"\"\"\n    visited = [False] * len(graph)\n    return dfs(graph, start, end, visited)\n\ndef dfs(graph, curr_node, end, visited):\n    if curr_node == end:\n        return True\n\n    visited[curr_node] = True\n\n    for i in range(len(graph[curr_node])):\n        if graph[curr_node][i] == 1 and not visited[i]:\n            if dfs(graph, i, end, visited):\n                return True\n\n    return False", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, determine the maximum path sum from the top-left cell\n    to the bottom-right cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum path sum from the top-left cell to the bottom-right cell is 21.\n\n    Therefore, the function should return 21.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 21\n\n", "emb": null, "idx_generation": 433, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid represented as a list of lists of integers, determine the maximum path sum from the top-left cell\n    to the bottom-right cell. You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The maximum path sum from the top-left cell to the bottom-right cell is 21.\n\n    Therefore, the function should return 21.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers arr and a target integer, find the maximum number of operations needed to transform arr into a list where each element is equal to the target by performing bitwise OR operation on a subset of the list.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr: int) -> int:\n        if curr == target:\n            return 0\n        if index == len(arr):\n            return float('-inf')\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(arr, target, index + 1, curr | arr[index]) + 1\n\n        return max(exclude, include)\n\n    res = helper(arr, target, 0, 0)\n\n    if res == float('-inf'):\n        return -1\n    return res\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 6) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 433, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers arr and a target integer, find the maximum number of operations needed to transform arr into a list where each element is equal to the target by performing bitwise OR operation on a subset of the list.\n    \"\"\"\n    def helper(arr: List[int], target: int, index: int, curr: int) -> int:\n        if curr == target:\n            return 0\n        if index == len(arr):\n            return float('-inf')\n\n        # Exclude the current element\n        exclude = helper(arr, target, index + 1, curr)\n\n        # Include the current element\n        include = helper(arr, target, index + 1, curr | arr[index]) + 1\n\n        return max(exclude, include)\n\n    res = helper(arr, target, 0, 0)\n\n    if res == float('-inf'):\n        return -1\n    return res", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of positive integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is located at index 2 in the list.\n\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, low, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, high)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    Output:\n    2\n\n    Explanation:\n    The target value 5 is located at index 2 in the list.\n\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, low: int, high: int) -> int:\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, low, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, high)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of non-negative integers that have at most n digits.\n\n    Example:\n    n = 3\n\n    Output:\n    1000\n\n    Explanation:\n    The non-negative integers with at most 3 digits are 0, 1, 2, ..., 999, 1000.\n\n    \"\"\"\n\n    count = 0\n\n    for i in range(n + 1):\n        count += 10 ** i\n\n    return count\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 1000\n\n", "emb": null, "idx_generation": 434, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of non-negative integers that have at most n digits.\n\n    Example:\n    n = 3\n\n    Output:\n    1000\n\n    Explanation:\n    The non-negative integers with at most 3 digits are 0, 1, 2, ..., 999, 1000.\n\n    \"\"\"\n\n    count = 0\n\n    for i in range(n + 1):\n        count += 10 ** i\n\n    return count", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, determine whether there is a path from the start node to the end node.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    \"\"\"\n\n    def dfs(graph: List[List[int]], node: int, visited: List[bool], end: int) -> bool:\n        if node == end:\n            return True\n        \n        visited[node] = True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, visited, end):\n                    return True\n        \n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, start, visited, end)\n\ndef g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, determine whether there is a path from the start node to the end node.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from node 0 to node 3 in the graph.\n\n    \"\"\"\n\n    def dfs(graph: List[List[int]], node: int, visited: List[bool], end: int) -> bool:\n        if node == end:\n            return True\n        \n        visited[node] = True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                if dfs(graph, neighbor, visited, end):\n                    return True\n        \n        return False\n\n    visited = [False] * len(graph)\n    return dfs(graph, start, visited, end)", "solution_func": "def g() -> Tuple[List[List[int]], int, int]:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    An anagram is a word formed by rearranging the letters of another word. For example, \"listen\" and \"silent\" are anagrams.\n\n    Example:\n    Input:\n    words = [\"listen\", \"silent\", \"heart\", \"earth\", \"bread\"]\n\n    Output:\n    [\"listen\", \"silent\", \"heart\", \"earth\"]\n    \"\"\"\n\n    # Create a dictionary to store the sorted letters of each word and the corresponding list of anagrams\n    anagram_dict = {}\n\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagram_dict:\n            anagram_dict[sorted_word].append(word)\n        else:\n            anagram_dict[sorted_word] = [word]\n\n    # Filter out the words that have more than one anagram\n    result = [word for word_list in anagram_dict.values() if len(word_list) > 1 for word in word_list]\n\n    return result\n\ndef g():\n    words = [\"listen\", \"silent\", \"heart\", \"earth\", \"bread\"]\n    return [words]\n\nassert f(*g()) == [\"listen\", \"silent\", \"heart\", \"earth\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that are anagrams of each other.\n\n    An anagram is a word formed by rearranging the letters of another word. For example, \"listen\" and \"silent\" are anagrams.\n\n    Example:\n    Input:\n    words = [\"listen\", \"silent\", \"heart\", \"earth\", \"bread\"]\n\n    Output:\n    [\"listen\", \"silent\", \"heart\", \"earth\"]\n    \"\"\"\n\n    # Create a dictionary to store the sorted letters of each word and the corresponding list of anagrams\n    anagram_dict = {}\n\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagram_dict:\n            anagram_dict[sorted_word].append(word)\n        else:\n            anagram_dict[sorted_word] = [word]\n\n    # Filter out the words that have more than one anagram\n    result = [word for word_list in anagram_dict.values() if len(word_list) > 1 for word in word_list]\n\n    return result", "solution_func": "def g():\n    words = [\"listen\", \"silent\", \"heart\", \"earth\", \"bread\"]\n    return [words]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, check if the graph is a tree.\n\n    A tree is an undirected graph with no cycles and all vertices connected.\n\n    Example:\n    Input:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n\n    Output:\n    False\n    \"\"\"\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n\n    # Perform a depth-first search to check for cycles and connectivity\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in range(num_vertices):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] and neighbor != parent:\n                    return False\n                if not visited[neighbor] and not dfs(neighbor, node):\n                    return False\n\n        return True\n\n    # Check if the graph is connected and has no cycles\n    if not dfs(0, -1):\n        return False\n\n    # Check if all vertices are visited (connected graph)\n    if not all(visited):\n        return False\n\n    return True\n\ndef g():\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n    return [graph]\n\nassert f(*g()) == False\n", "emb": null, "idx_generation": 434, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representation of a graph, check if the graph is a tree.\n\n    A tree is an undirected graph with no cycles and all vertices connected.\n\n    Example:\n    Input:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n\n    Output:\n    False\n    \"\"\"\n\n    num_vertices = len(graph)\n    visited = [False] * num_vertices\n\n    # Perform a depth-first search to check for cycles and connectivity\n    def dfs(node, parent):\n        visited[node] = True\n\n        for neighbor in range(num_vertices):\n            if graph[node][neighbor] == 1:\n                if visited[neighbor] and neighbor != parent:\n                    return False\n                if not visited[neighbor] and not dfs(neighbor, node):\n                    return False\n\n        return True\n\n    # Check if the graph is connected and has no cycles\n    if not dfs(0, -1):\n        return False\n\n    # Check if all vertices are visited (connected graph)\n    if not all(visited):\n        return False\n\n    return True", "solution_func": "def g():\n    graph = [[0, 1, 1, 0],\n             [1, 0, 0, 1],\n             [1, 0, 0, 0],\n             [0, 1, 0, 0]]\n    return [graph]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    The Fibonacci sequence is defined as follows:\n    - The first two numbers in the sequence are 0 and 1.\n    - Each subsequent number is the sum of the two preceding ones.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    8\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib_sequence = [0, 1]\n\n    for i in range(2, n + 1):\n        fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n\n    return fib_sequence[n]\n\ndef g():\n    n = 6\n    return [n]\n\nassert f(*g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth number in the Fibonacci sequence.\n\n    The Fibonacci sequence is defined as follows:\n    - The first two numbers in the sequence are 0 and 1.\n    - Each subsequent number is the sum of the two preceding ones.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    8\n    \"\"\"\n\n    if n <= 0:\n        return 0\n\n    fib_sequence = [0, 1]\n\n    for i in range(2, n + 1):\n        fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n\n    return fib_sequence[n]", "solution_func": "def g():\n    n = 6\n    return [n]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11], target = 7\n    Output: 3\n\n    Explanation: The target value 7 is located at index 3 in the sorted list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        middle = (left + right) // 2\n        if nums[middle] == target:\n            return middle\n        elif nums[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11], target = 7\n    Output: 3\n\n    Explanation: The target value 7 is located at index 3 in the sorted list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        middle = (left + right) // 2\n        if nums[middle] == target:\n            return middle\n        elif nums[middle] < target:\n            left = middle + 1\n        else:\n            right = middle - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string s, shift each character in the string by n positions in the alphabet.\n    Wrap around from 'z' to 'a' and from 'Z' to 'A' if necessary.\n\n    Example:\n    Input: s = \"abcXYZ\", n = 2\n    Output: \"cdeZAB\"\n\n    Explanation: Shifting each character in the string \"abcXYZ\" by 2 positions gives \"cdeZAB\".\n    \"\"\"\n\n    shifted_string = \"\"\n\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                shift = (ord(char) - ord('a') + n) % 26\n                shifted_char = chr(ord('a') + shift)\n            else:\n                shift = (ord(char) - ord('A') + n) % 26\n                shifted_char = chr(ord('A') + shift)\n        else:\n            shifted_char = char\n\n        shifted_string += shifted_char\n\n    return shifted_string\n\ndef g():\n    s = \"abcXYZ\"\n    n = 2\n    return s, n\n\nassert f(*g()) == \"cdeZAB\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, n: int) -> str:\n    \"\"\"\n    Given a string s, shift each character in the string by n positions in the alphabet.\n    Wrap around from 'z' to 'a' and from 'Z' to 'A' if necessary.\n\n    Example:\n    Input: s = \"abcXYZ\", n = 2\n    Output: \"cdeZAB\"\n\n    Explanation: Shifting each character in the string \"abcXYZ\" by 2 positions gives \"cdeZAB\".\n    \"\"\"\n\n    shifted_string = \"\"\n\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                shift = (ord(char) - ord('a') + n) % 26\n                shifted_char = chr(ord('a') + shift)\n            else:\n                shift = (ord(char) - ord('A') + n) % 26\n                shifted_char = chr(ord('A') + shift)\n        else:\n            shifted_char = char\n\n        shifted_string += shifted_char\n\n    return shifted_string", "solution_func": "def g():\n    s = \"abcXYZ\"\n    n = 2\n    return s, n", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the sum of the ASCII values of all the characters in the string.\n\n    Example:\n    Input: s = \"hello\"\n    Output: 532\n\n    Explanation: The ASCII values of the characters 'h', 'e', 'l', 'l', and 'o' are 104, 101, 108, 108, and 111, respectively.\n    The sum of these ASCII values is 532.\n    \"\"\"\n\n    total_sum = 0\n\n    for char in s:\n        total_sum += ord(char)\n\n    return total_sum\n\ndef g():\n    s = \"hello\"\n    return s\n\nassert f(g()) == 532\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, calculate the sum of the ASCII values of all the characters in the string.\n\n    Example:\n    Input: s = \"hello\"\n    Output: 532\n\n    Explanation: The ASCII values of the characters 'h', 'e', 'l', 'l', and 'o' are 104, 101, 108, 108, and 111, respectively.\n    The sum of these ASCII values is 532.\n    \"\"\"\n\n    total_sum = 0\n\n    for char in s:\n        total_sum += ord(char)\n\n    return total_sum", "solution_func": "def g():\n    s = \"hello\"\n    return s", "map_ix": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of jumps required to reach the end of the list,\n    starting from the first element. Each element in the list represents the maximum number of steps\n    that can be jumped from that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n\n    The minimum number of jumps required is 2, which can be achieved by jumping from index 0 to index 1,\n    and then from index 1 to index 4.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n\n    return jumps[-1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 1, 1, 4]\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 434, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum number of jumps required to reach the end of the list,\n    starting from the first element. Each element in the list represents the maximum number of steps\n    that can be jumped from that position.\n\n    Example:\n    nums = [2, 3, 1, 1, 4]\n\n    The minimum number of jumps required is 2, which can be achieved by jumping from index 0 to index 1,\n    and then from index 1 to index 4.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n\n    return jumps[-1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 1, 1, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The maximum product is 20 (4 * 5).\n    Therefore, the function should return 20.\n    \"\"\"\n    n = len(nums)\n    max_product = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 20\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    The maximum product is 20 (4 * 5).\n    Therefore, the function should return 20.\n    \"\"\"\n    n = len(nums)\n    max_product = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    After rotating 90 degrees clockwise, the matrix becomes:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    Therefore, the function should return [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated_matrix = [[0] * n for _ in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n\n    return rotated_matrix\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate the matrix 90 degrees clockwise.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    After rotating 90 degrees clockwise, the matrix becomes:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    Therefore, the function should return [[7, 4, 1], [8, 5, 2], [9, 6, 3]].\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    rotated_matrix = [[0] * n for _ in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            rotated_matrix[j][n-i-1] = matrix[i][j]\n\n    return rotated_matrix", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The target value 5 is located at index 2.\n    Therefore, the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    The target value 5 is located at index 2.\n    Therefore, the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(x: float, n=100) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if x < 2:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True\ndef g(n = 100):\n    return n + 1\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(x: float, n=100) -> bool:\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if x < 2:\n        return False\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            return False\n    return True", "solution_func": "def g(n = 100):\n    return n + 1", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str, n=3) -> bool:\n    \"\"\"Check if two strings are anagrams.\"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for i in range(len(s)):\n        count_s[ord(s[i]) - ord('a')] += 1\n        count_t[ord(t[i]) - ord('a')] += 1\n    for i in range(26):\n        if count_s[i] != count_t[i]:\n            return False\n    return True\ndef g(n = 3):\n    return \"abc\" * n, \"cab\" * n\nassert f(*g())\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, t: str, n=3) -> bool:\n    \"\"\"Check if two strings are anagrams.\"\"\"\n    if len(s) != len(t):\n        return False\n    count_s = [0] * 26\n    count_t = [0] * 26\n    for i in range(len(s)):\n        count_s[ord(s[i]) - ord('a')] += 1\n        count_t[ord(t[i]) - ord('a')] += 1\n    for i in range(26):\n        if count_s[i] != count_t[i]:\n            return False\n    return True", "solution_func": "def g(n = 3):\n    return \"abc\" * n, \"cab\" * n", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(x: int, n=10) -> bool:\n    \"\"\"Check if a number is a palindrome.\"\"\"\n    if x < 0:\n        return False\n    reverse = 0\n    temp = x\n    while temp != 0:\n        reverse = reverse * 10 + temp % 10\n        temp = temp // 10\n    return x == reverse\ndef g(n = 10):\n    return int(str(n) + str(n)[::-1])\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 435, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(x: int, n=10) -> bool:\n    \"\"\"Check if a number is a palindrome.\"\"\"\n    if x < 0:\n        return False\n    reverse = 0\n    temp = x\n    while temp != 0:\n        reverse = reverse * 10 + temp % 10\n        temp = temp // 10\n    return x == reverse", "solution_func": "def g(n = 10):\n    return int(str(n) + str(n)[::-1])", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums\n\nassert f(g(), g()[1] + g()[-1]) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers that add up to a given target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return True\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=9):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string.\n    \"\"\"\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n\n    return count\n\ndef g(s='Hello, World!'):\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 435, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, count the number of vowels (a, e, i, o, u) in the string.\n    \"\"\"\n\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n\n    return count", "solution_func": "def g(s='Hello, World!'):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a number using recursion.\n    \"\"\"\n\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\ndef g() -> int:\n    \"\"\"\n    Generate a random integer.\n    \"\"\"\n\n    import random\n    return random.randint(1, 10)\n\nassert f(g()) == 362880\n", "emb": null, "idx_generation": 435, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a number using recursion.\n    \"\"\"\n\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a random integer.\n    \"\"\"\n\n    import random\n    return random.randint(1, 10)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    Input: matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g() -> List[List[int]]:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 435, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    Input: matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    return matrix", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n    Explanation: The maximum XOR value is achieved by combining the numbers 5 and 25, which gives 28 (10101 ^ 11001 = 01100).\n\n    Sample Input:\n    nums = [0, 1, 2, 3, 4, 5]\n\n    Sample Output:\n    7\n    Explanation: The maximum XOR value is achieved by combining the numbers 3 and 4, which gives 7 (0011 ^ 0100 = 0111).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if temp_max ^ prefix in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor\n\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 436, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Sample Input:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Sample Output:\n    28\n    Explanation: The maximum XOR value is achieved by combining the numbers 5 and 25, which gives 28 (10101 ^ 11001 = 01100).\n\n    Sample Input:\n    nums = [0, 1, 2, 3, 4, 5]\n\n    Sample Output:\n    7\n    Explanation: The maximum XOR value is achieved by combining the numbers 3 and 4, which gives 7 (0011 ^ 0100 = 0111).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if temp_max ^ prefix in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest arithmetic subsequence in the array.\n\n    Sample Input:\n    arr = [1, 7, 10, 13, 14, 19]\n\n    Sample Output:\n    4\n    Explanation: The longest arithmetic subsequence is [1, 7, 13, 19] with a common difference of 6.\n\n    Sample Input:\n    arr = [3, 6, 9, 12]\n\n    Sample Output:\n    4\n    Explanation: The longest arithmetic subsequence is [3, 6, 9, 12] with a common difference of 3.\n    \"\"\"\n\n    n = len(arr)\n    if n <= 2:\n        return n\n\n    dp = {}\n    longest = 2\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = arr[j] - arr[i]\n\n            if (i, diff) in dp:\n                dp[(j, diff)] = dp[(i, diff)] + 1\n            else:\n                dp[(j, diff)] = 2\n\n            longest = max(longest, dp[(j, diff)])\n\n    return longest\n\n\ndef g() -> List[int]:\n    return [1, 7, 10, 13, 14, 19]\n\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 436, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest arithmetic subsequence in the array.\n\n    Sample Input:\n    arr = [1, 7, 10, 13, 14, 19]\n\n    Sample Output:\n    4\n    Explanation: The longest arithmetic subsequence is [1, 7, 13, 19] with a common difference of 6.\n\n    Sample Input:\n    arr = [3, 6, 9, 12]\n\n    Sample Output:\n    4\n    Explanation: The longest arithmetic subsequence is [3, 6, 9, 12] with a common difference of 3.\n    \"\"\"\n\n    n = len(arr)\n    if n <= 2:\n        return n\n\n    dp = {}\n    longest = 2\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = arr[j] - arr[i]\n\n            if (i, diff) in dp:\n                dp[(j, diff)] = dp[(i, diff)] + 1\n            else:\n                dp[(j, diff)] = 2\n\n            longest = max(longest, dp[(j, diff)])\n\n    return longest", "solution_func": "def g() -> List[int]:\n    return [1, 7, 10, 13, 14, 19]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence in the array.\n\n    Sample Input:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101] with a length of 4.\n\n    Sample Input:\n    arr = [0, 1, 0, 3, 2, 3]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3] with a length of 4.\n    \"\"\"\n\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 436, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence in the array.\n\n    Sample Input:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101] with a length of 4.\n\n    Sample Input:\n    arr = [0, 1, 0, 3, 2, 3]\n\n    Sample Output:\n    4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3] with a length of 4.\n    \"\"\"\n\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]], n=5) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to rearrange the numbers in each row and column\n    such that each row and column has unique numbers from 1 to n. Return True if it is possible, False otherwise.\n    \"\"\"\n    def is_valid(arr):\n        return len(set(arr)) == len(arr)\n\n    for i in range(n):\n        row = grid[i]\n        if not is_valid(row):\n            return False\n\n        column = [grid[j][i] for j in range(n)]\n        if not is_valid(column):\n            return False\n\n    return True\n\ndef g(n=5):\n    \"\"\"\n    Generate a grid of size n x n where each row and column contains unique numbers from 1 to n.\n    \"\"\"\n    grid = [[(i * n + j + 1) % n + 1 for j in range(n)] for i in range(n)]\n    return grid\n\nassert f(g())\n", "emb": null, "idx_generation": 436, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]], n=5) -> bool:\n    \"\"\"\n    Given a grid of size n x n, determine if it is possible to rearrange the numbers in each row and column\n    such that each row and column has unique numbers from 1 to n. Return True if it is possible, False otherwise.\n    \"\"\"\n    def is_valid(arr):\n        return len(set(arr)) == len(arr)\n\n    for i in range(n):\n        row = grid[i]\n        if not is_valid(row):\n            return False\n\n        column = [grid[j][i] for j in range(n)]\n        if not is_valid(column):\n            return False\n\n    return True", "solution_func": "def g(n=5):\n    \"\"\"\n    Generate a grid of size n x n where each row and column contains unique numbers from 1 to n.\n    \"\"\"\n    grid = [[(i * n + j + 1) % n + 1 for j in range(n)] for i in range(n)]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, target='abc', count=4) -> bool:\n    \"\"\"\n    Given a string s, determine if it is possible to rearrange the letters in s to form the target string,\n    such that the target string appears count number of times consecutively. Return True if it is possible,\n    False otherwise.\n    \"\"\"\n    def is_valid(s, target, count):\n        return s.count(target) == count\n\n    return is_valid(s, target, count)\n\ndef g(target='abc', count=4):\n    \"\"\"\n    Generate a string by repeating the target string count number of times.\n    \"\"\"\n    return target * count\n\nassert f(g())\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 436, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, target='abc', count=4) -> bool:\n    \"\"\"\n    Given a string s, determine if it is possible to rearrange the letters in s to form the target string,\n    such that the target string appears count number of times consecutively. Return True if it is possible,\n    False otherwise.\n    \"\"\"\n    def is_valid(s, target, count):\n        return s.count(target) == count\n\n    return is_valid(s, target, count)", "solution_func": "def g(target='abc', count=4):\n    \"\"\"\n    Generate a string by repeating the target string count number of times.\n    \"\"\"\n    return target * count", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(grid: List[List[int]], n=4, target_sum=10) -> bool:\n    \"\"\"\n    Given a grid of size n x n containing positive integers, determine if it is possible to select a path from the\n    top-left corner to the bottom-right corner such that the sum of the numbers along the path is equal to\n    the target_sum. Return True if such a path exists, False otherwise.\n    \"\"\"\n    def dfs(i, j, curr_sum):\n        if i >= n or j >= n:\n            return False\n        if curr_sum + grid[i][j] == target_sum:\n            return True\n        if curr_sum + grid[i][j] > target_sum:\n            return False\n        return dfs(i + 1, j, curr_sum + grid[i][j]) or dfs(i, j + 1, curr_sum + grid[i][j])\n\n    return dfs(0, 0, 0)\n\ndef g(n=4, target_sum=10):\n    \"\"\"\n    Generate a grid of size n x n with random positive integers.\n    \"\"\"\n    import random\n    grid = [[random.randint(1, 9) for _ in range(n)] for _ in range(n)]\n    return grid\n\nassert f(g())\n", "emb": null, "idx_generation": 436, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\ndef f(grid: List[List[int]], n=4, target_sum=10) -> bool:\n    \"\"\"\n    Given a grid of size n x n containing positive integers, determine if it is possible to select a path from the\n    top-left corner to the bottom-right corner such that the sum of the numbers along the path is equal to\n    the target_sum. Return True if such a path exists, False otherwise.\n    \"\"\"\n    def dfs(i, j, curr_sum):\n        if i >= n or j >= n:\n            return False\n        if curr_sum + grid[i][j] == target_sum:\n            return True\n        if curr_sum + grid[i][j] > target_sum:\n            return False\n        return dfs(i + 1, j, curr_sum + grid[i][j]) or dfs(i, j + 1, curr_sum + grid[i][j])\n\n    return dfs(0, 0, 0)", "solution_func": "def g(n=4, target_sum=10):\n    \"\"\"\n    Generate a grid of size n x n with random positive integers.\n    \"\"\"\n    import random\n    grid = [[random.randint(1, 9) for _ in range(n)] for _ in range(n)]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there exists a path from the start node to the end node in the given directed graph.\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    return dfs(start)\n\ndef g(graph = {0: [1, 2], 1: [2, 3], 2: [3, 4], 3: [4], 4: []}, start = 0, end = 4):\n    return graph\n\nassert f(g())\n", "emb": null, "idx_generation": 436, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(graph: Dict[int, List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Determine if there exists a path from the start node to the end node in the given directed graph.\n    \"\"\"\n    visited = set()\n    \n    def dfs(node):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n        return False\n    \n    return dfs(start)", "solution_func": "def g(graph = {0: [1, 2], 1: [2, 3], 2: [3, 4], 3: [4], 4: []}, start = 0, end = 4):\n    return graph", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return sum(fib)\n\ndef g(n = 5):\n    return n\n\nassert f(g())\n", "emb": null, "idx_generation": 436, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the sum of the first n Fibonacci numbers.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    return sum(fib)", "solution_func": "def g(n = 5):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the minimum number of jumps required to reach the last index of the list, given that each element represents the maximum number of steps that can be jumped from that position.\n    \"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n    return jumps[-1]\n\ndef g(nums = [2, 3, 1, 1, 4], target = 4):\n    return nums, target\n\nassert f(*g())\n", "emb": null, "idx_generation": 436, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Find the minimum number of jumps required to reach the last index of the list, given that each element represents the maximum number of steps that can be jumped from that position.\n    \"\"\"\n    if not nums:\n        return 0\n    n = len(nums)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n    return jumps[-1]", "solution_func": "def g(nums = [2, 3, 1, 1, 4], target = 4):\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target string, determine if it is possible to construct the target string by concatenating\n    the words in the list. Each word from the list can be used only once.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cat\"]\n    target = \"applecatbanana\"\n    The target string can be constructed by concatenating the words in the list, so the function should return True.\n    \"\"\"\n    visited = set()\n\n    def dfs(curr):\n        if curr == target:\n            return True\n        if curr in visited:\n            return False\n        visited.add(curr)\n        for word in words:\n            if curr.startswith(word):\n                if dfs(curr[len(word):]):\n                    return True\n        return False\n\n    return dfs(\"\")\n\ndef g(words=[\"apple\", \"banana\", \"cat\"], target=\"applecatbanana\"):\n    \"\"\"\n    Generate a list of words by splitting the target string into substrings that are present in the words list.\n    \"\"\"\n    res = []\n    i = 0\n    while i < len(target):\n        for word in words:\n            if target[i:].startswith(word):\n                res.append(word)\n                i += len(word)\n                break\n    return res\n\nassert f(g(), target=\"applecatbanana\")\n", "emb": null, "idx_generation": 436, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target string, determine if it is possible to construct the target string by concatenating\n    the words in the list. Each word from the list can be used only once.\n\n    Example:\n    words = [\"apple\", \"banana\", \"cat\"]\n    target = \"applecatbanana\"\n    The target string can be constructed by concatenating the words in the list, so the function should return True.\n    \"\"\"\n    visited = set()\n\n    def dfs(curr):\n        if curr == target:\n            return True\n        if curr in visited:\n            return False\n        visited.add(curr)\n        for word in words:\n            if curr.startswith(word):\n                if dfs(curr[len(word):]):\n                    return True\n        return False\n\n    return dfs(\"\")", "solution_func": "def g(words=[\"apple\", \"banana\", \"cat\"], target=\"applecatbanana\"):\n    \"\"\"\n    Generate a list of words by splitting the target string into substrings that are present in the words list.\n    \"\"\"\n    res = []\n    i = 0\n    while i < len(target):\n        for word in words:\n            if target[i:].startswith(word):\n                res.append(word)\n                i += len(word)\n                break\n    return res", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers in the list is 60 (4 * 5 * 3).\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 437, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of any three numbers in the list is 60 (4 * 5 * 3).\n\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list that contains the strings sorted by their lengths in ascending order.\n    If two strings have the same length, they should be sorted in lexicographic order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n\n    The sorted list should be [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"].\n\n    Therefore, the function should return [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"].\n    \"\"\"\n    words.sort(key=lambda x: (len(x), x))\n    return words\n\ndef g() -> List[str]:\n    words = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n    return words\n\nassert f(g()) == [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 437, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list that contains the strings sorted by their lengths in ascending order.\n    If two strings have the same length, they should be sorted in lexicographic order.\n\n    Example:\n    words = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n\n    The sorted list should be [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"].\n\n    Therefore, the function should return [\"cat\", \"dog\", \"apple\", \"banana\", \"elephant\"].\n    \"\"\"\n    words.sort(key=lambda x: (len(x), x))\n    return words", "solution_func": "def g() -> List[str]:\n    words = [\"banana\", \"apple\", \"cat\", \"dog\", \"elephant\"]\n    return words", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix represented as a list of lists, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements of the matrix in spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    spiral = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            spiral.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral.append(matrix[i][left])\n            left += 1\n\n    return spiral\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 437, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix represented as a list of lists, return the elements of the matrix in spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements of the matrix in spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    spiral = []\n\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            spiral.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            spiral.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral.append(matrix[i][left])\n            left += 1\n\n    return spiral", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 437, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n    \"\"\"\n\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 7\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there is a subset of the list that sums up to the target value.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 437, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if there is a subset of the list that sums up to the target value.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if nums[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]", "solution_func": "def g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], dfs(x, y))\n\n        dp[i][j] += 1\n        return dp[i][j]\n\n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length\n\ndef g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 437, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(i, j):\n        if dp[i][j] != 0:\n            return dp[i][j]\n\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], dfs(x, y))\n\n        dp[i][j] += 1\n        return dp[i][j]\n\n    max_length = 0\n    for i in range(m):\n        for j in range(n):\n            max_length = max(max_length, dfs(i, j))\n\n    return max_length", "solution_func": "def g():\n    matrix = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a positive integer n and a list of integers nums, return all possible combinations of length n, \n    where each combination is formed by selecting elements from nums without repetition.\n    \"\"\"\n    def backtrack(nums, path, res, n):\n        if n == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res, n-1)\n    \n    res = []\n    backtrack(nums, [], res, n)\n    return res\n\ndef g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a positive integer n and a list of positive integers nums.\n    \"\"\"\n    return 3, [1, 2, 3, 4]\n\nassert f(*g()) == [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n", "emb": null, "idx_generation": 437, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a positive integer n and a list of integers nums, return all possible combinations of length n, \n    where each combination is formed by selecting elements from nums without repetition.\n    \"\"\"\n    def backtrack(nums, path, res, n):\n        if n == 0:\n            res.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res, n-1)\n    \n    res = []\n    backtrack(nums, [], res, n)\n    return res", "solution_func": "def g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a positive integer n and a list of positive integers nums.\n    \"\"\"\n    return 3, [1, 2, 3, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 4.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 437, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum XOR value that can be obtained by selecting one cell from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    The maximum XOR value that can be obtained is 15 by selecting 2 from the first row, 5 from the second row, and 8 from the third row.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    max_xor = 0\n    for row in grid:\n        for col in range(len(row)):\n            for i in range(len(row)):\n                max_xor = max(max_xor, row[col] ^ row[i])\n    return max_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 4.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a positive integer n and a list of integers nums, return the number of combinations of length n, \n    where each combination is formed by selecting elements from nums without repetition, and the XOR value \n    of the combination is divisible by n.\n    \"\"\"\n    def backtrack(nums, path, res, n):\n        if n == 0:\n            xor_val = 0\n            for num in path:\n                xor_val ^= num\n            if xor_val % n == 0:\n                res.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res, n-1)\n    \n    res = []\n    backtrack(nums, [], res, n)\n    return len(res)\n\ndef g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a positive integer n and a list of positive integers nums.\n    \"\"\"\n    return 3, [1, 2, 3, 4, 5, 6, 7]\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 437, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Given a positive integer n and a list of integers nums, return the number of combinations of length n, \n    where each combination is formed by selecting elements from nums without repetition, and the XOR value \n    of the combination is divisible by n.\n    \"\"\"\n    def backtrack(nums, path, res, n):\n        if n == 0:\n            xor_val = 0\n            for num in path:\n                xor_val ^= num\n            if xor_val % n == 0:\n                res.append(path)\n            return\n        for i in range(len(nums)):\n            backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res, n-1)\n    \n    res = []\n    backtrack(nums, [], res, n)\n    return len(res)", "solution_func": "def g() -> Tuple[int, List[int]]:\n    \"\"\"\n    Generate a positive integer n and a list of positive integers nums.\n    \"\"\"\n    return 3, [1, 2, 3, 4, 5, 6, 7]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', determine if there exists a path in the graph formed by the numbers such that the sum of the path is equal to the target.\n    Each number in the list can be used multiple times to form a path.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Path: 1 -> 1 -> 1 -> 1\n    The sum of the path is equal to the target, so the function should return True.\n    \"\"\"\n    def dfs(current_sum: int, index: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums) or current_sum > target:\n            return False\n        for i in range(index, len(nums)):\n            if dfs(current_sum + nums[i], i):\n                return True\n        return False\n\n    return dfs(0, 0)\n\ndef g(nums=[1, 2, 3], target=4):\n    \"\"\"\n    Generate a list of integers 'nums' and a target integer 'target' such that there exists a path in the graph formed by the numbers such that the sum of the path is equal to the target.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 437, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers 'nums' and a target integer 'target', determine if there exists a path in the graph formed by the numbers such that the sum of the path is equal to the target.\n    Each number in the list can be used multiple times to form a path.\n\n    Example:\n    nums = [1, 2, 3]\n    target = 4\n    Path: 1 -> 1 -> 1 -> 1\n    The sum of the path is equal to the target, so the function should return True.\n    \"\"\"\n    def dfs(current_sum: int, index: int) -> bool:\n        if current_sum == target:\n            return True\n        if index >= len(nums) or current_sum > target:\n            return False\n        for i in range(index, len(nums)):\n            if dfs(current_sum + nums[i], i):\n                return True\n        return False\n\n    return dfs(0, 0)", "solution_func": "def g(nums=[1, 2, 3], target=4):\n    \"\"\"\n    Generate a list of integers 'nums' and a target integer 'target' such that there exists a path in the graph formed by the numbers such that the sum of the path is equal to the target.\n    \"\"\"\n    return nums, target", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return a list of all possible combinations of k numbers out of the range [1, n].\n\n    The combinations should be sorted in lexicographic order.\n\n    Example:\n    Input:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(start, combination):\n        # Base case: if the combination has k elements, add it to the result\n        if len(combination) == k:\n            result.append(combination[:])\n            return\n\n        # Try all possible numbers starting from 'start'\n        for i in range(start, n + 1):\n            combination.append(i)\n            # Recursively backtrack with the next number\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0], "idx_generation": 438, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return a list of all possible combinations of k numbers out of the range [1, n].\n\n    The combinations should be sorted in lexicographic order.\n\n    Example:\n    Input:\n    n = 4\n    k = 2\n\n    Output:\n    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n    \"\"\"\n    def backtrack(start, combination):\n        # Base case: if the combination has k elements, add it to the result\n        if len(combination) == k:\n            result.append(combination[:])\n            return\n\n        # Try all possible numbers starting from 'start'\n        for i in range(start, n + 1):\n            combination.append(i)\n            # Recursively backtrack with the next number\n            backtrack(i + 1, combination)\n            combination.pop()\n\n    result = []\n    backtrack(1, [])\n    return result", "solution_func": "def g():\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 1, 0, 0, 0, 1, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers nums and a target integer target, return a list of all unique combinations of nums where the chosen numbers sum to target.\n\n    The combinations should be sorted in lexicographic order and each combination should not contain duplicate numbers.\n\n    Example:\n    Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n    \"\"\"\n    def backtrack(start, combination, current_sum):\n        # Base case: if the current sum is equal to the target, add the combination to the result\n        if current_sum == target:\n            result.append(combination[:])\n            return\n\n        # Try all possible numbers starting from 'start'\n        for i in range(start, len(nums)):\n            # If the current number exceeds the target, skip it\n            if current_sum + nums[i] > target:\n                break\n\n            combination.append(nums[i])\n            # Recursively backtrack with the next number and updated current sum\n            backtrack(i, combination, current_sum + nums[i])\n            combination.pop()\n\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 438, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of distinct integers nums and a target integer target, return a list of all unique combinations of nums where the chosen numbers sum to target.\n\n    The combinations should be sorted in lexicographic order and each combination should not contain duplicate numbers.\n\n    Example:\n    Input:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    Output:\n    [[2, 2, 3], [7]]\n    \"\"\"\n    def backtrack(start, combination, current_sum):\n        # Base case: if the current sum is equal to the target, add the combination to the result\n        if current_sum == target:\n            result.append(combination[:])\n            return\n\n        # Try all possible numbers starting from 'start'\n        for i in range(start, len(nums)):\n            # If the current number exceeds the target, skip it\n            if current_sum + nums[i] > target:\n                break\n\n            combination.append(nums[i])\n            # Recursively backtrack with the next number and updated current sum\n            backtrack(i, combination, current_sum + nums[i])\n            combination.pop()\n\n    result = []\n    backtrack(0, [], 0)\n    return result", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse the top row from left to right\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        # Traverse the right column from top to bottom\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse the bottom row from right to left\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse the left column from bottom to top\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(*g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": null, "idx_generation": 438, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    \"\"\"\n    result = []\n    if not matrix:\n        return result\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse the top row from left to right\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        # Traverse the right column from top to bottom\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse the bottom row from right to left\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse the left column from bottom to top\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n\n    Output:\n    3\n    Explanation:\n    Inversions: (2, 1), (4, 1), (4, 3)\n    \"\"\"\n    count = 0\n    \n    def merge_sort(nums):\n        nonlocal count\n        if len(nums) <= 1:\n            return nums\n        \n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        \n        i = j = 0\n        merged = []\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                count += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged\n    \n    merge_sort(nums)\n    \n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 1, 3, 5]\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 438, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, count the number of inversions in the list.\n    An inversion occurs when two elements in the list are out of order.\n\n    Example:\n    nums = [2, 4, 1, 3, 5]\n\n    Output:\n    3\n    Explanation:\n    Inversions: (2, 1), (4, 1), (4, 3)\n    \"\"\"\n    count = 0\n    \n    def merge_sort(nums):\n        nonlocal count\n        if len(nums) <= 1:\n            return nums\n        \n        mid = len(nums) // 2\n        left = merge_sort(nums[:mid])\n        right = merge_sort(nums[mid:])\n        \n        i = j = 0\n        merged = []\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                count += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged\n    \n    merge_sort(nums)\n    \n    return count", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 1, 3, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order using the quicksort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 1, 9, 4]\n\n    Output:\n    [9, 5, 4, 2, 1]\n    \"\"\"\n    def partition(nums, low, high):\n        pivot = nums[high]\n        i = low - 1\n        for j in range(low, high):\n            if nums[j] >= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1], nums[high] = nums[high], nums[i+1]\n        return i + 1\n    \n    def quicksort(nums, low, high):\n        if low < high:\n            pi = partition(nums, low, high)\n            quicksort(nums, low, pi - 1)\n            quicksort(nums, pi + 1, high)\n    \n    quicksort(nums, 0, len(nums) - 1)\n    \n    return nums\n\ndef g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 1, 9, 4]\n\nassert f(g()) == [9, 5, 4, 2, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 438, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in descending order using the quicksort algorithm.\n    Return the sorted list.\n\n    Example:\n    nums = [5, 2, 1, 9, 4]\n\n    Output:\n    [9, 5, 4, 2, 1]\n    \"\"\"\n    def partition(nums, low, high):\n        pivot = nums[high]\n        i = low - 1\n        for j in range(low, high):\n            if nums[j] >= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        nums[i+1], nums[high] = nums[high], nums[i+1]\n        return i + 1\n    \n    def quicksort(nums, low, high):\n        if low < high:\n            pi = partition(nums, low, high)\n            quicksort(nums, low, pi - 1)\n            quicksort(nums, pi + 1, high)\n    \n    quicksort(nums, 0, len(nums) - 1)\n    \n    return nums", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 1, 9, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of pairs of integers in the list\n    that add up to the target value.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 10\n\n    Output:\n    2\n    Explanation:\n    Pairs: (2, 8), (4, 6)\n    \"\"\"\n    count = 0\n    num_map = {}\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_map:\n            count += num_map[complement]\n        num_map[num] = num_map.get(num, 0) + 1\n    \n    return count\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 438, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of pairs of integers in the list\n    that add up to the target value.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 10\n\n    Output:\n    2\n    Explanation:\n    Pairs: (2, 8), (4, 6)\n    \"\"\"\n    count = 0\n    num_map = {}\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_map:\n            count += num_map[complement]\n        num_map[num] = num_map.get(num, 0) + 1\n    \n    return count", "solution_func": "def g():\n    nums = [2, 4, 6, 8, 10]\n    target = 10\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a permutation of the first n positive integers\n    such that the bitwise XOR of any k consecutive elements is equal to zero.\n    \"\"\"\n    return n % (k + 1) == 0\n\ndef g(n: int, k: int):\n    \"\"\"\n    Generate a permutation of the first n positive integers such that the bitwise XOR of any k consecutive elements is zero.\n    \"\"\"\n    if n % (k + 1) != 0:\n        return None\n    \n    arr = list(range(1, n + 1))\n    for i in range(0, n, k + 1):\n        for j in range(k):\n            arr[i + j] = arr[i]\n    \n    return arr\n\nassert f(*g())\n", "emb": null, "idx_generation": 438, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers n and k, determine if there exists a permutation of the first n positive integers\n    such that the bitwise XOR of any k consecutive elements is equal to zero.\n    \"\"\"\n    return n % (k + 1) == 0", "solution_func": "def g(n: int, k: int):\n    \"\"\"\n    Generate a permutation of the first n positive integers such that the bitwise XOR of any k consecutive elements is zero.\n    \"\"\"\n    if n % (k + 1) != 0:\n        return None\n    \n    arr = list(range(1, n + 1))\n    for i in range(0, n, k + 1):\n        for j in range(k):\n            arr[i + j] = arr[i]\n    \n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine the number of unique binary strings of length n that do not contain consecutive ones.\n    \"\"\"\n    if n <= 0:\n        return False\n    elif n == 1:\n        return True\n    \n    fib = [1, 2]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n-1]\n\ndef g(n: int):\n    \"\"\"\n    Generate a unique binary string of length n that does not contain consecutive ones.\n    \"\"\"\n    if n <= 0:\n        return None\n    elif n == 1:\n        return '0'\n    \n    fib = ['0', '01']\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n-1]\n\nassert f(len(g()))\n", "emb": null, "idx_generation": 438, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, determine the number of unique binary strings of length n that do not contain consecutive ones.\n    \"\"\"\n    if n <= 0:\n        return False\n    elif n == 1:\n        return True\n    \n    fib = [1, 2]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n-1]", "solution_func": "def g(n: int):\n    \"\"\"\n    Generate a unique binary string of length n that does not contain consecutive ones.\n    \"\"\"\n    if n <= 0:\n        return None\n    elif n == 1:\n        return '0'\n    \n    fib = ['0', '01']\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    \n    return fib[n-1]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x m grid, where each path can only move right or down.\n    \"\"\"\n    if n <= 0 or m <= 0:\n        return False\n    \n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]\n\ndef g(n: int, m: int):\n    \"\"\"\n    Generate a unique path from the top-left corner to the bottom-right corner of an n x m grid,\n    where each path can only move right or down.\n    \"\"\"\n    if n <= 0 or m <= 0:\n        return None\n    \n    path = ''\n    for _ in range(n - 1):\n        path += 'D'\n    for _ in range(m - 1):\n        path += 'R'\n    \n    return path\n\nassert f(len(g()), len(g()[0]))\n", "emb": null, "idx_generation": 438, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Given two integers n and m, determine the number of unique paths from the top-left corner to the bottom-right corner\n    of an n x m grid, where each path can only move right or down.\n    \"\"\"\n    if n <= 0 or m <= 0:\n        return False\n    \n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n    for j in range(m):\n        dp[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[n-1][m-1]", "solution_func": "def g(n: int, m: int):\n    \"\"\"\n    Generate a unique path from the top-left corner to the bottom-right corner of an n x m grid,\n    where each path can only move right or down.\n    \"\"\"\n    if n <= 0 or m <= 0:\n        return None\n    \n    path = ''\n    for _ in range(n - 1):\n        path += 'D'\n    for _ in range(m - 1):\n        path += 'R'\n    \n    return path", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, find the maximum product of any three numbers in the array.\n    Return True if the maximum product is greater than or equal to 100, otherwise False.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    return arr[n-1] * arr[n-2] * arr[n-3] >= 100\n\ndef g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == False\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 438, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, find the maximum product of any three numbers in the array.\n    Return True if the maximum product is greater than or equal to 100, otherwise False.\n    \"\"\"\n    arr.sort()\n    n = len(arr)\n    return arr[n-1] * arr[n-2] * arr[n-3] >= 100", "solution_func": "def g() -> List[int]:\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n    \n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    \n    Explanation:\n    The product of all the numbers except 1 is 2 * 3 * 4 = 24.\n    The product of all the numbers except 2 is 1 * 3 * 4 = 12.\n    The product of all the numbers except 3 is 1 * 2 * 4 = 8.\n    The product of all the numbers except 4 is 1 * 2 * 3 = 6.\n    \"\"\"\n    n = len(nums)\n    left = [1] * n\n    right = [1] * n\n    result = [1] * n\n    \n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n    \n    for i in range(n):\n        result[i] = left[i] * right[i]\n    \n    return result\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 439, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers in the original list except the one at that index.\n    \n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    \n    Explanation:\n    The product of all the numbers except 1 is 2 * 3 * 4 = 24.\n    The product of all the numbers except 2 is 1 * 3 * 4 = 12.\n    The product of all the numbers except 3 is 1 * 2 * 4 = 8.\n    The product of all the numbers except 4 is 1 * 2 * 3 = 6.\n    \"\"\"\n    n = len(nums)\n    left = [1] * n\n    right = [1] * n\n    result = [1] * n\n    \n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n    \n    for i in range(n):\n        result[i] = left[i] * right[i]\n    \n    return result", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n    \n    Example:\n    Input: [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    Output: 10\n    \n    Explanation:\n    The subarray with the maximum sum is [3, 4, -1, 2, 1], which has a sum of 10.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 10\n\n", "emb": null, "idx_generation": 439, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray within the list.\n    \n    Example:\n    Input: [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    Output: 10\n    \n    Explanation:\n    The subarray with the maximum sum is [3, 4, -1, 2, 1], which has a sum of 10.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, 4, -1, 2, 1, -5, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the list.\n    \n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    \n    Explanation:\n    The sum of 2 and 7 is 9, which is the target. Therefore, the indices of 2 and 7 in the list are [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 439, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers, find two numbers such that they add up to a specific target.\n    Return the indices of the two numbers in the list.\n    \n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    \n    Explanation:\n    The sum of 2 and 7 is 9, which is the target. Therefore, the indices of 2 and 7 in the list are [0, 1].\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    return [2, 7, 11, 15], 9", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    The list is sorted in non-decreasing order, so return True.\n\n    arr = [5, 4, 3, 2, 1]\n    The list is not sorted in non-decreasing order, so return False.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 439, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the list is sorted in non-decreasing order.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    The list is sorted in non-decreasing order, so return True.\n\n    arr = [5, 4, 3, 2, 1]\n    The list is not sorted in non-decreasing order, so return False.\n    \"\"\"\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return False\n    return True", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Example:\n    n = 5\n    The factorial of 5 is 5! = 5 x 4 x 3 x 2 x 1 = 120.\n    Return 120.\n    \"\"\"\n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n    return factorial\n\ndef g() -> int:\n    return 5\n\nassert f(g()) == 120\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 439, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the factorial of n.\n\n    Example:\n    n = 5\n    The factorial of 5 is 5! = 5 x 4 x 3 x 2 x 1 = 120.\n    Return 120.\n    \"\"\"\n    factorial = 1\n    for i in range(2, n+1):\n        factorial *= i\n    return factorial", "solution_func": "def g() -> int:\n    return 5", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    The maximum XOR value between any two numbers in the list is 27 (3 XOR 25).\n    Return 27.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor_value = arr[i] ^ arr[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 27\n", "emb": null, "idx_generation": 439, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    arr = [3, 10, 5, 25, 2, 8]\n    The maximum XOR value between any two numbers in the list is 27 (3 XOR 25).\n    Return 27.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor_value = arr[i] ^ arr[j]\n            if xor_value > max_xor:\n                max_xor = xor_value\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in nums that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    f(nums, target) => [0, 1]\n    Explanation: The numbers at indices 0 and 1, which are 2 and 7 respectively, add up to 9.\n\n    \"\"\"\n\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n\n    return []\n\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 439, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in nums that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    f(nums, target) => [0, 1]\n    Explanation: The numbers at indices 0 and 1, which are 2 and 7 respectively, add up to 9.\n\n    \"\"\"\n\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a 2D matrix, rotate the matrix clockwise by 90 degrees.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(matrix) => [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix\n\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n]\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 439, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a 2D matrix, rotate the matrix clockwise by 90 degrees.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(matrix) => [\n        [7, 4, 1],\n        [8, 5, 2],\n        [9, 6, 3]\n    ]\n\n    \"\"\"\n\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n    return matrix", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    f(nums) => 4\n    Explanation: The longest increasing subsequence in the list is [2, 3, 7, 101], which has a length of 4.\n\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 439, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence in the list.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    f(nums) => 4\n    Explanation: The longest increasing subsequence in the list is [2, 3, 7, 101], which has a length of 4.\n\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list\n    that sum up to the target.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n\n    Note: The solution set must not contain duplicate combinations.\n\n    Hint: This problem can be solved using backtracking and recursion.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], remaining: int) -> None:\n        if remaining == 0:\n            result.append(path[:])\n            return\n        if remaining < 0:\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i, path, remaining - nums[i])\n            path.pop()\n\n    result = []\n    nums.sort()\n    backtrack(0, [], target)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 439, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all unique combinations of numbers in the list\n    that sum up to the target.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n\n    Note: The solution set must not contain duplicate combinations.\n\n    Hint: This problem can be solved using backtracking and recursion.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], remaining: int) -> None:\n        if remaining == 0:\n            result.append(path[:])\n            return\n        if remaining < 0:\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i, path, remaining - nums[i])\n            path.pop()\n\n    result = []\n    nums.sort()\n    backtrack(0, [], target)\n    return result", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle of size n.\n\n    Example:\n    Input: n = 5\n    Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n\n    Explanation:\n    Pascal's triangle is a triangular array of binomial coefficients. Each number in the triangle is the sum of the two numbers directly above it.\n    \"\"\"\n\n    triangle = [[1] * (i + 1) for i in range(n)]\n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n    return triangle\n\ndef g():\n    n = 5\n    return n\n\nassert f(g()) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 440, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[int]]:\n    \"\"\"\n    Given an integer n, generate a Pascal's triangle of size n.\n\n    Example:\n    Input: n = 5\n    Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n\n    Explanation:\n    Pascal's triangle is a triangular array of binomial coefficients. Each number in the triangle is the sum of the two numbers directly above it.\n    \"\"\"\n\n    triangle = [[1] * (i + 1) for i in range(n)]\n    for i in range(2, n):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n    return triangle", "solution_func": "def g():\n    n = 5\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation:\n    The string \"Hello World\" is reversed word by word, resulting in \"olleH dlroW\".\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 440, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of characters in each word within the string while still preserving whitespace and initial word order.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation:\n    The string \"Hello World\" is reversed word by word, resulting in \"olleH dlroW\".\n    \"\"\"\n\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find two numbers such that they add up to the target and return their indices.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] = 2 and nums[1] = 7 is 9, so the indices [0, 1] are returned.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 440, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, find two numbers such that they add up to the target and return their indices.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] = 2 and nums[1] = 7 is 9, so the indices [0, 1] are returned.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 1, 1, 0, 1, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [0,1]\n    Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if target - num in complement:\n            return [complement[target - num], i]\n        complement[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 440, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    You can return the answer in any order.\n\n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [0,1]\n    Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n    \"\"\"\n    complement = {}\n    for i, num in enumerate(nums):\n        if target - num in complement:\n            return [complement[target - num], i]\n        complement[num] = i\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums, every element appears twice except for one. Find that single one.\n\n    Example:\n    Input: nums = [4,1,2,1,2]\n    Output: 4\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g() -> List[int]:\n    nums = [4, 1, 2, 1, 2]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 440, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an integer array nums, every element appears twice except for one. Find that single one.\n\n    Example:\n    Input: nums = [4,1,2,1,2]\n    Output: 4\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [4, 1, 2, 1, 2]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the path from top left to bottom right which minimizes the sum of all numbers along its path.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n    Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum of all numbers along its path.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 440, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the path from top left to bottom right which minimizes the sum of all numbers along its path.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n    Output: 7\n    Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum of all numbers along its path.\n    \"\"\"\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it can be rearranged into a palindrome.\n\n    Example:\n    Input: \"aab\"\n    Output: True\n\n    Explanation:\n    \"aab\" can be rearranged into \"aba\", which is a palindrome.\n    \"\"\"\n\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 == 1:\n            odd_count += 1\n\n    return odd_count <= 1\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that can be rearranged into a palindrome.\n    \"\"\"\n    return \"aab\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 440, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(string: str) -> bool:\n    \"\"\"\n    Given a string, determine if it can be rearranged into a palindrome.\n\n    Example:\n    Input: \"aab\"\n    Output: True\n\n    Explanation:\n    \"aab\" can be rearranged into \"aba\", which is a palindrome.\n    \"\"\"\n\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 == 1:\n            odd_count += 1\n\n    return odd_count <= 1", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string that can be rearranged into a palindrome.\n    \"\"\"\n    return \"aab\"", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list containing only the strings that can be rearranged into a palindrome.\n\n    Example:\n    Input: [\"aab\", \"abc\", \"cdc\", \"deed\"]\n    Output: [\"aab\", \"cdc\", \"deed\"]\n\n    Explanation:\n    \"aab\" can be rearranged into \"aba\", which is a palindrome.\n    \"abc\" cannot be rearranged into a palindrome.\n    \"cdc\" can be rearranged into \"cdc\", which is a palindrome.\n    \"deed\" can be rearranged into \"deed\", which is a palindrome.\n    Therefore, only \"aab\", \"cdc\", and \"deed\" are returned.\n    \"\"\"\n\n    def is_palindrome(string: str) -> bool:\n        return string == string[::-1]\n\n    palindromes = []\n    for string in strings:\n        if is_palindrome(string):\n            palindromes.append(string)\n\n    return palindromes\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of strings where some strings can be rearranged into a palindrome.\n    \"\"\"\n    return [\"aab\", \"abc\", \"cdc\", \"deed\"]\n\nassert f(g()) == [\"aab\", \"cdc\", \"deed\"]\n\n", "emb": null, "idx_generation": 440, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(strings: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list containing only the strings that can be rearranged into a palindrome.\n\n    Example:\n    Input: [\"aab\", \"abc\", \"cdc\", \"deed\"]\n    Output: [\"aab\", \"cdc\", \"deed\"]\n\n    Explanation:\n    \"aab\" can be rearranged into \"aba\", which is a palindrome.\n    \"abc\" cannot be rearranged into a palindrome.\n    \"cdc\" can be rearranged into \"cdc\", which is a palindrome.\n    \"deed\" can be rearranged into \"deed\", which is a palindrome.\n    Therefore, only \"aab\", \"cdc\", and \"deed\" are returned.\n    \"\"\"\n\n    def is_palindrome(string: str) -> bool:\n        return string == string[::-1]\n\n    palindromes = []\n    for string in strings:\n        if is_palindrome(string):\n            palindromes.append(string)\n\n    return palindromes", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of strings where some strings can be rearranged into a palindrome.\n    \"\"\"\n    return [\"aab\", \"abc\", \"cdc\", \"deed\"]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum bitwise XOR value can be achieved by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum bitwise XOR value of any two elements is known.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 440, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum bitwise XOR value can be achieved by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum bitwise XOR value of any two elements is known.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the number of subarrays with a sum less than or equal to n.\n\n    Example:\n    nums = [1, -2, 3, 4, -5]\n    n = 4\n    Output: 7\n\n    Explanation: There are 7 subarrays with a sum less than or equal to 4: [1], [1, -2], [1, -2, 3], [3], [3, 4], [4], [-5]\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            subarray = nums[i:j+1]\n            if sum(subarray) <= n:\n                count += 1\n    return count\n\ndef g(nums: List[int] = [1, -2, 3, 4, -5], n: int = 4):\n    return n, nums\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 440, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers nums and an integer n, find the number of subarrays with a sum less than or equal to n.\n\n    Example:\n    nums = [1, -2, 3, 4, -5]\n    n = 4\n    Output: 7\n\n    Explanation: There are 7 subarrays with a sum less than or equal to 4: [1], [1, -2], [1, -2, 3], [3], [3, 4], [4], [-5]\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            subarray = nums[i:j+1]\n            if sum(subarray) <= n:\n                count += 1\n    return count", "solution_func": "def g(nums: List[int] = [1, -2, 3, 4, -5], n: int = 4):\n    return n, nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order and return the sorted list.\n\n    Example:\n    nums = [5, 3, 7, 1, 2]\n    Output: [1, 2, 3, 5, 7]\n\n    \"\"\"\n\n    return sorted(nums)\n\n\ndef g() -> List[int]:\n    nums = [5, 3, 7, 1, 2]\n    return nums\n\nassert f(g()) == [1, 2, 3, 5, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order and return the sorted list.\n\n    Example:\n    nums = [5, 3, 7, 1, 2]\n    Output: [1, 2, 3, 5, 7]\n\n    \"\"\"\n\n    return sorted(nums)", "solution_func": "def g() -> List[int]:\n    nums = [5, 3, 7, 1, 2]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n items in a row if there are no restrictions on the arrangement.\n\n    Example:\n    n = 4\n    Output: 24\n\n    \"\"\"\n\n    return factorial(n)\n\n\ndef g() -> int:\n    n = 4\n    return n\n\nassert f(g()) == 24\n\ndef factorial(n: int) -> int:\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n", "emb": null, "idx_generation": 441, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of ways to arrange n items in a row if there are no restrictions on the arrangement.\n\n    Example:\n    n = 4\n    Output: 24\n\n    \"\"\"\n\n    return factorial(n)", "solution_func": "def g() -> int:\n    n = 4\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all the numbers from 1 to n.\n\n    Example:\n    n = 5\n    Output: 15\n\n    \"\"\"\n\n    return sum(range(1, n+1))\n\n\ndef g() -> int:\n    n = 5\n    return n\n\nassert f(g()) == 15\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the sum of all the numbers from 1 to n.\n\n    Example:\n    n = 5\n    Output: 15\n\n    \"\"\"\n\n    return sum(range(1, n+1))", "solution_func": "def g() -> int:\n    n = 5\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest\n\ndef g() -> List[int]:\n    nums = [5, 2, 7, 1, 8, 4]\n    return nums\n\nassert f(g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the second smallest element.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest", "solution_func": "def g() -> List[int]:\n    nums = [5, 2, 7, 1, 8, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D DP table to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the first row and first column of the DP table\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, cols):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == 29\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29\n\n    Explanation:\n    The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D DP table to store the maximum sum at each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Fill in the first row and first column of the DP table\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, cols):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    # Fill in the rest of the DP table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, convert it to its binary representation.\n    \"\"\"\n    binary_nums = []\n\n    for num in nums:\n        binary_num = bin(num)[2:]  # remove '0b' prefix from binary string\n        binary_nums.append(binary_num)\n\n    return binary_nums\n\ndef g() -> List[int]:\n    nums = [10, 5, 7]\n    return nums\n\nassert f(g()) == ['1010', '101', '111']\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, convert it to its binary representation.\n    \"\"\"\n    binary_nums = []\n\n    for num in nums:\n        binary_num = bin(num)[2:]  # remove '0b' prefix from binary string\n        binary_nums.append(binary_num)\n\n    return binary_nums", "solution_func": "def g() -> List[int]:\n    nums = [10, 5, 7]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that add up to the target using a recursive binary search.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list of two numbers that add up to the target sum.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 6\n    Output: [1, 5]\n\n    Explanation:\n    The numbers 1 and 5 from the list [1, 2, 3, 4, 5] add up to the target sum of 6.\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            return binary_search(arr, mid + 1, end, target)\n        else:\n            return binary_search(arr, start, mid - 1, target)\n\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        result = binary_search(arr, i + 1, len(arr) - 1, complement)\n        if result is not None:\n            return [arr[i], result]\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers 'arr' and a target integer 'target'.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)\n\nassert f(*g()) == [1, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', find two numbers in the list that add up to the target using a recursive binary search.\n\n    Args:\n    - arr: A sorted list of integers.\n    - target: The target sum.\n\n    Returns:\n    - A list of two numbers that add up to the target sum.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 6\n    Output: [1, 5]\n\n    Explanation:\n    The numbers 1 and 5 from the list [1, 2, 3, 4, 5] add up to the target sum of 6.\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return arr[mid]\n        elif arr[mid] < target:\n            return binary_search(arr, mid + 1, end, target)\n        else:\n            return binary_search(arr, start, mid - 1, target)\n\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        result = binary_search(arr, i + 1, len(arr) - 1, complement)\n        if result is not None:\n            return [arr[i], result]\n    \n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers 'arr' and a target integer 'target'.\n    \"\"\"\n    return ([1, 2, 3, 4, 5], 6)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'arr', find the maximum sum of a subarray using Kadane's algorithm.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers 'arr'.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'arr', find the maximum sum of a subarray using Kadane's algorithm.\n\n    Args:\n    - arr: A list of integers.\n\n    Returns:\n    - The maximum sum of a subarray.\n\n    Example:\n    Input: arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation:\n    The subarray [4, -1, 2, 1] has the maximum sum of 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers 'arr'.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of distinct integers 'arr' and a target integer 'target', find the index of the target using binary search.\n\n    Args:\n    - arr: A sorted list of distinct integers.\n    - target: The target integer.\n\n    Returns:\n    - The index of the target integer in the list, or -1 if it is not found.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target integer 5 is found at index 2 in the list [1, 3, 5, 7, 9].\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, mid + 1, end, target)\n        else:\n            return binary_search(arr, start, mid - 1, target)\n\n    return binary_search(arr, 0, len(arr) - 1, target)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers 'arr' and a target integer 'target'.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 441, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of distinct integers 'arr' and a target integer 'target', find the index of the target using binary search.\n\n    Args:\n    - arr: A sorted list of distinct integers.\n    - target: The target integer.\n\n    Returns:\n    - The index of the target integer in the list, or -1 if it is not found.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n\n    Explanation:\n    The target integer 5 is found at index 2 in the list [1, 3, 5, 7, 9].\n    \"\"\"\n    def binary_search(arr, start, end, target):\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, mid + 1, end, target)\n        else:\n            return binary_search(arr, start, mid - 1, target)\n\n    return binary_search(arr, 0, len(arr) - 1, target)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of distinct integers 'arr' and a target integer 'target'.\n    \"\"\"\n    return ([1, 3, 5, 7, 9], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be formed by concatenating the words in the list.\n    Each word can be used only once.\n    \"\"\"\n    n = len(s)\n    m = len(words)\n    \n    if n == 0 or m == 0:\n        return False\n    \n    memo = [False] * (n + 1)\n    memo[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if memo[j] and s[j:i] in words:\n                memo[i] = True\n                break\n    \n    return memo[n]\n\ndef g(s: str, words: List[str]) -> str:\n    \"\"\"\n    Generate a string by concatenating the words in the list.\n    \"\"\"\n    return ''.join(words) + s\n\nassert f(g(\"hellothere\", [\"hello\", \"there\"])) == True\n", "emb": null, "idx_generation": 441, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> bool:\n    \"\"\"\n    Given a string s and a list of words, determine if s can be formed by concatenating the words in the list.\n    Each word can be used only once.\n    \"\"\"\n    n = len(s)\n    m = len(words)\n    \n    if n == 0 or m == 0:\n        return False\n    \n    memo = [False] * (n + 1)\n    memo[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if memo[j] and s[j:i] in words:\n                memo[i] = True\n                break\n    \n    return memo[n]", "solution_func": "def g(s: str, words: List[str]) -> str:\n    \"\"\"\n    Generate a string by concatenating the words in the list.\n    \"\"\"\n    return ''.join(words) + s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where the elements are non-consecutive.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n    output: 12\n\n    Explanation: The maximum sum subsequence without consecutive elements is [2, 9, 1], which has a sum of 12.\n    \"\"\"\n    def max_sum_subsequence(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subsequence(arr, n-1, memo), arr[n] + max_sum_subsequence(arr, n-2, memo))\n        return memo[n]\n\n    return max_sum_subsequence(arr, len(arr)-1, {})\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [2, 7, 9, 3, 1]\n    return arr\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where the elements are non-consecutive.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n    output: 12\n\n    Explanation: The maximum sum subsequence without consecutive elements is [2, 9, 1], which has a sum of 12.\n    \"\"\"\n    def max_sum_subsequence(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subsequence(arr, n-1, memo), arr[n] + max_sum_subsequence(arr, n-2, memo))\n        return memo[n]\n\n    return max_sum_subsequence(arr, len(arr)-1, {})", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [2, 7, 9, 3, 1]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray where the elements are non-consecutive.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n    output: 16\n\n    Explanation: The maximum sum subarray without consecutive elements is [7, 9], which has a sum of 16.\n    \"\"\"\n    def max_sum_subarray(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subarray(arr, n-1, memo), arr[n] + max_sum_subarray(arr, n-2, memo))\n        return memo[n]\n\n    return max_sum_subarray(arr, len(arr)-1, {})\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [2, 7, 9, 3, 1]\n    return arr\n\nassert f(g()) == 16\n\n", "emb": null, "idx_generation": 442, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray where the elements are non-consecutive.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [2, 7, 9, 3, 1]\n    output: 16\n\n    Explanation: The maximum sum subarray without consecutive elements is [7, 9], which has a sum of 16.\n    \"\"\"\n    def max_sum_subarray(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subarray(arr, n-1, memo), arr[n] + max_sum_subarray(arr, n-2, memo))\n        return memo[n]\n\n    return max_sum_subarray(arr, len(arr)-1, {})", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [2, 7, 9, 3, 1]\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray where the elements are non-consecutive.\n\n    However, this time, you are only allowed to skip one element in the subarray.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [3, 4, -1, 2, 1, -5, 4]\n    output: 10\n\n    Explanation: The maximum sum subarray without consecutive elements and skipping at most one element is [3, -1, 1, 4], which has a sum of 10.\n    \"\"\"\n    def max_sum_subarray(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subarray(arr, n-1, memo), arr[n] + max_sum_subarray(arr, n-2, memo), arr[n] + max_sum_subarray(arr, n-3, memo))\n        return memo[n]\n\n    return max_sum_subarray(arr, len(arr)-1, {})\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [3, 4, -1, 2, 1, -5, 4]\n    return arr\n\nassert f(g()) == 10\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray where the elements are non-consecutive.\n\n    However, this time, you are only allowed to skip one element in the subarray.\n\n    Return the maximum sum.\n\n    Example:\n    arr = [3, 4, -1, 2, 1, -5, 4]\n    output: 10\n\n    Explanation: The maximum sum subarray without consecutive elements and skipping at most one element is [3, -1, 1, 4], which has a sum of 10.\n    \"\"\"\n    def max_sum_subarray(arr, n, memo):\n        if n < 0:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(max_sum_subarray(arr, n-1, memo), arr[n] + max_sum_subarray(arr, n-2, memo), arr[n] + max_sum_subarray(arr, n-3, memo))\n        return memo[n]\n\n    return max_sum_subarray(arr, len(arr)-1, {})", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    arr = [3, 4, -1, 2, 1, -5, 4]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the numbers in the list.\n    \"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return product\n\ndef g():\n    nums = [2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 120\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the numbers in the list.\n    \"\"\"\n    product = 1\n    for num in nums:\n        product *= num\n    return product", "solution_func": "def g():\n    nums = [2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all the duplicate elements removed.\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g():\n    nums = [1, 2, 3, 4, 2, 3, 5]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all the duplicate elements removed.\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 2, 3, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the elements reversed.\n    \"\"\"\n    reversed_nums = []\n    for i in range(len(nums)-1, -1, -1):\n        reversed_nums.append(nums[i])\n    return reversed_nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the elements reversed.\n    \"\"\"\n    reversed_nums = []\n    for i in range(len(nums)-1, -1, -1):\n        reversed_nums.append(nums[i])\n    return reversed_nums", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all elements that are divisible by 3.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements divisible by 3 are 3, 6, and 9.\n    The sum of these elements is 3 + 6 + 9 = 18.\n\n    Therefore, the function should return 18.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0:\n                total_sum += num\n    return total_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 18\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the sum of all elements that are divisible by 3.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements divisible by 3 are 3, 6, and 9.\n    The sum of these elements is 3 + 6 + 9 = 18.\n\n    Therefore, the function should return 18.\n    \"\"\"\n    total_sum = 0\n    for row in matrix:\n        for num in row:\n            if num % 3 == 0:\n                total_sum += num\n    return total_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [-10, -3, 1, 2, 3, 4]\n\n    The maximum product of any three elements is (-10) * (-3) * 4 = 120.\n\n    Therefore, the function should return 120.\n    \"\"\"\n    max_product = float('-inf')\n    nums.sort()\n    n = len(nums)\n    max_product = max(max_product, nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [-10, -3, 1, 2, 3, 4]\n\nassert f(g()) == 120\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three elements in the list.\n\n    Example:\n    nums = [-10, -3, 1, 2, 3, 4]\n\n    The maximum product of any three elements is (-10) * (-3) * 4 = 120.\n\n    Therefore, the function should return 120.\n    \"\"\"\n    max_product = float('-inf')\n    nums.sort()\n    n = len(nums)\n    max_product = max(max_product, nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n    return max_product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [-10, -3, 1, 2, 3, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray with length at most 3.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 6]\n\n    The subarrays with length at most 3 are [1], [-2], [3], [4], [-5], [6], [1, -2], [3, 4], [-5, 6], [1, -2, 3], [4, -5, 6].\n    The maximum sum among these subarrays is 9, which corresponds to the subarray [3, 4, -5].\n\n    Therefore, the function should return 9.\n    \"\"\"\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)+1):\n            subarray = nums[i:j]\n            if len(subarray) <= 3:\n                max_sum = max(max_sum, sum(subarray))\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, -2, 3, 4, -5, 6]\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 442, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray with length at most 3.\n\n    Example:\n    nums = [1, -2, 3, 4, -5, 6]\n\n    The subarrays with length at most 3 are [1], [-2], [3], [4], [-5], [6], [1, -2], [3, 4], [-5, 6], [1, -2, 3], [4, -5, 6].\n    The maximum sum among these subarrays is 9, which corresponds to the subarray [3, 4, -5].\n\n    Therefore, the function should return 9.\n    \"\"\"\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)+1):\n            subarray = nums[i:j]\n            if len(subarray) <= 3:\n                max_sum = max(max_sum, sum(subarray))\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, -2, 3, 4, -5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nimport math\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome, i.e., reads the same forwards and backwards.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: The string \"racecar\" reads the same forwards and backwards, so it is a palindrome.\n    \"\"\"\n\n    # Remove all non-alphanumeric characters and convert string to lowercase\n    s = ''.join(char.lower() for char in s if char.isalnum())\n\n    # Check if the reverse of s is equal to s\n    return s == s[::-1]\n\ndef g():\n    s = \"racecar\"\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 442, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nimport math\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome, i.e., reads the same forwards and backwards.\n\n    Example:\n    Input: s = \"racecar\"\n    Output: True\n\n    Explanation: The string \"racecar\" reads the same forwards and backwards, so it is a palindrome.\n    \"\"\"\n\n    # Remove all non-alphanumeric characters and convert string to lowercase\n    s = ''.join(char.lower() for char in s if char.isalnum())\n\n    # Check if the reverse of s is equal to s\n    return s == s[::-1]", "solution_func": "def g():\n    s = \"racecar\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]], n=4) -> bool:\n    \"\"\"Check if the given matrix is a magic square of size n. A magic square is a square matrix in which the sum of each row, each column, and both diagonals is the same.\"\"\"\n    target_sum = n * (n**2 + 1) // 2\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    return all(sum == target_sum for sum in row_sums + col_sums + [diagonal_sum1, diagonal_sum2])\n\ndef g(n=4):\n    \"\"\"Generate a magic square of size n\"\"\"\n    magic_square = [[0] * n for _ in range(n)]\n    i, j = n // 2, n - 1\n    for num in range(1, n**2 + 1):\n        magic_square[i][j] = num\n        i = (i - 1) % n\n        j = (j + 1) % n\n        if magic_square[i][j] != 0:\n            i = (i + 1) % n\n            j = (j - 2) % n\n    return magic_square\n\nassert f(g())\n", "emb": null, "idx_generation": 443, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], n=4) -> bool:\n    \"\"\"Check if the given matrix is a magic square of size n. A magic square is a square matrix in which the sum of each row, each column, and both diagonals is the same.\"\"\"\n    target_sum = n * (n**2 + 1) // 2\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    return all(sum == target_sum for sum in row_sums + col_sums + [diagonal_sum1, diagonal_sum2])", "solution_func": "def g(n=4):\n    \"\"\"Generate a magic square of size n\"\"\"\n    magic_square = [[0] * n for _ in range(n)]\n    i, j = n // 2, n - 1\n    for num in range(1, n**2 + 1):\n        magic_square[i][j] = num\n        i = (i - 1) % n\n        j = (j + 1) % n\n        if magic_square[i][j] != 0:\n            i = (i + 1) % n\n            j = (j - 2) % n\n    return magic_square", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"Check if there exists a path in the given graph from the start node to the end node.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False\n\ndef g():\n    \"\"\"Generate a graph with nodes and edges\"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['A']\n    }\n    return graph\n\nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 443, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(graph: Dict[str, List[str]], start='A', end='D') -> bool:\n    \"\"\"Check if there exists a path in the given graph from the start node to the end node.\"\"\"\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node == end:\n            return True\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return False", "solution_func": "def g():\n    \"\"\"Generate a graph with nodes and edges\"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['C', 'D'],\n        'C': ['D'],\n        'D': ['A']\n    }\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if n is divisible by k using the modulo operator.\"\"\"\n    return n % k == 0\n\ndef g(n=24, k=6):\n    \"\"\"Generate two integers n and k\"\"\"\n    return n, k\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 443, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Check if n is divisible by k using the modulo operator.\"\"\"\n    return n % k == 0", "solution_func": "def g(n=24, k=6):\n    \"\"\"Generate two integers n and k\"\"\"\n    return n, k", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target exists in the list.\n    Return True if the target exists, otherwise return False.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False\n\ndef g():\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 4\n\nassert f(*g()) == False\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 443, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if the target exists in the list.\n    Return True if the target exists, otherwise return False.\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return False", "solution_func": "def g():\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 4", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of different ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    Return the number of distinct ways to climb the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 443, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of different ways to climb to the top of a staircase with n steps.\n    You can climb either 1 or 2 steps at a time.\n    Return the number of distinct ways to climb the staircase.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n=4):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(adjacency_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if the graph contains a cycle.\n    Return True if the graph contains a cycle, otherwise return False.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(adjacency_list)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return [[1, 2], [2, 3], [3], []]\n\nassert f(g()) == False\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 443, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(adjacency_list: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency list representing a directed graph, determine if the graph contains a cycle.\n    Return True if the graph contains a cycle, otherwise return False.\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    num_nodes = len(adjacency_list)\n    visited = [False] * num_nodes\n    stack = [False] * num_nodes\n\n    for node in range(num_nodes):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False", "solution_func": "def g():\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return [[1, 2], [2, 3], [3], []]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int, target='abcde') -> bool:\n    \"\"\"\n    Given a string `s`, find the number of non-empty contiguous substrings of `s` that contain exactly `k`\n    occurrences of each character from the target string. Return True if the count of such substrings is equal\n    to the length of the target string, otherwise return False.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            sub = s[i:j]\n            sub_count = {c: sub.count(c) for c in target}\n            if all(sub_count[c] == k for c in target):\n                count += 1\n    return count == len(target)\ndef g(k: int, target='abcde'):\n    return target * k\nassert f(g())\n", "emb": null, "idx_generation": 443, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int, target='abcde') -> bool:\n    \"\"\"\n    Given a string `s`, find the number of non-empty contiguous substrings of `s` that contain exactly `k`\n    occurrences of each character from the target string. Return True if the count of such substrings is equal\n    to the length of the target string, otherwise return False.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            sub = s[i:j]\n            sub_count = {c: sub.count(c) for c in target}\n            if all(sub_count[c] == k for c in target):\n                count += 1\n    return count == len(target)", "solution_func": "def g(k: int, target='abcde'):\n    return target * k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(pattern: str, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a pattern string and a grid of characters, determine if the pattern can be found as a contiguous\n    sequence of characters in the grid. The pattern can start from any cell in the grid and can move in any\n    of the four cardinal directions (up, down, left, right). Return True if the pattern is found, otherwise return False.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, pattern, 0, grid):\n                return True\n    return False\n\ndef dfs(i, j, pattern, idx, grid):\n    if idx == len(pattern):\n        return True\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != pattern[idx]:\n        return False\n\n    temp = grid[i][j]\n    grid[i][j] = \"#\"\n\n    found = dfs(i+1, j, pattern, idx+1, grid) or dfs(i-1, j, pattern, idx+1, grid) or dfs(i, j+1, pattern, idx+1, grid) or dfs(i, j-1, pattern, idx+1, grid)\n\n    grid[i][j] = temp\n\n    return found\n\ndef g(pattern: str, grid: List[List[str]]):\n    return pattern, grid\n\nassert f(*g())\n", "emb": null, "idx_generation": 443, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(pattern: str, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a pattern string and a grid of characters, determine if the pattern can be found as a contiguous\n    sequence of characters in the grid. The pattern can start from any cell in the grid and can move in any\n    of the four cardinal directions (up, down, left, right). Return True if the pattern is found, otherwise return False.\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, pattern, 0, grid):\n                return True\n    return False\n\ndef dfs(i, j, pattern, idx, grid):\n    if idx == len(pattern):\n        return True\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != pattern[idx]:\n        return False\n\n    temp = grid[i][j]\n    grid[i][j] = \"#\"\n\n    found = dfs(i+1, j, pattern, idx+1, grid) or dfs(i-1, j, pattern, idx+1, grid) or dfs(i, j+1, pattern, idx+1, grid) or dfs(i, j-1, pattern, idx+1, grid)\n\n    grid[i][j] = temp\n\n    return found", "solution_func": "def g(pattern: str, grid: List[List[str]]):\n    return pattern, grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers `n` and `k`, find a valid string of length `n` such that there are exactly `k` distinct\n    characters in the string. Return True if such a string exists, otherwise return False.\n    \"\"\"\n    if k > n or k < 2:\n        return False\n    elif k == 2:\n        return n % 2 == 0\n    else:\n        return True\ndef g(n: int, k: int):\n    return n, k\nassert f(*g())\n", "emb": null, "idx_generation": 443, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Given two integers `n` and `k`, find a valid string of length `n` such that there are exactly `k` distinct\n    characters in the string. Return True if such a string exists, otherwise return False.\n    \"\"\"\n    if k > n or k < 2:\n        return False\n    elif k == 2:\n        return n % 2 == 0\n    else:\n        return True", "solution_func": "def g(n: int, k: int):\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers (1-indexed) as an array of integers, where the first index is less than the second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [1,2]\n    Explanation: The sum of 2 and 7 is 9. Therefore index 1 and 2 are returned.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left + 1, right + 1]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums, target\n\nassert f(*g()) == [1, 2]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 443, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums sorted in ascending order, find two numbers such that they add up to a specific target number.\n    Return the indices of the two numbers (1-indexed) as an array of integers, where the first index is less than the second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    Input: nums = [2,7,11,15], target = 9\n    Output: [1,2]\n    Explanation: The sum of 2 and 7 is 9. Therefore index 1 and 2 are returned.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [left + 1, right + 1]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums=[2, 7, 11, 15], target=9):\n    \"\"\"\n    g() function returns the input values for the f() function.\n    \"\"\"\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The maximum subarray sum is [4, -1, 2, 1] which sums to 6.\n    \"\"\"\n\n    def max_subarray_sum(nums: List[int], left: int, right: int) -> int:\n        if left == right:\n            return nums[left]\n        \n        mid = (left + right) // 2\n        \n        left_sum = max_subarray_sum(nums, left, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, right)\n        \n        cross_sum = cross_subarray_sum(nums, left, mid, right)\n        \n        return max(left_sum, right_sum, cross_sum)\n    \n    def cross_subarray_sum(nums: List[int], left: int, mid: int, right: int) -> int:\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, left - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, right + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return max_subarray_sum(nums, 0, len(nums) - 1)\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 444, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The maximum subarray sum is [4, -1, 2, 1] which sums to 6.\n    \"\"\"\n\n    def max_subarray_sum(nums: List[int], left: int, right: int) -> int:\n        if left == right:\n            return nums[left]\n        \n        mid = (left + right) // 2\n        \n        left_sum = max_subarray_sum(nums, left, mid)\n        right_sum = max_subarray_sum(nums, mid + 1, right)\n        \n        cross_sum = cross_subarray_sum(nums, left, mid, right)\n        \n        return max(left_sum, right_sum, cross_sum)\n    \n    def cross_subarray_sum(nums: List[int], left: int, mid: int, right: int) -> int:\n        left_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid, left - 1, -1):\n            curr_sum += nums[i]\n            left_sum = max(left_sum, curr_sum)\n        \n        right_sum = float('-inf')\n        curr_sum = 0\n        for i in range(mid + 1, right + 1):\n            curr_sum += nums[i]\n            right_sum = max(right_sum, curr_sum)\n        \n        return left_sum + right_sum\n    \n    return max_subarray_sum(nums, 0, len(nums) - 1)", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the next permutation of the numbers.\n\n    Example:\n    Input: [1, 2, 3]\n    Output: [1, 3, 2]\n\n    Explanation: The next permutation of [1, 2, 3] is [1, 3, 2].\n    \"\"\"\n\n    def next_permutation(nums: List[int]) -> None:\n        n = len(nums)\n        i = n - 2\n        \n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        if i >= 0:\n            j = n - 1\n            while j >= 0 and nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        left = i + 1\n        right = n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    \n    next_permutation(nums)\n    return nums\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 444, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return the next permutation of the numbers.\n\n    Example:\n    Input: [1, 2, 3]\n    Output: [1, 3, 2]\n\n    Explanation: The next permutation of [1, 2, 3] is [1, 3, 2].\n    \"\"\"\n\n    def next_permutation(nums: List[int]) -> None:\n        n = len(nums)\n        i = n - 2\n        \n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        if i >= 0:\n            j = n - 1\n            while j >= 0 and nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        left = i + 1\n        right = n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    \n    next_permutation(nums)\n    return nums", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 ([2, 7]) add up to 9.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        num_dict = dict()\n        \n        for i, num in enumerate(nums):\n            if target - num in num_dict:\n                return [num_dict[target - num], i]\n            num_dict[num] = i\n        \n        return []\n    \n    return two_sum(nums, target)\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 444, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The numbers at indices 0 and 1 ([2, 7]) add up to 9.\n    \"\"\"\n\n    def two_sum(nums: List[int], target: int) -> List[int]:\n        num_dict = dict()\n        \n        for i, num in enumerate(nums):\n            if target - num in num_dict:\n                return [num_dict[target - num], i]\n            num_dict[num] = i\n        \n        return []\n    \n    return two_sum(nums, target)", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True\n\ndef g():\n    n = 17\n    return n\n\nassert f(g())\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 444, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a prime number.\n\n    \"\"\"\n    if n < 2:\n        return False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    \n    return True", "solution_func": "def g():\n    n = 17\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there is a subset of nums that adds up to the target.\n\n    \"\"\"\n    def subset_sum(nums, target, index, memo):\n        # Base cases\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        \n        # Check if subset sum has already been computed\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        # Recursive case: include current number or exclude it\n        include = subset_sum(nums, target - nums[index], index + 1, memo)\n        exclude = subset_sum(nums, target, index + 1, memo)\n        \n        # Store result in memoization table\n        memo[(index, target)] = include or exclude\n        \n        return include or exclude\n    \n    memo = {}\n    return subset_sum(nums, target, 0, memo)\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target\n\nassert f(*g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 444, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target integer, determine if there is a subset of nums that adds up to the target.\n\n    \"\"\"\n    def subset_sum(nums, target, index, memo):\n        # Base cases\n        if target == 0:\n            return True\n        if index >= len(nums) or target < 0:\n            return False\n        \n        # Check if subset sum has already been computed\n        if (index, target) in memo:\n            return memo[(index, target)]\n        \n        # Recursive case: include current number or exclude it\n        include = subset_sum(nums, target - nums[index], index + 1, memo)\n        exclude = subset_sum(nums, target, index + 1, memo)\n        \n        # Store result in memoization table\n        memo[(index, target)] = include or exclude\n        \n        return include or exclude\n    \n    memo = {}\n    return subset_sum(nums, target, 0, memo)", "solution_func": "def g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return nums, target", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself.\n\n    \"\"\"\n    def sum_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        \n        return sum(divisors)\n    \n    return sum_divisors(n) == n\n\ndef g():\n    n = 28\n    return n\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 444, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given a positive integer n, determine if it is a perfect number.\n    A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding the number itself.\n\n    \"\"\"\n    def sum_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        \n        return sum(divisors)\n    \n    return sum_divisors(n) == n", "solution_func": "def g():\n    n = 28\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given array whose bitwise XOR is equal to the target value.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False\n\ndef g(arr: List[int], target: int):\n    \"\"\"\n    Generate all possible pairs of numbers in the array and return them.\n    \"\"\"\n    n = len(arr)\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n):\n            ans.append((arr[i], arr[j]))\n    return ans\n\nassert f(g([1, 2, 3, 4, 5], 6), 6) == True\n", "emb": null, "idx_generation": 444, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a pair of numbers in the given array whose bitwise XOR is equal to the target value.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] ^ arr[j] == target:\n                return True\n    return False", "solution_func": "def g(arr: List[int], target: int):\n    \"\"\"\n    Generate all possible pairs of numbers in the array and return them.\n    \"\"\"\n    n = len(arr)\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n):\n            ans.append((arr[i], arr[j]))\n    return ans", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list whose sum is equal to the target value.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if sum(nums[i:j]) == target:\n                return True\n    return False\n\ndef g(nums: List[int], target: int):\n    \"\"\"\n    Generate all possible subarrays of the given list and return them.\n    \"\"\"\n    n = len(nums)\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            ans.append(nums[i:j])\n    return ans\n\nassert f(g([1, 2, 3, 4, 5], 9), 9) == True\n", "emb": null, "idx_generation": 444, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Check if there exists a subarray in the given list whose sum is equal to the target value.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if sum(nums[i:j]) == target:\n                return True\n    return False", "solution_func": "def g(nums: List[int], target: int):\n    \"\"\"\n    Generate all possible subarrays of the given list and return them.\n    \"\"\"\n    n = len(nums)\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            ans.append(nums[i:j])\n    return ans", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Check if there exists a path in the given matrix from the top-left corner to the bottom-right corner\n    such that the XOR of all the numbers along the path is equal to the target value.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, xor):\n        if i == m-1 and j == n-1:\n            return xor ^ matrix[i][j] == target\n        if i < m-1 and dfs(i+1, j, xor ^ matrix[i][j]):\n            return True\n        if j < n-1 and dfs(i, j+1, xor ^ matrix[i][j]):\n            return True\n        return False\n    \n    return dfs(0, 0, 0)\n\ndef g(matrix: List[List[int]], target: int):\n    \"\"\"\n    Generate all possible paths in the matrix and return them.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, path):\n        if i == m-1 and j == n-1:\n            path.append(matrix[i][j])\n            return [path]\n        \n        path.append(matrix[i][j])\n        \n        paths = []\n        \n        if i < m-1:\n            down_paths = dfs(i+1, j, path.copy())\n            paths.extend(down_paths)\n        \n        if j < n-1:\n            right_paths = dfs(i, j+1, path.copy())\n            paths.extend(right_paths)\n        \n        return paths\n    \n    return g(0, 0, [])\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 13), 13) == True\n", "emb": null, "idx_generation": 444, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Check if there exists a path in the given matrix from the top-left corner to the bottom-right corner\n    such that the XOR of all the numbers along the path is equal to the target value.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, xor):\n        if i == m-1 and j == n-1:\n            return xor ^ matrix[i][j] == target\n        if i < m-1 and dfs(i+1, j, xor ^ matrix[i][j]):\n            return True\n        if j < n-1 and dfs(i, j+1, xor ^ matrix[i][j]):\n            return True\n        return False\n    \n    return dfs(0, 0, 0)", "solution_func": "def g(matrix: List[List[int]], target: int):\n    \"\"\"\n    Generate all possible paths in the matrix and return them.\n    \"\"\"\n    m = len(matrix)\n    n = len(matrix[0])\n    \n    def dfs(i, j, path):\n        if i == m-1 and j == n-1:\n            path.append(matrix[i][j])\n            return [path]\n        \n        path.append(matrix[i][j])\n        \n        paths = []\n        \n        if i < m-1:\n            down_paths = dfs(i+1, j, path.copy())\n            paths.extend(down_paths)\n        \n        if j < n-1:\n            right_paths = dfs(i, j+1, path.copy())\n            paths.extend(right_paths)\n        \n        return paths\n    \n    return g(0, 0, [])", "map_ix": null}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"Check if it is possible to rearrange the characters of the string such that no two adjacent characters are the same, and there are at least k distinct characters in the rearranged string.\"\"\"\n    count = {}\n    for char in string:\n        count[char] = count.get(char, 0) + 1\n    distinct_chars = len(count)\n    max_freq = max(count.values())\n    return max_freq <= (len(string) + 1) // 2 and distinct_chars >= k\n\ndef g(k: int):\n    \"\"\"Generate a string with k distinct characters.\"\"\"\n    import random\n    chars = [chr(random.randint(65, 90)) for _ in range(k)]\n    return ''.join(chars)\n\nassert f(g(5), 5)\n", "emb": null, "idx_generation": 444, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "import random\nfrom typing import*\ndef f(string: str, k: int) -> bool:\n    \"\"\"Check if it is possible to rearrange the characters of the string such that no two adjacent characters are the same, and there are at least k distinct characters in the rearranged string.\"\"\"\n    count = {}\n    for char in string:\n        count[char] = count.get(char, 0) + 1\n    distinct_chars = len(count)\n    max_freq = max(count.values())\n    return max_freq <= (len(string) + 1) // 2 and distinct_chars >= k", "solution_func": "def g(k: int):\n    \"\"\"Generate a string with k distinct characters.\"\"\"\n    import random\n    chars = [chr(random.randint(65, 90)) for _ in range(k)]\n    return ''.join(chars)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product is 4 * 5 = 20.\n\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product is 4 * 5 = 20.\n\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 or 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 33\n    Explanation: The numbers divisible by 3 or 5 are 3, 5, 6, 9, and 10. Their sum is 33.\n\n    \"\"\"\n\n    total_sum = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            total_sum += num\n\n    return total_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 or 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 33\n    Explanation: The numbers divisible by 3 or 5 are 3, 5, 6, 9, and 10. Their sum is 33.\n\n    \"\"\"\n\n    total_sum = 0\n\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            total_sum += num\n\n    return total_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the indices of two numbers in the list that add up to the target value. Return the indices in ascending order.\n\n    Example:\n    nums = [3, 1, 5, 2, 4]\n    target = 6\n    Output: [1, 4]\n    Explanation: The numbers at indices 1 and 4 (1 and 4) add up to 6.\n\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 1, 5, 2, 4], 6\n\nassert f(*g()) == [1, 4]\n", "emb": null, "idx_generation": 445, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find the indices of two numbers in the list that add up to the target value. Return the indices in ascending order.\n\n    Example:\n    nums = [3, 1, 5, 2, 4]\n    target = 6\n    Output: [1, 4]\n    Explanation: The numbers at indices 1 and 4 (1 and 4) add up to 6.\n\n    \"\"\"\n\n    num_dict = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [3, 1, 5, 2, 4], 6", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique binary strings of length n that do not contain consecutive ones.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: For n = 3, the unique binary strings are [\"000\", \"001\", \"010\", \"100\", \"101\"], where none of them contain consecutive ones.\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i-1] + dp[i-2]) % (10**9 + 7)\n\n    return dp[n]\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique binary strings of length n that do not contain consecutive ones.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: For n = 3, the unique binary strings are [\"000\", \"001\", \"010\", \"100\", \"101\"], where none of them contain consecutive ones.\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i-1] + dp[i-2]) % (10**9 + 7)\n\n    return dp[n]", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Explanation: The largest square containing only 1's is the 2x2 square at the top right corner, which has an area of 4.\n\n    Note:\n    - The input matrix can have a maximum size of 300 x 300.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_side = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\n    Example:\n    Input:\n    matrix = [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]\n    Output: 4\n\n    Explanation: The largest square containing only 1's is the 2x2 square at the top right corner, which has an area of 4.\n\n    Note:\n    - The input matrix can have a maximum size of 300 x 300.\n    \"\"\"\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_side = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 0, 1, 0, 0],\n        [1, 0, 1, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 0, 0, 1, 0]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct valid parentheses strings of length 2n.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: For n = 3, the distinct valid parentheses strings are [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"].\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n] % (10**9 + 7)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct valid parentheses strings of length 2n.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: For n = 3, the distinct valid parentheses strings are [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"].\n\n    Note:\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i-j-1]\n\n    return dp[n] % (10**9 + 7)", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Note:\n    - You may assume that each input would have exactly one solution.\n    - The array is sorted in ascending order.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return [left, right]\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to 9.\n\n    Note:\n    - You may assume that each input would have exactly one solution.\n    - The array is sorted in ascending order.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        total = nums[left] + nums[right]\n        if total == target:\n            return [left, right]\n        elif total < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Note:\n    - The subarray must contain at least one element.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    current_sum = max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The contiguous subarray [4, -1, 2, 1] has the largest sum of 6.\n\n    Note:\n    - The subarray must contain at least one element.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    current_sum = max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    Return the length of the longest increasing path.\n\n    Example:\n    Input: grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Note:\n    - You can move in any of the four directions: up, down, left, or right.\n    - You may assume all elements in the grid are unique.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        longest_path = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                longest_path = max(longest_path, 1 + dfs(new_row, new_col))\n\n        memo[row][col] = longest_path\n        return longest_path\n\n    longest_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\ndef g() -> List[List[int]]:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 445, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the length of the longest increasing path.\n    A path is considered increasing if each cell in the path is greater than the previous cell.\n    Return the length of the longest increasing path.\n\n    Example:\n    Input: grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    Output: 4\n    Explanation: The longest increasing path is [1, 2, 6, 9].\n\n    Note:\n    - You can move in any of the four directions: up, down, left, or right.\n    - You may assume all elements in the grid are unique.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    memo = [[0] * cols for _ in range(rows)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(row: int, col: int) -> int:\n        if memo[row][col] != 0:\n            return memo[row][col]\n\n        longest_path = 1\n\n        for dx, dy in directions:\n            new_row, new_col = row + dx, col + dy\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] > grid[row][col]:\n                longest_path = max(longest_path, 1 + dfs(new_row, new_col))\n\n        memo[row][col] = longest_path\n        return longest_path\n\n    longest_path = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [9, 9, 4],\n        [6, 6, 8],\n        [2, 1, 1]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(num: int, pattern: str, target: int) -> bool:\n    \"\"\"\n    Given a positive integer num, a pattern string consisting of '+' and '-', and a target integer,\n    determine if it is possible to insert the '+' and '-' signs between the digits of num to form an\n    expression that evaluates to the target.\n\n    Example:\n    Input:\n    num = 123\n    pattern = \"+-\"\n    target = 6\n\n    Output:\n    True\n\n    Explanation:\n    The possible expressions are: 1+2-3 = 0, 1-2+3 = 2, 1+2+3 = 6.\n    Since there is an expression that evaluates to the target, the function should return True.\n    \"\"\"\n\n    def evaluate_expression(expression: str) -> int:\n        return eval(expression)\n\n    def backtrack(expression: str, index: int) -> bool:\n        if index == len(num):\n            if evaluate_expression(expression) == target:\n                return True\n            return False\n\n        if backtrack(expression + '+' + num[index], index + 1):\n            return True\n\n        if backtrack(expression + '-' + num[index], index + 1):\n            return True\n\n        return False\n\n    return backtrack(num[0], 1)\n\ndef g():\n    num = \"123\"\n    pattern = \"+-\"\n    target = 6\n    return [num, pattern, target]\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 445, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(num: int, pattern: str, target: int) -> bool:\n    \"\"\"\n    Given a positive integer num, a pattern string consisting of '+' and '-', and a target integer,\n    determine if it is possible to insert the '+' and '-' signs between the digits of num to form an\n    expression that evaluates to the target.\n\n    Example:\n    Input:\n    num = 123\n    pattern = \"+-\"\n    target = 6\n\n    Output:\n    True\n\n    Explanation:\n    The possible expressions are: 1+2-3 = 0, 1-2+3 = 2, 1+2+3 = 6.\n    Since there is an expression that evaluates to the target, the function should return True.\n    \"\"\"\n\n    def evaluate_expression(expression: str) -> int:\n        return eval(expression)\n\n    def backtrack(expression: str, index: int) -> bool:\n        if index == len(num):\n            if evaluate_expression(expression) == target:\n                return True\n            return False\n\n        if backtrack(expression + '+' + num[index], index + 1):\n            return True\n\n        if backtrack(expression + '-' + num[index], index + 1):\n            return True\n\n        return False\n\n    return backtrack(num[0], 1)", "solution_func": "def g():\n    num = \"123\"\n    pattern = \"+-\"\n    target = 6\n    return [num, pattern, target]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of elements that have their binary representation\n    ending with the digit 1.\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num & 1 == 1:\n            count += 1\n    return count\n\ndef g():\n    numbers = [5, 6, 7, 8, 9]\n    return numbers\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 446, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of elements that have their binary representation\n    ending with the digit 1.\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num & 1 == 1:\n            count += 1\n    return count", "solution_func": "def g():\n    numbers = [5, 6, 7, 8, 9]\n    return numbers", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be represented as a concatenation of two non-empty substrings.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s[:i] + s[:i] == s:\n            return True\n    return False\n\ndef g():\n    return \"abcabc\"\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 446, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string, check if it can be represented as a concatenation of two non-empty substrings.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s[:i] + s[:i] == s:\n            return True\n    return False", "solution_func": "def g():\n    return \"abcabc\"", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string, split it into a list of all possible substrings.\n    \"\"\"\n    n = len(s)\n    substrings = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.append(s[i:j])\n    return substrings\n\ndef g():\n    return \"abc\"\n\nassert f(g()) == ['a', 'ab', 'abc', 'b', 'bc', 'c']\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 446, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string, split it into a list of all possible substrings.\n    \"\"\"\n    n = len(s)\n    substrings = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substrings.append(s[i:j])\n    return substrings", "solution_func": "def g():\n    return \"abc\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the smallest subarray length whose sum is greater than or equal to the target value.\n    Return the length of the smallest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [2, 3, 1, 2, 4, 3], target = 7\n    Output: 2\n\n    Hint: Use a sliding window approach to find the smallest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    min_length = float('inf')\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= arr[left]\n            left += 1\n\n        right += 1\n\n    return min_length if min_length != float('inf') else -1\n\ndef g():\n    return [2, 3, 1, 2, 4, 3], 7\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 446, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the smallest subarray length whose sum is greater than or equal to the target value.\n    Return the length of the smallest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [2, 3, 1, 2, 4, 3], target = 7\n    Output: 2\n\n    Hint: Use a sliding window approach to find the smallest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    min_length = float('inf')\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= arr[left]\n            left += 1\n\n        right += 1\n\n    return min_length if min_length != float('inf') else -1", "solution_func": "def g():\n    return [2, 3, 1, 2, 4, 3], 7", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the length of the shortest subarray whose sum is greater than or equal to the target value.\n    Return the length of the shortest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [1, 4, 45, 6, 0, 19], target = 51\n    Output: 3\n\n    Hint: Use a sliding window approach to find the shortest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    min_length = float('inf')\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= arr[left]\n            left += 1\n\n        right += 1\n\n    return min_length if min_length != float('inf') else -1\n\ndef g():\n    return [1, 4, 45, 6, 0, 19], 51\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 446, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the length of the shortest subarray whose sum is greater than or equal to the target value.\n    Return the length of the shortest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [1, 4, 45, 6, 0, 19], target = 51\n    Output: 3\n\n    Hint: Use a sliding window approach to find the shortest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    min_length = float('inf')\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            curr_sum -= arr[left]\n            left += 1\n\n        right += 1\n\n    return min_length if min_length != float('inf') else -1", "solution_func": "def g():\n    return [1, 4, 45, 6, 0, 19], 51", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the length of the longest subarray whose sum is less than or equal to the target value.\n    Return the length of the longest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 15\n    Output: 7\n\n    Hint: Use a sliding window approach to find the longest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    max_length = 0\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum > target:\n            curr_sum -= arr[left]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n        right += 1\n\n    return max_length if max_length != 0 else -1\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 15\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 446, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target value, find the length of the longest subarray whose sum is less than or equal to the target value.\n    Return the length of the longest subarray, or -1 if no such subarray exists.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], target = 15\n    Output: 7\n\n    Hint: Use a sliding window approach to find the longest subarray.\n    \"\"\"\n\n    left = 0\n    right = 0\n    curr_sum = 0\n    max_length = 0\n\n    while right < len(arr):\n        curr_sum += arr[right]\n\n        while curr_sum > target:\n            curr_sum -= arr[left]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n        right += 1\n\n    return max_length if max_length != 0 else -1", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9], 15", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, return True if the matrix is a magic square, and False otherwise.\n    A magic square is a square matrix in which the sums of the elements in each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[2, 9, 4],\n              [7, 5, 3],\n              [6, 1, 8]]\n    Output: True\n\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output: False\n    \"\"\"\n\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n\n        # Check rows\n        for row in matrix:\n            if sum(row) != target_sum:\n                return False\n\n        # Check columns\n        for j in range(n):\n            column_sum = 0\n            for i in range(n):\n                column_sum += matrix[i][j]\n            if column_sum != target_sum:\n                return False\n\n        # Check main diagonal\n        diagonal_sum = 0\n        for i in range(n):\n            diagonal_sum += matrix[i][i]\n        if diagonal_sum != target_sum:\n            return False\n\n        # Check secondary diagonal\n        diagonal_sum = 0\n        for i in range(n):\n            diagonal_sum += matrix[i][n - 1 - i]\n        if diagonal_sum != target_sum:\n            return False\n\n        return True\n\n    return is_magic_square(matrix)\n\ndef g() -> List[List[int]]:\n    return [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 446, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, return True if the matrix is a magic square, and False otherwise.\n    A magic square is a square matrix in which the sums of the elements in each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[2, 9, 4],\n              [7, 5, 3],\n              [6, 1, 8]]\n    Output: True\n\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    Output: False\n    \"\"\"\n\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n\n        # Check rows\n        for row in matrix:\n            if sum(row) != target_sum:\n                return False\n\n        # Check columns\n        for j in range(n):\n            column_sum = 0\n            for i in range(n):\n                column_sum += matrix[i][j]\n            if column_sum != target_sum:\n                return False\n\n        # Check main diagonal\n        diagonal_sum = 0\n        for i in range(n):\n            diagonal_sum += matrix[i][i]\n        if diagonal_sum != target_sum:\n            return False\n\n        # Check secondary diagonal\n        diagonal_sum = 0\n        for i in range(n):\n            diagonal_sum += matrix[i][n - 1 - i]\n        if diagonal_sum != target_sum:\n            return False\n\n        return True\n\n    return is_magic_square(matrix)", "solution_func": "def g() -> List[List[int]]:\n    return [[2, 9, 4], [7, 5, 3], [6, 1, 8]]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of characters and a word, return True if the word exists in the grid, and False otherwise.\n    The word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are horizontally or vertically neighboring.\n    The same letter cell may not be used more than once in a word.\n\n    Example:\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n    Output: True\n\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"SEE\"\n    Output: True\n\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCB\"\n    Output: False\n    \"\"\"\n\n    def exist(grid: List[List[str]], word: str) -> bool:\n        def dfs(i: int, j: int, k: int) -> bool:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            temp = grid[i][j]\n            grid[i][j] = ''\n            res = dfs(i - 1, j, k + 1) or dfs(i + 1, j, k + 1) or dfs(i, j - 1, k + 1) or dfs(i, j + 1, k + 1)\n            grid[i][j] = temp\n            return res\n\n        m = len(grid)\n        n = len(grid[0])\n\n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n\n        return False\n\n    return exist(grid, word)\n\ndef g() -> (List[List[str]], str):\n    return [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \"ABCCED\"\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 446, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]], word: str) -> bool:\n    \"\"\"\n    Given a 2D grid of characters and a word, return True if the word exists in the grid, and False otherwise.\n    The word can be constructed from letters of sequentially adjacent cells, where \"adjacent\" cells are horizontally or vertically neighboring.\n    The same letter cell may not be used more than once in a word.\n\n    Example:\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCCED\"\n    Output: True\n\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"SEE\"\n    Output: True\n\n    grid = [['A','B','C','E'],\n            ['S','F','C','S'],\n            ['A','D','E','E']]\n    word = \"ABCB\"\n    Output: False\n    \"\"\"\n\n    def exist(grid: List[List[str]], word: str) -> bool:\n        def dfs(i: int, j: int, k: int) -> bool:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            temp = grid[i][j]\n            grid[i][j] = ''\n            res = dfs(i - 1, j, k + 1) or dfs(i + 1, j, k + 1) or dfs(i, j - 1, k + 1) or dfs(i, j + 1, k + 1)\n            grid[i][j] = temp\n            return res\n\n        m = len(grid)\n        n = len(grid[0])\n\n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n\n        return False\n\n    return exist(grid, word)", "solution_func": "def g() -> (List[List[str]], str):\n    return [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \"ABCCED\"", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    The output should be sorted by the frequency from highest to lowest. If two words have the same frequency, sort them alphabetically.\n\n    Example:\n    words = [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"]\n    k = 4\n    Output: [\"the\", \"is\", \"sunny\", \"day\"]\n    \"\"\"\n\n    from collections import Counter\n\n    counter = Counter(words)\n\n    sorted_words = sorted(counter.keys(), key=lambda x: (-counter[x], x))\n\n    return sorted_words[:k]\n\ndef g() -> (List[str], int):\n    return [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], 4\n\nassert f(*g()) == [\"the\", \"is\", \"sunny\", \"day\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 446, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, return the k most frequent words in the list.\n    The output should be sorted by the frequency from highest to lowest. If two words have the same frequency, sort them alphabetically.\n\n    Example:\n    words = [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"]\n    k = 4\n    Output: [\"the\", \"is\", \"sunny\", \"day\"]\n    \"\"\"\n\n    from collections import Counter\n\n    counter = Counter(words)\n\n    sorted_words = sorted(counter.keys(), key=lambda x: (-counter[x], x))\n\n    return sorted_words[:k]", "solution_func": "def g() -> (List[str], int):\n    return [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], 4", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    queue = [start]\n    while queue:\n        current_node = queue.pop(0)\n        if current_node == end:\n            return True\n        visited.add(current_node)\n        if current_node in graph:\n            for neighbor in graph[current_node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False\n\ndef g(graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': ['F'], 'F': []}, start = 'A', end = 'F'):\n    return graph\n\nassert f(g(), 'A', 'F') == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 446, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List, Dict\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"Check if there is a path from the start node to the end node in the given graph.\"\"\"\n    visited = set()\n    queue = [start]\n    while queue:\n        current_node = queue.pop(0)\n        if current_node == end:\n            return True\n        visited.add(current_node)\n        if current_node in graph:\n            for neighbor in graph[current_node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False", "solution_func": "def g(graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E'], 'D': ['F'], 'E': ['F'], 'F': []}, start = 'A', end = 'F'):\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, check if the target number is present in the list using binary search.\n\n    Args:\n    - nums: A sorted list of integers\n    - target: The target number to search for\n\n    Returns:\n    - True if the target number is present in the list, False otherwise\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 447, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, check if the target number is present in the list using binary search.\n\n    Args:\n    - nums: A sorted list of integers\n    - target: The target number to search for\n\n    Returns:\n    - True if the target number is present in the list, False otherwise\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> float:\n    \"\"\"\n    Given a list of numbers, calculate the mean (average) of the numbers.\n\n    Args:\n    - nums: A list of numbers\n\n    Returns:\n    - The mean of the numbers\n    \"\"\"\n    return sum(nums) / len(nums)\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3.0\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 447, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> float:\n    \"\"\"\n    Given a list of numbers, calculate the mean (average) of the numbers.\n\n    Args:\n    - nums: A list of numbers\n\n    Returns:\n    - The mean of the numbers\n    \"\"\"\n    return sum(nums) / len(nums)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the Euclidean distance between the two closest points.\n\n    Args:\n    - points: A list of 2D points, where each point is represented as a list [x, y]\n\n    Returns:\n    - The Euclidean distance between the two closest points\n    \"\"\"\n    n = len(points)\n    min_distance = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            if distance < min_distance:\n                min_distance = distance\n\n    return min_distance\n\ndef g():\n    points = [[0, 0], [3, 4], [1, 1], [2, 2]]\n    return points\n\nassert f(g()) == 1.0\n\n", "emb": null, "idx_generation": 447, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(points: List[List[int]]) -> float:\n    \"\"\"\n    Given a list of 2D points, calculate the Euclidean distance between the two closest points.\n\n    Args:\n    - points: A list of 2D points, where each point is represented as a list [x, y]\n\n    Returns:\n    - The Euclidean distance between the two closest points\n    \"\"\"\n    n = len(points)\n    min_distance = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            if distance < min_distance:\n                min_distance = distance\n\n    return min_distance", "solution_func": "def g():\n    points = [[0, 0], [3, 4], [1, 1], [2, 2]]\n    return points", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there exists a pair of numbers in the list such that their XOR is equal to the target value.\n    \n    Example:\n    nums = [4, 5, 6, 7, 8]\n    target = 12\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a pair of numbers in the list, 4 and 8, such that their XOR is equal to the target value 12.\n    \"\"\"\n\n    def find_pair(nums, target, start, path, result):\n        if target == 0:\n            result[0] = True\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            find_pair(nums, target ^ nums[i], i + 1, path, result)\n            path.pop()\n\n    result = [False]\n    nums.sort()\n    find_pair(nums, target, 0, [], result)\n    return result[0]\n\ndef g() -> List[int]:\n    nums = [4, 5, 6, 7, 8]\n    target = 12\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 447, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers nums and a target value, determine if there exists a pair of numbers in the list such that their XOR is equal to the target value.\n    \n    Example:\n    nums = [4, 5, 6, 7, 8]\n    target = 12\n    \n    Output:\n    True\n    \n    Explanation:\n    There exists a pair of numbers in the list, 4 and 8, such that their XOR is equal to the target value 12.\n    \"\"\"\n\n    def find_pair(nums, target, start, path, result):\n        if target == 0:\n            result[0] = True\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            find_pair(nums, target ^ nums[i], i + 1, path, result)\n            path.pop()\n\n    result = [False]\n    nums.sort()\n    find_pair(nums, target, 0, [], result)\n    return result[0]", "solution_func": "def g() -> List[int]:\n    nums = [4, 5, 6, 7, 8]\n    target = 12\n    return nums, target", "map_ix": [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two numbers in the list.\n    \n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    Output:\n    28\n    \n    Explanation:\n    The maximum XOR value is 28, which is the result of XORing 5 and 25 from the list.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit] is not None:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(*g()) == 28\n\n", "emb": null, "idx_generation": 447, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two numbers in the list.\n    \n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    \n    Output:\n    28\n    \n    Explanation:\n    The maximum XOR value is 28, which is the result of XORing 5 and 25 from the list.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[1 - bit] is not None:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n    \n    Example:\n    nums = [1, 2, 3, 4]\n    \n    Output:\n    24\n    \n    Explanation:\n    The maximum product is 24, which is the result of multiplying 2, 3, and 4 from the list.\n    \"\"\"\n\n    def find_max_product(nums):\n        nums.sort()\n        n = len(nums)\n        return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1])\n\n    return find_max_product(nums)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(*g()) == 24\n\n", "emb": null, "idx_generation": 447, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n    \n    Example:\n    nums = [1, 2, 3, 4]\n    \n    Output:\n    24\n    \n    Explanation:\n    The maximum product is 24, which is the result of multiplying 2, 3, and 4 from the list.\n    \"\"\"\n\n    def find_max_product(nums):\n        nums.sort()\n        n = len(nums)\n        return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1])\n\n    return find_max_product(nums)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the missing number in the sequence.\n\n    The array is sorted in ascending order and contains unique numbers from 1 to n, except for one missing number.\n\n    Example:\n    arr = [1, 2, 4, 5, 6]\n    Output: 3\n    Explanation: The missing number in the sequence is 3.\n    \"\"\"\n\n    # Use binary search to find the missing number\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == mid + 1:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left + 1\n\ndef g():\n    return [1, 2, 4, 5, 6]\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 447, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of integers, find the missing number in the sequence.\n\n    The array is sorted in ascending order and contains unique numbers from 1 to n, except for one missing number.\n\n    Example:\n    arr = [1, 2, 4, 5, 6]\n    Output: 3\n    Explanation: The missing number in the sequence is 3.\n    \"\"\"\n\n    # Use binary search to find the missing number\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == mid + 1:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left + 1", "solution_func": "def g():\n    return [1, 2, 4, 5, 6]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a perfect square (4^2 = 16).\n    \"\"\"\n\n    # Use the mathematical property that the square root of a perfect square is an integer\n    return int(n ** 0.5) ** 2 == n\n\ndef g():\n    return 16\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 447, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "import math\nfrom typing import*\nfrom typing import List\n\ndef f(n: int) -> bool:\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a perfect square (4^2 = 16).\n    \"\"\"\n\n    # Use the mathematical property that the square root of a perfect square is an integer\n    return int(n ** 0.5) ** 2 == n", "solution_func": "def g():\n    return 16", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the sum of all numbers that are divisible by 3.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 18\n    Explanation: The numbers divisible by 3 in the grid are 3, 6, and 9. Their sum is 18.\n    \"\"\"\n\n    # Traverse the grid and sum up all numbers that are divisible by 3\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            if num % 3 == 0:\n                total_sum += num\n\n    return total_sum\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 18\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 447, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, calculate the sum of all numbers that are divisible by 3.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 18\n    Explanation: The numbers divisible by 3 in the grid are 3, 6, and 9. Their sum is 18.\n    \"\"\"\n\n    # Traverse the grid and sum up all numbers that are divisible by 3\n    total_sum = 0\n    for row in grid:\n        for num in row:\n            if num % 3 == 0:\n                total_sum += num\n\n    return total_sum", "solution_func": "def g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of combinations of three numbers from the list that add up to zero.\n\n    Example:\n    arr = [-1, 0, 1, 2, -1, -4]\n    Output: 2\n\n    Explanation:\n    The combinations that add up to zero are [-1, 0, 1] and [-1, -1, 2].\n\n    arr = [1, 2, 3, 4, 5]\n    Output: 0\n\n    Explanation:\n    There are no combinations that add up to zero.\n\n    \"\"\"\n\n    count = 0\n    n = len(arr)\n    \n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    count += 1\n\n    return count\n\ndef g(arr: List[int] = [-1, 0, 1, 2, -1, -4]):\n    return arr\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 447, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of combinations of three numbers from the list that add up to zero.\n\n    Example:\n    arr = [-1, 0, 1, 2, -1, -4]\n    Output: 2\n\n    Explanation:\n    The combinations that add up to zero are [-1, 0, 1] and [-1, -1, 2].\n\n    arr = [1, 2, 3, 4, 5]\n    Output: 0\n\n    Explanation:\n    There are no combinations that add up to zero.\n\n    \"\"\"\n\n    count = 0\n    n = len(arr)\n    \n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if arr[i] + arr[j] + arr[k] == 0:\n                    count += 1\n\n    return count", "solution_func": "def g(arr: List[int] = [-1, 0, 1, 2, -1, -4]):\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target value.\n    \"\"\"\n    target = 10\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a sorted list of integers where there exists a pair of numbers whose sum is equal to the target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there exists a pair of numbers whose sum is equal to the target value.\n    \"\"\"\n    target = 10\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target:\n            return True\n        elif arr[left] + arr[right] < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g():\n    \"\"\"\n    Generate a sorted list of integers where there exists a pair of numbers whose sum is equal to the target value.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number is a palindrome in base 2, base 8, and base 10.\n    \"\"\"\n    binary = bin(n)[2:]\n    octal = oct(n)[2:]\n    decimal = str(n)\n    \n    return binary == binary[::-1] and octal == octal[::-1] and decimal == decimal[::-1]\n\ndef g():\n    \"\"\"\n    Generate a number that is a palindrome in base 2, base 8, and base 10.\n    \"\"\"\n    return 585\n\nassert f(g())\n", "emb": [1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number is a palindrome in base 2, base 8, and base 10.\n    \"\"\"\n    binary = bin(n)[2:]\n    octal = oct(n)[2:]\n    decimal = str(n)\n    \n    return binary == binary[::-1] and octal == octal[::-1] and decimal == decimal[::-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a number that is a palindrome in base 2, base 8, and base 10.\n    \"\"\"\n    return 585", "map_ix": [1, 0, 0, 1, 1, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of all elements along the path is greater than or equal to a target value.\n    \"\"\"\n    target = 20\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1] >= target\n\ndef g():\n    \"\"\"\n    Generate a matrix of integers where there exists a path from the top-left corner to the bottom-right corner\n    where the sum of all elements along the path is greater than or equal to a target value.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g())\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, determine if there exists a path from the top-left corner to the bottom-right corner\n    where the sum of all elements along the path is greater than or equal to a target value.\n    \"\"\"\n    target = 20\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    return dp[rows-1][cols-1] >= target", "solution_func": "def g():\n    \"\"\"\n    Generate a matrix of integers where there exists a path from the top-left corner to the bottom-right corner\n    where the sum of all elements along the path is greater than or equal to a target value.\n    \"\"\"\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Args:\n        nums: A sorted list of integers.\n        target: The target value.\n\n    Returns:\n        The index of the target value in the list, or -1 if it is not found.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, right)\n\n    return binary_search(nums, target, 0, len(nums) - 1)\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Args:\n        nums: A sorted list of integers.\n        target: The target value.\n\n    Returns:\n        The index of the target value in the list, or -1 if it is not found.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9], target = 5\n    Output: 2\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: int, right: int) -> int:\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid - 1)\n        else:\n            return binary_search(nums, target, mid + 1, right)\n\n    return binary_search(nums, target, 0, len(nums) - 1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the number of increasing subarrays of length at least 2.\n\n    Args:\n        nums: A list of non-negative integers.\n\n    Returns:\n        The number of increasing subarrays of length at least 2.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 6\n\n    Explanation:\n    There are 6 increasing subarrays of length at least 2: [1, 2], [1, 2, 3], [1, 2, 3, 4], [2, 3], [2, 3, 4], [3, 4].\n    \"\"\"\n\n    count = 0\n    length = 2\n\n    for i in range(len(nums) - length + 1):\n        if nums[i+1] > nums[i]:\n            count += 1\n\n        for j in range(i + 2, len(nums)):\n            if nums[j] > nums[j-1]:\n                count += 1\n            else:\n                break\n\n    return count\n\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\n\nassert f(*g()) == 6\n\n", "emb": null, "idx_generation": 448, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, find the number of increasing subarrays of length at least 2.\n\n    Args:\n        nums: A list of non-negative integers.\n\n    Returns:\n        The number of increasing subarrays of length at least 2.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 6\n\n    Explanation:\n    There are 6 increasing subarrays of length at least 2: [1, 2], [1, 2, 3], [1, 2, 3, 4], [2, 3], [2, 3, 4], [3, 4].\n    \"\"\"\n\n    count = 0\n    length = 2\n\n    for i in range(len(nums) - length + 1):\n        if nums[i+1] > nums[i]:\n            count += 1\n\n        for j in range(i + 2, len(nums)):\n            if nums[j] > nums[j-1]:\n                count += 1\n            else:\n                break\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of non-negative integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers in the list.\n\n    Args:\n        nums: A list of non-negative integers.\n        target: The target value.\n\n    Returns:\n        The indices of the two numbers that sum up to the target value.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 ([2, 7]) sum up to the target value 9.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of non-negative integers and a target value, find two numbers in the list that sum up to the target value.\n    Return the indices of the two numbers in the list.\n\n    Args:\n        nums: A list of non-negative integers.\n        target: The target value.\n\n    Returns:\n        The indices of the two numbers that sum up to the target value.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The numbers at indices 0 and 1 ([2, 7]) sum up to the target value 9.\n    \"\"\"\n\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations of the integers that sum up to the target.\n    \"\"\"\n    def backtrack(start, curr_sum):\n        nonlocal count\n        if curr_sum == target:\n            count += 1\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, curr_sum + nums[i])\n    \n    count = 0\n    backtrack(0, 0)\n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target number, find the number of combinations of the integers that sum up to the target.\n    \"\"\"\n    def backtrack(start, curr_sum):\n        nonlocal count\n        if curr_sum == target:\n            count += 1\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, curr_sum + nums[i])\n    \n    count = 0\n    backtrack(0, 0)\n    return count", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3]\n    target = 4\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of connected islands in the grid.\n    Two cells are considered connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count\n\ndef g():\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the number of connected islands in the grid.\n    Two cells are considered connected if they are adjacent horizontally or vertically.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n        grid[i][j] = -1\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                count += 1\n                dfs(i, j)\n    \n    return count", "solution_func": "def g():\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings, determine if one is a substring of the other.\n    \"\"\"\n    if len(s) < len(t):\n        s, t = t, s\n    return t in s\n\ndef g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s = \"abcdefg\"\n    t = \"cde\"\n    return s, t\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings, determine if one is a substring of the other.\n    \"\"\"\n    if len(s) < len(t):\n        s, t = t, s\n    return t in s", "solution_func": "def g():\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    s = \"abcdefg\"\n    t = \"cde\"\n    return s, t", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subarray with the same number of even and odd elements,\n    and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 1, 3, 5]\n\n    The subarray [2, 4, 6, 1, 3] has 3 even elements and 2 odd elements, so the function should return True.\n\n    nums = [2, 4, 6, 1, 3]\n\n    The subarray [2, 4, 6] has 3 even elements and 0 odd elements, so the function should return False.\n    \"\"\"\n    count = 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count += 1\n        else:\n            count -= 1\n        \n        if count in count_map:\n            if i - count_map[count] > 1:\n                return True\n        else:\n            count_map[count] = i\n    \n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 6, 1, 3, 5]\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 448, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if there exists a subarray with the same number of even and odd elements,\n    and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 1, 3, 5]\n\n    The subarray [2, 4, 6, 1, 3] has 3 even elements and 2 odd elements, so the function should return True.\n\n    nums = [2, 4, 6, 1, 3]\n\n    The subarray [2, 4, 6] has 3 even elements and 0 odd elements, so the function should return False.\n    \"\"\"\n    count = 0\n    count_map = {0: -1}\n\n    for i, num in enumerate(nums):\n        if num % 2 == 0:\n            count += 1\n        else:\n            count -= 1\n        \n        if count in count_map:\n            if i - count_map[count] > 1:\n                return True\n        else:\n            count_map[count] = i\n    \n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 6, 1, 3, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int, arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, arr, find if there exists a subarray of length k such that the sum of its elements is divisible by n.\n    \"\"\"\n    prefix_sum = [0] * (len(arr) + 1)\n    for i in range(1, len(arr) + 1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    for i in range(k, len(arr) + 1):\n        if (prefix_sum[i] - prefix_sum[i-k]) % n == 0:\n            return True\n    return False\n\ndef g(arr: List[int], n: int, k: int):\n    return arr, n, k\n\nassert f(g())\n", "emb": null, "idx_generation": 449, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int, arr: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers, arr, find if there exists a subarray of length k such that the sum of its elements is divisible by n.\n    \"\"\"\n    prefix_sum = [0] * (len(arr) + 1)\n    for i in range(1, len(arr) + 1):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i-1]\n    for i in range(k, len(arr) + 1):\n        if (prefix_sum[i] - prefix_sum[i-k]) % n == 0:\n            return True\n    return False", "solution_func": "def g(arr: List[int], n: int, k: int):\n    return arr, n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = rows - 1, 0\n    while row >= 0 and col < cols:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            row -= 1\n    return False\n\ndef g(matrix: List[List[int]], target: int):\n    return matrix, target\n\nassert f(g())\n", "emb": null, "idx_generation": 449, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a 2D matrix of integers and a target value, determine if the target value exists in the matrix.\n    The matrix is sorted row-wise and column-wise in ascending order.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return False\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = rows - 1, 0\n    while row >= 0 and col < cols:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            row -= 1\n    return False", "solution_func": "def g(matrix: List[List[int]], target: int):\n    return matrix, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase.\n    You can climb 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef g(n: int):\n    return n\n\nassert f(g())\n", "emb": null, "idx_generation": 449, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase.\n    You can climb 1 or 2 steps at a time.\n    \"\"\"\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]", "solution_func": "def g(n: int):\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the square of the corresponding element in the input list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 4, 9, 16, 25]\n\n    Hint: Use list comprehension to iterate through the input list and calculate the square of each element.\n    \"\"\"\n\n    return [num ** 2 for num in nums]\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == [1, 4, 9, 16, 25]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 449, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the square of the corresponding element in the input list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 4, 9, 16, 25]\n\n    Hint: Use list comprehension to iterate through the input list and calculate the square of each element.\n    \"\"\"\n\n    return [num ** 2 for num in nums]", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There are two numbers in the list, 3 and 4, that add up to the target number 7.\n\n    Hint: Use two pointers, one starting from the beginning of the list and the other starting from the end.\n    Move the pointers towards each other and check if the sum of the numbers at the pointers is equal to the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 449, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Explanation: There are two numbers in the list, 3 and 4, that add up to the target number 7.\n\n    Hint: Use two pointers, one starting from the beginning of the list and the other starting from the end.\n    Move the pointers towards each other and check if the sum of the numbers at the pointers is equal to the target.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=7):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"world hello\"\n\n    Hint: Use string split to split the string into words, reverse the list of words, and join them back into a string.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n\ndef g(s=\"hello world\"):\n    return s\n\nassert f(g()) == \"world hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 449, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of the words in the string.\n\n    Example:\n    Input: s = \"hello world\"\n    Output: \"world hello\"\n\n    Hint: Use string split to split the string into words, reverse the list of words, and join them back into a string.\n    \"\"\"\n\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "solution_func": "def g(s=\"hello world\"):\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return all unique combinations of numbers from the array that sum up to the target.\n    The same number may be chosen from the array an unlimited number of times.\n    The combinations should be returned in ascending order.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], curr_sum: int) -> None:\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, path + [nums[i]], curr_sum + nums[i])\n\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return (nums, target)\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 449, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target integer, return all unique combinations of numbers from the array that sum up to the target.\n    The same number may be chosen from the array an unlimited number of times.\n    The combinations should be returned in ascending order.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], curr_sum: int) -> None:\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i, path + [nums[i]], curr_sum + nums[i])\n\n    result = []\n    nums.sort()\n    backtrack(0, [], 0)\n    return result", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[int]:\n    \"\"\"\n    Given a string s and a list of words, return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, without any intervening characters.\n    You may return the answer in any order.\n    \"\"\"\n\n    def backtrack(start: int, path: List[str]) -> None:\n        if len(path) == len(words):\n            if s[start:].startswith(\"\".join(path)):\n                result.append(start)\n            return\n        for i in range(len(words)):\n            if words[i] not in path:\n                backtrack(start, path + [words[i]])\n    \n    result = []\n    backtrack(0, [])\n    return result\n\ndef g():\n    s = \"barfoothefoobarman\"\n    words = [\"foo\", \"bar\"]\n    return (s, words)\n\nassert f(*g()) == [0, 9]\n", "emb": null, "idx_generation": 449, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, words: List[str]) -> List[int]:\n    \"\"\"\n    Given a string s and a list of words, return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, without any intervening characters.\n    You may return the answer in any order.\n    \"\"\"\n\n    def backtrack(start: int, path: List[str]) -> None:\n        if len(path) == len(words):\n            if s[start:].startswith(\"\".join(path)):\n                result.append(start)\n            return\n        for i in range(len(words)):\n            if words[i] not in path:\n                backtrack(start, path + [words[i]])\n    \n    result = []\n    backtrack(0, [])\n    return result", "solution_func": "def g():\n    s = \"barfoothefoobarman\"\n    words = [\"foo\", \"bar\"]\n    return (s, words)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array nums and a target value, return the number of non-empty subsequences of the array such that the sum of the minimum and maximum element on it is less or equal to target.\n    Since the answer may be too large, return it modulo 10^9 + 7.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], curr_min: int, curr_max: int) -> None:\n        if start > len(nums):\n            return\n        if curr_max - curr_min <= target:\n            result.add(tuple(path))\n        for i in range(start, len(nums)):\n            if nums[i] >= curr_min and nums[i] <= curr_max:\n                backtrack(i + 1, path + [nums[i]], min(curr_min, nums[i]), max(curr_max, nums[i]))\n\n    result = set()\n    nums.sort()\n    backtrack(0, [], float('inf'), float('-inf'))\n    return len(result) % (10**9 + 7)\n\ndef g():\n    nums = [3, 5, 6, 7]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 449, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given an array nums and a target value, return the number of non-empty subsequences of the array such that the sum of the minimum and maximum element on it is less or equal to target.\n    Since the answer may be too large, return it modulo 10^9 + 7.\n    \"\"\"\n\n    def backtrack(start: int, path: List[int], curr_min: int, curr_max: int) -> None:\n        if start > len(nums):\n            return\n        if curr_max - curr_min <= target:\n            result.add(tuple(path))\n        for i in range(start, len(nums)):\n            if nums[i] >= curr_min and nums[i] <= curr_max:\n                backtrack(i + 1, path + [nums[i]], min(curr_min, nums[i]), max(curr_max, nums[i]))\n\n    result = set()\n    nums.sort()\n    backtrack(0, [], float('inf'), float('-inf'))\n    return len(result) % (10**9 + 7)", "solution_func": "def g():\n    nums = [3, 5, 6, 7]\n    target = 9\n    return (nums, target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer,\n    return the index of the target if it is found in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 7\n\n    The target number 7 is found at index 3, so the function should return 3.\n\n    Hint: Use binary search to find the target number.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums = [1, 2, 4, 7, 11, 15], target = 7):\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 449, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer,\n    return the index of the target if it is found in the list.\n    If the target is not found, return -1.\n\n    Example:\n    nums = [1, 2, 4, 7, 11, 15]\n    target = 7\n\n    The target number 7 is found at index 3, so the function should return 3.\n\n    Hint: Use binary search to find the target number.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums = [1, 2, 4, 7, 11, 15], target = 7):\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of all the odd numbers.\n    \"\"\"\n    queue = []\n    for num in nums:\n        if num % 2 != 0:\n            queue.append(num ** 2)\n    return sum(queue)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g()) == 84\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 450, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\nimport math\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of the squares of all the odd numbers.\n    \"\"\"\n    queue = []\n    for num in nums:\n        if num % 2 != 0:\n            queue.append(num ** 2)\n    return sum(queue)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the product of all the even numbers.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num % 2 == 0:\n            stack.append(num)\n    product = 1\n    while stack:\n        product *= stack.pop()\n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [2, 4, 6, 8, 10]\n\nassert f(g()) == 3840\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 450, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the product of all the even numbers.\n    \"\"\"\n    stack = []\n    for num in nums:\n        if num % 2 == 0:\n            stack.append(num)\n    product = 1\n    while stack:\n        product *= stack.pop()\n    return product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of random integers.\n    \"\"\"\n    return [2, 4, 6, 8, 10]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words and capitalize the first letter of each word.\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            if word:\n                stack.append(word)\n                word = \"\"\n        else:\n            word += char\n    if word:\n        stack.append(word)\n    reversed_words = [word[::-1].capitalize() for word in stack[::-1]]\n    return \" \".join(reversed_words)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string with words in random order.\n    \"\"\"\n    return \"hello world my name is\"\n\nassert f(g()) == \"Si eman ym dlrow olleh\"\n", "emb": null, "idx_generation": 450, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words and capitalize the first letter of each word.\n    \"\"\"\n    stack = []\n    word = \"\"\n    for char in s:\n        if char == \" \":\n            if word:\n                stack.append(word)\n                word = \"\"\n        else:\n            word += char\n    if word:\n        stack.append(word)\n    reversed_words = [word[::-1].capitalize() for word in stack[::-1]]\n    return \" \".join(reversed_words)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string with words in random order.\n    \"\"\"\n    return \"hello world my name is\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 450, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    Each step can either move down or right.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]\n\ndef g():\n    return 3\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 450, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of unique paths from the top-left corner to the bottom-right corner of a n x n grid.\n    Each step can either move down or right.\n    \"\"\"\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[n-1][n-1]", "solution_func": "def g():\n    return 3", "map_ix": [1, 1, 1, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix with dimensions at most 2 x 2.\n    Return the maximum sum.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    max_sum = float('-inf')\n    for i in range(n-1):\n        for j in range(m-1):\n            curr_sum = matrix[i][j] + matrix[i][j+1] + matrix[i+1][j] + matrix[i+1][j+1]\n            max_sum = max(max_sum, curr_sum)\n    return max_sum\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 30\n\n", "emb": null, "idx_generation": 450, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a submatrix with dimensions at most 2 x 2.\n    Return the maximum sum.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    max_sum = float('-inf')\n    for i in range(n-1):\n        for j in range(m-1):\n            curr_sum = matrix[i][j] + matrix[i][j+1] + matrix[i+1][j] + matrix[i+1][j+1]\n            max_sum = max(max_sum, curr_sum)\n    return max_sum", "solution_func": "def g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, where each cell contains a non-negative integer, calculate the sum of all the elements in the grid.\n\n    Sample Input:\n    n = 3\n    m = 4\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n\n    Sample Output:\n    78\n\n    Explanation: The sum of all the elements in the grid is 1+2+3+4+5+6+7+8+9+10+11+12 = 78.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    return total_sum\n\ndef g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x m with random non-negative integer values.\n    \"\"\"\n    n = 3\n    m = 4\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n    return n, m, grid\n\nassert f(*g()) == 78\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 450, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, where each cell contains a non-negative integer, calculate the sum of all the elements in the grid.\n\n    Sample Input:\n    n = 3\n    m = 4\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n\n    Sample Output:\n    78\n\n    Explanation: The sum of all the elements in the grid is 1+2+3+4+5+6+7+8+9+10+11+12 = 78.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    return total_sum", "solution_func": "def g() -> Tuple[int, int, List[List[int]]]:\n    \"\"\"\n    Generate a grid of size n x m with random non-negative integer values.\n    \"\"\"\n    n = 3\n    m = 4\n    grid = [\n        [1, 2, 3, 4],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12]\n    ]\n    return n, m, grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, determine if there exists a cycle in the graph.\n\n    Sample Input:\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n\n    Sample Output:\n    True\n\n    Explanation: The graph has a cycle: 1->2->3->4->1.\n    \"\"\"\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    visited = [False] * (n + 1)\n    stack = [False] * (n + 1)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False\n\ndef g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a random graph with a certain number of nodes and edges.\n    \"\"\"\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, edges\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 450, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(n: int, edges: List[List[int]]) -> bool:\n    \"\"\"\n    Given a number of nodes n and a list of edges connecting the nodes, determine if there exists a cycle in the graph.\n\n    Sample Input:\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n\n    Sample Output:\n    True\n\n    Explanation: The graph has a cycle: 1->2->3->4->1.\n    \"\"\"\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    visited = [False] * (n + 1)\n    stack = [False] * (n + 1)\n\n    def dfs(node):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif stack[neighbor]:\n                return True\n\n        stack[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i):\n                return True\n\n    return False", "solution_func": "def g() -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Generate a random graph with a certain number of nodes and edges.\n    \"\"\"\n    n = 4\n    edges = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    return n, edges", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import Tuple\n\ndef f(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Given three positive integers a, b, and c, calculate the value of (a^b) % c, where ^ denotes exponentiation.\n\n    Sample Input:\n    a = 3\n    b = 4\n    c = 5\n\n    Sample Output:\n    1\n\n    Explanation: (3^4) % 5 = 81 % 5 = 1.\n    \"\"\"\n    return pow(a, b, c)\n\ndef g() -> Tuple[int, int, int]:\n    \"\"\"\n    Generate three positive integers a, b, and c with random values.\n    \"\"\"\n    a = 3\n    b = 4\n    c = 5\n    return a, b, c\n\nassert f(*g()) == 1\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 450, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import Tuple\n\ndef f(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Given three positive integers a, b, and c, calculate the value of (a^b) % c, where ^ denotes exponentiation.\n\n    Sample Input:\n    a = 3\n    b = 4\n    c = 5\n\n    Sample Output:\n    1\n\n    Explanation: (3^4) % 5 = 81 % 5 = 1.\n    \"\"\"\n    return pow(a, b, c)", "solution_func": "def g() -> Tuple[int, int, int]:\n    \"\"\"\n    Generate three positive integers a, b, and c with random values.\n    \"\"\"\n    a = 3\n    b = 4\n    c = 5\n    return a, b, c", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations of numbers in nums that add up to the target.\n    Each number in nums may only be used once in each combination.\n    Return a list of lists containing the combinations in ascending order.\n    \"\"\"\n    def backtrack(start: int, remain: int, path: List[int]) -> None:\n        if remain == 0:\n            combinations.append(path)\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > remain:\n                break\n            backtrack(i + 1, remain - nums[i], path + [nums[i]])\n\n    nums.sort()\n    combinations = []\n    backtrack(0, target, [])\n    return combinations\n\ndef g():\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return (nums, target)\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 450, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find all unique combinations of numbers in nums that add up to the target.\n    Each number in nums may only be used once in each combination.\n    Return a list of lists containing the combinations in ascending order.\n    \"\"\"\n    def backtrack(start: int, remain: int, path: List[int]) -> None:\n        if remain == 0:\n            combinations.append(path)\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > remain:\n                break\n            backtrack(i + 1, remain - nums[i], path + [nums[i]])\n\n    nums.sort()\n    combinations = []\n    backtrack(0, target, [])\n    return combinations", "solution_func": "def g():\n    nums = [10, 1, 2, 7, 6, 1, 5]\n    target = 8\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, count: int) -> bool:\n    \"\"\"\n    Given a list of positive integers, find if there exists a subsequence of length `count` whose sum is equal to `target`.\n    The subsequence does not have to be contiguous.\n\n    For example, if the list is [1, 2, 3, 4, 5] and the target is 9 with count 3,\n    we can choose the subsequence [2, 3, 4] whose sum is 9.\n    \"\"\"\n    def helper(nums, target, count, curr_sum, curr_count, start):\n        if curr_sum == target and curr_count == count:\n            return True\n        if curr_sum > target or curr_count > count:\n            return False\n        for i in range(start, len(nums)):\n            if helper(nums, target, count, curr_sum + nums[i], curr_count + 1, i + 1):\n                return True\n        return False\n\n    return helper(nums, target, count, 0, 0, 0)\n\ndef g(nums=[1, 2, 3, 4, 5], target=9, count=3):\n    \"\"\"\n    Generate a list of positive integers such that there exists a subsequence of length `count` whose sum is equal to `target`.\n    The subsequence does not have to be contiguous.\n    \"\"\"\n    return nums\n\nassert f(g())\n", "emb": null, "idx_generation": 451, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int, count: int) -> bool:\n    \"\"\"\n    Given a list of positive integers, find if there exists a subsequence of length `count` whose sum is equal to `target`.\n    The subsequence does not have to be contiguous.\n\n    For example, if the list is [1, 2, 3, 4, 5] and the target is 9 with count 3,\n    we can choose the subsequence [2, 3, 4] whose sum is 9.\n    \"\"\"\n    def helper(nums, target, count, curr_sum, curr_count, start):\n        if curr_sum == target and curr_count == count:\n            return True\n        if curr_sum > target or curr_count > count:\n            return False\n        for i in range(start, len(nums)):\n            if helper(nums, target, count, curr_sum + nums[i], curr_count + 1, i + 1):\n                return True\n        return False\n\n    return helper(nums, target, count, 0, 0, 0)", "solution_func": "def g(nums=[1, 2, 3, 4, 5], target=9, count=3):\n    \"\"\"\n    Generate a list of positive integers such that there exists a subsequence of length `count` whose sum is equal to `target`.\n    The subsequence does not have to be contiguous.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n: int, target: str) -> bool:\n    \"\"\"\n    Given a string `s`, find the shortest substring that contains all characters of `target` at least `n` times.\n\n    For example, if `s` is \"abcabcabc\" and `target` is \"abc\" with `n` equal to 3,\n    the shortest substring that satisfies the condition is \"abcabcabc\" itself.\n    \"\"\"\n    def check_counts(counts, target_counts):\n        for c in target_counts:\n            if counts[c] < target_counts[c]:\n                return False\n        return True\n\n    target_counts = {}\n    for c in target:\n        if c not in target_counts:\n            target_counts[c] = 0\n        target_counts[c] += 1\n\n    counts = {}\n    start = 0\n    min_len = float('inf')\n    min_substring = \"\"\n\n    for i in range(len(s)):\n        if s[i] not in counts:\n            counts[s[i]] = 0\n        counts[s[i]] += 1\n\n        while check_counts(counts, target_counts):\n            if i - start + 1 < min_len:\n                min_len = i - start + 1\n                min_substring = s[start:i+1]\n            counts[s[start]] -= 1\n            start += 1\n\n    return min_substring\n\ndef g(s=\"abcabcabc\", n=3, target=\"abc\"):\n    \"\"\"\n    Generate a string such that the shortest substring that contains all characters of `target` at least `n` times.\n    \"\"\"\n    return s\n\nassert f(g())\n", "emb": null, "idx_generation": 451, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, n: int, target: str) -> bool:\n    \"\"\"\n    Given a string `s`, find the shortest substring that contains all characters of `target` at least `n` times.\n\n    For example, if `s` is \"abcabcabc\" and `target` is \"abc\" with `n` equal to 3,\n    the shortest substring that satisfies the condition is \"abcabcabc\" itself.\n    \"\"\"\n    def check_counts(counts, target_counts):\n        for c in target_counts:\n            if counts[c] < target_counts[c]:\n                return False\n        return True\n\n    target_counts = {}\n    for c in target:\n        if c not in target_counts:\n            target_counts[c] = 0\n        target_counts[c] += 1\n\n    counts = {}\n    start = 0\n    min_len = float('inf')\n    min_substring = \"\"\n\n    for i in range(len(s)):\n        if s[i] not in counts:\n            counts[s[i]] = 0\n        counts[s[i]] += 1\n\n        while check_counts(counts, target_counts):\n            if i - start + 1 < min_len:\n                min_len = i - start + 1\n                min_substring = s[start:i+1]\n            counts[s[start]] -= 1\n            start += 1\n\n    return min_substring", "solution_func": "def g(s=\"abcabcabc\", n=3, target=\"abc\"):\n    \"\"\"\n    Generate a string such that the shortest substring that contains all characters of `target` at least `n` times.\n    \"\"\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum number of moves required to reach the bottom-right corner\n    from the top-left corner. You can only move down or right.\n\n    For example, if the grid is [[1, 3, 1], [1, 5, 1], [4, 2, 1]],\n    the minimum number of moves required is 7: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a 2D grid of integers such that the minimum number of moves required to reach the bottom-right corner\n    from the top-left corner is maximum.\n    \"\"\"\n    return grid\n\nassert f(g())\n", "emb": null, "idx_generation": 451, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Given a 2D grid of integers, find the minimum number of moves required to reach the bottom-right corner\n    from the top-left corner. You can only move down or right.\n\n    For example, if the grid is [[1, 3, 1], [1, 5, 1], [4, 2, 1]],\n    the minimum number of moves required is 7: 1 -> 3 -> 1 -> 1 -> 1.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    \"\"\"\n    Generate a 2D grid of integers such that the minimum number of moves required to reach the bottom-right corner\n    from the top-left corner is maximum.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs that sum up to a target value.\n    Return the count of distinct pairs.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The distinct pairs that sum up to 6 are (1, 5), (2, 4), and (3, 3).\n\n    Therefore, the function should return 3.\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            count += 1\n        seen.add(num)\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 451, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct pairs that sum up to a target value.\n    Return the count of distinct pairs.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    The distinct pairs that sum up to 6 are (1, 5), (2, 4), and (3, 3).\n\n    Therefore, the function should return 3.\n    \"\"\"\n    count = 0\n    seen = set()\n\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            count += 1\n        seen.add(num)\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the values of the elements in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements visited in a clockwise spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    result = []\n\n    while top <= bottom and left <= right:\n        # Traverse the top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        # Traverse the right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse the bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse the left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 451, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the values of the elements in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    The elements visited in a clockwise spiral order are [1, 2, 3, 6, 9, 8, 7, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 6, 9, 8, 7, 4, 5].\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    result = []\n\n    while top <= bottom and left <= right:\n        # Traverse the top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        # Traverse the right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse the bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse the left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the same elements, but in reverse order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The reverse of the list is [5, 4, 3, 2, 1].\n\n    Therefore, the function should return [5, 4, 3, 2, 1].\n    \"\"\"\n    return nums[::-1]\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [5, 4, 3, 2, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with the same elements, but in reverse order.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The reverse of the list is [5, 4, 3, 2, 1].\n\n    Therefore, the function should return [5, 4, 3, 2, 1].\n    \"\"\"\n    return nums[::-1]", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any subarray.\n\n    Example:\n    Input: [1, -2, 3, 4, -5, 6]\n    Output: 10\n\n    Explanation:\n    The subarray with the maximum sum is [3, 4, -5, 6].\n\n    Therefore, the function should return 10.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        max_sum = max(max_sum, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\ndef g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6]\n\nassert f(g()) == 10\n\n", "emb": null, "idx_generation": 451, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any subarray.\n\n    Example:\n    Input: [1, -2, 3, 4, -5, 6]\n    Output: 10\n\n    Explanation:\n    The subarray with the maximum sum is [3, 4, -5, 6].\n\n    Therefore, the function should return 10.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        max_sum = max(max_sum, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    return [1, -2, 3, 4, -5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subarray.\n\n    Example:\n    Input: [1, 2, 3, 2, 4, 5, 6]\n    Output: 4\n\n    Explanation:\n    The longest increasing subarray is [2, 4, 5, 6].\n\n    Therefore, the function should return 4.\n    \"\"\"\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n\n    return max_length\n\ndef g() -> List[int]:\n    return [1, 2, 3, 2, 4, 5, 6]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subarray.\n\n    Example:\n    Input: [1, 2, 3, 2, 4, 5, 6]\n    Output: 4\n\n    Explanation:\n    The longest increasing subarray is [2, 4, 5, 6].\n\n    Therefore, the function should return 4.\n    \"\"\"\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n\n    return max_length", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 2, 4, 5, 6]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest common prefix among all the elements.\n\n    Example:\n    Input: [\"flower\", \"flow\", \"flight\"]\n    Output: 2\n\n    Explanation:\n    The longest common prefix is \"fl\".\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    min_length = float('inf')\n    for word in nums:\n        min_length = min(min_length, len(word))\n\n    longest_prefix = \"\"\n    for i in range(min_length):\n        char = nums[0][i]\n        for j in range(1, len(nums)):\n            if nums[j][i] != char:\n                return len(longest_prefix)\n        longest_prefix += char\n\n    return len(longest_prefix)\n\ndef g() -> List[int]:\n    return [\"flower\", \"flow\", \"flight\"]\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest common prefix among all the elements.\n\n    Example:\n    Input: [\"flower\", \"flow\", \"flight\"]\n    Output: 2\n\n    Explanation:\n    The longest common prefix is \"fl\".\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    min_length = float('inf')\n    for word in nums:\n        min_length = min(min_length, len(word))\n\n    longest_prefix = \"\"\n    for i in range(min_length):\n        char = nums[0][i]\n        for j in range(1, len(nums)):\n            if nums[j][i] != char:\n                return len(longest_prefix)\n        longest_prefix += char\n\n    return len(longest_prefix)", "solution_func": "def g() -> List[int]:\n    return [\"flower\", \"flow\", \"flight\"]", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the squares of all the positive integers less than or equal to n.\n\n    Example:\n    n = 5\n    Output: 55\n    Explanation: The sum of the squares of numbers less than or equal to 5 is 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55.\n\n    Constraints:\n    - n will be a positive integer.\n    \"\"\"\n    return sum([i**2 for i in range(1, n+1)])\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5\n\nassert f(g()) == 55\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 451, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of the squares of all the positive integers less than or equal to n.\n\n    Example:\n    n = 5\n    Output: 55\n    Explanation: The sum of the squares of numbers less than or equal to 5 is 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55.\n\n    Constraints:\n    - n will be a positive integer.\n    \"\"\"\n    return sum([i**2 for i in range(1, n+1)])", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n.\n    \"\"\"\n    return 5", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3, m = 4\n    Output: 10\n    Explanation: There are 10 unique paths to reach the bottom-right corner.\n    \"\"\"\n\n    def unique_paths(n: int, m: int) -> int:\n        if n == 1 or m == 1:\n            return 1\n        return unique_paths(n - 1, m) + unique_paths(n, m - 1)\n\n    return unique_paths(n, m)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate two integers n and m.\n    \"\"\"\n    return [3, 4]\n\nassert f(*g()) == 10\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int) -> int:\n    \"\"\"\n    Given two integers n and m, find the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid.\n    You can only move down or right at any point in time.\n\n    Example:\n    Input: n = 3, m = 4\n    Output: 10\n    Explanation: There are 10 unique paths to reach the bottom-right corner.\n    \"\"\"\n\n    def unique_paths(n: int, m: int) -> int:\n        if n == 1 or m == 1:\n            return 1\n        return unique_paths(n - 1, m) + unique_paths(n, m - 1)\n\n    return unique_paths(n, m)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate two integers n and m.\n    \"\"\"\n    return [3, 4]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    \"\"\"\n\n    def backtrack(nums: List[int], path: List[int], result: List[List[int]]) -> None:\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(nums, path, result)\n                path.pop()\n\n    result = []\n    backtrack(nums, [], result)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]\n\nassert f(g()) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, return all possible permutations of the numbers.\n\n    Example:\n    Input: nums = [1, 2, 3]\n    Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    \"\"\"\n\n    def backtrack(nums: List[int], path: List[int], result: List[List[int]]) -> None:\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(nums, path, result)\n                path.pop()\n\n    result = []\n    backtrack(nums, [], result)\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all unique combinations in the list where the selected numbers sum to the target.\n    The same number can be chosen from the list multiple times.\n    The combinations should be in ascending order.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, path: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(path[:])\n            return\n        if target < 0:\n            return\n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(nums[i:], target - nums[i], path, result)\n            path.pop()\n\n    result = []\n    backtrack(nums, target, [], result)\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return [2, 3, 6, 7], 7\n\nassert f(*g()) == [[2, 2, 3], [7]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target number, find all unique combinations in the list where the selected numbers sum to the target.\n    The same number can be chosen from the list multiple times.\n    The combinations should be in ascending order.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    \"\"\"\n\n    def backtrack(nums: List[int], target: int, path: List[int], result: List[List[int]]) -> None:\n        if target == 0:\n            result.append(path[:])\n            return\n        if target < 0:\n            return\n        for i in range(len(nums)):\n            path.append(nums[i])\n            backtrack(nums[i:], target - nums[i], path, result)\n            path.pop()\n\n    result = []\n    backtrack(nums, target, [], result)\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    return [2, 3, 6, 7], 7", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n    Explanation: The maximum product can be obtained by multiplying 2, 3, and 4.\n\n    \"\"\"\n\n    nums.sort()\n\n    # Case 1: All positive numbers\n    max_product = nums[-1] * nums[-2] * nums[-3]\n\n    # Case 2: Two negative numbers and one positive number\n    if nums[0] < 0 and nums[1] < 0:\n        max_product = max(max_product, nums[0] * nums[1] * nums[-1])\n\n    return max_product\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n    Explanation: The maximum product can be obtained by multiplying 2, 3, and 4.\n\n    \"\"\"\n\n    nums.sort()\n\n    # Case 1: All positive numbers\n    max_product = nums[-1] * nums[-2] * nums[-3]\n\n    # Case 2: Two negative numbers and one positive number\n    if nums[0] < 0 and nums[1] < 0:\n        max_product = max(max_product, nums[0] * nums[1] * nums[-1])\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i, char in enumerate(s):\n        # If the character is already in the map and its index is greater than or equal to the start index\n        # Update the start index to the index of the repeated character + 1\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n\n        # Update the index of the current character in the map\n        char_map[char] = i\n\n        # Update the maximum length if the current substring length is greater\n        max_length = max(max_length, i - start + 1)\n\n    return max_length\n\ndef g() -> str:\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n\n    \"\"\"\n\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for i, char in enumerate(s):\n        # If the character is already in the map and its index is greater than or equal to the start index\n        # Update the start index to the index of the repeated character + 1\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n\n        # Update the index of the current character in the map\n        char_map[char] = i\n\n        # Update the maximum length if the current substring length is greater\n        max_length = max(max_length, i - start + 1)\n\n    return max_length", "solution_func": "def g() -> str:\n    return \"abcabcbb\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return [num_map[complement], i]\n\n        num_map[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 452, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers as a list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: The numbers at indices 0 and 1 (2 and 7) add up to the target value of 9.\n\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return [num_map[complement], i]\n\n        num_map[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the one at that index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The output should be [24, 12, 8, 6], since:\n    - The product of all elements except the first one is 2 * 3 * 4 = 24\n    - The product of all elements except the second one is 1 * 3 * 4 = 12\n    - The product of all elements except the third one is 1 * 2 * 4 = 8\n    - The product of all elements except the fourth one is 1 * 2 * 3 = 6\n\n    Return the new list as the result.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    result = [1] * n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 452, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the elements in the original list except the one at that index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The output should be [24, 12, 8, 6], since:\n    - The product of all elements except the first one is 2 * 3 * 4 = 24\n    - The product of all elements except the second one is 1 * 3 * 4 = 12\n    - The product of all elements except the third one is 1 * 2 * 4 = 8\n    - The product of all elements except the fourth one is 1 * 2 * 3 = 6\n\n    Return the new list as the result.\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    result = [1] * n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two distinct numbers in the list whose XOR is equal to the target.\n\n    Return the pair of numbers as a list, or an empty list if no such pair exists.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    The XOR of 2 and 4 is 6, so the output should be [2, 4].\n\n    Return the pair of numbers as the result, or an empty list if no such pair exists.\n    \"\"\"\n    xor_set = set()\n    result = []\n\n    for num in nums:\n        complement = target ^ num\n        if complement in xor_set:\n            result = [num, complement]\n            break\n        xor_set.add(num)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == [2, 4]\n\n", "emb": null, "idx_generation": 452, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two distinct numbers in the list whose XOR is equal to the target.\n\n    Return the pair of numbers as a list, or an empty list if no such pair exists.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    The XOR of 2 and 4 is 6, so the output should be [2, 4].\n\n    Return the pair of numbers as the result, or an empty list if no such pair exists.\n    \"\"\"\n    xor_set = set()\n    result = []\n\n    for num in nums:\n        complement = target ^ num\n        if complement in xor_set:\n            result = [num, complement]\n            break\n        xor_set.add(num)\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the next permutation in lexicographic order.\n\n    If the input list is the last permutation, return the first permutation.\n\n    Example:\n    nums = [1, 2, 3]\n    The next permutation is [1, 3, 2], since it is the smallest permutation greater than the original list [1, 2, 3].\n\n    Return the next permutation as the result.\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n\n    # Find the first decreasing element from the right\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = n - 1\n        # Find the first element greater than the decreasing element\n        while j >= 0 and nums[i] >= nums[j]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    # Reverse the suffix after the decreasing element\n    left = i + 1\n    right = n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [1, 3, 2]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 452, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the next permutation in lexicographic order.\n\n    If the input list is the last permutation, return the first permutation.\n\n    Example:\n    nums = [1, 2, 3]\n    The next permutation is [1, 3, 2], since it is the smallest permutation greater than the original list [1, 2, 3].\n\n    Return the next permutation as the result.\n    \"\"\"\n    n = len(nums)\n    i = n - 2\n\n    # Find the first decreasing element from the right\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        j = n - 1\n        # Find the first element greater than the decreasing element\n        while j >= 0 and nums[i] >= nums[j]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n\n    # Reverse the suffix after the decreasing element\n    left = i + 1\n    right = n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [1, 2, 3]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, check if there exists a Hamiltonian path in the graph.\n    A Hamiltonian path is a path in a graph that visits each vertex exactly once.\n    \"\"\"\n\n    def backtrack(curr_node, visited, num_visited):\n        \"\"\"\n        Helper function to perform backtracking to find a Hamiltonian path.\n        \"\"\"\n        if num_visited == len(matrix):\n            return True\n        \n        for next_node in range(len(matrix)):\n            if matrix[curr_node][next_node] == 1 and not visited[next_node]:\n                visited[next_node] = True\n                if backtrack(next_node, visited, num_visited + 1):\n                    return True\n                visited[next_node] = False\n        \n        return False\n\n    # Initialize visited array\n    visited = [False] * len(matrix)\n\n    # Start the backtracking from each vertex\n    for start_node in range(len(matrix)):\n        visited[start_node] = True\n        if backtrack(start_node, visited, 1):\n            return True\n        visited[start_node] = False\n    \n    return False\n\ndef g():\n    \"\"\"\n    Generate a random adjacency matrix for a directed graph with 4 vertices.\n    \"\"\"\n    return [[0, 1, 1, 0],\n            [1, 0, 0, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0]]\n    \nassert f(g())\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 452, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix of a directed graph, check if there exists a Hamiltonian path in the graph.\n    A Hamiltonian path is a path in a graph that visits each vertex exactly once.\n    \"\"\"\n\n    def backtrack(curr_node, visited, num_visited):\n        \"\"\"\n        Helper function to perform backtracking to find a Hamiltonian path.\n        \"\"\"\n        if num_visited == len(matrix):\n            return True\n        \n        for next_node in range(len(matrix)):\n            if matrix[curr_node][next_node] == 1 and not visited[next_node]:\n                visited[next_node] = True\n                if backtrack(next_node, visited, num_visited + 1):\n                    return True\n                visited[next_node] = False\n        \n        return False\n\n    # Initialize visited array\n    visited = [False] * len(matrix)\n\n    # Start the backtracking from each vertex\n    for start_node in range(len(matrix)):\n        visited[start_node] = True\n        if backtrack(start_node, visited, 1):\n            return True\n        visited[start_node] = False\n    \n    return False", "solution_func": "def g():\n    \"\"\"\n    Generate a random adjacency matrix for a directed graph with 4 vertices.\n    \"\"\"\n    return [[0, 1, 1, 0],\n            [1, 0, 0, 1],\n            [1, 0, 0, 1],\n            [0, 1, 1, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers (1-indexed) as a list, where the first index is smaller than the second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n    You can return the answer in any order.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left+1, right+1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value that can be used to find two numbers that add up to the target.\n    \"\"\"\n    return nums, target\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7\nassert f(*g(nums, target)) == [2, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers (1-indexed) as a list, where the first index is smaller than the second index.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n    You can return the answer in any order.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left+1, right+1]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value that can be used to find two numbers that add up to the target.\n    \"\"\"\n    return nums, target\n\nnums = [1, 2, 3, 4, 5]\ntarget = 7", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    dp = [0] * (n+1)\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate a positive integer n that can be used to find the nth Fibonacci number.\n    \"\"\"\n    return 6\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 453, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    dp = [0] * (n+1)\n    dp[1] = 1\n\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate a positive integer n that can be used to find the nth Fibonacci number.\n    \"\"\"\n    return 6", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum submatrix where the sum is less than or equal to a given target.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        row_sums = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                row_sums[i] += matrix[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be used to find the maximum sum submatrix.\n    \"\"\"\n    return matrix\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6]\n]\nassert f(g(matrix)) == 21\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum submatrix where the sum is less than or equal to a given target.\n    \"\"\"\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for left in range(cols):\n        row_sums = [0] * rows\n        for right in range(left, cols):\n            for i in range(rows):\n                row_sums[i] += matrix[i][right]\n\n            max_sum = max(max_sum, max_subarray_sum(row_sums))\n\n    return max_sum\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(curr_sum + num, num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a matrix of integers that can be used to find the maximum sum submatrix.\n    \"\"\"\n    return matrix\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6]\n]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str = \"pre\", suffix: str = \"fix\") -> bool:\n    \"\"\"\n    Given a list of words, check if there exists a word in the list that starts with the given prefix and ends with the given suffix.\n    Return True if such a word exists, False otherwise.\n    \"\"\"\n    for word in words:\n        if word.startswith(prefix) and word.endswith(suffix):\n            return True\n    return False\n\ndef g(words: List[str], prefix: str = \"pre\", suffix: str = \"fix\") -> List[str]:\n    \"\"\"\n    Generate a list of words that starts with the given prefix and ends with the given suffix.\n    \"\"\"\n    new_words = []\n    for word in words:\n        if word.startswith(prefix) and word.endswith(suffix):\n            new_words.append(word)\n    return new_words\n\nassert f(g())\n", "emb": null, "idx_generation": 453, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str = \"pre\", suffix: str = \"fix\") -> bool:\n    \"\"\"\n    Given a list of words, check if there exists a word in the list that starts with the given prefix and ends with the given suffix.\n    Return True if such a word exists, False otherwise.\n    \"\"\"\n    for word in words:\n        if word.startswith(prefix) and word.endswith(suffix):\n            return True\n    return False", "solution_func": "def g(words: List[str], prefix: str = \"pre\", suffix: str = \"fix\") -> List[str]:\n    \"\"\"\n    Generate a list of words that starts with the given prefix and ends with the given suffix.\n    \"\"\"\n    new_words = []\n    for word in words:\n        if word.startswith(prefix) and word.endswith(suffix):\n            new_words.append(word)\n    return new_words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int = 10) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that sum up to the target value.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    left = 0\n    right = len(sorted_numbers) - 1\n    while left < right:\n        current_sum = sorted_numbers[left] + sorted_numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g(numbers: List[int], target: int = 10) -> List[int]:\n    \"\"\"\n    Generate a list of two numbers that sum up to the target value.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    left = 0\n    right = len(sorted_numbers) - 1\n    while left < right:\n        current_sum = sorted_numbers[left] + sorted_numbers[right]\n        if current_sum == target:\n            return [sorted_numbers[left], sorted_numbers[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n\nassert f(g())\n", "emb": null, "idx_generation": 453, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(numbers: List[int], target: int = 10) -> bool:\n    \"\"\"\n    Given a list of numbers, find two numbers that sum up to the target value.\n    Return True if such numbers exist, False otherwise.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    left = 0\n    right = len(sorted_numbers) - 1\n    while left < right:\n        current_sum = sorted_numbers[left] + sorted_numbers[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g(numbers: List[int], target: int = 10) -> List[int]:\n    \"\"\"\n    Generate a list of two numbers that sum up to the target value.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    left = 0\n    right = len(sorted_numbers) - 1\n    while left < right:\n        current_sum = sorted_numbers[left] + sorted_numbers[right]\n        if current_sum == target:\n            return [sorted_numbers[left], sorted_numbers[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]], target: int = 0) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if there exists a submatrix (contiguous subarray) whose sum is equal to the target value.\n    Return True if such a submatrix exists, False otherwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            current_sum = 0\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    current_sum += matrix[x][y]\n                    if current_sum == target:\n                        return True\n                    elif current_sum > target:\n                        break\n    return False\n\ndef g(matrix: List[List[int]], target: int = 0) -> List[List[int]]:\n    \"\"\"\n    Generate a submatrix (contiguous subarray) from the given matrix whose sum is equal to the target value.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            current_sum = 0\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    current_sum += matrix[x][y]\n                    if current_sum == target:\n                        return [matrix[i:x+1][j:y+1] for i in range(i, x+1)]\n                    elif current_sum > target:\n                        break\n    return []\n\nassert f(g())\n", "emb": null, "idx_generation": 453, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]], target: int = 0) -> bool:\n    \"\"\"\n    Given a matrix of integers, check if there exists a submatrix (contiguous subarray) whose sum is equal to the target value.\n    Return True if such a submatrix exists, False otherwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            current_sum = 0\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    current_sum += matrix[x][y]\n                    if current_sum == target:\n                        return True\n                    elif current_sum > target:\n                        break\n    return False", "solution_func": "def g(matrix: List[List[int]], target: int = 0) -> List[List[int]]:\n    \"\"\"\n    Generate a submatrix (contiguous subarray) from the given matrix whose sum is equal to the target value.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            current_sum = 0\n            for x in range(i, rows):\n                for y in range(j, cols):\n                    current_sum += matrix[x][y]\n                    if current_sum == target:\n                        return [matrix[i:x+1][j:y+1] for i in range(i, x+1)]\n                    elif current_sum > target:\n                        break\n    return []", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there exist two numbers in the list that add up to the target.\n    The list is sorted in non-decreasing order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True (There exist two numbers, 2 and 7, that add up to 9)\n\n    Hint: Use the two-pointer technique to solve this problem efficiently.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, determine if there exist two numbers in the list that add up to the target.\n    The list is sorted in non-decreasing order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True (There exist two numbers, 2 and 7, that add up to 9)\n\n    Hint: Use the two-pointer technique to solve this problem efficiently.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 11, 15]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the missing number in the range from 0 to n.\n    The list contains all the numbers from 0 to n except for one.\n\n    Example:\n    Input: [3, 0, 1]\n    Output: 2 (The missing number is 2)\n\n    Hint: Use the XOR operator to find the missing number efficiently.\n    \"\"\"\n    missing = len(nums)\n\n    for i, num in enumerate(nums):\n        missing ^= i ^ num\n\n    return missing\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [3, 0, 1]\n\nassert f(g()) == 2\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the missing number in the range from 0 to n.\n    The list contains all the numbers from 0 to n except for one.\n\n    Example:\n    Input: [3, 0, 1]\n    Output: 2 (The missing number is 2)\n\n    Hint: Use the XOR operator to find the missing number efficiently.\n    \"\"\"\n    missing = len(nums)\n\n    for i, num in enumerate(nums):\n        missing ^= i ^ num\n\n    return missing", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 4.\n    \"\"\"\n    return [3, 0, 1]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all duplicate elements such that each element appears only once.\n    The original list should be modified in-place, and the modified list should be sorted in non-decreasing order.\n\n    Example:\n    Input: [1, 1, 2, 2, 3, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n\n    Hint: Use a two-pointer technique to solve this problem efficiently.\n    \"\"\"\n    if len(nums) < 2:\n        return nums\n\n    left = 0\n    right = 1\n\n    while right < len(nums):\n        if nums[left] != nums[right]:\n            left += 1\n            nums[left] = nums[right]\n        \n        right += 1\n\n    return nums[:left + 1]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 1, 2, 2, 3, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 453, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all duplicate elements such that each element appears only once.\n    The original list should be modified in-place, and the modified list should be sorted in non-decreasing order.\n\n    Example:\n    Input: [1, 1, 2, 2, 3, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n\n    Hint: Use a two-pointer technique to solve this problem efficiently.\n    \"\"\"\n    if len(nums) < 2:\n        return nums\n\n    left = 0\n    right = 1\n\n    while right < len(nums):\n        if nums[left] != nums[right]:\n            left += 1\n            nums[left] = nums[right]\n        \n        right += 1\n\n    return nums[:left + 1]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [1, 1, 2, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(arr: List[str]) -> bool:\n    \"\"\"\n    Given a list of strings, return True if there exists a pair of strings in the list such that their bitwise OR is a palindrome, otherwise return False.\n\n    Example:\n    Input: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"]\n    Output: True\n\n    Explanation:\n    The bitwise OR of \"abc\" and \"mno\" is \"mno\", which is a palindrome.\n    Therefore, there exists a pair whose bitwise OR is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            bitwise_or = int(arr[i], 2) | int(arr[j], 2)\n            if is_palindrome(bin(bitwise_or)[2:]):\n                return True\n\n    return False\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of binary strings where there exists a pair whose bitwise OR is a palindrome.\n    \"\"\"\n    return [\"101\", \"1101\", \"1110\", \"10001\"]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 453, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(arr: List[str]) -> bool:\n    \"\"\"\n    Given a list of strings, return True if there exists a pair of strings in the list such that their bitwise OR is a palindrome, otherwise return False.\n\n    Example:\n    Input: [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"]\n    Output: True\n\n    Explanation:\n    The bitwise OR of \"abc\" and \"mno\" is \"mno\", which is a palindrome.\n    Therefore, there exists a pair whose bitwise OR is a palindrome.\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            bitwise_or = int(arr[i], 2) | int(arr[j], 2)\n            if is_palindrome(bin(bitwise_or)[2:]):\n                return True\n\n    return False", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of binary strings where there exists a pair whose bitwise OR is a palindrome.\n    \"\"\"\n    return [\"101\", \"1101\", \"1110\", \"10001\"]", "map_ix": [0, 0, 0, 0, 1, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target value.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g(nums: List[int], target: int) -> List[int]:\n    return nums, target\n\nassert f(*g([2, 7, 11, 15], 9)) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers, find two numbers that add up to the target value.\n    Return the indices of the two numbers in the original list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length\n\ndef g(nums: List[int]) -> List[int]:\n    return nums\n\nassert f(g([10, 9, 2, 5, 3, 7, 101, 18])) == 4\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence.\n    \"\"\"\n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length", "solution_func": "def g(nums: List[int]) -> List[int]:\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum size of a subarray\n    that sums up to at least the target value.\n    \"\"\"\n    min_length = float('inf')\n    left = 0\n    current_sum = 0\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length\n\ndef g(nums: List[int], target: int) -> int:\n    return nums, target\n\nassert f(*g([2, 3, 1, 2, 4, 3], 7)) == 2\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum size of a subarray\n    that sums up to at least the target value.\n    \"\"\"\n    min_length = float('inf')\n    left = 0\n    current_sum = 0\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length", "solution_func": "def g(nums: List[int], target: int) -> int:\n    return nums, target", "map_ix": [1, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of combinations that add up to the target.\n\n    Example:\n    Input: [1, 2, 3, 4, 5], 5\n    Output: 4\n\n    Explanation:\n    There are four combinations that add up to 5: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], and [5].\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5], 5)\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 454, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of combinations that add up to the target.\n\n    Example:\n    Input: [1, 2, 3, 4, 5], 5\n    Output: 4\n\n    Explanation:\n    There are four combinations that add up to 5: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], and [5].\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 2, 3, 4, 5], 5)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all unique combinations in nums where the numbers sum to target.\n\n    Example:\n    Input: [2, 3, 5], 8\n    Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n    Explanation:\n    There are three unique combinations that add up to 8: [2, 2, 2, 2], [2, 3, 3], and [3, 5].\n    \"\"\"\n    result = []\n    nums.sort()\n\n    def backtrack(curr_sum, start, path):\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(curr_sum + nums[i], i, path + [nums[i]])\n\n    backtrack(0, 0, [])\n    return result\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 3, 5], 8)\n\nassert f(*g()) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target number, find all unique combinations in nums where the numbers sum to target.\n\n    Example:\n    Input: [2, 3, 5], 8\n    Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n\n    Explanation:\n    There are three unique combinations that add up to 8: [2, 2, 2, 2], [2, 3, 3], and [3, 5].\n    \"\"\"\n    result = []\n    nums.sort()\n\n    def backtrack(curr_sum, start, path):\n        if curr_sum == target:\n            result.append(path)\n            return\n        if curr_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(curr_sum + nums[i], i, path + [nums[i]])\n\n    backtrack(0, 0, [])\n    return result", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 3, 5], 8)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the minimum number of coins needed to make the target sum.\n    You may assume that you have an infinite number of each kind of coin.\n\n    Example:\n    Input: [1, 2, 5], 11\n    Output: 3\n\n    Explanation:\n    The minimum number of coins needed to make 11 is 3: 5 + 5 + 1 = 11.\n    \"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for coin in nums:\n            if i >= coin:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 5], 11)\n\nassert f(*g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target number, find the minimum number of coins needed to make the target sum.\n    You may assume that you have an infinite number of each kind of coin.\n\n    Example:\n    Input: [1, 2, 5], 11\n    Output: 3\n\n    Explanation:\n    The minimum number of coins needed to make 11 is 3: 5 + 5 + 1 = 11.\n    \"\"\"\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        for coin in nums:\n            if i >= coin:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 2, 5], 11)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers excluding the current number.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The output list is calculated as [2*3*4, 1*3*4, 1*2*4, 1*2*3].\n\n    Hint: Use dynamic programming to calculate the products of the prefix and suffix of each number.\n    \"\"\"\n\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n\n    for i in range(1, n):\n        prefix[i] = prefix[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix[i] = suffix[i+1] * nums[i+1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers excluding the current number.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: [24, 12, 8, 6]\n    Explanation: The output list is calculated as [2*3*4, 1*3*4, 1*2*4, 1*2*3].\n\n    Hint: Use dynamic programming to calculate the products of the prefix and suffix of each number.\n    \"\"\"\n\n    n = len(nums)\n    prefix = [1] * n\n    suffix = [1] * n\n\n    for i in range(1, n):\n        prefix[i] = prefix[i-1] * nums[i-1]\n\n    for i in range(n-2, -1, -1):\n        suffix[i] = suffix[i+1] * nums[i+1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of distinct sequences of length k that can be formed using numbers from 1 to n (inclusive).\n\n    Example:\n    Input: n = 4, k = 2\n    Output: 12\n    Explanation: The distinct sequences of length 2 that can be formed using numbers from 1 to 4 are: [1, 1], [1, 2], [1, 3], [1, 4], [2, 1], [2, 2], [2, 3], [2, 4], [3, 1], [3, 2], [3, 3], [3, 4].\n\n    Hint: Use dynamic programming to calculate the number of distinct sequences.\n    \"\"\"\n\n    dp = [[0] * (n+1) for _ in range(k+1)]\n    dp[0][0] = 1\n\n    for i in range(1, k+1):\n        for j in range(1, n+1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[k][n]\n\ndef g() -> Tuple[int, int]:\n    return 4, 2\n\nassert f(*g()) == 12\n", "emb": null, "idx_generation": 454, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of distinct sequences of length k that can be formed using numbers from 1 to n (inclusive).\n\n    Example:\n    Input: n = 4, k = 2\n    Output: 12\n    Explanation: The distinct sequences of length 2 that can be formed using numbers from 1 to 4 are: [1, 1], [1, 2], [1, 3], [1, 4], [2, 1], [2, 2], [2, 3], [2, 4], [3, 1], [3, 2], [3, 3], [3, 4].\n\n    Hint: Use dynamic programming to calculate the number of distinct sequences.\n    \"\"\"\n\n    dp = [[0] * (n+1) for _ in range(k+1)]\n    dp[0][0] = 1\n\n    for i in range(1, k+1):\n        for j in range(1, n+1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[k][n]", "solution_func": "def g() -> Tuple[int, int]:\n    return 4, 2", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return a list of the nodes in the graph in topological order.\n\n    Example:\n    Input: [[1, 2], [3], [3], []]\n    Output: [0, 1, 2, 3]\n    Explanation: The topological order of the nodes in the graph is [0, 1, 2, 3].\n\n    Hint: Use depth-first search (DFS) to perform a topological sort.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        result.append(node)\n\n    n = len(graph)\n    visited = [False] * n\n    result = []\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    return result[::-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 2], [3], [3], []]\n\nassert f(g()) == [0, 1, 2, 3]\n", "emb": null, "idx_generation": 454, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given an undirected graph represented as an adjacency list, return a list of the nodes in the graph in topological order.\n\n    Example:\n    Input: [[1, 2], [3], [3], []]\n    Output: [0, 1, 2, 3]\n    Explanation: The topological order of the nodes in the graph is [0, 1, 2, 3].\n\n    Hint: Use depth-first search (DFS) to perform a topological sort.\n    \"\"\"\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        result.append(node)\n\n    n = len(graph)\n    visited = [False] * n\n    result = []\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    return result[::-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2], [3], [3], []]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a tuple (index1, index2).\n    Assume that there is exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The two numbers that sum up to the target 9 are 2 and 7.\n    The indices of these numbers are 0 and 1, respectively.\n\n    Therefore, the function should return (0, 1).\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return (num_map[complement], i)\n        \n        num_map[num] = i\n    \n    return ()\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == (0, 1)\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 454, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the two numbers in the list that sum up to the target.\n    Return the indices of the two numbers as a tuple (index1, index2).\n    Assume that there is exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The two numbers that sum up to the target 9 are 2 and 7.\n    The indices of these numbers are 0 and 1, respectively.\n\n    Therefore, the function should return (0, 1).\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in num_map:\n            return (num_map[complement], i)\n        \n        num_map[num] = i\n    \n    return ()", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the kth largest element in the array.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    Output: 5\n    Explanation: The 2nd largest element in the array is 5.\n\n    \"\"\"\n\n    def partition(nums, low, high):\n        pivot = nums[high]\n        i = low - 1\n\n        for j in range(low, high):\n            if nums[j] < pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n\n        nums[i+1], nums[high] = nums[high], nums[i+1]\n        return i+1\n\n    def quicksort(nums, low, high, k):\n        if low < high:\n            pivot_index = partition(nums, low, high)\n\n            if pivot_index == len(nums) - k:\n                return nums[pivot_index]\n            elif pivot_index > len(nums) - k:\n                return quicksort(nums, low, pivot_index-1, k)\n            else:\n                return quicksort(nums, pivot_index+1, high, k)\n\n    return quicksort(nums, 0, len(nums)-1, k)\n\ndef g() -> List[int]:\n    nums = [3, 2, 1, 5, 6, 4]\n    return nums\n\nassert f(g()) == 5\n\n", "emb": null, "idx_generation": 455, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the kth largest element in the array.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    Output: 5\n    Explanation: The 2nd largest element in the array is 5.\n\n    \"\"\"\n\n    def partition(nums, low, high):\n        pivot = nums[high]\n        i = low - 1\n\n        for j in range(low, high):\n            if nums[j] < pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n\n        nums[i+1], nums[high] = nums[high], nums[i+1]\n        return i+1\n\n    def quicksort(nums, low, high, k):\n        if low < high:\n            pivot_index = partition(nums, low, high)\n\n            if pivot_index == len(nums) - k:\n                return nums[pivot_index]\n            elif pivot_index > len(nums) - k:\n                return quicksort(nums, low, pivot_index-1, k)\n            else:\n                return quicksort(nums, pivot_index+1, high, k)\n\n    return quicksort(nums, 0, len(nums)-1, k)", "solution_func": "def g() -> List[int]:\n    nums = [3, 2, 1, 5, 6, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the maximum product of any two elements in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 250\n    Explanation: The maximum product is obtained by multiplying 10 and 25 (10 * 25 = 250).\n\n    \"\"\"\n\n    max_product = float('-inf')\n    max_num = float('-inf')\n    second_max_num = float('-inf')\n    min_num = float('inf')\n    second_min_num = float('inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max_num = max_num\n            max_num = num\n        elif num > second_max_num:\n            second_max_num = num\n\n        if num < min_num:\n            second_min_num = min_num\n            min_num = num\n        elif num < second_min_num:\n            second_min_num = num\n\n    max_product = max(max_num * second_max_num, min_num * second_min_num)\n\n    return max_product\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 250\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers 'nums', find the maximum product of any two elements in the array.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n    Output: 250\n    Explanation: The maximum product is obtained by multiplying 10 and 25 (10 * 25 = 250).\n\n    \"\"\"\n\n    max_product = float('-inf')\n    max_num = float('-inf')\n    second_max_num = float('-inf')\n    min_num = float('inf')\n    second_min_num = float('inf')\n\n    for num in nums:\n        if num > max_num:\n            second_max_num = max_num\n            max_num = num\n        elif num > second_max_num:\n            second_max_num = num\n\n        if num < min_num:\n            second_min_num = min_num\n            min_num = num\n        elif num < second_min_num:\n            second_min_num = num\n\n    max_product = max(max_num * second_max_num, min_num * second_min_num)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output: 7\n    Explanation: The minimum sum of a path is 1 + 3 + 1 + 1 + 1 = 7.\n\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]\n\ndef g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\nassert f(g()) == 7\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n\n    Output: 7\n    Explanation: The minimum sum of a path is 1 + 3 + 1 + 1 + 1 = 7.\n\n    \"\"\"\n    n = len(grid)\n    m = len(grid[0])\n\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, m):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[-1][-1]", "solution_func": "def g():\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if there exists a subsequence of the list\n    such that the sum of the subsequence is equal to the target.\n    Return True if such subsequence exists, False otherwise.\n    \"\"\"\n\n    n = len(nums)\n    total_sum = sum(nums)\n\n    if total_sum < target or target % 2 != total_sum % 2:\n        return False\n\n    half_sum = target // 2\n    dp = [False] * (half_sum + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(half_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[half_sum]\n\ndef g() -> List[int]:\n    return [1, 5, 11, 5]\n\nassert f(g(), 16) == True\n", "emb": null, "idx_generation": 455, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if there exists a subsequence of the list\n    such that the sum of the subsequence is equal to the target.\n    Return True if such subsequence exists, False otherwise.\n    \"\"\"\n\n    n = len(nums)\n    total_sum = sum(nums)\n\n    if total_sum < target or target % 2 != total_sum % 2:\n        return False\n\n    half_sum = target // 2\n    dp = [False] * (half_sum + 1)\n    dp[0] = True\n\n    for num in nums:\n        for i in range(half_sum, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[half_sum]", "solution_func": "def g() -> List[int]:\n    return [1, 5, 11, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS) in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS) in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and an integer k, return the k most frequent elements in the list.\n    \"\"\"\n\n    freq = {}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n\n    freq_list = [(num, count) for num, count in freq.items()]\n    freq_list.sort(key=lambda x: x[1], reverse=True)\n\n    return [num for num, _ in freq_list[:k]]\n\ndef g() -> List[int]:\n    return [1, 1, 1, 2, 2, 3]\n\nassert f(g(), 2) == [1, 2]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and an integer k, return the k most frequent elements in the list.\n    \"\"\"\n\n    freq = {}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n\n    freq_list = [(num, count) for num, count in freq.items()]\n    freq_list.sort(key=lambda x: x[1], reverse=True)\n\n    return [num for num, _ in freq_list[:k]]", "solution_func": "def g() -> List[int]:\n    return [1, 1, 1, 2, 2, 3]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, determine the length of the longest common prefix among all the words.\n    \n    Sample Input:\n    words = ['apple', 'app', 'application']\n    \n    Sample Output:\n    3\n    \"\"\"\n    if not words:\n        return 0\n    \n    prefix = words[0]\n    \n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return 0\n    \n    return len(prefix)\n\ndef g():\n    words = ['apple', 'app', 'application']\n    return words\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 455, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, determine the length of the longest common prefix among all the words.\n    \n    Sample Input:\n    words = ['apple', 'app', 'application']\n    \n    Sample Output:\n    3\n    \"\"\"\n    if not words:\n        return 0\n    \n    prefix = words[0]\n    \n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return 0\n    \n    return len(prefix)", "solution_func": "def g():\n    words = ['apple', 'app', 'application']\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List, Dict\n\ndef f(words: List[str]) -> Dict[str, List[str]]:\n    \"\"\"\n    Given a list of words, group them based on their anagrams.\n    \n    Sample Input:\n    words = ['cat', 'act', 'dog', 'god', 'bird', 'drib']\n    \n    Sample Output:\n    {'act': ['cat', 'act'], 'dog': ['dog', 'god'], 'bird': ['bird', 'drib']}\n    \"\"\"\n    groups = {}\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in groups:\n            groups[sorted_word].append(word)\n        else:\n            groups[sorted_word] = [word]\n    \n    return groups\n\ndef g():\n    words = ['cat', 'act', 'dog', 'god', 'bird', 'drib']\n    return words\n\nassert f(*g()) == {'act': ['cat', 'act'], 'dog': ['dog', 'god'], 'bird': ['bird', 'drib']}\n", "emb": null, "idx_generation": 455, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Dict\n\ndef f(words: List[str]) -> Dict[str, List[str]]:\n    \"\"\"\n    Given a list of words, group them based on their anagrams.\n    \n    Sample Input:\n    words = ['cat', 'act', 'dog', 'god', 'bird', 'drib']\n    \n    Sample Output:\n    {'act': ['cat', 'act'], 'dog': ['dog', 'god'], 'bird': ['bird', 'drib']}\n    \"\"\"\n    groups = {}\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in groups:\n            groups[sorted_word].append(word)\n        else:\n            groups[sorted_word] = [word]\n    \n    return groups", "solution_func": "def g():\n    words = ['cat', 'act', 'dog', 'god', 'bird', 'drib']\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a word in the grid.\n    \n    Sample Input:\n    grid = [['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p']]\n    word = 'go'\n    \n    Sample Output:\n    1\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    count = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == word[0]:\n                if dfs(grid, i, j, word):\n                    count += 1\n    \n    return count\n\ndef dfs(grid, i, j, word):\n    if len(word) == 0:\n        return True\n    \n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n        return False\n    \n    temp = grid[i][j]\n    grid[i][j] = '#'\n    \n    # Check for word in all four directions\n    found = dfs(grid, i+1, j, word[1:]) or dfs(grid, i-1, j, word[1:]) or dfs(grid, i, j+1, word[1:]) or dfs(grid, i, j-1, word[1:])\n    \n    grid[i][j] = temp\n    \n    return found\n\ndef g():\n    grid = [['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p']]\n    word = 'go'\n    return grid, word\n\nassert f(*g()) == 1\n", "emb": null, "idx_generation": 455, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a word in the grid.\n    \n    Sample Input:\n    grid = [['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p']]\n    word = 'go'\n    \n    Sample Output:\n    1\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    count = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == word[0]:\n                if dfs(grid, i, j, word):\n                    count += 1\n    \n    return count\n\ndef dfs(grid, i, j, word):\n    if len(word) == 0:\n        return True\n    \n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[0]:\n        return False\n    \n    temp = grid[i][j]\n    grid[i][j] = '#'\n    \n    # Check for word in all four directions\n    found = dfs(grid, i+1, j, word[1:]) or dfs(grid, i-1, j, word[1:]) or dfs(grid, i, j+1, word[1:]) or dfs(grid, i, j-1, word[1:])\n    \n    grid[i][j] = temp\n    \n    return found", "solution_func": "def g():\n    grid = [['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p']]\n    word = 'go'\n    return grid, word", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The sum of nums[0] and nums[1] is 2 + 7 = 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        num_indices[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 455, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target number, find two numbers in the array that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n\n    The sum of nums[0] and nums[1] is 2 + 7 = 9.\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        num_indices[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the sum of the squares of all the numbers is a palindrome.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: True\n\n    Explanation: The sum of the squares of the numbers [1, 2, 3, 4] is 1^2 + 2^2 + 3^2 + 4^2 = 1 + 4 + 9 + 16 = 30.\n    The reverse of 30 is also 30, so it is a palindrome.\n    \"\"\"\n    total_sum = sum([num**2 for num in nums])\n    s = str(total_sum)\n    return s == s[::-1]\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 456, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if the sum of the squares of all the numbers is a palindrome.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: True\n\n    Explanation: The sum of the squares of the numbers [1, 2, 3, 4] is 1^2 + 2^2 + 3^2 + 4^2 = 1 + 4 + 9 + 16 = 30.\n    The reverse of 30 is also 30, so it is a palindrome.\n    \"\"\"\n    total_sum = sum([num**2 for num in nums])\n    s = str(total_sum)\n    return s == s[::-1]", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 12\n\n    Explanation: The maximum product of any two numbers in the list [1, 2, 3, 4] is 3*4 = 12.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 12\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 12\n\n    Explanation: The maximum product of any two numbers in the list [1, 2, 3, 4] is 3*4 = 12.\n    \"\"\"\n    max_product = float('-inf')\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with each word reversed.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation: Each word in the string is reversed individually.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)\n\ndef g():\n    s = \"Hello World\"\n    return s\n\nassert f(g()) == \"olleH dlroW\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the string with each word reversed.\n\n    Example:\n    Input: s = \"Hello World\"\n    Output: \"olleH dlroW\"\n\n    Explanation: Each word in the string is reversed individually.\n    \"\"\"\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)", "solution_func": "def g():\n    s = \"Hello World\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \n    Args:\n    nums (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum product of any three numbers.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    # Case 1: All positive numbers\n    max_product = nums[n-1] * nums[n-2] * nums[n-3]\n    \n    # Case 2: Two negative numbers and one positive number\n    if nums[0] < 0 and nums[1] < 0:\n        max_product = max(max_product, nums[0] * nums[1] * nums[n-1])\n    \n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    \n    Args:\n    nums (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum product of any three numbers.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    \n    # Case 1: All positive numbers\n    max_product = nums[n-1] * nums[n-2] * nums[n-3]\n    \n    # Case 2: Two negative numbers and one positive number\n    if nums[0] < 0 and nums[1] < 0:\n        max_product = max(max_product, nums[0] * nums[1] * nums[n-1])\n    \n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, group them by anagrams and return the groups.\n    \n    Args:\n    words (List[str]): The input list of words.\n    \n    Returns:\n    List[str]: The groups of anagrams.\n    \"\"\"\n    anagram_groups = {}\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word not in anagram_groups:\n            anagram_groups[sorted_word] = []\n        anagram_groups[sorted_word].append(word)\n    \n    return list(anagram_groups.values())\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, group them by anagrams and return the groups.\n    \n    Args:\n    words (List[str]): The input list of words.\n    \n    Returns:\n    List[str]: The groups of anagrams.\n    \"\"\"\n    anagram_groups = {}\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word not in anagram_groups:\n            anagram_groups[sorted_word] = []\n        anagram_groups[sorted_word].append(word)\n    \n    return list(anagram_groups.values())", "solution_func": "def g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \n    Args:\n    nums (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum sum of a subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n    \n    Args:\n    nums (List[int]): The input list of integers.\n    \n    Returns:\n    int: The maximum sum of a subarray.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets that have an even sum.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n\n    Output:\n    4\n\n    Explanation:\n    The subsets with an even sum are [1], [2], [3], [2,3].\n    \"\"\"\n\n    def count_subsets(nums: List[int], index: int, current_sum: int) -> int:\n        if index == len(nums):\n            if current_sum % 2 == 0:\n                return 1\n            else:\n                return 0\n        else:\n            count = 0\n            count += count_subsets(nums, index + 1, current_sum + nums[index])\n            count += count_subsets(nums, index + 1, current_sum)\n            return count\n\n    return count_subsets(nums, 0, 0)\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets that have an even sum.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n\n    Output:\n    4\n\n    Explanation:\n    The subsets with an even sum are [1], [2], [3], [2,3].\n    \"\"\"\n\n    def count_subsets(nums: List[int], index: int, current_sum: int) -> int:\n        if index == len(nums):\n            if current_sum % 2 == 0:\n                return 1\n            else:\n                return 0\n        else:\n            count = 0\n            count += count_subsets(nums, index + 1, current_sum + nums[index])\n            count += count_subsets(nums, index + 1, current_sum)\n            return count\n\n    return count_subsets(nums, 0, 0)", "solution_func": "def g():\n    nums = [1, 2, 3]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product is 3 * 4 = 12.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4]\n\n    Output:\n    12\n\n    Explanation:\n    The maximum product is 3 * 4 = 12.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a prime number.\n\n    Example:\n    Input:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True\n\ndef g():\n    return 7\n\nassert f(g()) == True\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Given an integer n, check if it is a prime number.\n\n    Example:\n    Input:\n    n = 7\n\n    Output:\n    True\n\n    Explanation:\n    7 is a prime number.\n    \"\"\"\n\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "solution_func": "def g():\n    return 7", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]\n\ndef g() -> str:\n    \"\"\"\n    Generate a string that is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama!\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 456, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s == s[::-1]", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string that is a palindrome after removing all non-alphanumeric characters and ignoring case.\n    \"\"\"\n    return \"A man, a plan, a canal: Panama!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n\n    Sample Output:\n    [1, 4]\n    Explanation: The numbers at indices 1 and 4, [2, 5], add up to the target value 7.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [1, 4]\n\n", "emb": null, "idx_generation": 457, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n\n    Sample Output:\n    [1, 4]\n    Explanation: The numbers at indices 1 and 4, [2, 5], add up to the target value 7.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return [left, right]\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all possible combinations of two numbers in the list that add up to the target.\n    Return a list of lists, where each inner list contains the indices of two numbers in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n\n    Sample Output:\n    [[1, 4], [2, 3]]\n    Explanation: The numbers at indices 1 and 4, [2, 5], and at indices 2 and 3, [3, 4], both add up to the target value 7.\n    \"\"\"\n\n    result = []\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            result.append([num_map[complement], i])\n        num_map[num] = i\n    \n    return result\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[1, 4], [2, 3]]\n\n", "emb": null, "idx_generation": 457, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers and a target value, find all possible combinations of two numbers in the list that add up to the target.\n    Return a list of lists, where each inner list contains the indices of two numbers in the original list.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n\n    Sample Output:\n    [[1, 4], [2, 3]]\n    Explanation: The numbers at indices 1 and 4, [2, 5], and at indices 2 and 3, [3, 4], both add up to the target value 7.\n    \"\"\"\n\n    result = []\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            result.append([num_map[complement], i])\n        num_map[num] = i\n    \n    return result", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, value):\n        self.stack.append(value)\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack.pop()\n    \n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to reach the target value using the following operations:\n    - Push a number from the list onto a stack\n    - Pop the top number from the stack\n    Return True if the target value can be reached, False otherwise.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n    Explanation: It is possible to reach the target value 6 by pushing 1 and 2 onto the stack, and then popping both numbers from the stack.\n    \"\"\"\n\n    stack = Stack()\n    for num in nums:\n        stack.push(num)\n        while not stack.is_empty() and stack.stack[-1] == target:\n            stack.pop()\n    \n    return not stack.is_empty()\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 457, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, value):\n        self.stack.append(value)\n    \n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack.pop()\n    \n    def is_empty(self):\n        return len(self.stack) == 0\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to reach the target value using the following operations:\n    - Push a number from the list onto a stack\n    - Pop the top number from the stack\n    Return True if the target value can be reached, False otherwise.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n\n    Sample Output:\n    True\n    Explanation: It is possible to reach the target value 6 by pushing 1 and 2 onto the stack, and then popping both numbers from the stack.\n    \"\"\"\n\n    stack = Stack()\n    for num in nums:\n        stack.push(num)\n        while not stack.is_empty() and stack.stack[-1] == target:\n            stack.pop()\n    \n    return not stack.is_empty()", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 6\n    return nums, target", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1]\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list.\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number\n    complements = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n\n        # Check if the complement exists in the dictionary\n        if complement in complements:\n            # Return the indices of the two numbers\n            return [complements[complement], i]\n\n        # Add the current number and its index to the dictionary\n        complements[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n    Explanation: nums[0] + nums[1] = 2 + 7 = 9, so the indices are [0, 1]\n\n    Hint: Use a dictionary to store the complement of each number as you iterate through the list.\n    \"\"\"\n\n    # Create a dictionary to store the complement of each number\n    complements = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n\n        # Check if the complement exists in the dictionary\n        if complement in complements:\n            # Return the indices of the two numbers\n            return [complements[complement], i]\n\n        # Add the current number and its index to the dictionary\n        complements[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix (2D list) of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: 21\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which sums up to 21.\n\n    Hint: Use dynamic programming to compute the maximum sum for each cell in the matrix.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D table to store the maximum sum for each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Compute the maximum sum for each cell\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Return the maximum sum for the bottom-right cell\n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == 21\n", "emb": null, "idx_generation": 457, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix (2D list) of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: 21\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9, which sums up to 21.\n\n    Hint: Use dynamic programming to compute the maximum sum for each cell in the matrix.\n    \"\"\"\n\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Create a 2D table to store the maximum sum for each cell\n    dp = [[0] * cols for _ in range(rows)]\n\n    # Compute the maximum sum for each cell\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    # Return the maximum sum for the bottom-right cell\n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of unique combinations of numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: The unique combinations are [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n\n    Hint: Use dynamic programming to compute the number of combinations for each target sum.\n    \"\"\"\n\n    # Create a list to store the number of combinations for each target sum\n    dp = [0] * (target + 1)\n\n    # Initialize the number of combinations for a target sum of 0 to 1\n    dp[0] = 1\n\n    # Compute the number of combinations for each target sum\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    # Return the number of combinations for the target sum\n    return dp[target]\n\ndef g() -> Tuple[List[int], int]:\n    return ([1, 2, 3], 4)\n\nassert f(*g()) == 7\n", "emb": null, "idx_generation": 457, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target integer, find the number of unique combinations of numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 3], target = 4\n    Output: 7\n    Explanation: The unique combinations are [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2], [3, 1], [1, 3].\n\n    Hint: Use dynamic programming to compute the number of combinations for each target sum.\n    \"\"\"\n\n    # Create a list to store the number of combinations for each target sum\n    dp = [0] * (target + 1)\n\n    # Initialize the number of combinations for a target sum of 0 to 1\n    dp[0] = 1\n\n    # Compute the number of combinations for each target sum\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    # Return the number of combinations for the target sum\n    return dp[target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([1, 2, 3], 4)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    The sequence should have consecutive integers starting from 1.\n    Return the missing number if found, otherwise return -1.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1\n\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n\n    return -1\n\ndef g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers with a missing number in the sequence.\n    \"\"\"\n    if len(arr) == 0:\n        return [1]\n    \n    n = len(arr) + 1\n    missing_number = n // 2\n\n    result = []\n    for i in range(1, n + 1):\n        if i != missing_number:\n            result.append(i)\n\n    return result\n\n# Test case\narr = [1, 2, 3, 5]\nassert f(g(arr)) == 4\n", "emb": null, "idx_generation": 457, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the missing number in the sequence.\n\n    The sequence should have consecutive integers starting from 1.\n    Return the missing number if found, otherwise return -1.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return -1\n\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n\n    return -1", "solution_func": "def g(arr: List[int]) -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers with a missing number in the sequence.\n    \"\"\"\n    if len(arr) == 0:\n        return [1]\n    \n    n = len(arr) + 1\n    missing_number = n // 2\n\n    result = []\n    for i in range(1, n + 1):\n        if i != missing_number:\n            result.append(i)\n\n    return result\n\n# Test case\narr = [1, 2, 3, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all positive integers up to n.\n\n    Return the sum.\n    \"\"\"\n    return (n * (n + 1)) // 2\n\ndef g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\n# Test case\nn = 10\nassert f(g(n)) == 55\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, calculate the sum of all positive integers up to n.\n\n    Return the sum.\n    \"\"\"\n    return (n * (n + 1)) // 2", "solution_func": "def g(n: int) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\n# Test case\nn = 10", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    The path can only move down or right.\n    Return the maximum sum.\n    \"\"\"\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of random integers.\n    \"\"\"\n    return grid\n\n# Test case\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert f(g(grid)) == 9\n", "emb": null, "idx_generation": 457, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "import random\nfrom typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    The path can only move down or right.\n    Return the maximum sum.\n    \"\"\"\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of random integers.\n    \"\"\"\n    return grid\n\n# Test case\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', \n    check if there exists a pair of integers in the list whose sum is equal to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    Explanation: The pair (2, 5) has a sum of 7.\n\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 457, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers 'arr' and a target integer 'target', \n    check if there exists a pair of integers in the list whose sum is equal to the target.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    Output: True\n    Explanation: The pair (2, 5) has a sum of 7.\n\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [1, 2, 3, 4, 5]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the two numbers in the list that XOR to the target value.\n    Return the product of the two numbers.\n\n    Example:\n    nums = [2, 3, 4, 5, 6]\n    target = 7\n\n    Output:\n    20\n\n    Explanation:\n    The two numbers that XOR to 7 are 2 and 5. Their product is 20.\n    \"\"\"\n\n    def find_numbers(nums, target):\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            xor = nums[left] ^ nums[right]\n            if xor == target:\n                return nums[left] * nums[right]\n            elif xor < target:\n                left += 1\n            else:\n                right -= 1\n\n        return -1\n\n    return find_numbers(nums, target)\n\ndef g() -> List[int]:\n    nums = [2, 3, 4, 5, 6]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 20\n\n", "emb": null, "idx_generation": 458, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers nums and a target value, find the two numbers in the list that XOR to the target value.\n    Return the product of the two numbers.\n\n    Example:\n    nums = [2, 3, 4, 5, 6]\n    target = 7\n\n    Output:\n    20\n\n    Explanation:\n    The two numbers that XOR to 7 are 2 and 5. Their product is 20.\n    \"\"\"\n\n    def find_numbers(nums, target):\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            xor = nums[left] ^ nums[right]\n            if xor == target:\n                return nums[left] * nums[right]\n            elif xor < target:\n                left += 1\n            else:\n                right -= 1\n\n        return -1\n\n    return find_numbers(nums, target)", "solution_func": "def g() -> List[int]:\n    nums = [2, 3, 4, 5, 6]\n    target = 7\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end_of_word = False\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.is_end_of_word = True\n\n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(*g()) == 28\n\n", "emb": null, "idx_generation": 458, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers nums, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value is obtained by XORing 5 and 25, which results in 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end_of_word = False\n\n    def insert(root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.is_end_of_word = True\n\n    def find_max_xor(root, num):\n        node = root\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= (1 << i)\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        return xor\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        insert(root, num)\n        max_xor = max(max_xor, find_max_xor(root, num))\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of non-adjacent elements in the list.\n\n    Example:\n    nums = [2, 4, 6, 8, 10, 12, 14]\n\n    Output:\n    34\n\n    Explanation:\n    The maximum sum of non-adjacent elements is obtained by selecting elements [2, 8, 12, 14], which results in a sum of 34.\n    \"\"\"\n\n    def find_max_sum(nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        elif n == 2:\n            return max(nums[0], nums[1])\n        \n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n\n        for i in range(2, n):\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n        return dp[-1]\n\n    return find_max_sum(nums)\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10, 12, 14]\n    return nums\n\nassert f(*g()) == 34\n\n", "emb": null, "idx_generation": 458, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of non-adjacent elements in the list.\n\n    Example:\n    nums = [2, 4, 6, 8, 10, 12, 14]\n\n    Output:\n    34\n\n    Explanation:\n    The maximum sum of non-adjacent elements is obtained by selecting elements [2, 8, 12, 14], which results in a sum of 34.\n    \"\"\"\n\n    def find_max_sum(nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        elif n == 2:\n            return max(nums[0], nums[1])\n        \n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n\n        for i in range(2, n):\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n        return dp[-1]\n\n    return find_max_sum(nums)", "solution_func": "def g() -> List[int]:\n    nums = [2, 4, 6, 8, 10, 12, 14]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value\n    if it is found in the list. If the target value is not found, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7], target = 4\n    Output: 3\n\n    arr = [10, 20, 30, 40, 50], target = 25\n    Output: -1\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]\n\nassert f(g(), 4) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value\n    if it is found in the list. If the target value is not found, return -1.\n\n    Example:\n    arr = [1, 2, 3, 4, 5, 6, 7], target = 4\n    Output: 3\n\n    arr = [10, 20, 30, 40, 50], target = 25\n    Output: -1\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer value for the number of steps in the staircase.\n    \"\"\"\n    return 3\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase with n steps.\n\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, or 2 steps + 1 step.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer value for the number of steps in the staircase.\n    \"\"\"\n    return 3", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine whether it is possible to reach the target\n    by performing addition, subtraction, or multiplication on the integers in the list.\n\n    Example:\n    nums = [1, 3, 2, 5], target = 8\n    Output: True\n\n    Explanation: 1 * (3 + 2) = 5, 5 + 3 = 8\n\n    nums = [2, 4, 6, 8], target = 9\n    Output: False\n    \"\"\"\n    def dfs(nums: List[int], target: int, index: int, curr_sum: int) -> bool:\n        if index == len(nums):\n            return curr_sum == target\n\n        return dfs(nums, target, index + 1, curr_sum + nums[index]) or \\\n               dfs(nums, target, index + 1, curr_sum - nums[index]) or \\\n               dfs(nums, target, index + 1, curr_sum * nums[index])\n\n    return dfs(nums, target, 0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 3, 2, 5], 8\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 458, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine whether it is possible to reach the target\n    by performing addition, subtraction, or multiplication on the integers in the list.\n\n    Example:\n    nums = [1, 3, 2, 5], target = 8\n    Output: True\n\n    Explanation: 1 * (3 + 2) = 5, 5 + 3 = 8\n\n    nums = [2, 4, 6, 8], target = 9\n    Output: False\n    \"\"\"\n    def dfs(nums: List[int], target: int, index: int, curr_sum: int) -> bool:\n        if index == len(nums):\n            return curr_sum == target\n\n        return dfs(nums, target, index + 1, curr_sum + nums[index]) or \\\n               dfs(nums, target, index + 1, curr_sum - nums[index]) or \\\n               dfs(nums, target, index + 1, curr_sum * nums[index])\n\n    return dfs(nums, target, 0, 0)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [1, 3, 2, 5], 8", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the number of pairs of numbers in the list that add up to the target.\n    \"\"\"\n    nums.sort()\n    count = 0\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return count\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value such that the number of pairs of numbers in the list that add up to the target is greater than 0.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10, 12]\n    target = 14\n    return nums, target\n\nassert f(*g()) > 0\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the number of pairs of numbers in the list that add up to the target.\n    \"\"\"\n    nums.sort()\n    count = 0\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            count += 1\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return count", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers and a target value such that the number of pairs of numbers in the list that add up to the target is greater than 0.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10, 12]\n    target = 14\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k elements from a set of n elements.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g():\n    \"\"\"\n    Generate two integers n and k such that the number of ways to choose k elements from a set of n elements is greater than 0.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k\n\nassert f(*g()) > 0\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 458, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k elements from a set of n elements.\n    \"\"\"\n    if k == 0 or k == n:\n        return 1\n    return f(n-1, k-1) + f(n-1, k)", "solution_func": "def g():\n    \"\"\"\n    Generate two integers n and k such that the number of ways to choose k elements from a set of n elements is greater than 0.\n    \"\"\"\n    n = 5\n    k = 3\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, return a list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    \"\"\"\n    Generate a list of integers and a target value such that there exists a pair of numbers in the list that add up to the target.\n    \"\"\"\n    nums = [3, 5, 2, 8, 10, 4]\n    target = 7\n    return nums, target\n\nassert f(*g()) != []\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 458, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, return a list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g():\n    \"\"\"\n    Generate a list of integers and a target value such that there exists a pair of numbers in the list that add up to the target.\n    \"\"\"\n    nums = [3, 5, 2, 8, 10, 4]\n    target = 7\n    return nums, target", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: arr = [1, -2, 3, -4, 5]\n    Output: 60\n    Explanation: The maximum product of any three numbers in the list is 5 * (-2) * (-4) = 60.\n\n    Hint: Use dynamic programming to keep track of the maximum and minimum products of two numbers in the list.\n    Initialize two variables, max_product and min_product, with the first two numbers in the list.\n    Then, iterate through the remaining numbers in the list, updating the max_product and min_product based on the current number.\n    Finally, return the maximum product of three numbers from the max_product variable.\n    \"\"\"\n\n    if len(arr) < 3:\n        return 0\n\n    max_product = arr[0] * arr[1] * arr[2]\n    min_product = arr[0] * arr[1] * arr[2]\n\n    for i in range(3, len(arr)):\n        current_num = arr[i]\n\n        product1 = max_product * current_num\n        product2 = min_product * current_num\n\n        max_product = max(product1, product2, current_num)\n        min_product = min(product1, product2, current_num)\n\n    return max_product\n\ndef g() -> List[int]:\n    arr = [1, -2, 3, -4, 5]\n    return arr\n\nassert f(g()) == 60\n", "emb": null, "idx_generation": 458, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: arr = [1, -2, 3, -4, 5]\n    Output: 60\n    Explanation: The maximum product of any three numbers in the list is 5 * (-2) * (-4) = 60.\n\n    Hint: Use dynamic programming to keep track of the maximum and minimum products of two numbers in the list.\n    Initialize two variables, max_product and min_product, with the first two numbers in the list.\n    Then, iterate through the remaining numbers in the list, updating the max_product and min_product based on the current number.\n    Finally, return the maximum product of three numbers from the max_product variable.\n    \"\"\"\n\n    if len(arr) < 3:\n        return 0\n\n    max_product = arr[0] * arr[1] * arr[2]\n    min_product = arr[0] * arr[1] * arr[2]\n\n    for i in range(3, len(arr)):\n        current_num = arr[i]\n\n        product1 = max_product * current_num\n        product2 = min_product * current_num\n\n        max_product = max(product1, product2, current_num)\n        min_product = min(product1, product2, current_num)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    arr = [1, -2, 3, -4, 5]\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers, find the missing number in the range from 0 to n.\n\n    Example:\n    Input: [0, 1, 2, 4, 5, 6]\n    Output: 3\n    Explanation: The missing number in the range from 0 to 6 is 3.\n    \"\"\"\n\n    def find_missing_number(nums):\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if nums[mid] == mid:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return left\n\n    return find_missing_number(nums)\n\ndef g() -> List[int]:\n    nums = [0, 1, 2, 4, 5, 6]\n    return nums\n\nassert f(g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a sorted array of distinct integers, find the missing number in the range from 0 to n.\n\n    Example:\n    Input: [0, 1, 2, 4, 5, 6]\n    Output: 3\n    Explanation: The missing number in the range from 0 to 6 is 3.\n    \"\"\"\n\n    def find_missing_number(nums):\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if nums[mid] == mid:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return left\n\n    return find_missing_number(nums)", "solution_func": "def g() -> List[int]:\n    nums = [0, 1, 2, 4, 5, 6]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', return the longest palindrome that can be constructed by rearranging the characters in 's'.\n    If multiple palindromes of the same length exist, return the lexicographically smallest one.\n\n    Example:\n    Input: \"abccccdd\"\n    Output: \"dccaccd\"\n    Explanation: The longest palindrome that can be constructed is \"dccaccd\".\n    \"\"\"\n\n    def longest_palindrome(s):\n        char_count = {}\n\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n\n        odd_count = 0\n        middle_char = \"\"\n        palindrome = \"\"\n\n        for char, count in char_count.items():\n            if count % 2 == 0:\n                palindrome += char * (count // 2)\n            else:\n                odd_count += 1\n                middle_char = char\n\n                if odd_count > 1:\n                    return \"\"\n\n        return palindrome + middle_char + palindrome[::-1]\n\n    return longest_palindrome(s)\n\ndef g() -> str:\n    s = \"abccccdd\"\n    return s\n\nassert f(g()) == \"dccaccd\"\n\n", "emb": null, "idx_generation": 459, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string 's', return the longest palindrome that can be constructed by rearranging the characters in 's'.\n    If multiple palindromes of the same length exist, return the lexicographically smallest one.\n\n    Example:\n    Input: \"abccccdd\"\n    Output: \"dccaccd\"\n    Explanation: The longest palindrome that can be constructed is \"dccaccd\".\n    \"\"\"\n\n    def longest_palindrome(s):\n        char_count = {}\n\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n\n        odd_count = 0\n        middle_char = \"\"\n        palindrome = \"\"\n\n        for char, count in char_count.items():\n            if count % 2 == 0:\n                palindrome += char * (count // 2)\n            else:\n                odd_count += 1\n                middle_char = char\n\n                if odd_count > 1:\n                    return \"\"\n\n        return palindrome + middle_char + palindrome[::-1]\n\n    return longest_palindrome(s)", "solution_func": "def g() -> str:\n    s = \"abccccdd\"\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'nums', return True if it can be partitioned into two subsets such that the sum of elements\n    in both subsets is equal, otherwise return False.\n\n    Example:\n    Input: [1, 5, 11, 5]\n    Output: True\n    Explanation: The array can be partitioned into [1, 5, 5] and [11] with equal sum.\n    \"\"\"\n\n    def can_partition(nums):\n        total_sum = sum(nums)\n\n        if total_sum % 2 != 0:\n            return False\n\n        target_sum = total_sum // 2\n        dp = [False] * (target_sum + 1)\n        dp[0] = True\n\n        for num in nums:\n            for i in range(target_sum, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n\n        return dp[target_sum]\n\n    return can_partition(nums)\n\ndef g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given an array of integers 'nums', return True if it can be partitioned into two subsets such that the sum of elements\n    in both subsets is equal, otherwise return False.\n\n    Example:\n    Input: [1, 5, 11, 5]\n    Output: True\n    Explanation: The array can be partitioned into [1, 5, 5] and [11] with equal sum.\n    \"\"\"\n\n    def can_partition(nums):\n        total_sum = sum(nums)\n\n        if total_sum % 2 != 0:\n            return False\n\n        target_sum = total_sum // 2\n        dp = [False] * (target_sum + 1)\n        dp[0] = True\n\n        for num in nums:\n            for i in range(target_sum, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n\n        return dp[target_sum]\n\n    return can_partition(nums)", "solution_func": "def g() -> List[int]:\n    nums = [1, 5, 11, 5]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed and capitalized.\n\n    Example:\n    words = [\"hello\", \"world\", \"python\"]\n\n    The function should return [\"OLLEH\", \"DLROW\", \"NOHTYP\"].\n    \"\"\"\n    reversed_words = []\n    for word in words:\n        reversed_word = word[::-1]\n        reversed_word = reversed_word.upper()\n        reversed_words.append(reversed_word)\n    return reversed_words\n\ndef g():\n    words = [\"hello\", \"world\", \"python\"]\n    return words\n\nassert f(g()) == [\"OLLEH\", \"DLROW\", \"NOHTYP\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list where each word is reversed and capitalized.\n\n    Example:\n    words = [\"hello\", \"world\", \"python\"]\n\n    The function should return [\"OLLEH\", \"DLROW\", \"NOHTYP\"].\n    \"\"\"\n    reversed_words = []\n    for word in words:\n        reversed_word = word[::-1]\n        reversed_word = reversed_word.upper()\n        reversed_words.append(reversed_word)\n    return reversed_words", "solution_func": "def g():\n    words = [\"hello\", \"world\", \"python\"]\n    return words", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the longest consecutive sequence of 1s.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 0, 1, 1]\n    ]\n\n    The longest consecutive sequence of 1s has a length of 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_length = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                length = dfs(grid, i, j)\n                max_length = max(max_length, length)\n\n    return max_length\n\ndef dfs(grid: List[List[int]], row: int, col: int) -> int:\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n        return 0\n\n    grid[row][col] = 0\n\n    length = 1\n\n    length += dfs(grid, row + 1, col)\n    length += dfs(grid, row - 1, col)\n    length += dfs(grid, row, col + 1)\n    length += dfs(grid, row, col - 1)\n\n    return length\n\ndef g():\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 459, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, find the length of the longest consecutive sequence of 1s.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 0, 1, 1]\n    ]\n\n    The longest consecutive sequence of 1s has a length of 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    max_length = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                length = dfs(grid, i, j)\n                max_length = max(max_length, length)\n\n    return max_length\n\ndef dfs(grid: List[List[int]], row: int, col: int) -> int:\n    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n        return 0\n\n    grid[row][col] = 0\n\n    length = 1\n\n    length += dfs(grid, row + 1, col)\n    length += dfs(grid, row - 1, col)\n    length += dfs(grid, row, col + 1)\n    length += dfs(grid, row, col - 1)\n\n    return length", "solution_func": "def g():\n    grid = [\n        [1, 1, 0, 0],\n        [0, 1, 1, 1],\n        [1, 0, 0, 1],\n        [1, 0, 1, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    The function should return [1, 2], since nums[1] + nums[2] = 4 + 6 = 10.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return (nums, target)\n\nassert f(*g()) == [1, 2]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 459, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of numbers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in a list.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    The function should return [1, 2], since nums[1] + nums[2] = 4 + 6 = 10.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []", "solution_func": "def g():\n    nums = [2, 4, 6, 8]\n    target = 10\n    return (nums, target)", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n    Explanation:\n    The maximum product can be achieved by multiplying 2, 3, and 4, resulting in 24.\n\n    Note:\n    - The length of the input list will be at least 3.\n    - The input list may contain negative numbers.\n    \"\"\"\n\n    def max_product(nums):\n        nums.sort()\n        n = len(nums)\n        return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\n    return max_product(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4]\n    Output: 24\n    Explanation:\n    The maximum product can be achieved by multiplying 2, 3, and 4, resulting in 24.\n\n    Note:\n    - The length of the input list will be at least 3.\n    - The input list may contain negative numbers.\n    \"\"\"\n\n    def max_product(nums):\n        nums.sort()\n        n = len(nums)\n        return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\n    return max_product(nums)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The function should return 12, as the maximum sum of a path is 12 (1 -> 3 -> 5 -> 2 -> 1).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n\n    def max_path_sum(grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        dp = [[0] * cols for _ in range(rows)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, rows):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n        return dp[rows - 1][cols - 1]\n\n    return max_path_sum(grid)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 459, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The function should return 12, as the maximum sum of a path is 12 (1 -> 3 -> 5 -> 2 -> 1).\n\n    Note:\n    - The grid has at most 200 cells.\n    - Each cell in the grid contains a non-negative integer.\n    - The grid is rectangular in shape, with at least one row and one column.\n    \"\"\"\n\n    def max_path_sum(grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        dp = [[0] * cols for _ in range(rows)]\n        dp[0][0] = grid[0][0]\n\n        for i in range(1, rows):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n        for j in range(1, cols):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n        return dp[rows - 1][cols - 1]\n\n    return max_path_sum(grid)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any non-adjacent numbers in the list.\n\n    Example:\n    Input: [2, 4, 6, 2, 5]\n    Output: 13\n    Explanation:\n    The maximum sum can be achieved by selecting numbers 2, 6, and 5, resulting in a sum of 13.\n\n    Note:\n    - The length of the input list will be at least 3.\n    - The input list may contain negative numbers.\n    \"\"\"\n\n    def max_sum(nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n        return dp[n - 1]\n\n    return max_sum(nums)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 6, 2, 5]\n\nassert f(g()) == 13\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 459, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any non-adjacent numbers in the list.\n\n    Example:\n    Input: [2, 4, 6, 2, 5]\n    Output: 13\n    Explanation:\n    The maximum sum can be achieved by selecting numbers 2, 6, and 5, resulting in a sum of 13.\n\n    Note:\n    - The length of the input list will be at least 3.\n    - The input list may contain negative numbers.\n    \"\"\"\n\n    def max_sum(nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n        return dp[n - 1]\n\n    return max_sum(nums)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 4, 6, 2, 5]", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a palindrome and contains only prime numbers.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    nums = [str(num) for num in nums]\n    return all(is_prime(int(num)) for num in nums) and is_palindrome(''.join(nums))\n\ndef g():\n    return [2, 3, 5, 7, 11, 131]\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 459, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> bool:\n    \"\"\"Check if the given list of numbers is a palindrome and contains only prime numbers.\"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    nums = [str(num) for num in nums]\n    return all(is_prime(int(num)) for num in nums) and is_palindrome(''.join(nums))", "solution_func": "def g():\n    return [2, 3, 5, 7, 11, 131]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two vertices 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\n\n    Example:\n    Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from 'A' to 'D' in the graph: A -> B -> D.\n    \"\"\"\n\n    def dfs(node: str, visited: set) -> bool:\n        if node == end:\n            return True\n\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = set()\n    return dfs(start, visited)\n\ndef g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, along with 'start' and 'end' vertices, such that there is a path from 'start' to 'end' in the graph.\n    \"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n    return graph, start, end\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency list and two vertices 'start' and 'end', determine if there is a path from 'start' to 'end' in the graph.\n\n    Example:\n    Input:\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n\n    Output:\n    True\n\n    Explanation:\n    There is a path from 'A' to 'D' in the graph: A -> B -> D.\n    \"\"\"\n\n    def dfs(node: str, visited: set) -> bool:\n        if node == end:\n            return True\n\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n\n        return False\n\n    visited = set()\n    return dfs(start, visited)", "solution_func": "def g() -> Tuple[Dict[str, List[str]], str, str]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency list, along with 'start' and 'end' vertices, such that there is a path from 'start' to 'end' in the graph.\n    \"\"\"\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n    start = 'A'\n    end = 'D'\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'target', find the number of ways to combine the numbers in 'nums' using bitwise OR such that the result is equal to 'target'.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    There are 2 ways to combine the numbers in 'nums' using bitwise OR to get 6:\n    - 1 | 2 | 3 = 6\n    - 2 | 4 = 6\n    \"\"\"\n\n    def dfs(index: int, current: int) -> int:\n        if index == len(nums):\n            return 1 if current == target else 0\n\n        count = dfs(index + 1, current | nums[index])\n        count += dfs(index + 1, current)\n\n        return count\n\n    return dfs(0, 0)\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers 'nums' and an integer 'target' such that there are multiple ways to combine the numbers in 'nums' using bitwise OR to get 'target'.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 460, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'target', find the number of ways to combine the numbers in 'nums' using bitwise OR such that the result is equal to 'target'.\n\n    Example:\n    Input:\n    nums = [1, 2, 3, 4]\n    target = 6\n\n    Output:\n    2\n\n    Explanation:\n    There are 2 ways to combine the numbers in 'nums' using bitwise OR to get 6:\n    - 1 | 2 | 3 = 6\n    - 2 | 4 = 6\n    \"\"\"\n\n    def dfs(index: int, current: int) -> int:\n        if index == len(nums):\n            return 1 if current == target else 0\n\n        count = dfs(index + 1, current | nums[index])\n        count += dfs(index + 1, current)\n\n        return count\n\n    return dfs(0, 0)", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers 'nums' and an integer 'target' such that there are multiple ways to combine the numbers in 'nums' using bitwise OR to get 'target'.\n    \"\"\"\n    nums = [1, 2, 3, 4]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string 'string', return the shortest palindrome that can be formed by adding characters to the beginning of 'string'.\n\n    Example:\n    Input: \"abc\"\n    Output: \"cbabc\"\n\n    Explanation:\n    The shortest palindrome that can be formed by adding characters to the beginning of \"abc\" is \"cbabc\".\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(start: int, end: int) -> str:\n        if start >= end or is_palindrome(string[start:end+1]):\n            return string[:start] + string[start:end+1][::-1] + string[end+1:]\n\n        return dfs(start, end - 1)\n\n    return dfs(0, len(string) - 1)\n\ndef g() -> str:\n    \"\"\"\n    Generate a string 'string' such that the shortest palindrome that can be formed by adding characters to the beginning of 'string' is longer than 'string' itself.\n    \"\"\"\n    string = \"abc\"\n    return string\n\nassert f(g()) == \"cbabc\"\n", "emb": null, "idx_generation": 460, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string 'string', return the shortest palindrome that can be formed by adding characters to the beginning of 'string'.\n\n    Example:\n    Input: \"abc\"\n    Output: \"cbabc\"\n\n    Explanation:\n    The shortest palindrome that can be formed by adding characters to the beginning of \"abc\" is \"cbabc\".\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def dfs(start: int, end: int) -> str:\n        if start >= end or is_palindrome(string[start:end+1]):\n            return string[:start] + string[start:end+1][::-1] + string[end+1:]\n\n        return dfs(start, end - 1)\n\n    return dfs(0, len(string) - 1)", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string 'string' such that the shortest palindrome that can be formed by adding characters to the beginning of 'string' is longer than 'string' itself.\n    \"\"\"\n    string = \"abc\"\n    return string", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median element.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2\n    else:\n        return nums[n // 2]\n\ndef g():\n    nums = [5, 2, 7, 9, 1, 3]\n    return nums\n\nassert f(g()) == 4.0\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the median element.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2\n    else:\n        return nums[n // 2]", "solution_func": "def g():\n    nums = [5, 2, 7, 9, 1, 3]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, count the number of occurrences of the target in the list.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num == target:\n            count += 1\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 2, 2, 5, 2]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, count the number of occurrences of the target in the list.\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num == target:\n            count += 1\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 2, 2, 5, 2]\n    target = 2\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicate elements removed.\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums\n\ndef g():\n    nums = [1, 2, 3, 2, 4, 5, 3]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with all duplicate elements removed.\n    \"\"\"\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums", "solution_func": "def g():\n    nums = [1, 2, 3, 2, 4, 5, 3]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    Input: nums = [2, 3, -2, 4]\n    Output: 6\n    Explanation: The subarray [2, 3] has the maximum product of 6.\n\n    Input: nums = [-2, 0, -1]\n    Output: 0\n    Explanation: The subarray [-2, 0, -1] has the maximum product of 0.\n    \"\"\"\n\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n\n        result = max(result, max_product)\n\n    return result\n\ndef g() -> List[int]:\n    nums = [2, 3, -2, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 460, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of a subarray.\n\n    Example:\n    Input: nums = [2, 3, -2, 4]\n    Output: 6\n    Explanation: The subarray [2, 3] has the maximum product of 6.\n\n    Input: nums = [-2, 0, -1]\n    Output: 0\n    Explanation: The subarray [-2, 0, -1] has the maximum product of 0.\n    \"\"\"\n\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n\n        result = max(result, max_product)\n\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [2, 3, -2, 4]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Input: nums = [1]\n    Output: 1\n    Explanation: The subarray [1] has the maximum sum of 1.\n    \"\"\"\n\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Input: nums = [1]\n    Output: 1\n    Explanation: The subarray [1] has the maximum sum of 1.\n    \"\"\"\n\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Input: nums = [0, 1, 0, 3, 2, 3]\n    Output: 4\n    Explanation: The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.\n    \"\"\"\n\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, return the number of paths from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    n = 3, m = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n\n    The grid represents a 3x3 grid with all cells initially set to 0.\n    The number of paths from the top-left cell to the bottom-right cell is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def backtrack(row, col):\n        if row == n - 1 and col == m - 1:\n            return 1\n        if row >= n or col >= m:\n            return 0\n        return backtrack(row + 1, col) + backtrack(row, col + 1)\n\n    return backtrack(0, 0)\n\ndef g():\n    n = 3\n    m = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n    return n, m, grid\n\nassert f(*g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 460, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of size n x m, return the number of paths from the top-left cell to the bottom-right cell.\n    You can only move right or down.\n\n    Example:\n    n = 3, m = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n\n    The grid represents a 3x3 grid with all cells initially set to 0.\n    The number of paths from the top-left cell to the bottom-right cell is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    def backtrack(row, col):\n        if row == n - 1 and col == m - 1:\n            return 1\n        if row >= n or col >= m:\n            return 0\n        return backtrack(row + 1, col) + backtrack(row, col + 1)\n\n    return backtrack(0, 0)", "solution_func": "def g():\n    n = 3\n    m = 3\n    grid = [[0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]]\n    return n, m, grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value that can be obtained by selecting two numbers from the list is 28, which can be obtained by XORing the numbers 25 and 3.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting two numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value that can be obtained by selecting two numbers from the list is 28, which can be obtained by XORing the numbers 25 and 3.\n\n    Therefore, the function should return 28.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the minimum XOR value between any two nodes.\n\n    Return the minimum XOR value.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    The minimum XOR value between any two nodes in the graph is 0, which can be obtained by XORing the nodes 0 and 0.\n\n    Therefore, the function should return 0.\n    \"\"\"\n    min_xor = float('inf')\n\n    for i in range(len(graph)):\n        for j in range(len(graph[0])):\n            if graph[i][j] == 1:\n                xor = i ^ j\n                min_xor = min(min_xor, xor)\n\n    return min_xor\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\nassert f(g()) == 0\n", "emb": null, "idx_generation": 461, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the minimum XOR value between any two nodes.\n\n    Return the minimum XOR value.\n\n    Example:\n    graph = [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]\n\n    The minimum XOR value between any two nodes in the graph is 0, which can be obtained by XORing the nodes 0 and 0.\n\n    Therefore, the function should return 0.\n    \"\"\"\n    min_xor = float('inf')\n\n    for i in range(len(graph)):\n        for j in range(len(graph[0])):\n            if graph[i][j] == 1:\n                xor = i ^ j\n                min_xor = min(min_xor, xor)\n\n    return min_xor", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a graph represented as an adjacency matrix for Puzzle 4.\n    \"\"\"\n    return [\n        [0, 1, 0, 1],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [1, 0, 1, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting three numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value that can be obtained by selecting three numbers from the list is 31, which can be obtained by XORing the numbers 25, 5, and 1.\n\n    Therefore, the function should return 31.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                xor = nums[i] ^ nums[j] ^ nums[k]\n                max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 31\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum XOR value that can be obtained by selecting three numbers from the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value that can be obtained by selecting three numbers from the list is 31, which can be obtained by XORing the numbers 25, 5, and 1.\n\n    Therefore, the function should return 31.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                xor = nums[i] ^ nums[j] ^ nums[k]\n                max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 5.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    The function should return True since 3 + 4 = 7.\n\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    The function should return False since there are no two numbers that add up to 10.\n\n    Return True or False as the result.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\ndef h() -> int:\n    \"\"\"\n    Generate a target value.\n    \"\"\"\n    target = 7\n    return target\n\nassert f(g(), h()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such a pair exists, otherwise return False.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 7\n    The function should return True since 3 + 4 = 7.\n\n    nums = [1, 2, 3, 4, 5]\n    target = 10\n    The function should return False since there are no two numbers that add up to 10.\n\n    Return True or False as the result.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        sum = nums[left] + nums[right]\n        if sum == target:\n            return True\n        elif sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\ndef h() -> int:\n    \"\"\"\n    Generate a target value.\n    \"\"\"\n    target = 7\n    return target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    A path can only move down or right.\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The function should return 7 since the minimum sum path is 1->3->1->1->1.\n\n    Return the minimum sum as the result.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum sum of a path from the top-left cell to the bottom-right cell.\n    A path can only move down or right.\n    Return the minimum sum.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    The function should return 7 since the minimum sum path is 1->3->1->1->1.\n\n    Return the minimum sum as the result.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two.\n    Return the nth number as the result.\n\n    Example:\n    n = 6\n    The function should return 8 since the 6th Fibonacci number is 8.\n\n    Return the nth Fibonacci number as the result.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev = 0\n    curr = 1\n\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 6\n    return n\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth number in the Fibonacci sequence.\n    The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two.\n    Return the nth number as the result.\n\n    Example:\n    n = 6\n    The function should return 8 since the 6th Fibonacci number is 8.\n\n    Return the nth Fibonacci number as the result.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    prev = 0\n    curr = 1\n\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer.\n    \"\"\"\n    n = 6\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 2, 3, and 4.\n    Therefore, the function should return 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    # If all numbers are negative or all numbers are positive, the maximum product is the product of the three largest numbers\n    if nums[0] >= 0 or nums[n-1] <= 0:\n        return nums[n-1] * nums[n-2] * nums[n-3]\n\n    # Otherwise, the maximum product is the maximum of the product of the two smallest negative numbers and the largest positive number\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4]\n\nassert f(g()) == 24\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of any three numbers in the list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4]\n    Output: 24\n\n    Explanation:\n    The maximum product can be obtained by multiplying 2, 3, and 4.\n    Therefore, the function should return 24.\n    \"\"\"\n\n    nums.sort()\n    n = len(nums)\n\n    # If all numbers are negative or all numbers are positive, the maximum product is the product of the three largest numbers\n    if nums[0] >= 0 or nums[n-1] <= 0:\n        return nums[n-1] * nums[n-2] * nums[n-3]\n\n    # Otherwise, the maximum product is the maximum of the product of the two smallest negative numbers and the largest positive number\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Example:\n    Input: s = \"Hello World!\"\n    Output: \"World! Hello\"\n\n    Explanation: The words in the string are \"Hello\" and \"World!\". Reversing the order of the words gives \"World! Hello\".\n    Therefore, the function should return \"World! Hello\".\n    \"\"\"\n\n    words = s.split()\n    return ' '.join(words[::-1])\n\ndef g() -> str:\n    return \"Hello World!\"\n\nassert f(g()) == \"World! Hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 461, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n\n    Example:\n    Input: s = \"Hello World!\"\n    Output: \"World! Hello\"\n\n    Explanation: The words in the string are \"Hello\" and \"World!\". Reversing the order of the words gives \"World! Hello\".\n    Therefore, the function should return \"World! Hello\".\n    \"\"\"\n\n    words = s.split()\n    return ' '.join(words[::-1])", "solution_func": "def g() -> str:\n    return \"Hello World!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any two non-overlapping subarrays of size k.\n\n    Example:\n    Input: nums = [1, 2, 1, 2, 6, 7, 5, 1], k = 2\n    Output: 15\n\n    Explanation:\n    The maximum sum can be obtained by selecting the subarrays [1, 2] and [6, 7].\n    Therefore, the function should return 15.\n    \"\"\"\n\n    def max_sum(nums: List[int], k: int) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        left = 0\n        for right in range(len(nums)):\n            curr_sum += nums[right]\n            if right - left + 1 == k:\n                max_sum = max(max_sum, curr_sum)\n                curr_sum -= nums[left]\n                left += 1\n        return max_sum\n\n    n = len(nums)\n    max_sum1 = float('-inf')\n\n    for i in range(n - 1):\n        subarray1 = nums[i:i+k]\n        subarray2 = nums[i+k:]\n        sum1 = max_sum(subarray1, k)\n        sum2 = max_sum(subarray2, k)\n        max_sum1 = max(max_sum1, sum1 + sum2)\n\n    return max_sum1\n\ndef g() -> List[int]:\n    return [1, 2, 1, 2, 6, 7, 5, 1]\n\nassert f(g()) == 15\n\n", "emb": null, "idx_generation": 461, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of any two non-overlapping subarrays of size k.\n\n    Example:\n    Input: nums = [1, 2, 1, 2, 6, 7, 5, 1], k = 2\n    Output: 15\n\n    Explanation:\n    The maximum sum can be obtained by selecting the subarrays [1, 2] and [6, 7].\n    Therefore, the function should return 15.\n    \"\"\"\n\n    def max_sum(nums: List[int], k: int) -> int:\n        max_sum = float('-inf')\n        curr_sum = 0\n        left = 0\n        for right in range(len(nums)):\n            curr_sum += nums[right]\n            if right - left + 1 == k:\n                max_sum = max(max_sum, curr_sum)\n                curr_sum -= nums[left]\n                left += 1\n        return max_sum\n\n    n = len(nums)\n    max_sum1 = float('-inf')\n\n    for i in range(n - 1):\n        subarray1 = nums[i:i+k]\n        subarray2 = nums[i+k:]\n        sum1 = max_sum(subarray1, k)\n        sum2 = max_sum(subarray2, k)\n        max_sum1 = max(max_sum1, sum1 + sum2)\n\n    return max_sum1", "solution_func": "def g() -> List[int]:\n    return [1, 2, 1, 2, 6, 7, 5, 1]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nimport itertools\n\ndef f(n: int, pattern: str) -> bool:\n    \"\"\"\n    Given a positive integer n and a pattern, determine if the pattern can be formed by arranging the digits of n in a circular manner.\n    \"\"\"\n\n    def get_permutations(num):\n        num_str = str(num)\n        digits = len(num_str)\n        num_list = []\n        for i in range(digits):\n            num_list.append(num_str[i:] + num_str[:i])\n        return num_list\n\n    def check_pattern(num, pattern):\n        permutations = get_permutations(num)\n        for perm in permutations:\n            if perm == pattern:\n                return True\n        return False\n\n    return check_pattern(n, pattern)\n\ndef g(n=12345, pattern='54321'):\n    return n, pattern\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 461, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nimport itertools\n\ndef f(n: int, pattern: str) -> bool:\n    \"\"\"\n    Given a positive integer n and a pattern, determine if the pattern can be formed by arranging the digits of n in a circular manner.\n    \"\"\"\n\n    def get_permutations(num):\n        num_str = str(num)\n        digits = len(num_str)\n        num_list = []\n        for i in range(digits):\n            num_list.append(num_str[i:] + num_str[:i])\n        return num_list\n\n    def check_pattern(num, pattern):\n        permutations = get_permutations(num)\n        for perm in permutations:\n            if perm == pattern:\n                return True\n        return False\n\n    return check_pattern(n, pattern)", "solution_func": "def g(n=12345, pattern='54321'):\n    return n, pattern", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 1 and 9 add up to the target number 10.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, start: int, end: int) -> bool:\n        if start > end:\n            return False\n\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, end)\n        else:\n            return binary_search(nums, target, start, mid - 1)\n\n    nums.sort()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums, complement, i + 1, len(nums) - 1):\n            return True\n\n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g())\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n\n    Output:\n    True\n\n    Explanation:\n    The numbers 1 and 9 add up to the target number 10.\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, start: int, end: int) -> bool:\n        if start > end:\n            return False\n\n        mid = (start + end) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            return binary_search(nums, target, mid + 1, end)\n        else:\n            return binary_search(nums, target, start, mid - 1)\n\n    nums.sort()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if binary_search(nums, complement, i + 1, len(nums) - 1):\n            return True\n\n    return False", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string consisting of only '0's and '1's, find the longest substring that contains equal number of '0's and '1's.\n\n    Example:\n    s = \"1101001110\"\n\n    Output:\n    6\n\n    Explanation:\n    The longest substring with equal number of '0's and '1's is \"110100\".\n    \"\"\"\n\n    def longest_substring(s: str, count0: int, count1: int, max_length: int) -> int:\n        if not s:\n            return max_length\n\n        if count0 == count1:\n            return max(max_length, len(s))\n\n        if s[0] == '0':\n            count0 += 1\n        else:\n            count1 += 1\n\n        return longest_substring(s[1:], count0, count1, max_length)\n\n    return longest_substring(s, 0, 0, 0)\n\ndef g():\n    s = \"1101001110\"\n    return s\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 462, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string consisting of only '0's and '1's, find the longest substring that contains equal number of '0's and '1's.\n\n    Example:\n    s = \"1101001110\"\n\n    Output:\n    6\n\n    Explanation:\n    The longest substring with equal number of '0's and '1's is \"110100\".\n    \"\"\"\n\n    def longest_substring(s: str, count0: int, count1: int, max_length: int) -> int:\n        if not s:\n            return max_length\n\n        if count0 == count1:\n            return max(max_length, len(s))\n\n        if s[0] == '0':\n            count0 += 1\n        else:\n            count1 += 1\n\n        return longest_substring(s[1:], count0, count1, max_length)\n\n    return longest_substring(s, 0, 0, 0)", "solution_func": "def g():\n    s = \"1101001110\"\n    return s", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n\n    Explanation:\n    The maximum sum path is 1 -> 2 -> 3 -> 6 -> 9, with a total sum of 21.\n    \"\"\"\n\n    def max_path_sum(grid: List[List[int]], i: int, j: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        down = right = float('-inf')\n\n        if i < len(grid) - 1:\n            down = max_path_sum(grid, i + 1, j, memo)\n\n        if j < len(grid[0]) - 1:\n            right = max_path_sum(grid, i, j + 1, memo)\n\n        memo[(i, j)] = grid[i][j] + max(down, right)\n        return memo[(i, j)]\n\n    memo = {}\n    return max_path_sum(grid, 0, 0, memo)\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 21\n", "emb": null, "idx_generation": 462, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n\n    Explanation:\n    The maximum sum path is 1 -> 2 -> 3 -> 6 -> 9, with a total sum of 21.\n    \"\"\"\n\n    def max_path_sum(grid: List[List[int]], i: int, j: int, memo: Dict[Tuple[int, int], int]) -> int:\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return grid[i][j]\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        down = right = float('-inf')\n\n        if i < len(grid) - 1:\n            down = max_path_sum(grid, i + 1, j, memo)\n\n        if j < len(grid[0]) - 1:\n            right = max_path_sum(grid, i, j + 1, memo)\n\n        memo[(i, j)] = grid[i][j] + max(down, right)\n        return memo[(i, j)]\n\n    memo = {}\n    return max_path_sum(grid, 0, 0, memo)", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of elements in the given array whose sum is equal to the target value.\"\"\"\n    arr.sort()  # Sorting the array to utilize binary search\n    low = 0\n    high = len(arr) - 1\n\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            low += 1\n        else:\n            high -= 1\n\n    return False\n\ndef g(arr=[1, 3, 5, 7, 9], target=10) -> List[int]:\n    return arr\n\nassert f(g())\n", "emb": null, "idx_generation": 462, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"Find if there exists a pair of elements in the given array whose sum is equal to the target value.\"\"\"\n    arr.sort()  # Sorting the array to utilize binary search\n    low = 0\n    high = len(arr) - 1\n\n    while low < high:\n        curr_sum = arr[low] + arr[high]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            low += 1\n        else:\n            high -= 1\n\n    return False", "solution_func": "def g(arr=[1, 3, 5, 7, 9], target=10) -> List[int]:\n    return arr", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner in an n x n grid.\"\"\"\n    memo = [[0] * (n + 1) for _ in range(n + 1)]  # Memoization to store computed values\n\n    def unique_paths(i: int, j: int) -> int:\n        if i == n and j == n:\n            return 1\n        if i > n or j > n:\n            return 0\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        memo[i][j] = unique_paths(i + 1, j) + unique_paths(i, j + 1)\n        return memo[i][j]\n\n    return unique_paths(0, 0)\n\ndef g(n=3) -> int:\n    return n\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 462, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"Find the number of unique paths from the top-left corner to the bottom-right corner in an n x n grid.\"\"\"\n    memo = [[0] * (n + 1) for _ in range(n + 1)]  # Memoization to store computed values\n\n    def unique_paths(i: int, j: int) -> int:\n        if i == n and j == n:\n            return 1\n        if i > n or j > n:\n            return 0\n        if memo[i][j] != 0:\n            return memo[i][j]\n\n        memo[i][j] = unique_paths(i + 1, j) + unique_paths(i, j + 1)\n        return memo[i][j]\n\n    return unique_paths(0, 0)", "solution_func": "def g(n=3) -> int:\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in the given array using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> List[int]:\n    return arr\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"Find the maximum subarray sum in the given array using Kadane's algorithm.\"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in arr:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g(arr=[-2, 1, -3, 4, -1, 2, 1, -5, 4]) -> List[int]:\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 1]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum sum can be obtained by selecting subarray [1, 3].\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g():\n    return [1, 2, 3, 1]\n\nassert f(g()) == 4\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum that can be obtained by selecting a subarray with the constraint that no two numbers in the subarray are adjacent.\n\n    Example:\n    nums = [1, 2, 3, 1]\n\n    Output:\n    4\n\n    Explanation:\n    The maximum sum can be obtained by selecting subarray [1, 3].\n    \"\"\"\n\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]", "solution_func": "def g():\n    return [1, 2, 3, 1]", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if it is possible to obtain the target sum by selecting a subset of the integers.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 4, 8] sums up to 14, so it is possible to obtain the target sum.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n\n    for i in range(n+1):\n        dp[i][0] = True\n\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n\n    return dp[n][target]\n\ndef g():\n    nums = [2, 4, 6, 8]\n    target = 14\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 462, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target sum, determine if it is possible to obtain the target sum by selecting a subset of the integers.\n\n    Example:\n    nums = [2, 4, 6, 8]\n    target = 14\n\n    Output:\n    True\n\n    Explanation:\n    The subset [2, 4, 8] sums up to 14, so it is possible to obtain the target sum.\n    \"\"\"\n\n    n = len(nums)\n    dp = [[False] * (target + 1) for _ in range(n+1)]\n\n    for i in range(n+1):\n        dp[i][0] = True\n\n    for i in range(1, n+1):\n        for j in range(1, target+1):\n            if j < nums[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]\n\n    return dp[n][target]", "solution_func": "def g():\n    nums = [2, 4, 6, 8]\n    target = 14\n    return nums, target", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the maximum sum of any contiguous subarray of size k.\n\n    Example:\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n\n    Output:\n    9\n\n    Explanation:\n    The subarray with maximum sum is [5, 1, 3], which sums up to 9.\n    \"\"\"\n\n    n = len(nums)\n\n    if n < k:\n        return 0\n\n    max_sum = sum(nums[:k])\n    current_sum = max_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i-k]\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n    return nums, k\n\nassert f(*g()) == 9\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 462, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and a value k, find the maximum sum of any contiguous subarray of size k.\n\n    Example:\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n\n    Output:\n    9\n\n    Explanation:\n    The subarray with maximum sum is [5, 1, 3], which sums up to 9.\n    \"\"\"\n\n    n = len(nums)\n\n    if n < k:\n        return 0\n\n    max_sum = sum(nums[:k])\n    current_sum = max_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i-k]\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [2, 1, 5, 1, 3, 2]\n    k = 3\n    return nums, k", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, return True if the matrix can be transformed into a magic square, otherwise return False.\n\n    A magic square is a square matrix where the sum of each row, each column, and both diagonals is the same.\n\n    Example:\n    Input: [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n\n    Explanation:\n    The matrix can be transformed into the following magic square:\n        2 9 4\n        7 5 3\n        6 1 8\n    The sum of each row, each column, and both diagonals is 15.\n    \"\"\"\n\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n        for i in range(n):\n            if sum(matrix[i]) != target_sum:\n                return False\n            if sum(row[i] for row in matrix) != target_sum:\n                return False\n        if sum(matrix[i][i] for i in range(n)) != target_sum:\n            return False\n        if sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n            return False\n        return True\n\n    return is_magic_square(matrix)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix where all rows, columns, and diagonals have the same sum.\n    \"\"\"\n    return [[8, 1, 6], [3, 5, 7], [4, 9, 2]]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 462, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of integers, return True if the matrix can be transformed into a magic square, otherwise return False.\n\n    A magic square is a square matrix where the sum of each row, each column, and both diagonals is the same.\n\n    Example:\n    Input: [[2, 7, 6], [9, 5, 1], [4, 3, 8]]\n    Output: True\n\n    Explanation:\n    The matrix can be transformed into the following magic square:\n        2 9 4\n        7 5 3\n        6 1 8\n    The sum of each row, each column, and both diagonals is 15.\n    \"\"\"\n\n    def is_magic_square(matrix: List[List[int]]) -> bool:\n        n = len(matrix)\n        target_sum = sum(matrix[0])\n        for i in range(n):\n            if sum(matrix[i]) != target_sum:\n                return False\n            if sum(row[i] for row in matrix) != target_sum:\n                return False\n        if sum(matrix[i][i] for i in range(n)) != target_sum:\n            return False\n        if sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n            return False\n        return True\n\n    return is_magic_square(matrix)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix where all rows, columns, and diagonals have the same sum.\n    \"\"\"\n    return [[8, 1, 6], [3, 5, 7], [4, 9, 2]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [2, 7, 11, 15]\n\nassert f(g(), 9) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        \n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [2, 7, 11, 15]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2 since nums[2] = 5.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), 5) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 463, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2 since nums[2] = 5.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 1]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph, determine if there is a path from the start node to the end node using a depth-first search (DFS).\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    The function should return True since there is a path from node 0 to node 4: [0, 1, 2, 3, 4].\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix.\n    \"\"\"\n    return [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n\nassert f(g(), 0, 4) == True\n", "emb": null, "idx_generation": 463, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> bool:\n    \"\"\"\n    Given a directed graph, determine if there is a path from the start node to the end node using a depth-first search (DFS).\n    Return True if a path exists, False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = 0\n    end = 4\n\n    The function should return True since there is a path from node 0 to node 4: [0, 1, 2, 3, 4].\n    \"\"\"\n    visited = [False] * len(graph)\n    \n    def dfs(node):\n        if node == end:\n            return True\n        \n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        \n        return False\n    \n    return dfs(start)", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a directed graph represented as an adjacency matrix.\n    \"\"\"\n    return [\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    4\n\n    Explanation:\n    The distinct pairs (i, j) are (1, 2), (1, 5), (2, 4), and (3, 4), which sum up to 3, 6, 7, and 9 respectively. \n    Out of these pairs, (3, 4) and (1, 2) are divisible by 3, so the answer is 4.\n    \"\"\"\n\n    count = 0\n    remainder_count = [0] * 3\n\n    for num in nums:\n        remainder_count[num % 3] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs with remainder 0\n    count += remainder_count[1] * remainder_count[2]  # Count pairs with remainders 1 and 2\n\n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the number of distinct pairs (i, j) where i < j and nums[i] + nums[j] is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5]\n\n    Sample Output:\n    4\n\n    Explanation:\n    The distinct pairs (i, j) are (1, 2), (1, 5), (2, 4), and (3, 4), which sum up to 3, 6, 7, and 9 respectively. \n    Out of these pairs, (3, 4) and (1, 2) are divisible by 3, so the answer is 4.\n    \"\"\"\n\n    count = 0\n    remainder_count = [0] * 3\n\n    for num in nums:\n        remainder_count[num % 3] += 1\n\n    count += (remainder_count[0] * (remainder_count[0] - 1)) // 2  # Count pairs with remainder 0\n    count += remainder_count[1] * remainder_count[2]  # Count pairs with remainders 1 and 2\n\n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The elements of the matrix in spiral order are 1, 2, 3, 6, 9, 8, 7, 4, and 5.\n    \"\"\"\n\n    spiral_order = []\n    if not matrix:\n        return spiral_order\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the elements of the matrix in spiral order.\n\n    Sample Input:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Sample Output:\n    [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    Explanation:\n    The elements of the matrix in spiral order are 1, 2, 3, 6, 9, 8, 7, 4, and 5.\n    \"\"\"\n\n    spiral_order = []\n    if not matrix:\n        return spiral_order\n\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for i in range(left, right + 1):\n            spiral_order.append(matrix[top][i])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            spiral_order.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                spiral_order.append(matrix[bottom][i])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                spiral_order.append(matrix[i][left])\n            left += 1\n\n    return spiral_order", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum difference between two elements in the list.\n\n    Sample Input:\n    nums = [9, 2, 5, 1, 7, 4, 10, 8]\n\n    Sample Output:\n    8\n\n    Explanation:\n    The maximum difference between two elements in the list is 8, which can be obtained by subtracting 2 from 10.\n    \"\"\"\n\n    if len(nums) < 2:\n        return 0\n\n    min_num = float('inf')\n    max_diff = 0\n\n    for num in nums:\n        min_num = min(min_num, num)\n        max_diff = max(max_diff, num - min_num)\n\n    return max_diff\n\ndef g():\n    nums = [9, 2, 5, 1, 7, 4, 10, 8]\n    return nums\n\nassert f(g()) == 8\n\n", "emb": null, "idx_generation": 463, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum difference between two elements in the list.\n\n    Sample Input:\n    nums = [9, 2, 5, 1, 7, 4, 10, 8]\n\n    Sample Output:\n    8\n\n    Explanation:\n    The maximum difference between two elements in the list is 8, which can be obtained by subtracting 2 from 10.\n    \"\"\"\n\n    if len(nums) < 2:\n        return 0\n\n    min_num = float('inf')\n    max_diff = 0\n\n    for num in nums:\n        min_num = min(min_num, num)\n        max_diff = max(max_diff, num - min_num)\n\n    return max_diff", "solution_func": "def g():\n    nums = [9, 2, 5, 1, 7, 4, 10, 8]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target element to find.\n\n    Returns:\n    - The index of the target element if found, otherwise -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 9) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 463, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n\n    Args:\n    - nums: A sorted list of integers.\n    - target: The target element to find.\n\n    Returns:\n    - The index of the target element if found, otherwise -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9, 11, 13, 15]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, world!\"\n\nassert f(g()) == \"world! Hello,\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of words in the string.\n\n    Args:\n    - s: The input string.\n\n    Returns:\n    - The string with words reversed.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"Hello, world!\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of elements in a rectangular subgrid of the given grid, where each element is a power of 2.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of elements in a rectangular subgrid.\n    \"\"\"\n    max_sum = 0\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k + 1):\n                        for n in range(j, l + 1):\n                            if grid[m][n] & (grid[m][n] - 1) == 0:\n                                subgrid_sum += grid[m][n]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    return [[1, 2, 4], [8, 16, 32], [64, 128, 256]]\n\nassert f(g()) == 408\n", "emb": null, "idx_generation": 463, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the maximum sum of elements in a rectangular subgrid of the given grid, where each element is a power of 2.\n\n    Args:\n    - grid: A 2D grid of integers.\n\n    Returns:\n    - The maximum sum of elements in a rectangular subgrid.\n    \"\"\"\n    max_sum = 0\n    rows = len(grid)\n    cols = len(grid[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    subgrid_sum = 0\n                    for m in range(i, k + 1):\n                        for n in range(j, l + 1):\n                            if grid[m][n] & (grid[m][n] - 1) == 0:\n                                subgrid_sum += grid[m][n]\n                    max_sum = max(max_sum, subgrid_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of integers.\n    \"\"\"\n    return [[1, 2, 4], [8, 16, 32], [64, 128, 256]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the starting and ending position of a given target value in the array.\n\n    Example:\n    Input: nums = [5, 7, 7, 8, 8, 10], target = 8\n    Output: [3, 4]\n\n    Explanation:\n    The value 8 appears at indices 3 and 4 in the array, so the output is [3, 4].\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: bool) -> int:\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] > target or (left and nums[mid] == target):\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start\n\n    left_index = binary_search(nums, target, True)\n    right_index = binary_search(nums, target, False) - 1\n\n    if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n        return [left_index, right_index]\n    else:\n        return [-1, -1]\n\ndef g():\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [3, 4]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 463, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the starting and ending position of a given target value in the array.\n\n    Example:\n    Input: nums = [5, 7, 7, 8, 8, 10], target = 8\n    Output: [3, 4]\n\n    Explanation:\n    The value 8 appears at indices 3 and 4 in the array, so the output is [3, 4].\n    \"\"\"\n\n    def binary_search(nums: List[int], target: int, left: bool) -> int:\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] > target or (left and nums[mid] == target):\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start\n\n    left_index = binary_search(nums, target, True)\n    right_index = binary_search(nums, target, False) - 1\n\n    if left_index <= right_index and right_index < len(nums) and nums[left_index] == target and nums[right_index] == target:\n        return [left_index, right_index]\n    else:\n        return [-1, -1]", "solution_func": "def g():\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"\n    Given an integer n and a string s, check if the length of s is a multiple of n.\n\n    Return True if the length of s is a multiple of n, False otherwise.\n    \"\"\"\n    return len(s) % n == 0\n\ndef g(n=4, s='hello'):\n    return n, s\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 464, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, s: str) -> bool:\n    \"\"\"\n    Given an integer n and a string s, check if the length of s is a multiple of n.\n\n    Return True if the length of s is a multiple of n, False otherwise.\n    \"\"\"\n    return len(s) % n == 0", "solution_func": "def g(n=4, s='hello'):\n    return n, s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n    \n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words\n\ndef g():\n    return 'Hello World'\n\nassert f(g()) == 'World Hello'\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the order of words in the string.\n    \n    Return the reversed string.\n    \"\"\"\n    words = s.split()\n    reversed_words = ' '.join(words[::-1])\n    return reversed_words", "solution_func": "def g():\n    return 'Hello World'", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all even numbers from the list and return the updated list.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == [1, 3, 5, 7, 9]\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, remove all even numbers from the list and return the updated list.\n    \"\"\"\n    return [num for num in nums if num % 2 != 0]", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [1, 1, 0, 1, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of subsets of the list that XOR to the target.\n    Return the count of such subsets.\n    \"\"\"\n    count = 0\n    subsets = [[]]\n    \n    for num in nums:\n        new_subsets = []\n        for subset in subsets:\n            new_subset = subset + [num]\n            new_subsets.append(new_subset)\n            xor_result = 0\n            for n in new_subset:\n                xor_result ^= n\n            if xor_result == target:\n                count += 1\n        subsets.extend(new_subsets)\n    \n    return count\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 464, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target integer, find the number of subsets of the list that XOR to the target.\n    Return the count of such subsets.\n    \"\"\"\n    count = 0\n    subsets = [[]]\n    \n    for num in nums:\n        new_subsets = []\n        for subset in subsets:\n            new_subset = subset + [num]\n            new_subsets.append(new_subset)\n            xor_result = 0\n            for n in new_subset:\n                xor_result ^= n\n            if xor_result == target:\n                count += 1\n        subsets.extend(new_subsets)\n    \n    return count", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of 0s and 1s, convert all the elements in the same connected component as the top left corner\n    to 1s. A connected component is a group of adjacent 1s (horizontally or vertically).\n    Return the modified matrix.\n    \"\"\"\n    if not matrix:\n        return matrix\n    \n    rows, cols = len(matrix), len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or matrix[row][col] == 0:\n            return\n        visited[row][col] = True\n        matrix[row][col] = 1\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    dfs(0, 0)\n    return matrix\n\ndef g():\n    matrix = [\n        [1, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1]\n    ]\n    return matrix\n\nassert f(g()) == [\n    [1, 1, 1, 1],\n    [1, 1, 1, 0],\n    [1, 1, 1, 0],\n    [1, 1, 0, 1]\n]\n", "emb": null, "idx_generation": 464, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of 0s and 1s, convert all the elements in the same connected component as the top left corner\n    to 1s. A connected component is a group of adjacent 1s (horizontally or vertically).\n    Return the modified matrix.\n    \"\"\"\n    if not matrix:\n        return matrix\n    \n    rows, cols = len(matrix), len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or matrix[row][col] == 0:\n            return\n        visited[row][col] = True\n        matrix[row][col] = 1\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    dfs(0, 0)\n    return matrix", "solution_func": "def g():\n    matrix = [\n        [1, 0, 0, 0],\n        [0, 1, 1, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1]\n    ]\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the total number of islands in the matrix.\n    An island is a group of adjacent 1s (horizontally or vertically).\n    Return the count of islands.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows, cols = len(matrix), len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or matrix[row][col] == 0:\n            return\n        visited[row][col] = True\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j] and matrix[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    \n    return count\n\ndef g():\n    matrix = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return matrix\n\nassert f(g()) == 3\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of 0s and 1s, find the total number of islands in the matrix.\n    An island is a group of adjacent 1s (horizontally or vertically).\n    Return the count of islands.\n    \"\"\"\n    if not matrix:\n        return 0\n    \n    rows, cols = len(matrix), len(matrix[0])\n    visited = [[False] * cols for _ in range(rows)]\n    count = 0\n    \n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or col >= cols or visited[row][col] or matrix[row][col] == 0:\n            return\n        visited[row][col] = True\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j] and matrix[i][j] == 1:\n                dfs(i, j)\n                count += 1\n    \n    return count", "solution_func": "def g():\n    matrix = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return matrix", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 and greater than 10.\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num % 3 == 0 and num > 10:\n            total += num\n    return total\n\ndef g():\n    nums = [5, 12, 9, 7, 15, 20, 4]\n    return nums\n\nassert f(g()) == 27\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are divisible by 3 and greater than 10.\n    \"\"\"\n    total = 0\n    for num in nums:\n        if num % 3 == 0 and num > 10:\n            total += num\n    return total", "solution_func": "def g():\n    nums = [5, 12, 9, 7, 15, 20, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    rotated_matrix = [[0] * rows for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_matrix[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated_matrix\n\ndef g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, rotate it 90 degrees clockwise.\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    rotated_matrix = [[0] * rows for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            rotated_matrix[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated_matrix", "solution_func": "def g():\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next greater element for each element in the list. If there is no greater element, return -1.\n    \"\"\"\n    stack = []\n    next_greater = [-1] * len(nums)\n    \n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            next_greater[stack.pop()] = nums[i]\n        stack.append(i)\n    \n    return next_greater\n\ndef g():\n    nums = [4, 5, 2, 8, 3, 9, 1]\n    return nums\n\nassert f(g()) == [5, 8, 8, 9, 9, -1, -1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 464, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the next greater element for each element in the list. If there is no greater element, return -1.\n    \"\"\"\n    stack = []\n    next_greater = [-1] * len(nums)\n    \n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            next_greater[stack.pop()] = nums[i]\n        stack.append(i)\n    \n    return next_greater", "solution_func": "def g():\n    nums = [4, 5, 2, 8, 3, 9, 1]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, determine if it is possible to rearrange the characters of s such that no two adjacent characters are the same, and the resulting string has at least k distinct substrings of length 2.\n\n    Return True if it is possible, False otherwise.\n\n    Example:\n    Input: s = \"abb\", k = 2\n    Output: True\n    Explanation: The string \"abb\" can be rearranged as \"bab\" or \"bba\", which both have at least 2 distinct substrings of length 2 (\"ba\" and \"bb\").\n    \"\"\"\n    from collections import Counter\n\n    counts = Counter(s)\n    max_freq = max(counts.values())\n\n    if max_freq > (len(s) + 1) // 2:\n        return False\n\n    return True\n\ndef g():\n    s = \"abb\"\n    k = 2\n    return s, k\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 464, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Given a string s and an integer k, determine if it is possible to rearrange the characters of s such that no two adjacent characters are the same, and the resulting string has at least k distinct substrings of length 2.\n\n    Return True if it is possible, False otherwise.\n\n    Example:\n    Input: s = \"abb\", k = 2\n    Output: True\n    Explanation: The string \"abb\" can be rearranged as \"bab\" or \"bba\", which both have at least 2 distinct substrings of length 2 (\"ba\" and \"bb\").\n    \"\"\"\n    from collections import Counter\n\n    counts = Counter(s)\n    max_freq = max(counts.values())\n\n    if max_freq > (len(s) + 1) // 2:\n        return False\n\n    return True", "solution_func": "def g():\n    s = \"abb\"\n    k = 2\n    return s, k", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid-1)\n        else:\n            return binary_search(nums, target, mid+1, right)\n    \n    return binary_search(nums, target, 0, len(nums)-1)\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list.\n    If the target value is not found, return -1.\n    \"\"\"\n    def binary_search(nums, target, left, right):\n        if left > right:\n            return -1\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] > target:\n            return binary_search(nums, target, left, mid-1)\n        else:\n            return binary_search(nums, target, mid+1, right)\n    \n    return binary_search(nums, target, 0, len(nums)-1)", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    target = 6\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a new list of words that match the pattern.\n    A word matches the pattern if it has the same length as the pattern and each character in the word\n    corresponds to a unique character in the pattern.\n    \"\"\"\n    def matches_pattern(word, pattern):\n        if len(word) != len(pattern):\n            return False\n        word_to_pattern = {}\n        pattern_to_word = {}\n        for i in range(len(word)):\n            if word[i] in word_to_pattern and word_to_pattern[word[i]] != pattern[i]:\n                return False\n            if pattern[i] in pattern_to_word and pattern_to_word[pattern[i]] != word[i]:\n                return False\n            word_to_pattern[word[i]] = pattern[i]\n            pattern_to_word[pattern[i]] = word[i]\n        return True\n    \n    return [word for word in words if matches_pattern(word, pattern)]\n\ndef g():\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"]\n    pattern = \"abb\"\n    return words, pattern\n\nassert f(*g()) == [\"def\", \"jkl\"]\n\n", "emb": null, "idx_generation": 465, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], pattern: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a pattern, return a new list of words that match the pattern.\n    A word matches the pattern if it has the same length as the pattern and each character in the word\n    corresponds to a unique character in the pattern.\n    \"\"\"\n    def matches_pattern(word, pattern):\n        if len(word) != len(pattern):\n            return False\n        word_to_pattern = {}\n        pattern_to_word = {}\n        for i in range(len(word)):\n            if word[i] in word_to_pattern and word_to_pattern[word[i]] != pattern[i]:\n                return False\n            if pattern[i] in pattern_to_word and pattern_to_word[pattern[i]] != word[i]:\n                return False\n            word_to_pattern[word[i]] = pattern[i]\n            pattern_to_word[pattern[i]] = word[i]\n        return True\n    \n    return [word for word in words if matches_pattern(word, pattern)]", "solution_func": "def g():\n    words = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"]\n    pattern = \"abb\"\n    return words, pattern", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the closest value to the target.\n    If there are multiple closest values, return the smallest one.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    closest = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return target\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n        if abs(nums[mid] - target) < abs(closest - target) or (abs(nums[mid] - target) == abs(closest - target) and nums[mid] < closest):\n            closest = nums[mid]\n    return closest\n\ndef g():\n    nums = [1, 5, 10, 15, 20]\n    target = 12\n    return nums, target\n\nassert f(*g()) == 10\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the closest value to the target.\n    If there are multiple closest values, return the smallest one.\n    \"\"\"\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    closest = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return target\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n        if abs(nums[mid] - target) < abs(closest - target) or (abs(nums[mid] - target) == abs(closest - target) and nums[mid] < closest):\n            closest = nums[mid]\n    return closest", "solution_func": "def g():\n    nums = [1, 5, 10, 15, 20]\n    target = 12\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def backtrack(index, total):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        for i in range(index, len(nums)):\n            current_num = nums[i]\n            nums[i], nums[index] = nums[index], nums[i]\n\n            if backtrack(index + 1, total + current_num):\n                return True\n\n            nums[i], nums[index] = nums[index], nums[i]\n\n        return False\n\n    return backtrack(0, 0)\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def backtrack(index, total):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        for i in range(index, len(nums)):\n            current_num = nums[i]\n            nums[i], nums[index] = nums[index], nums[i]\n\n            if backtrack(index + 1, total + current_num):\n                return True\n\n            nums[i], nums[index] = nums[index], nums[i]\n\n        return False\n\n    return backtrack(0, 0)", "solution_func": "def g():\n    return [2, 3, 5]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def backtrack(index, total, used):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n\n            used[i] = True\n\n            if backtrack(index + 1, total + nums[i], used):\n                return True\n\n            used[i] = False\n\n        return False\n\n    used = [False] * len(nums)\n    return backtrack(0, 0, used)\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def backtrack(index, total, used):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n\n            used[i] = True\n\n            if backtrack(index + 1, total + nums[i], used):\n                return True\n\n            used[i] = False\n\n        return False\n\n    used = [False] * len(nums)\n    return backtrack(0, 0, used)", "solution_func": "def g():\n    return [2, 3, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def dp(index, total):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        if dp(index + 1, total + nums[index]):\n            return True\n\n        if dp(index + 1, total - nums[index]):\n            return True\n\n        if dp(index + 1, total * nums[index]):\n            return True\n\n        if nums[index] != 0 and dp(index + 1, total / nums[index]):\n            return True\n\n        return False\n\n    return dp(0, 0)\n\ndef g():\n    return [2, 3, 5]\n\nassert f(g(), 8) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, determine if it is possible to form the target value using the numbers in the list.\n    You can perform addition, subtraction, multiplication, and division using any of the numbers in the list.\n    Each number can be used only once.\n\n    Example:\n    nums = [2, 3, 5], target = 8\n    Output: True\n\n    nums = [4, 6, 8], target = 7\n    Output: False\n    \"\"\"\n\n    def dp(index, total):\n        if total == target:\n            return True\n        if index >= len(nums) or total > target:\n            return False\n\n        if dp(index + 1, total + nums[index]):\n            return True\n\n        if dp(index + 1, total - nums[index]):\n            return True\n\n        if dp(index + 1, total * nums[index]):\n            return True\n\n        if nums[index] != 0 and dp(index + 1, total / nums[index]):\n            return True\n\n        return False\n\n    return dp(0, 0)", "solution_func": "def g():\n    return [2, 3, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\n\n    Example:\n    Input: n = 2\n    Output: 91\n    Explanation: The answer should be the total numbers in the range of 0 <= x < 100, where all numbers have unique digits.\n    The numbers with repeating digits are: 11, 22, 33, 44, 55, 66, 77, 88, 99. Therefore, the count is 91.\n\n    Input: n = 1\n    Output: 10\n    Explanation: The answer should be the total numbers in the range of 0 <= x < 10, where all numbers have unique digits.\n    The numbers with repeating digits are: None. Therefore, the count is 10.\n    \"\"\"\n    count = 0\n    for i in range(10 ** n):\n        num = str(i)\n        if len(set(num)) == len(num):\n            count += 1\n    return count\n\ndef g(n: int = 2):\n    return n\n\nassert f(g()) == 91\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\n\n    Example:\n    Input: n = 2\n    Output: 91\n    Explanation: The answer should be the total numbers in the range of 0 <= x < 100, where all numbers have unique digits.\n    The numbers with repeating digits are: 11, 22, 33, 44, 55, 66, 77, 88, 99. Therefore, the count is 91.\n\n    Input: n = 1\n    Output: 10\n    Explanation: The answer should be the total numbers in the range of 0 <= x < 10, where all numbers have unique digits.\n    The numbers with repeating digits are: None. Therefore, the count is 10.\n    \"\"\"\n    count = 0\n    for i in range(10 ** n):\n        num = str(i)\n        if len(set(num)) == len(num):\n            count += 1\n    return count", "solution_func": "def g(n: int = 2):\n    return n", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and an integer k, return a list of all numbers that appear at least k times in the array.\n\n    Example:\n    Input: nums = [1, 2, 3, 2, 1, 4, 4, 2, 5], k = 2\n    Output: [1, 2, 4]\n    Explanation: The numbers that appear at least 2 times in the array are 1, 2, and 4.\n\n    Input: nums = [1, 2, 3, 4, 5], k = 3\n    Output: []\n    Explanation: There are no numbers that appear at least 3 times in the array.\n\n    Input: nums = [1, 2, 3, 4, 1, 2, 3, 1, 2, 1], k = 1\n    Output: [1, 2, 3, 4]\n    Explanation: All numbers appear at least 1 time in the array.\n    \"\"\"\n    count = {}\n    result = []\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    for num, freq in count.items():\n        if freq >= k:\n            result.append(num)\n    return result\n\ndef g(nums: List[int] = [1, 2, 3, 2, 1, 4, 4, 2, 5], k: int = 2):\n    return nums, k\n\nassert f(*g()) == [1, 2, 4]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 465, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and an integer k, return a list of all numbers that appear at least k times in the array.\n\n    Example:\n    Input: nums = [1, 2, 3, 2, 1, 4, 4, 2, 5], k = 2\n    Output: [1, 2, 4]\n    Explanation: The numbers that appear at least 2 times in the array are 1, 2, and 4.\n\n    Input: nums = [1, 2, 3, 4, 5], k = 3\n    Output: []\n    Explanation: There are no numbers that appear at least 3 times in the array.\n\n    Input: nums = [1, 2, 3, 4, 1, 2, 3, 1, 2, 1], k = 1\n    Output: [1, 2, 3, 4]\n    Explanation: All numbers appear at least 1 time in the array.\n    \"\"\"\n    count = {}\n    result = []\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    for num, freq in count.items():\n        if freq >= k:\n            result.append(num)\n    return result", "solution_func": "def g(nums: List[int] = [1, 2, 3, 2, 1, 4, 4, 2, 5], k: int = 2):\n    return nums, k", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of numbers from 1 to n (inclusive) that do not contain the digit 3.\n\n    Example:\n    Input: n = 10\n    Output: 9\n    Explanation: The numbers from 1 to 10 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n    The numbers that do not contain the digit 3 are [1, 2, 4, 5, 6, 7, 8, 9, 10].\n    Therefore, the count is 9.\n\n    Input: n = 20\n    Output: 19\n    Explanation: The numbers from 1 to 20 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].\n    The numbers that do not contain the digit 3 are [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20].\n    Therefore, the count is 19.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if '3' not in str(i):\n            count += 1\n    return count\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 9\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 465, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the count of numbers from 1 to n (inclusive) that do not contain the digit 3.\n\n    Example:\n    Input: n = 10\n    Output: 9\n    Explanation: The numbers from 1 to 10 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n    The numbers that do not contain the digit 3 are [1, 2, 4, 5, 6, 7, 8, 9, 10].\n    Therefore, the count is 9.\n\n    Input: n = 20\n    Output: 19\n    Explanation: The numbers from 1 to 20 are [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].\n    The numbers that do not contain the digit 3 are [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 18, 19, 20].\n    Therefore, the count is 19.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if '3' not in str(i):\n            count += 1\n    return count", "solution_func": "def g(n: int = 10):\n    return n", "map_ix": [0, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return a list of all numbers between 1 and n (inclusive) that have exactly k divisors.\n\n    Example:\n    n = 10, k = 2\n\n    The numbers between 1 and 10 that have exactly 2 divisors are 4 and 9.\n    Therefore, the function should return [4, 9].\n\n    n = 20, k = 3\n\n    The numbers between 1 and 20 that have exactly 3 divisors are 8 and 9.\n    Therefore, the function should return [8, 9].\n    \"\"\"\n\n    def count_divisors(num: int) -> int:\n        count = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count += 1\n        return count\n\n    result = []\n    for i in range(1, n + 1):\n        if count_divisors(i) == k:\n            result.append(i)\n\n    return result\n\ndef g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two integers n and k for Puzzle 3.\n    \"\"\"\n    return 20, 3\n\nassert f(*g()) == [8, 9]\n", "emb": null, "idx_generation": 465, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return a list of all numbers between 1 and n (inclusive) that have exactly k divisors.\n\n    Example:\n    n = 10, k = 2\n\n    The numbers between 1 and 10 that have exactly 2 divisors are 4 and 9.\n    Therefore, the function should return [4, 9].\n\n    n = 20, k = 3\n\n    The numbers between 1 and 20 that have exactly 3 divisors are 8 and 9.\n    Therefore, the function should return [8, 9].\n    \"\"\"\n\n    def count_divisors(num: int) -> int:\n        count = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count += 1\n        return count\n\n    result = []\n    for i in range(1, n + 1):\n        if count_divisors(i) == k:\n            result.append(i)\n\n    return result", "solution_func": "def g() -> Tuple[int, int]:\n    \"\"\"\n    Generate two integers n and k for Puzzle 3.\n    \"\"\"\n    return 20, 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that the subarray contains at least three numbers.\n\n    Example:\n    Input: nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    Output: 10\n\n    Explanation: The subarray [3, 4, -1, 2, 1] has the maximum sum of 10.\n\n    Hint: Use Kadane's algorithm to find the maximum sum subarray.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 10\n", "emb": null, "idx_generation": 466, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray such that the subarray contains at least three numbers.\n\n    Example:\n    Input: nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    Output: 10\n\n    Explanation: The subarray [3, 4, -1, 2, 1] has the maximum sum of 10.\n\n    Hint: Use Kadane's algorithm to find the maximum sum subarray.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right of the grid.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation: The minimum path sum is 7 (1 -> 3 -> 1 -> 1 -> 1).\n\n    Hint: Use dynamic programming to calculate the minimum path sum.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right of the grid.\n    You can only move down or right.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 7\n\n    Explanation: The minimum path sum is 7 (1 -> 3 -> 1 -> 1 -> 1).\n\n    Hint: Use dynamic programming to calculate the minimum path sum.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    You are given an array prices where prices[i] is the price of a given stock on the ith day.\n    You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n    Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n    Example:\n    Input: prices = [7, 1, 5, 3, 6, 4]\n    Output: 5\n\n    Explanation: The maximum profit is 5 (buying at day 2 (price = 1) and selling at day 5 (price = 6)).\n\n    Hint: Use dynamic programming to keep track of the minimum price and maximum profit.\n    \"\"\"\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return max_profit\n\ndef g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(prices: List[int]) -> int:\n    \"\"\"\n    You are given an array prices where prices[i] is the price of a given stock on the ith day.\n    You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n    Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n    Example:\n    Input: prices = [7, 1, 5, 3, 6, 4]\n    Output: 5\n\n    Explanation: The maximum profit is 5 (buying at day 2 (price = 1) and selling at day 5 (price = 6)).\n\n    Hint: Use dynamic programming to keep track of the minimum price and maximum profit.\n    \"\"\"\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n\n    return max_profit", "solution_func": "def g():\n    prices = [7, 1, 5, 3, 6, 4]\n    return prices", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if the number of permutations of 'n' elements taken 'k' at a time is divisible by 3.\n\n    Example:\n    n = 5\n    k = 2\n    Output: True\n    Explanation: The number of permutations of 5 elements taken 2 at a time is 20, which is divisible by 3.\n\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    num_permutations = factorial(n) // factorial(n - k)\n\n    return num_permutations % 3 == 0\n\ndef g(n=5, k=2) -> Tuple[int, int]:\n    return n, k\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 466, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"\n    Determine if the number of permutations of 'n' elements taken 'k' at a time is divisible by 3.\n\n    Example:\n    n = 5\n    k = 2\n    Output: True\n    Explanation: The number of permutations of 5 elements taken 2 at a time is 20, which is divisible by 3.\n\n    \"\"\"\n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        else:\n            return num * factorial(num - 1)\n\n    num_permutations = factorial(n) // factorial(n - k)\n\n    return num_permutations % 3 == 0", "solution_func": "def g(n=5, k=2) -> Tuple[int, int]:\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number 'n' is a power of 2.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a power of 2.\n\n    \"\"\"\n    if n <= 0:\n        return False\n\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n\n    return True\n\ndef g(n=16) -> int:\n    return n\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> bool:\n    \"\"\"\n    Determine if the given number 'n' is a power of 2.\n\n    Example:\n    n = 16\n    Output: True\n    Explanation: 16 is a power of 2.\n\n    \"\"\"\n    if n <= 0:\n        return False\n\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n\n    return True", "solution_func": "def g(n=16) -> int:\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if the given string 's' is a palindrome.\n\n    Example:\n    s = \"racecar\"\n    Output: True\n    Explanation: \"racecar\" is a palindrome.\n\n    \"\"\"\n    s = s.lower()\n    s = ''.join(ch for ch in s if ch.isalnum())\n\n    return s == s[::-1]\n\ndef g(s=\"Race car!\") -> str:\n    return s\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Determine if the given string 's' is a palindrome.\n\n    Example:\n    s = \"racecar\"\n    Output: True\n    Explanation: \"racecar\" is a palindrome.\n\n    \"\"\"\n    s = s.lower()\n    s = ''.join(ch for ch in s if ch.isalnum())\n\n    return s == s[::-1]", "solution_func": "def g(s=\"Race car!\") -> str:\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if there exists a number x such that (x & n) + (x | m) = 0\n    \"\"\"\n    return (n & m) == 0\n\ndef g(n: int = 10, m: int = 15) -> int:\n    \"\"\"\n    Find a number x such that (x & n) + (x | m) = 0\n    \"\"\"\n    x = 0\n    while (x & n) + (x | m) != 0:\n        x += 1\n    return x\n    \nassert f(g(), g()) == True\n", "emb": null, "idx_generation": 466, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, m: int) -> bool:\n    \"\"\"\n    Check if there exists a number x such that (x & n) + (x | m) = 0\n    \"\"\"\n    return (n & m) == 0", "solution_func": "def g(n: int = 10, m: int = 15) -> int:\n    \"\"\"\n    Find a number x such that (x & n) + (x | m) = 0\n    \"\"\"\n    x = 0\n    while (x & n) + (x | m) != 0:\n        x += 1\n    return x", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n: int, m: int) -> bool:\n    \"\"\"\n    Check if there exists a substring of length m in the given string that contains exactly n distinct characters.\n    \"\"\"\n    return any(len(set(s[i:i+m])) == n for i in range(len(s) - m + 1))\n\ndef g(n: int = 2, m: int = 3) -> str:\n    \"\"\"\n    Generate a string containing a substring of length m that contains exactly n distinct characters.\n    \"\"\"\n    return \"abc\" * n\n    \nassert f(g(), 2, 3) == True\n", "emb": null, "idx_generation": 466, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, n: int, m: int) -> bool:\n    \"\"\"\n    Check if there exists a substring of length m in the given string that contains exactly n distinct characters.\n    \"\"\"\n    return any(len(set(s[i:i+m])) == n for i in range(len(s) - m + 1))", "solution_func": "def g(n: int = 2, m: int = 3) -> str:\n    \"\"\"\n    Generate a string containing a substring of length m that contains exactly n distinct characters.\n    \"\"\"\n    return \"abc\" * n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Check if there exists a substring of length n in the given string that is a palindrome.\n    \"\"\"\n    return any(s[i:i+n] == s[i:i+n][::-1] for i in range(len(s) - n + 1))\n\ndef g(n: int = 3) -> str:\n    \"\"\"\n    Generate a string containing a palindrome substring of length n.\n    \"\"\"\n    if n % 2 == 0:\n        return \"a\" * (n // 2) + \"b\" * (n // 2)\n    else:\n        return \"a\" * (n // 2) + \"b\" + \"a\" * (n // 2)\n    \nassert f(g(), 3) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 466, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Check if there exists a substring of length n in the given string that is a palindrome.\n    \"\"\"\n    return any(s[i:i+n] == s[i:i+n][::-1] for i in range(len(s) - n + 1))", "solution_func": "def g(n: int = 3) -> str:\n    \"\"\"\n    Generate a string containing a palindrome substring of length n.\n    \"\"\"\n    if n % 2 == 0:\n        return \"a\" * (n // 2) + \"b\" * (n // 2)\n    else:\n        return \"a\" * (n // 2) + \"b\" + \"a\" * (n // 2)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    Input: nums = [4, 2, 7, 1, 5]\n    Output: [1, 2, 4, 5, 7]\n\n    Explanation: The list is sorted in ascending order.\n\n    Note: Implement the bubble sort algorithm in place, without using any extra space.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums\n\n\ndef g() -> List[int]:\n    nums = [4, 2, 7, 1, 5]\n    return nums\n\n\nassert f(g()) == [1, 2, 4, 5, 7]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 466, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the bubble sort algorithm.\n\n    Example:\n    Input: nums = [4, 2, 7, 1, 5]\n    Output: [1, 2, 4, 5, 7]\n\n    Explanation: The list is sorted in ascending order.\n\n    Note: Implement the bubble sort algorithm in place, without using any extra space.\n    \"\"\"\n\n    n = len(nums)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n\n    return nums", "solution_func": "def g() -> List[int]:\n    nums = [4, 2, 7, 1, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, determine if there are two numbers in the list that add up to the target.\n    Return True if such pair exists, False otherwise.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return False", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 10\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with any duplicate elements removed.\n    The order of the elements in the resulting list should be the same as the original list.\n    \"\"\"\n    stack = []\n    seen = set()\n\n    for num in nums:\n        if num not in seen:\n            stack.append(num)\n            seen.add(num)\n    \n    return stack\n\ndef g():\n    nums = [1, 2, 3, 2, 4, 5, 1]\n    return nums\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 467, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list with any duplicate elements removed.\n    The order of the elements in the resulting list should be the same as the original list.\n    \"\"\"\n    stack = []\n    seen = set()\n\n    for num in nums:\n        if num not in seen:\n            stack.append(num)\n            seen.add(num)\n    \n    return stack", "solution_func": "def g():\n    nums = [1, 2, 3, 2, 4, 5, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum product of any three numbers from the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 120\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum product of any three numbers from the list.\n    Return the maximum product.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-3] * nums[n-2] * nums[n-1])", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) where a and b are elements of the list\n    and a < b.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The distinct pairs are (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5).\n    Therefore, the function should return 10.\n    \"\"\"\n    distinct_pairs = set()\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] < arr[j]:\n                distinct_pairs.add((arr[i], arr[j]))\n\n    return len(distinct_pairs)\n\ndef g():\n    arr = [1, 2, 3, 4, 5]\n    return arr\n\nassert f(g()) == 10\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs (a, b) where a and b are elements of the list\n    and a < b.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The distinct pairs are (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5).\n    Therefore, the function should return 10.\n    \"\"\"\n    distinct_pairs = set()\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] < arr[j]:\n                distinct_pairs.add((arr[i], arr[j]))\n\n    return len(distinct_pairs)", "solution_func": "def g():\n    arr = [1, 2, 3, 4, 5]\n    return arr", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each character is replaced by its corresponding ASCII value.\n\n    Example:\n    string = \"hello\"\n\n    The ASCII values of the characters in the string are 104, 101, 108, 108, 111.\n    Therefore, the function should return \"104101108108111\".\n    \"\"\"\n    ascii_string = \"\"\n\n    for char in string:\n        ascii_string += str(ord(char))\n\n    return ascii_string\n\ndef g():\n    string = \"hello\"\n    return string\n\nassert f(g()) == \"104101108108111\"\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each character is replaced by its corresponding ASCII value.\n\n    Example:\n    string = \"hello\"\n\n    The ASCII values of the characters in the string are 104, 101, 108, 108, 111.\n    Therefore, the function should return \"104101108108111\".\n    \"\"\"\n    ascii_string = \"\"\n\n    for char in string:\n        ascii_string += str(ord(char))\n\n    return ascii_string", "solution_func": "def g():\n    string = \"hello\"\n    return string", "map_ix": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of k numbers out of the range from 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    The possible combinations are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    Therefore, the function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n    combinations = []\n\n    def backtrack(start, curr_combo):\n        if len(curr_combo) == k:\n            combinations.append(curr_combo[:])\n        else:\n            for i in range(start, n+1):\n                curr_combo.append(i)\n                backtrack(i+1, curr_combo)\n                curr_combo.pop()\n\n    backtrack(1, [])\n\n    return combinations\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Generate all possible combinations of k numbers out of the range from 1 to n.\n\n    Example:\n    n = 4, k = 2\n\n    The possible combinations are [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    Therefore, the function should return [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].\n    \"\"\"\n    combinations = []\n\n    def backtrack(start, curr_combo):\n        if len(curr_combo) == k:\n            combinations.append(curr_combo[:])\n        else:\n            for i in range(start, n+1):\n                curr_combo.append(i)\n                backtrack(i+1, curr_combo)\n                curr_combo.pop()\n\n    backtrack(1, [])\n\n    return combinations", "solution_func": "def g():\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, return a list of all pairs of numbers from the list that add up to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 6\n    Output: [(1, 5), (2, 4)]\n\n    Hint: Use two pointers to iterate through the list and find the pairs that add up to the target.\n    \"\"\"\n    pairs = []\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            pairs.append((arr[left], arr[right]))\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return pairs\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 6) == [(1, 5), (2, 4)]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, return a list of all pairs of numbers from the list that add up to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 6\n    Output: [(1, 5), (2, 4)]\n\n    Hint: Use two pointers to iterate through the list and find the pairs that add up to the target.\n    \"\"\"\n    pairs = []\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            pairs.append((arr[left], arr[right]))\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return pairs", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise AND of all the numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 0 (1 & 2 & 3 & 4 & 5 = 0)\n\n    Hint: Use bit manipulation to perform the AND operation.\n    \"\"\"\n    result = nums[0]\n    for i in range(1, len(nums)):\n        result &= nums[i]\n\n    return result\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 0\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, calculate the bitwise AND of all the numbers in the list.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 0 (1 & 2 & 3 & 4 & 5 = 0)\n\n    Hint: Use bit manipulation to perform the AND operation.\n    \"\"\"\n    result = nums[0]\n    for i in range(1, len(nums)):\n        result &= nums[i]\n\n    return result", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Hint: Use two pointers to iterate through the list and find the pairs whose XOR is equal to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 7) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 467, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target.\n\n    Example:\n    Input: arr = [1, 2, 3, 4, 5], target = 7\n    Output: True\n\n    Hint: Use two pointers to iterate through the list and find the pairs whose XOR is equal to the target.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        xor = arr[left] ^ arr[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of unique combinations in nums where the numbers sum to target.\n\n    Example:\n    Input: [1, 2, 3, 4], 5\n    Output: 3\n\n    Explanation:\n    There are three unique combinations that add up to 5: [1, 1, 1, 1, 1], [1, 1, 1, 2], and [1, 2, 2].\n    \"\"\"\n    count = 0\n\n    def backtrack(curr_sum, start):\n        nonlocal count\n        if curr_sum == target:\n            count += 1\n            return\n        if curr_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(curr_sum + nums[i], i)\n\n    backtrack(0, 0)\n    return count\n\ndef g() -> List[int, int]:\n    return ([1, 2, 3, 4], 5)\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 467, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of unique combinations in nums where the numbers sum to target.\n\n    Example:\n    Input: [1, 2, 3, 4], 5\n    Output: 3\n\n    Explanation:\n    There are three unique combinations that add up to 5: [1, 1, 1, 1, 1], [1, 1, 1, 2], and [1, 2, 2].\n    \"\"\"\n    count = 0\n\n    def backtrack(curr_sum, start):\n        nonlocal count\n        if curr_sum == target:\n            count += 1\n            return\n        if curr_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(curr_sum + nums[i], i)\n\n    backtrack(0, 0)\n    return count", "solution_func": "def g() -> List[int, int]:\n    return ([1, 2, 3, 4], 5)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, find if there is a path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a valid path.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0:\n            return False\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return True\n        matrix[i][j] = 0\n        return dfs(i + 1, j) or dfs(i, j + 1) or dfs(i - 1, j) or dfs(i, j - 1)\n\n    return dfs(0, 0)\n\ndef g(matrix = [[1, 0, 1, 1, 1],\n                [1, 0, 1, 0, 1],\n                [1, 1, 1, 0, 1],\n                [0, 0, 0, 0, 1],\n                [1, 1, 1, 1, 1]]):\n    return matrix\n\nassert f(g())\n", "emb": null, "idx_generation": 468, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix of 0s and 1s, find if there is a path from the top-left corner to the bottom-right corner,\n    where 0 represents an obstacle and 1 represents a valid path.\n    \"\"\"\n    def dfs(i, j):\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or matrix[i][j] == 0:\n            return False\n        if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n            return True\n        matrix[i][j] = 0\n        return dfs(i + 1, j) or dfs(i, j + 1) or dfs(i - 1, j) or dfs(i, j - 1)\n\n    return dfs(0, 0)", "solution_func": "def g(matrix = [[1, 0, 1, 1, 1],\n                [1, 0, 1, 0, 1],\n                [1, 1, 1, 0, 1],\n                [0, 0, 0, 0, 1],\n                [1, 1, 1, 1, 1]]):\n    return matrix", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of different ways to represent n as a sum of 1, 3, and 4.\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    return f(n - 1) + f(n - 3) + f(n - 4)\n\ndef g(n = 5):\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of different ways to represent n as a sum of 1, 3, and 4.\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    return f(n - 1) + f(n - 3) + f(n - 4)", "solution_func": "def g(n = 5):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(coins: List[int], amount: int) -> int:\n    \"\"\"\n    Given a list of coin denominations and an amount, find the minimum number of coins required to make up the amount,\n    using the given coins. Return -1 if it is not possible to make up the amount.\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] != float('inf') else -1\n\ndef g(coins = [1, 2, 5], amount = 11):\n    return coins, amount\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(coins: List[int], amount: int) -> int:\n    \"\"\"\n    Given a list of coin denominations and an amount, find the minimum number of coins required to make up the amount,\n    using the given coins. Return -1 if it is not possible to make up the amount.\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] != float('inf') else -1", "solution_func": "def g(coins = [1, 2, 5], amount = 11):\n    return coins, amount", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is a geometric progression, False otherwise.\n    A geometric progression is defined as a sequence of numbers where each term after the first is found by multiplying the previous term by a fixed, non-zero number called the common ratio.\n\n    Sample Input:\n    nums = [2, 4, 8, 16]\n\n    Sample Output:\n    True\n    \"\"\"\n\n    if len(nums) < 2:\n        return False\n\n    ratio = nums[1] / nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] / nums[i-1] != ratio:\n            return False\n\n    return True\n\ndef g():\n    return [2, 4, 8, 16]\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, return True if the list is a geometric progression, False otherwise.\n    A geometric progression is defined as a sequence of numbers where each term after the first is found by multiplying the previous term by a fixed, non-zero number called the common ratio.\n\n    Sample Input:\n    nums = [2, 4, 8, 16]\n\n    Sample Output:\n    True\n    \"\"\"\n\n    if len(nums) < 2:\n        return False\n\n    ratio = nums[1] / nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] / nums[i-1] != ratio:\n            return False\n\n    return True", "solution_func": "def g():\n    return [2, 4, 8, 16]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\ndef f(expression: str) -> int:\n    \"\"\"\n    Given a mathematical expression as a string, evaluate the expression and return its result.\n\n    Sample Input:\n    expression = \"3 + 4 * 2 / (1 - 5) ^ 2\"\n\n    Sample Output:\n    3.5\n    \"\"\"\n\n    return eval(expression)\n\ndef g():\n    return \"3 + 4 * 2 / (1 - 5) ^ 2\"\n\nassert f(g()) == 3.5\n", "emb": null, "idx_generation": 468, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "import math\nfrom typing import*\ndef f(expression: str) -> int:\n    \"\"\"\n    Given a mathematical expression as a string, evaluate the expression and return its result.\n\n    Sample Input:\n    expression = \"3 + 4 * 2 / (1 - 5) ^ 2\"\n\n    Sample Output:\n    3.5\n    \"\"\"\n\n    return eval(expression)", "solution_func": "def g():\n    return \"3 + 4 * 2 / (1 - 5) ^ 2\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each occurrence of the word \"is\" is replaced with \"was\".\n\n    Sample Input:\n    s = \"This is a test sentence. This is another test sentence.\"\n\n    Sample Output:\n    \"This was a test sentence. This was another test sentence.\"\n    \"\"\"\n\n    return s.replace(\"is\", \"was\")\n\ndef g():\n    return \"This is a test sentence. This is another test sentence.\"\n\nassert f(g()) == \"This was a test sentence. This was another test sentence.\"\n", "emb": null, "idx_generation": 468, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, return a new string where each occurrence of the word \"is\" is replaced with \"was\".\n\n    Sample Input:\n    s = \"This is a test sentence. This is another test sentence.\"\n\n    Sample Output:\n    \"This was a test sentence. This was another test sentence.\"\n    \"\"\"\n\n    return s.replace(\"is\", \"was\")", "solution_func": "def g():\n    return \"This is a test sentence. This is another test sentence.\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    The target number 3 is found at index 2.\n    Return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target number using binary search.\n    If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    The target number 3 is found at index 2.\n    Return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target number.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if the target exists in the array.\n    Use binary search to find the target in the array.\n    Return True if the target exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    return arr\n\nassert f(g(), 9) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, determine if the target exists in the array.\n    Use binary search to find the target in the array.\n    Return True if the target exists, False otherwise.\n    \"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted array of integers.\n    \"\"\"\n    arr = [1, 3, 5, 7, 9, 11, 13, 15]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses combinations of length 2n.\n    Use recursion to generate the combinations.\n    Return a list of strings representing the valid parentheses combinations.\n    \"\"\"\n    result = []\n    generate_parentheses(result, \"\", n, n)\n    return result\n\ndef generate_parentheses(result: List[str], curr: str, left: int, right: int) -> None:\n    if left == 0 and right == 0:\n        result.append(curr)\n        return\n\n    if left > 0:\n        generate_parentheses(result, curr + \"(\", left - 1, right)\n\n    if right > left:\n        generate_parentheses(result, curr + \")\", left, right - 1)\n\ndef g() -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    n = 3\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 468, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses combinations of length 2n.\n    Use recursion to generate the combinations.\n    Return a list of strings representing the valid parentheses combinations.\n    \"\"\"\n    result = []\n    generate_parentheses(result, \"\", n, n)\n    return result\n\ndef generate_parentheses(result: List[str], curr: str, left: int, right: int) -> None:\n    if left == 0 and right == 0:\n        result.append(curr)\n        return\n\n    if left > 0:\n        generate_parentheses(result, curr + \"(\", left - 1, right)\n\n    if right > left:\n        generate_parentheses(result, curr + \")\", left, right - 1)", "solution_func": "def g() -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    n = 3\n    return n", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n    Use dynamic programming to calculate the maximum sum.\n    Return the maximum sum of the path.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 4, 2],\n        [2, 1, 3, 1],\n        [4, 2, 1, 2],\n        [1, 2, 3, 4]\n    ]\n    return grid\n\nassert f(g()) == 16\n\n", "emb": null, "idx_generation": 468, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n    Use dynamic programming to calculate the maximum sum.\n    Return the maximum sum of the path.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    grid = [\n        [1, 3, 4, 2],\n        [2, 1, 3, 1],\n        [4, 2, 1, 2],\n        [1, 2, 3, 4]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value. Return the indices of those numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value 9. The indices of these numbers in the list are 0 and 1.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    def find_indices(nums, target):\n        \"\"\"\n        Find the indices of two numbers in the list that add up to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n\n        return []\n\n    return find_indices(nums, target)\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value. Return the indices of those numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value 9. The indices of these numbers in the list are 0 and 1.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n\n    def find_indices(nums, target):\n        \"\"\"\n        Find the indices of two numbers in the list that add up to the target value.\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n\n        return []\n\n    return find_indices(nums, target)", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n\n    Explanation:\n    The 6th Fibonacci number is 8.\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return f(n-1) + f(n-2)", "solution_func": "def g() -> int:\n    return 6", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of unique combinations of the list elements that add up to the target value.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    There are 2 unique combinations of the list elements that add up to the target value:\n    - [2, 2, 3]\n    - [7]\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def count_combinations(nums, target):\n        \"\"\"\n        Count the number of unique combinations of the list elements that add up to the target value.\n        \"\"\"\n        combinations = []\n\n        def backtrack(remain, current_combination, start):\n            if remain == 0:\n                combinations.append(list(current_combination))\n                return\n            elif remain < 0:\n                return\n\n            for i in range(start, len(nums)):\n                current_combination.append(nums[i])\n                backtrack(remain - nums[i], current_combination, i)\n                current_combination.pop()\n\n        backtrack(target, [], 0)\n\n        return len(combinations)\n\n    return count_combinations(nums, target)\n\ndef g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the number of unique combinations of the list elements that add up to the target value.\n\n    Example:\n    nums = [2, 3, 6, 7]\n    target = 7\n\n    There are 2 unique combinations of the list elements that add up to the target value:\n    - [2, 2, 3]\n    - [7]\n\n    Therefore, the function should return 2.\n    \"\"\"\n\n    def count_combinations(nums, target):\n        \"\"\"\n        Count the number of unique combinations of the list elements that add up to the target value.\n        \"\"\"\n        combinations = []\n\n        def backtrack(remain, current_combination, start):\n            if remain == 0:\n                combinations.append(list(current_combination))\n                return\n            elif remain < 0:\n                return\n\n            for i in range(start, len(nums)):\n                current_combination.append(nums[i])\n                backtrack(remain - nums[i], current_combination, i)\n                current_combination.pop()\n\n        backtrack(target, [], 0)\n\n        return len(combinations)\n\n    return count_combinations(nums, target)", "solution_func": "def g():\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 6\n\n    The XOR of any two numbers in the list is calculated by performing a bitwise XOR operation.\n    For example, the XOR of 3 and 5 is 6 (3 ^ 5 = 6).\n\n    In the given example, there exists a pair of numbers (2, 4) whose XOR is equal to the target value 6.\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g(), 6) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of numbers in the list whose XOR is equal to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 6\n\n    The XOR of any two numbers in the list is calculated by performing a bitwise XOR operation.\n    For example, the XOR of 3 and 5 is 6 (3 ^ 5 = 6).\n\n    In the given example, there exists a pair of numbers (2, 4) whose XOR is equal to the target value 6.\n    Therefore, the function should return True.\n    \"\"\"\n\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        xor = nums[left] ^ nums[right]\n        if xor == target:\n            return True\n        elif xor < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two numbers in the list is 28 (5 ^ 25 = 28).\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The maximum XOR value between two numbers in the list is 28 (5 ^ 25 = 28).\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, find all pairs of numbers in the list whose XOR is equal to k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 7\n\n    The XOR of any two numbers in the list is calculated by performing a bitwise XOR operation.\n    For example, the XOR of 3 and 4 is 7 (3 ^ 4 = 7).\n\n    In the given example, there are two pairs of numbers (1, 6) and (2, 5) whose XOR is equal to the target value 7.\n    Therefore, the function should return [(1, 6), (2, 5)].\n    \"\"\"\n\n    xor_pairs = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor == k:\n                xor_pairs.append((nums[i], nums[j]))\n\n    return xor_pairs\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g(), 7) == [(1, 6), (2, 5)]\n\n", "emb": null, "idx_generation": 469, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value k, find all pairs of numbers in the list whose XOR is equal to k.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n    k = 7\n\n    The XOR of any two numbers in the list is calculated by performing a bitwise XOR operation.\n    For example, the XOR of 3 and 4 is 7 (3 ^ 4 = 7).\n\n    In the given example, there are two pairs of numbers (1, 6) and (2, 5) whose XOR is equal to the target value 7.\n    Therefore, the function should return [(1, 6), (2, 5)].\n    \"\"\"\n\n    xor_pairs = []\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            if xor == k:\n                xor_pairs.append((nums[i], nums[j]))\n\n    return xor_pairs", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    Output:\n    6\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = 1\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\n\ndef g():\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the number of unique paths from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    Output:\n    6\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = 1\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]\n    return grid", "map_ix": [0, 0, 0, 1, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 469, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right in the grid.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output:\n    7\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses sequences of length n.\n\n    Example:\n    Input:\n    n = 3\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def backtrack(seq, opens, closes):\n        if len(seq) == 2 * n:\n            result.append(''.join(seq))\n            return\n        if opens < n:\n            seq.append('(')\n            backtrack(seq, opens + 1, closes)\n            seq.pop()\n        if closes < opens:\n            seq.append(')')\n            backtrack(seq, opens, closes + 1)\n            seq.pop()\n\n    result = []\n    backtrack([], 0, 0)\n    return result\n\n\ndef g():\n    n = 3\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all valid parentheses sequences of length n.\n\n    Example:\n    Input:\n    n = 3\n    Output:\n    [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n    \"\"\"\n\n    def backtrack(seq, opens, closes):\n        if len(seq) == 2 * n:\n            result.append(''.join(seq))\n            return\n        if opens < n:\n            seq.append('(')\n            backtrack(seq, opens + 1, closes)\n            seq.pop()\n        if closes < opens:\n            seq.append(')')\n            backtrack(seq, opens, closes + 1)\n            seq.pop()\n\n    result = []\n    backtrack([], 0, 0)\n    return result", "solution_func": "def g():\n    n = 3\n    return n", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a pair of numbers in the array that XOR to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [1, 2, 3, 4, 5], target = 6\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        xor_sum = arr[left] ^ arr[right]\n        if xor_sum == target:\n            return True\n        elif xor_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\nassert f(g(), 14)\n", "emb": [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 469, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers and a target value, check if there exists a pair of numbers in the array that XOR to the target.\n    You may assume that each input would have exactly one solution and you may not use the same element twice.\n\n    Sample input:\n    arr = [1, 2, 3, 4, 5], target = 6\n\n    Sample output:\n    True\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    while left < right:\n        xor_sum = arr[left] ^ arr[right]\n        if xor_sum == target:\n            return True\n        elif xor_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g():\n    return [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]", "map_ix": [1, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, return the number of unique combinations of elements in arr that sum up to a target value of 0.\n\n    Example:\n    arr = [1, -1, 2, -2, 3, -3]\n    The unique combinations that sum up to 0 are:\n    [1, -1], [2, -2], [3, -3], [1, -1, 2, -2], [1, -1, 3, -3], [2, -2, 3, -3], [1, -1, 2, -2, 3, -3]\n    So the expected output is 7.\n    \"\"\"\n    def backtrack(index, target):\n        if target == 0:\n            return 1\n        if index >= len(arr) or target < 0:\n            return 0\n        \n        count = 0\n        # Include current element\n        count += backtrack(index+1, target-arr[index])\n        # Exclude current element\n        count += backtrack(index+1, target)\n        \n        return count\n    \n    return backtrack(0, 0)\n\ndef g(arr=[1, -1, 2, -2, 3, -3]):\n    return arr\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 470, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers arr, return the number of unique combinations of elements in arr that sum up to a target value of 0.\n\n    Example:\n    arr = [1, -1, 2, -2, 3, -3]\n    The unique combinations that sum up to 0 are:\n    [1, -1], [2, -2], [3, -3], [1, -1, 2, -2], [1, -1, 3, -3], [2, -2, 3, -3], [1, -1, 2, -2, 3, -3]\n    So the expected output is 7.\n    \"\"\"\n    def backtrack(index, target):\n        if target == 0:\n            return 1\n        if index >= len(arr) or target < 0:\n            return 0\n        \n        count = 0\n        # Include current element\n        count += backtrack(index+1, target-arr[index])\n        # Exclude current element\n        count += backtrack(index+1, target)\n        \n        return count\n    \n    return backtrack(0, 0)", "solution_func": "def g(arr=[1, -1, 2, -2, 3, -3]):\n    return arr", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the maximum sum of a non-empty subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum sum of a subarray is [4, -1, 2, 1] which has a sum of 6.\n    So the expected output is 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the maximum sum of a non-empty subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    The maximum sum of a subarray is [4, -1, 2, 1] which has a sum of 6.\n    So the expected output is 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of arithmetic subarrays.\n\n    An arithmetic subarray is a contiguous subarray in which the difference between consecutive elements is the same.\n    \n    Example:\n    nums = [1, 2, 3, 4]\n    The arithmetic subarrays are [1, 2, 3, 4], [1, 2, 3], [2, 3, 4], and [4].\n    So the expected output is 4.\n    \"\"\"\n    count = 0\n    \n    for i in range(len(nums)-2):\n        diff = nums[i+1] - nums[i]\n        for j in range(i+2, len(nums)):\n            if nums[j] - nums[j-1] == diff:\n                count += 1\n            else:\n                break\n    \n    return count\n\ndef g(nums=[1, 2, 3, 4]):\n    return nums\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 470, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, return the number of arithmetic subarrays.\n\n    An arithmetic subarray is a contiguous subarray in which the difference between consecutive elements is the same.\n    \n    Example:\n    nums = [1, 2, 3, 4]\n    The arithmetic subarrays are [1, 2, 3, 4], [1, 2, 3], [2, 3, 4], and [4].\n    So the expected output is 4.\n    \"\"\"\n    count = 0\n    \n    for i in range(len(nums)-2):\n        diff = nums[i+1] - nums[i]\n        for j in range(i+2, len(nums)):\n            if nums[j] - nums[j-1] == diff:\n                count += 1\n            else:\n                break\n    \n    return count", "solution_func": "def g(nums=[1, 2, 3, 4]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 18], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (LIS).\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 18], which has a length of 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, calculate the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The maximum sum of a contiguous subarray in nums is 5, which is the sum of the subarray [2, 3].\n\n    Therefore, the function should return 5.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, -2, 4]\n\nassert f(g()) == 5\n\n", "emb": null, "idx_generation": 470, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of non-negative integers, calculate the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The maximum sum of a contiguous subarray in nums is 5, which is the sum of the subarray [2, 3].\n\n    Therefore, the function should return 5.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, -2, 4]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7] since nums[0] + nums[1] == 9.\n\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        else:\n            num_dict[num] = i\n    \n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple of a list of integers and a target integer.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers, find two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7] since nums[0] + nums[1] == 9.\n\n    \"\"\"\n    num_dict = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        else:\n            num_dict[num] = i\n    \n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a tuple of a list of integers and a target integer.\n    \"\"\"\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that \n    sum up to the target value. Return the indices of the two numbers.\n    \n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Sample Output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers and a target value, find two numbers in the array that \n    sum up to the target value. Return the indices of the two numbers.\n    \n    Sample Input:\n    nums = [2, 7, 11, 15]\n    target = 9\n    \n    Sample Output:\n    [0, 1]\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    \n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle,\n    find the minimum number of steps required to navigate from the start cell to the end cell,\n    considering only horizontal and vertical movements. If a path from start to end is not possible,\n    return -1.\n    \n    Sample Input:\n    grid = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    \n    Sample Output:\n    8\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0\n    \n    queue = [(start[0], start[1], 0)]  # (row, col, steps)\n    visited = set()\n    \n    while queue:\n        row, col, steps = queue.pop(0)\n        if (row, col) == end:\n            return steps\n        \n        for d_row, d_col in directions:\n            new_row, new_col = row + d_row, col + d_col\n            if is_valid_move(new_row, new_col) and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, steps + 1))\n                visited.add((new_row, new_col))\n    \n    return -1\n\ndef g():\n    grid = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    return grid, start, end\n\nassert f(*g()) == 8\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 470, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents an obstacle,\n    find the minimum number of steps required to navigate from the start cell to the end cell,\n    considering only horizontal and vertical movements. If a path from start to end is not possible,\n    return -1.\n    \n    Sample Input:\n    grid = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    \n    Sample Output:\n    8\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0\n    \n    queue = [(start[0], start[1], 0)]  # (row, col, steps)\n    visited = set()\n    \n    while queue:\n        row, col, steps = queue.pop(0)\n        if (row, col) == end:\n            return steps\n        \n        for d_row, d_col in directions:\n            new_row, new_col = row + d_row, col + d_col\n            if is_valid_move(new_row, new_col) and (new_row, new_col) not in visited:\n                queue.append((new_row, new_col, steps + 1))\n                visited.add((new_row, new_col))\n    \n    return -1", "solution_func": "def g():\n    grid = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n        [0, 0, 0, 0, 0]\n    ]\n    start = (0, 0)\n    end = (4, 4)\n    return grid, start, end", "map_ix": [1, 0, 0, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, every element appears twice except for one.\n    Find that single one.\n    \n    Sample Input:\n    nums = [2, 2, 1]\n    \n    Sample Output:\n    1\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef g():\n    nums = [2, 2, 1]\n    return nums\n\nassert f(g()) == 1\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, every element appears twice except for one.\n    Find that single one.\n    \n    Sample Input:\n    nums = [2, 2, 1]\n    \n    Sample Output:\n    1\n    \"\"\"\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", "solution_func": "def g():\n    nums = [2, 2, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [4, 8, 2, 10, 6]\n    return nums\n\nassert f(g()) == 14\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 470, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum XOR value between any two numbers in the list.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    int: The maximum XOR value between any two numbers in the list.\n    \"\"\"\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [4, 8, 2, 10, 6]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9], target = 5\n\n    The target value 5 is present at index 2 in the list.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5\n\nassert f(*g()) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n    If the target value is not present in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9], target = 5\n\n    The target value 5 is present at index 2 in the list.\n    Therefore, the function should return 2.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 5", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The even numbers in the list are 2, 4, and 6.\n    Therefore, the function should return 12.\n    \"\"\"\n\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The even numbers in the list are 2, 4, and 6.\n    Therefore, the function should return 12.\n    \"\"\"\n\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers if found, otherwise return an empty list.\n\n    Example:\n    nums = [2, 4, 6, 8, 10], target = 14\n\n    The numbers 4 and 10 add up to 14.\n    Therefore, the function should return [1, 4].\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g()) == [1, 4]\n\n", "emb": null, "idx_generation": 471, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers if found, otherwise return an empty list.\n\n    Example:\n    nums = [2, 4, 6, 8, 10], target = 14\n\n    The numbers 4 and 10 add up to 14.\n    Therefore, the function should return [1, 4].\n    \"\"\"\n\n    num_map = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 4, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The numbers 2 and 7 add up to the target value of 9.\n\n    Constraints:\n    - The input list is sorted in non-decreasing order.\n    - The length of the input list is at most 10^4.\n    - Each element in the list is an integer.\n    - The target value is an integer.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 4, 7, 11, 15], target=9) -> List[int]:\n    return nums\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 471, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n\n    Example:\n    Input: nums = [1, 2, 4, 7, 11, 15], target = 9\n    Output: True\n\n    Explanation: The numbers 2 and 7 add up to the target value of 9.\n\n    Constraints:\n    - The input list is sorted in non-decreasing order.\n    - The length of the input list is at most 10^4.\n    - Each element in the list is an integer.\n    - The target value is an integer.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 4, 7, 11, 15], target=9) -> List[int]:\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase. You can climb either 1 or 2 steps at a time.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation: There are 5 ways to climb to the top: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2].\n\n    Constraints:\n    - The input integer is positive and does not exceed 10^4.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\ndef g(n=4) -> int:\n    return n\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of ways to climb to the top of a staircase. You can climb either 1 or 2 steps at a time.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation: There are 5 ways to climb to the top: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2].\n\n    Constraints:\n    - The input integer is positive and does not exceed 10^4.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]", "solution_func": "def g(n=4) -> int:\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner, moving only down and right.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 8\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 8.\n\n    Constraints:\n    - The input grid is a rectangular grid containing at most 10^3 rows and columns.\n    - Each element in the grid is a non-negative integer.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    return grid\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 471, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left corner to the bottom-right corner, moving only down and right.\n\n    Example:\n    Input: grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 8\n\n    Explanation: The maximum sum path is 1 -> 3 -> 1 -> 1 -> 1, which gives a total sum of 8.\n\n    Constraints:\n    - The input grid is a rectangular grid containing at most 10^3 rows and columns.\n    - Each element in the grid is a non-negative integer.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g(grid=[[1, 3, 1], [1, 5, 1], [4, 2, 1]]) -> List[List[int]]:\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two vertices start and end, return the number of distinct paths from start to end.\n    A path is considered distinct if it does not contain any repeated vertices.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 1, 1],\n             [1, 1, 0, 1],\n             [0, 1, 1, 0]]\n\n    start = 0, end = 3\n\n    The number of distinct paths from vertex 0 to vertex 3 is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def dfs(v: int, visited: List[bool]) -> int:\n        if v == end:\n            return 1\n        count = 0\n        visited[v] = True\n        for neighbor in range(len(graph[v])):\n            if graph[v][neighbor] == 1 and not visited[neighbor]:\n                count += dfs(neighbor, visited)\n        visited[v] = False\n        return count\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)\n\ndef g() -> (List[List[int]], int, int):\n    \"\"\"\n    Generate a graph and two vertices for Puzzle 3.\n    \"\"\"\n    graph = [[0, 1, 1, 0],\n             [1, 0, 1, 1],\n             [1, 1, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n    return graph, start, end\n\nassert f(*g()) == 4\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]], start: int, end: int) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix and two vertices start and end, return the number of distinct paths from start to end.\n    A path is considered distinct if it does not contain any repeated vertices.\n\n    Example:\n    graph = [[0, 1, 1, 0],\n             [1, 0, 1, 1],\n             [1, 1, 0, 1],\n             [0, 1, 1, 0]]\n\n    start = 0, end = 3\n\n    The number of distinct paths from vertex 0 to vertex 3 is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    def dfs(v: int, visited: List[bool]) -> int:\n        if v == end:\n            return 1\n        count = 0\n        visited[v] = True\n        for neighbor in range(len(graph[v])):\n            if graph[v][neighbor] == 1 and not visited[neighbor]:\n                count += dfs(neighbor, visited)\n        visited[v] = False\n        return count\n\n    visited = [False] * len(graph)\n    return dfs(start, visited)", "solution_func": "def g() -> (List[List[int]], int, int):\n    \"\"\"\n    Generate a graph and two vertices for Puzzle 3.\n    \"\"\"\n    graph = [[0, 1, 1, 0],\n             [1, 0, 1, 1],\n             [1, 1, 0, 1],\n             [0, 1, 1, 0]]\n    start = 0\n    end = 3\n    return graph, start, end", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of the bitwise XOR of all pairs of integers in the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    The bitwise XOR of all pairs of integers in the grid is (1^2) + (1^3) + (2^4) + (2^5) + (2^6) + (3^4) + (3^7) + (4^5) + (4^8) + (5^6) + (5^7) + (5^9) + (6^8) + (7^8) + (7^9) = 73.\n\n    Therefore, the function should return 73.\n    \"\"\"\n    xor_sum = 0\n    for row in grid:\n        for col in row:\n            xor_sum ^= col\n    return xor_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 4.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 73\n\n", "emb": null, "idx_generation": 471, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of the bitwise XOR of all pairs of integers in the grid.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    The bitwise XOR of all pairs of integers in the grid is (1^2) + (1^3) + (2^4) + (2^5) + (2^6) + (3^4) + (3^7) + (4^5) + (4^8) + (5^6) + (5^7) + (5^9) + (6^8) + (7^8) + (7^9) = 73.\n\n    Therefore, the function should return 73.\n    \"\"\"\n    xor_sum = 0\n    for row in grid:\n        for col in row:\n            xor_sum ^= col\n    return xor_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 4.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum sum that can be obtained by selecting one number from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    The maximum sum that can be obtained is 9 + 8 + 7 = 24 by selecting 3 from the first row, 6 from the second row, and 9 from the third row.\n\n    Therefore, the function should return 24.\n    \"\"\"\n    max_sum = float('-inf')\n    for row in grid:\n        for col in range(len(row)):\n            row_sum = row[col]\n            for i in range(len(row)):\n                row_sum = max(row_sum, row[col] + grid[i][col])\n            max_sum = max(max_sum, row_sum)\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\nassert f(g()) == 24\n\n", "emb": null, "idx_generation": 471, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum sum that can be obtained by selecting one number from each row and each column.\n    Each cell in the grid contains a non-negative integer.\n\n    Example:\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n\n    The maximum sum that can be obtained is 9 + 8 + 7 = 24 by selecting 3 from the first row, 6 from the second row, and 9 from the third row.\n\n    Therefore, the function should return 24.\n    \"\"\"\n    max_sum = float('-inf')\n    for row in grid:\n        for col in range(len(row)):\n            row_sum = row[col]\n            for i in range(len(row)):\n                row_sum = max(row_sum, row[col] + grid[i][col])\n            max_sum = max(max_sum, row_sum)\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers for Puzzle 5.\n    \"\"\"\n    return [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that have a sum equal to zero.\n\n    Example:\n    nums = [1, -2, 3, -1, -2, 4, 2, -1]\n    Output: 4\n    Explanation: The distinct pairs with a sum equal to zero are (-2, 2), (-2, 2), (-1, 1), and (-1, 1).\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    num_set = set(nums)\n\n    for num in num_set:\n        if -num in num_set:\n            count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, -2, 3, -1, -2, 4, 2, -1]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 471, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that have a sum equal to zero.\n\n    Example:\n    nums = [1, -2, 3, -1, -2, 4, 2, -1]\n    Output: 4\n    Explanation: The distinct pairs with a sum equal to zero are (-2, 2), (-2, 2), (-1, 1), and (-1, 1).\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    num_set = set(nums)\n\n    for num in num_set:\n        if -num in num_set:\n            count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, -2, 3, -1, -2, 4, 2, -1]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of occurrences of the target in the list.\n\n    Example:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    The target number 2 appears 3 times in the list.\n    Return 3.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    count = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            count += 1\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return count\n\ndef g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 472, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target number, find the number of occurrences of the target in the list.\n\n    Example:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    The target number 2 appears 3 times in the list.\n    Return 3.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    count = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            count += 1\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return count", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [1, 2, 2, 2, 3, 4, 5]\n    target = 2\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given a positive integer n, generate a list of all binary strings of length n.\n\n    Example:\n    n = 3\n    The binary strings of length 3 are ['000', '001', '010', '011', '100', '101', '110', '111'].\n    Return ['000', '001', '010', '011', '100', '101', '110', '111'].\n    \"\"\"\n    strings = []\n\n    for i in range(2 ** n):\n        binary = bin(i)[2:]\n        binary = '0' * (n - len(binary)) + binary\n        strings.append(binary)\n\n    return strings\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == ['000', '001', '010', '011', '100', '101', '110', '111']\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given a positive integer n, generate a list of all binary strings of length n.\n\n    Example:\n    n = 3\n    The binary strings of length 3 are ['000', '001', '010', '011', '100', '101', '110', '111'].\n    Return ['000', '001', '010', '011', '100', '101', '110', '111'].\n    \"\"\"\n    strings = []\n\n    for i in range(2 ** n):\n        binary = bin(i)[2:]\n        binary = '0' * (n - len(binary)) + binary\n        strings.append(binary)\n\n    return strings", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the product of all the numbers except the current number at each index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The product of all numbers except the number at index 0 is 2 * 3 * 4 = 24.\n    The product of all numbers except the number at index 1 is 1 * 3 * 4 = 12.\n    The product of all numbers except the number at index 2 is 1 * 2 * 4 = 8.\n    The product of all numbers except the number at index 3 is 1 * 2 * 3 = 6.\n    Return [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == [24, 12, 8, 6]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 472, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the product of all the numbers except the current number at each index.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    The product of all numbers except the number at index 0 is 2 * 3 * 4 = 24.\n    The product of all numbers except the number at index 1 is 1 * 3 * 4 = 12.\n    The product of all numbers except the number at index 2 is 1 * 2 * 4 = 8.\n    The product of all numbers except the number at index 3 is 1 * 2 * 3 = 6.\n    Return [24, 12, 8, 6].\n    \"\"\"\n    n = len(nums)\n    left_products = [1] * n\n    right_products = [1] * n\n    result = [1] * n\n\n    for i in range(1, n):\n        left_products[i] = left_products[i - 1] * nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right_products[i] = right_products[i + 1] * nums[i + 1]\n\n    for i in range(n):\n        result[i] = left_products[i] * right_products[i]\n\n    return result", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [1, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that add up to a specific target.\n\n    Return True if there are two numbers that add up to the target, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    The numbers 2 and 10 add up to 12, so the output is True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return (nums, target)\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that add up to a specific target.\n\n    Return True if there are two numbers that add up to the target, False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    The numbers 2 and 10 add up to 12, so the output is True.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the length of the shortest cycle in the graph.\n    A cycle is a path that starts and ends at the same vertex and visits all other vertices exactly once.\n\n    Return the length of the shortest cycle. If there is no cycle in the graph, return -1.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\n    The shortest cycle is 4, which follows the path: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n    def dfs(node, visited, parent, length):\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, node, length + 1):\n                        return True\n                elif neighbor != parent and length >= 3:\n                    return True\n\n        visited[node] = False\n        return False\n\n    for i in range(len(graph)):\n        visited = [False] * len(graph)\n        if dfs(i, visited, -1, 1):\n            return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an undirected graph represented as an adjacency matrix, find the length of the shortest cycle in the graph.\n    A cycle is a path that starts and ends at the same vertex and visits all other vertices exactly once.\n\n    Return the length of the shortest cycle. If there is no cycle in the graph, return -1.\n\n    Example:\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n\n    The shortest cycle is 4, which follows the path: 0 -> 1 -> 2 -> 3 -> 0.\n    \"\"\"\n    def dfs(node, visited, parent, length):\n        visited[node] = True\n\n        for neighbor in range(len(graph)):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, node, length + 1):\n                        return True\n                elif neighbor != parent and length >= 3:\n                    return True\n\n        visited[node] = False\n        return False\n\n    for i in range(len(graph)):\n        visited = [False] * len(graph)\n        if dfs(i, visited, -1, 1):\n            return True\n\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 1, 0],\n        [1, 0, 1, 1],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, i.e., the sum of a contiguous subarray with the largest sum.\n\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which corresponds to the subarray [4, -1, 2, 1].\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum, i.e., the sum of a contiguous subarray with the largest sum.\n\n    Return the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which corresponds to the subarray [4, -1, 2, 1].\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that have a difference equal to 3.\n\n    Example:\n    nums = [1, 4, 2, 8, 7, 5, 9, 6]\n    Output: 4\n    Explanation: The distinct pairs with a difference equal to 3 are (1, 4), (2, 5), (4, 7), and (5, 8).\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    nums.sort()\n\n    for i in range(len(nums)):\n        if nums[i] + 3 in nums:\n            count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 4, 2, 8, 7, 5, 9, 6]\n    return nums\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 472, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the number of distinct pairs that have a difference equal to 3.\n\n    Example:\n    nums = [1, 4, 2, 8, 7, 5, 9, 6]\n    Output: 4\n    Explanation: The distinct pairs with a difference equal to 3 are (1, 4), (2, 5), (4, 7), and (5, 8).\n    Therefore, the function should return 4.\n    \"\"\"\n\n    count = 0\n    nums.sort()\n\n    for i in range(len(nums)):\n        if nums[i] + 3 in nums:\n            count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 4, 2, 8, 7, 5, 9, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return the first n Fibonacci numbers.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    [0, 1, 1, 2, 3, 5]\n\n    Explanation:\n    The first 6 Fibonacci numbers are [0, 1, 1, 2, 3, 5].\n    \"\"\"\n\n    fib_nums = [0, 1]\n\n    while len(fib_nums) < n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n\n    return fib_nums\n\ndef g() -> int:\n    return 6\n\nassert f(g()) == [0, 1, 1, 2, 3, 5]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return the first n Fibonacci numbers.\n\n    Example:\n    Input:\n    n = 6\n\n    Output:\n    [0, 1, 1, 2, 3, 5]\n\n    Explanation:\n    The first 6 Fibonacci numbers are [0, 1, 1, 2, 3, 5].\n    \"\"\"\n\n    fib_nums = [0, 1]\n\n    while len(fib_nums) < n:\n        fib_nums.append(fib_nums[-1] + fib_nums[-2])\n\n    return fib_nums", "solution_func": "def g() -> int:\n    return 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the number of islands in the grid.\n    An island is formed by connecting adjacent 1s horizontally or vertically.\n    Diagonal connections are not allowed.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 1, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The grid has 3 islands, represented by the 1s at positions (0, 0) to (1, 1), (1, 3) to (1, 4), and (3, 3) to (3, 4).\n    \"\"\"\n\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(grid, i - 1, j)\n        dfs(grid, i + 1, j)\n        dfs(grid, i, j - 1)\n        dfs(grid, i, j + 1)\n\n    islands = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                islands += 1\n                dfs(grid, i, j)\n\n    return islands\n\ndef g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 1, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 472, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, determine the number of islands in the grid.\n    An island is formed by connecting adjacent 1s horizontally or vertically.\n    Diagonal connections are not allowed.\n\n    Example:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 1, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n\n    Output:\n    3\n\n    Explanation:\n    The grid has 3 islands, represented by the 1s at positions (0, 0) to (1, 1), (1, 3) to (1, 4), and (3, 3) to (3, 4).\n    \"\"\"\n\n    def dfs(grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:\n            return\n\n        grid[i][j] = -1\n\n        dfs(grid, i - 1, j)\n        dfs(grid, i + 1, j)\n        dfs(grid, i, j - 1)\n        dfs(grid, i, j + 1)\n\n    islands = 0\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                islands += 1\n                dfs(grid, i, j)\n\n    return islands", "solution_func": "def g() -> List[List[int]]:\n    grid = [\n        [1, 1, 0, 0, 0],\n        [1, 1, 0, 1, 1],\n        [0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. \n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner.\n\n    Input: n = 1\n    Output: 1\n    Explanation: There is only 1 unique path to reach the bottom-right corner.\n    \"\"\"\n\n    def count_paths(n: int) -> int:\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = 1\n            dp[0][i] = 1\n\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[n - 1][n - 1]\n\n    return count_paths(n)\n\ndef g(n = 3) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 472, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid. \n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: n = 3\n    Output: 6\n    Explanation: There are 6 unique paths to reach the bottom-right corner.\n\n    Input: n = 1\n    Output: 1\n    Explanation: There is only 1 unique path to reach the bottom-right corner.\n    \"\"\"\n\n    def count_paths(n: int) -> int:\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = 1\n            dp[0][i] = 1\n\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[n - 1][n - 1]\n\n    return count_paths(n)", "solution_func": "def g(n = 3) -> int:\n    \"\"\"\n    Generate an integer n.\n    \"\"\"\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n    \n    Hint: Use backtracking to generate all combinations of k numbers.\n\n    \"\"\"\n    def backtrack(start, combo):\n        if len(combo) == k:\n            results.append(combo[:])\n        for i in range(start, n+1):\n            combo.append(i)\n            backtrack(i+1, combo)\n            combo.pop()\n    \n    results = []\n    backtrack(1, [])\n    return results\n\ndef g():\n    n = 4\n    k = 2\n    return n, k\n\nassert f(*g()) == [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int, k: int) -> List[List[int]]:\n    \"\"\"\n    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].\n\n    Example:\n    Input: n = 4, k = 2\n    Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n    \n    Hint: Use backtracking to generate all combinations of k numbers.\n\n    \"\"\"\n    def backtrack(start, combo):\n        if len(combo) == k:\n            results.append(combo[:])\n        for i in range(start, n+1):\n            combo.append(i)\n            backtrack(i+1, combo)\n            combo.pop()\n    \n    results = []\n    backtrack(1, [])\n    return results", "solution_func": "def g():\n    n = 4\n    k = 2\n    return n, k", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct subsequences of s.\n\n    Example:\n    Input: s = \"rabbbit\"\n    Output: 3\n    \n    Hint: Use dynamic programming to count the number of distinct subsequences.\n\n    \"\"\"\n    def count_subsequences(i, j):\n        if j == len(t):\n            return 1\n        if i == len(s):\n            return 0\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if s[i] == t[j]:\n            dp[i][j] = count_subsequences(i+1, j+1) + count_subsequences(i+1, j)\n        else:\n            dp[i][j] = count_subsequences(i+1, j)\n        return dp[i][j]\n    \n    t = \"rabbit\"\n    dp = [[-1] * (len(t)+1) for _ in range(len(s)+1)]\n    return count_subsequences(0, 0)\n\ndef g():\n    s = \"rabbbit\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the number of distinct subsequences of s.\n\n    Example:\n    Input: s = \"rabbbit\"\n    Output: 3\n    \n    Hint: Use dynamic programming to count the number of distinct subsequences.\n\n    \"\"\"\n    def count_subsequences(i, j):\n        if j == len(t):\n            return 1\n        if i == len(s):\n            return 0\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if s[i] == t[j]:\n            dp[i][j] = count_subsequences(i+1, j+1) + count_subsequences(i+1, j)\n        else:\n            dp[i][j] = count_subsequences(i+1, j)\n        return dp[i][j]\n    \n    t = \"rabbit\"\n    dp = [[-1] * (len(t)+1) for _ in range(len(s)+1)]\n    return count_subsequences(0, 0)", "solution_func": "def g():\n    s = \"rabbbit\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return the nth row of Pascal's triangle.\n    \n    Example:\n    Input: n = 4\n    Output: [1,3,3,1]\n    \n    Hint: Use dynamic programming to generate Pascal's triangle.\n\n    \"\"\"\n    triangle = [[1] * (i+1) for i in range(n+1)]\n    for i in range(2, n+1):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n    return triangle[n]\n\ndef g():\n    n = 4\n    return n\n\nassert f(g()) == [1,3,3,1]\n", "emb": null, "idx_generation": 473, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\n\ndef f(n: int) -> List[int]:\n    \"\"\"\n    Given a positive integer n, return the nth row of Pascal's triangle.\n    \n    Example:\n    Input: n = 4\n    Output: [1,3,3,1]\n    \n    Hint: Use dynamic programming to generate Pascal's triangle.\n\n    \"\"\"\n    triangle = [[1] * (i+1) for i in range(n+1)]\n    for i in range(2, n+1):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]\n    return triangle[n]", "solution_func": "def g():\n    n = 4\n    return n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a sorted list of the squares of those integers.\n\n    Example:\n    nums = [-4, -2, 0, 2, 4]\n\n    The squares of the integers in the list are [16, 4, 0, 4, 16].\n\n    Therefore, the function should return [0, 4, 4, 16, 16].\n    \"\"\"\n    return sorted([num**2 for num in nums])\n\ndef g():\n    return [-4, -2, 0, 2, 4]\n\nassert f(g()) == [0, 4, 4, 16, 16]\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a sorted list of the squares of those integers.\n\n    Example:\n    nums = [-4, -2, 0, 2, 4]\n\n    The squares of the integers in the list are [16, 4, 0, 4, 16].\n\n    Therefore, the function should return [0, 4, 4, 16, 16].\n    \"\"\"\n    return sorted([num**2 for num in nums])", "solution_func": "def g():\n    return [-4, -2, 0, 2, 4]", "map_ix": [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of digits, return the sum of all the even digits in the string.\n\n    Example:\n    s = \"123456789\"\n\n    The even digits in the string are 2, 4, 6, and 8.\n\n    Therefore, the function should return 20.\n    \"\"\"\n    return sum([int(digit) for digit in s if int(digit) % 2 == 0])\n\ndef g():\n    return \"123456789\"\n\nassert f(g()) == 20\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string of digits, return the sum of all the even digits in the string.\n\n    Example:\n    s = \"123456789\"\n\n    The even digits in the string are 2, 4, 6, and 8.\n\n    Therefore, the function should return 20.\n    \"\"\"\n    return sum([int(digit) for digit in s if int(digit) % 2 == 0])", "solution_func": "def g():\n    return \"123456789\"", "map_ix": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing the words that have the letter 'a' as their first character \n    and the letter 'z' as their last character.\n\n    Example:\n    words = [\"apple\", \"banana\", \"kiwi\", \"zebra\", \"orange\"]\n\n    The words that meet the criteria are \"apple\" and \"zebra\".\n\n    Therefore, the function should return [\"apple\", \"zebra\"].\n    \"\"\"\n    return [word for word in words if word[0] == 'a' and word[-1] == 'z']\n\ndef g():\n    return [\"apple\", \"banana\", \"kiwi\", \"zebra\", \"orange\"]\n\nassert f(g()) == [\"apple\", \"zebra\"]\n", "emb": null, "idx_generation": 473, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing the words that have the letter 'a' as their first character \n    and the letter 'z' as their last character.\n\n    Example:\n    words = [\"apple\", \"banana\", \"kiwi\", \"zebra\", \"orange\"]\n\n    The words that meet the criteria are \"apple\" and \"zebra\".\n\n    Therefore, the function should return [\"apple\", \"zebra\"].\n    \"\"\"\n    return [word for word in words if word[0] == 'a' and word[-1] == 'z']", "solution_func": "def g():\n    return [\"apple\", \"banana\", \"kiwi\", \"zebra\", \"orange\"]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value k, find the index of the first occurrence of k in the array.\n    If k is not found in the array, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == k:\n            if mid == 0 or arr[mid - 1] < k:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return ([1, 2, 2, 3, 4, 5, 5, 5, 7, 8, 9], 5)\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 473, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given a sorted array of integers and a target value k, find the index of the first occurrence of k in the array.\n    If k is not found in the array, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == k:\n            if mid == 0 or arr[mid - 1] < k:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted array of integers and a target value.\n    \"\"\"\n    return ([1, 2, 2, 3, 4, 5, 5, 5, 7, 8, 9], 5)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of only digits, return the maximum possible value obtained by inserting the digit 5 anywhere in the string.\n\n    Example:\n    s = \"1234\"\n\n    The maximum possible value is 5234, which is obtained by inserting the digit 5 between the digits 2 and 3: \"12(5)34\".\n\n    Therefore, the function should return 5234.\n    \"\"\"\n\n    max_val = float('-inf')\n\n    for i in range(len(s)+1):\n        new_val = int(s[:i] + '5' + s[i:])\n        max_val = max(max_val, new_val)\n\n    return max_val\n\ndef g() -> str:\n    \"\"\"\n    Generate a string consisting of only digits.\n    \"\"\"\n    return \"1234\"\n\nassert f(g()) == 5234\n\n", "emb": null, "idx_generation": 473, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s consisting of only digits, return the maximum possible value obtained by inserting the digit 5 anywhere in the string.\n\n    Example:\n    s = \"1234\"\n\n    The maximum possible value is 5234, which is obtained by inserting the digit 5 between the digits 2 and 3: \"12(5)34\".\n\n    Therefore, the function should return 5234.\n    \"\"\"\n\n    max_val = float('-inf')\n\n    for i in range(len(s)+1):\n        new_val = int(s[:i] + '5' + s[i:])\n        max_val = max(max_val, new_val)\n\n    return max_val", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string consisting of only digits.\n    \"\"\"\n    return \"1234\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any hourglass shape within the grid.\n    An hourglass shape is defined by a set of 7 cells in the following pattern:\n\n        a b c\n          d\n        e f g\n\n    Example:\n    grid = [\n        [-9, -9, -9, 1, 1, 1],\n        [0, -9, 0, 4, 3, 2],\n        [-9, -9, -9, 1, 2, 3],\n        [0, 0, 8, 6, 6, 0],\n        [0, 0, 0, -2, 0, 0],\n        [0, 0, 1, 2, 4, 0]\n    ]\n\n    The maximum sum of any hourglass shape is 28, which is obtained from the hourglass shape [-9, -9, -9, -9, -9, -9, 1].\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_sum = float('-inf')\n\n    for i in range(len(grid)-2):\n        for j in range(len(grid[0])-2):\n            hourglass_sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\n            max_sum = max(max_sum, hourglass_sum)\n\n    return max_sum\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [-9, -9, -9, 1, 1, 1],\n        [0, -9, 0, 4, 3, 2],\n        [-9, -9, -9, 1, 2, 3],\n        [0, 0, 8, 6, 6, 0],\n        [0, 0, 0, -2, 0, 0],\n        [0, 0, 1, 2, 4, 0]\n    ]\n\nassert f(g()) == 28\n\n", "emb": [1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 473, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of any hourglass shape within the grid.\n    An hourglass shape is defined by a set of 7 cells in the following pattern:\n\n        a b c\n          d\n        e f g\n\n    Example:\n    grid = [\n        [-9, -9, -9, 1, 1, 1],\n        [0, -9, 0, 4, 3, 2],\n        [-9, -9, -9, 1, 2, 3],\n        [0, 0, 8, 6, 6, 0],\n        [0, 0, 0, -2, 0, 0],\n        [0, 0, 1, 2, 4, 0]\n    ]\n\n    The maximum sum of any hourglass shape is 28, which is obtained from the hourglass shape [-9, -9, -9, -9, -9, -9, 1].\n\n    Therefore, the function should return 28.\n    \"\"\"\n\n    max_sum = float('-inf')\n\n    for i in range(len(grid)-2):\n        for j in range(len(grid[0])-2):\n            hourglass_sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\n            max_sum = max(max_sum, hourglass_sum)\n\n    return max_sum", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [-9, -9, -9, 1, 1, 1],\n        [0, -9, 0, 4, 3, 2],\n        [-9, -9, -9, 1, 2, 3],\n        [0, 0, 8, 6, 6, 0],\n        [0, 0, 0, -2, 0, 0],\n        [0, 0, 1, 2, 4, 0]\n    ]", "map_ix": [1, 1, 1, 0, 1, 1, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, determine if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[4, 9, 2],\n              [3, 5, 7],\n              [8, 1, 6]]\n    f(matrix) => True\n    Explanation: The sums of each row, each column, and both diagonals are all 15.\n\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\n\ndef g():\n    return [[4, 9, 2],\n            [3, 5, 7],\n            [8, 1, 6]]\n\nassert f(g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 473, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given a matrix, determine if it is a magic square.\n    A magic square is a square matrix in which the sums of each row, each column, and both diagonals are the same.\n\n    Example:\n    matrix = [[4, 9, 2],\n              [3, 5, 7],\n              [8, 1, 6]]\n    f(matrix) => True\n    Explanation: The sums of each row, each column, and both diagonals are all 15.\n\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for j in range(n):\n        col_sum = 0\n        for i in range(n):\n            col_sum += matrix[i][j]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = 0\n    diagonal_sum2 = 0\n    for i in range(n):\n        diagonal_sum1 += matrix[i][i]\n        diagonal_sum2 += matrix[i][n - i - 1]\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True", "solution_func": "def g():\n    return [[4, 9, 2],\n            [3, 5, 7],\n            [8, 1, 6]]", "map_ix": [1, 1, 0, 1, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array that add up to the target.\n    Return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output: [0, 1]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find two numbers in the array that add up to the target.\n    Return their indices.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    Output: [0, 1]\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down, right, or diagonally.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output: 29\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            dp[i][j] = matrix[i-1][j-1] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[rows][cols]\n\ndef g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix\n\nassert f(g()) == 29\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left corner to the bottom-right corner,\n    moving only down, right, or diagonally.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    Output: 29\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    \n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            dp[i][j] = matrix[i-1][j-1] + max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[rows][cols]", "solution_func": "def g() -> List[List[int]]:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    return matrix", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the index of the target if it exists in the array.\n    If the target is not found, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n\ndef g() -> List[int]:\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted array of integers nums and a target value, find the index of the target if it exists in the array.\n    If the target is not found, return the index where it would be if it were inserted in order.\n\n    Example:\n    nums = [1, 3, 5, 6]\n    target = 5\n\n    Output: 2\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left", "solution_func": "def g() -> List[int]:\n    nums = [1, 3, 5, 6]\n    target = 5\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 7, 1, 3]\n\n    The sorted list should be [1, 2, 3, 5, 7].\n\n    Therefore, the function should return [1, 2, 3, 5, 7].\n    \"\"\"\n    nums.sort()\n    return nums\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 7, 1, 3]\n\nassert f(g()) == [1, 2, 3, 5, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in non-decreasing order.\n\n    Example:\n    nums = [5, 2, 7, 1, 3]\n\n    The sorted list should be [1, 2, 3, 5, 7].\n\n    Therefore, the function should return [1, 2, 3, 5, 7].\n    \"\"\"\n    nums.sort()\n    return nums", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [5, 2, 7, 1, 3]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(string: str, target: str) -> int:\n    \"\"\"\n    Given a string and a target substring, count the number of occurrences of the target substring in the string.\n\n    Example:\n    string = \"banana\"\n    target = \"ana\"\n\n    The target substring \"ana\" appears twice in the string \"banana\".\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    length = len(target)\n    \n    for i in range(len(string) - length + 1):\n        if string[i:i+length] == target:\n            count += 1\n    \n    return count\n\ndef g() -> (str, str):\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return \"banana\", \"ana\"\n\nassert f(*g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(string: str, target: str) -> int:\n    \"\"\"\n    Given a string and a target substring, count the number of occurrences of the target substring in the string.\n\n    Example:\n    string = \"banana\"\n    target = \"ana\"\n\n    The target substring \"ana\" appears twice in the string \"banana\".\n\n    Therefore, the function should return 2.\n    \"\"\"\n    count = 0\n    length = len(target)\n    \n    for i in range(len(string) - length + 1):\n        if string[i:i+length] == target:\n            count += 1\n    \n    return count", "solution_func": "def g() -> (str, str):\n    \"\"\"\n    Generate a string and a target substring.\n    \"\"\"\n    return \"banana\", \"ana\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates from the list and return the resulting list.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n\n    The list without duplicates should be [1, 2, 3, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 4, 5].\n    \"\"\"\n    return list(set(nums))\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates from the list and return the resulting list.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n\n    The list without duplicates should be [1, 2, 3, 4, 5].\n\n    Therefore, the function should return [1, 2, 3, 4, 5].\n    \"\"\"\n    return list(set(nums))", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 2, 3, 4, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid with 0s and 1s, find the largest square of 1s in the grid and return its area.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1]\n    ]\n\n    The largest square of 1s in the grid is:\n    [\n        [1, 1],\n        [1, 1]\n    ]\n\n    Therefore, the function should return 4.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    max_len = 0\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            elif grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            max_len = max(max_len, dp[i][j])\n\n    return max_len * max_len\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1]\n    ]\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid with 0s and 1s, find the largest square of 1s in the grid and return its area.\n\n    Example:\n    grid = [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1]\n    ]\n\n    The largest square of 1s in the grid is:\n    [\n        [1, 1],\n        [1, 1]\n    ]\n\n    Therefore, the function should return 4.\n    \"\"\"\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    max_len = 0\n\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = grid[i][j]\n            elif grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            max_len = max(max_len, dp[i][j])\n\n    return max_len * max_len", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of 0s and 1s for Puzzle 3.\n    \"\"\"\n    return [\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 0, 1],\n        [0, 0, 0, 1]\n    ]", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort them in lexicographic order. If two words are anagrams, sort them based on their original order.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\"]\n\n    After sorting, the list should be [\"cat\", \"tac\", \"dog\", \"god\"].\n\n    Therefore, the function should return [\"cat\", \"tac\", \"dog\", \"god\"].\n    \"\"\"\n    sorted_words = []\n\n    anagram_map = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagram_map:\n            anagram_map[sorted_word].append(word)\n        else:\n            anagram_map[sorted_word] = [word]\n\n    for sorted_word in sorted(anagram_map.keys()):\n        sorted_words.extend(anagram_map[sorted_word])\n\n    return sorted_words\n\ndef g() -> List[str]:\n    \"\"\"\n    Generate a list of words for Puzzle 4.\n    \"\"\"\n    return [\"cat\", \"dog\", \"tac\", \"god\"]\n\nassert f(g()) == [\"cat\", \"tac\", \"dog\", \"god\"]\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, sort them in lexicographic order. If two words are anagrams, sort them based on their original order.\n\n    Example:\n    words = [\"cat\", \"dog\", \"tac\", \"god\"]\n\n    After sorting, the list should be [\"cat\", \"tac\", \"dog\", \"god\"].\n\n    Therefore, the function should return [\"cat\", \"tac\", \"dog\", \"god\"].\n    \"\"\"\n    sorted_words = []\n\n    anagram_map = {}\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        if sorted_word in anagram_map:\n            anagram_map[sorted_word].append(word)\n        else:\n            anagram_map[sorted_word] = [word]\n\n    for sorted_word in sorted(anagram_map.keys()):\n        sorted_words.extend(anagram_map[sorted_word])\n\n    return sorted_words", "solution_func": "def g() -> List[str]:\n    \"\"\"\n    Generate a list of words for Puzzle 4.\n    \"\"\"\n    return [\"cat\", \"dog\", \"tac\", \"god\"]", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcba\"\n\n    After removing the character 'c', the string becomes a palindrome.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True\n\ndef g() -> str:\n    \"\"\"\n    Generate a string for Puzzle 5.\n    \"\"\"\n    return \"abcba\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 474, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome after removing at most one character.\n\n    Example:\n    s = \"abcba\"\n\n    After removing the character 'c', the string becomes a palindrome.\n\n    Therefore, the function should return True.\n    \"\"\"\n    def is_palindrome(s, left, right):\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)\n        left += 1\n        right -= 1\n\n    return True", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string for Puzzle 5.\n    \"\"\"\n    return \"abcba\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n        \n        def insert(self, num):\n            node = self\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if not node.children[bit]:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n        \n        def findMaxXOR(self, num):\n            node = self\n            xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[1 - bit]:\n                    xor |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        root.insert(num)\n        xor = root.findMaxXOR(num)\n        max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(*g()) == 28\n", "emb": null, "idx_generation": 474, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value between any two numbers in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n\n    Explanation:\n    The maximum XOR value can be obtained by XORing 5 and 25, which gives 28.\n    \"\"\"\n\n    class TrieNode:\n        def __init__(self):\n            self.children = [None, None]\n        \n        def insert(self, num):\n            node = self\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if not node.children[bit]:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n        \n        def findMaxXOR(self, num):\n            node = self\n            xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[1 - bit]:\n                    xor |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor\n\n    root = TrieNode()\n    max_xor = 0\n    for num in nums:\n        root.insert(num)\n        xor = root.findMaxXOR(num)\n        max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, m: int, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of size n x m, determine if there is a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    def dfs(i, j):\n        if i >= n or j >= m or grid[i][j] == '#':\n            return False\n        if i == n-1 and j == m-1:\n            return True\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)\n\ndef g(n: int, m: int, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Generate a grid of size n x m with a valid path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    grid[0][0] = '.'\n    for i in range(1, n):\n        grid[i][0] = '.'\n    for j in range(1, m):\n        grid[0][j] = '.'\n    return grid\n\nassert f(*g(n=3, m=4, grid=[['.', '#', '.', '.'], ['.', '.', '#', '.'], ['#', '.', '.', '.']]))\n\n", "emb": null, "idx_generation": 475, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, m: int, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Given a grid of size n x m, determine if there is a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n    \"\"\"\n    def dfs(i, j):\n        if i >= n or j >= m or grid[i][j] == '#':\n            return False\n        if i == n-1 and j == m-1:\n            return True\n        return dfs(i+1, j) or dfs(i, j+1)\n    \n    return dfs(0, 0)", "solution_func": "def g(n: int, m: int, grid: List[List[str]]) -> bool:\n    \"\"\"\n    Generate a grid of size n x m with a valid path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    grid[0][0] = '.'\n    for i in range(1, n):\n        grid[i][0] = '.'\n    for j in range(1, m):\n        grid[0][j] = '.'\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, substrings: List[str]) -> bool:\n    \"\"\"\n    Determine if a string can be constructed by concatenating multiple substrings from a given list.\n    \"\"\"\n    def dfs(s):\n        if s == \"\":\n            return True\n        for substr in substrings:\n            if s.startswith(substr):\n                if dfs(s[len(substr):]):\n                    return True\n        return False\n    \n    return dfs(s)\n\ndef g(substrings: List[str]) -> bool:\n    \"\"\"\n    Generate a string that can be constructed by concatenating multiple substrings from a given list.\n    \"\"\"\n    return \"\".join(substrings)\n\nassert f(g(substrings=[\"abc\", \"def\", \"ghi\"]), substrings=[\"abc\", \"def\", \"ghi\"])\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, substrings: List[str]) -> bool:\n    \"\"\"\n    Determine if a string can be constructed by concatenating multiple substrings from a given list.\n    \"\"\"\n    def dfs(s):\n        if s == \"\":\n            return True\n        for substr in substrings:\n            if s.startswith(substr):\n                if dfs(s[len(substr):]):\n                    return True\n        return False\n    \n    return dfs(s)", "solution_func": "def g(substrings: List[str]) -> bool:\n    \"\"\"\n    Generate a string that can be constructed by concatenating multiple substrings from a given list.\n    \"\"\"\n    return \"\".join(substrings)", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import random\nfrom typing import*\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if it is possible to reach the bottom-right cell of a grid by starting from the top-left cell.\n    The value in each cell represents the maximum number of steps that can be taken from that cell.\n    \"\"\"\n    def dfs(i, j):\n        if i >= n or j >= m:\n            return False\n        if i == n-1 and j == m-1:\n            return True\n        steps = grid[i][j]\n        return dfs(i+steps, j) or dfs(i, j+steps)\n    \n    return dfs(0, 0)\n\ndef g(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Generate a grid with random values for testing.\n    \"\"\"\n    return grid\n\nassert f(*g(n=3, m=3, grid=[[2, 3, 1], [1, 5, 2], [1, 1, 2]]))\n\n", "emb": null, "idx_generation": 475, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "import random\nfrom typing import*\ndef f(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if it is possible to reach the bottom-right cell of a grid by starting from the top-left cell.\n    The value in each cell represents the maximum number of steps that can be taken from that cell.\n    \"\"\"\n    def dfs(i, j):\n        if i >= n or j >= m:\n            return False\n        if i == n-1 and j == m-1:\n            return True\n        steps = grid[i][j]\n        return dfs(i+steps, j) or dfs(i, j+steps)\n    \n    return dfs(0, 0)", "solution_func": "def g(n: int, m: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Generate a grid with random values for testing.\n    \"\"\"\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there exists two numbers in the list such that their sum is equal to the target value.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6], target = 8\n    Output: True\n\n    Explanation: There exists two numbers in the list, 2 and 6, that sum up to 8.\n\n    Constraints:\n    - The input list is sorted in ascending order.\n    - The length of the list is at most 10^5.\n    - The elements in the list are unique integers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5, 6], target=8) -> List[int]:\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], "idx_generation": 475, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers in ascending order, determine if there exists two numbers in the list such that their sum is equal to the target value.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6], target = 8\n    Output: True\n\n    Explanation: There exists two numbers in the list, 2 and 6, that sum up to 8.\n\n    Constraints:\n    - The input list is sorted in ascending order.\n    - The length of the list is at most 10^5.\n    - The elements in the list are unique integers.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6], target=8) -> List[int]:\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[str]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of well-formed parentheses with n pairs.\n\n    Example:\n    Input: n = 3\n    Output: [\n        \"((()))\",\n        \"(()())\",\n        \"(())()\",\n        \"()(())\",\n        \"()()()\"\n    ]\n\n    Constraints:\n    - n is a positive integer.\n    - The number of combinations is at most 10^4.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    combinations = []\n    backtrack('', 0, 0)\n    return combinations\n\ndef g(n=3) -> int:\n    return n\n\nassert f(g()) == [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[List[str]]:\n    \"\"\"\n    Given an integer n, generate all possible combinations of well-formed parentheses with n pairs.\n\n    Example:\n    Input: n = 3\n    Output: [\n        \"((()))\",\n        \"(()())\",\n        \"(())()\",\n        \"()(())\",\n        \"()()()\"\n    ]\n\n    Constraints:\n    - n is a positive integer.\n    - The number of combinations is at most 10^4.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    combinations = []\n    backtrack('', 0, 0)\n    return combinations", "solution_func": "def g(n=3) -> int:\n    return n", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where no two elements in the subsequence are adjacent.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: 12\n\n    Explanation: The maximum sum can be obtained by selecting the subsequence [2, 4, 6].\n\n    Constraints:\n    - The length of the list is at most 10^5.\n    - The elements in the list are non-negative integers.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]\n\ndef g(nums=[1, 2, 3, 4, 5, 6]) -> List[int]:\n    return nums\n\nassert f(g()) == 12\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subsequence where no two elements in the subsequence are adjacent.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: 12\n\n    Explanation: The maximum sum can be obtained by selecting the subsequence [2, 4, 6].\n\n    Constraints:\n    - The length of the list is at most 10^5.\n    - The elements in the list are non-negative integers.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n    return dp[n-1]", "solution_func": "def g(nums=[1, 2, 3, 4, 5, 6]) -> List[int]:\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a matrix, find the maximum element in each row.\n\n    Example:\n    matrix = np.array([[1, 2, 3],\n                       [4, 5, 6],\n                       [7, 8, 9]])\n\n    The maximum elements in each row are [3, 6, 9].\n\n    Therefore, the function should return np.array([3, 6, 9]).\n    \"\"\"\n    max_elements = np.max(matrix, axis=1)\n    return max_elements\n\ndef g() -> np.ndarray:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    return np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nassert np.array_equal(f(g()), np.array([3, 6, 9]))\n\nassert f(g()) == True", "emb": null, "idx_generation": 475, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nimport numpy as np\n\ndef f(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a matrix, find the maximum element in each row.\n\n    Example:\n    matrix = np.array([[1, 2, 3],\n                       [4, 5, 6],\n                       [7, 8, 9]])\n\n    The maximum elements in each row are [3, 6, 9].\n\n    Therefore, the function should return np.array([3, 6, 9]).\n    \"\"\"\n    max_elements = np.max(matrix, axis=1)\n    return max_elements", "solution_func": "def g() -> np.ndarray:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    return np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the maximum and minimum elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum element is 5 and the minimum element is 1.\n\n    Therefore, the function should return [5, 1].\n    \"\"\"\n    max_num = max(nums)\n    min_num = min(nums)\n    return [max_num, min_num]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [5, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, find the maximum and minimum elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum element is 5 and the minimum element is 1.\n\n    Therefore, the function should return [5, 1].\n    \"\"\"\n    max_num = max(nums)\n    min_num = min(nums)\n    return [max_num, min_num]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The target value 3 is located at index 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g(), 3) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 475, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    target = 3\n\n    The target value 3 is located at index 2.\n\n    Therefore, the function should return 2.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if it is possible to create a square grid of size n x n by rotating the given grid 90 degrees.\n    \"\"\"\n    rotated_grid = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0])-1, -1, -1)]\n    return len(rotated_grid) == n and all(len(row) == n for row in rotated_grid)\n\ndef g(grid: List[List[int]]):\n    return len(grid)\n\nassert f(g([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n", "emb": null, "idx_generation": 475, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int, grid: List[List[int]]) -> bool:\n    \"\"\"\n    Determine if it is possible to create a square grid of size n x n by rotating the given grid 90 degrees.\n    \"\"\"\n    rotated_grid = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0])-1, -1, -1)]\n    return len(rotated_grid) == n and all(len(row) == n for row in rotated_grid)", "solution_func": "def g(grid: List[List[int]]):\n    return len(grid)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', return True if the list is sorted in non-decreasing order, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: True\n    \"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    return True\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers 'nums', return True if the list is sorted in non-decreasing order, False otherwise.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    Output: True\n    \"\"\"\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    return True", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', return the number of set bits in all the elements of the list.\n\n    Example:\n    nums = [2, 3, 4, 5, 6]\n\n    Output: 8\n    \"\"\"\n    count = 0\n    for num in nums:\n        count += bin(num).count('1')\n    return count\n\ndef g() -> List[int]:\n    nums = [2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', return the number of set bits in all the elements of the list.\n\n    Example:\n    nums = [2, 3, 4, 5, 6]\n\n    Output: 8\n    \"\"\"\n    count = 0\n    for num in nums:\n        count += bin(num).count('1')\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [2, 3, 4, 5, 6]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(word: str) -> str:\n    \"\"\"\n    Given a string 'word', return the string with all vowels replaced by 'z'.\n\n    Example:\n    word = \"hello\"\n\n    Output: \"hzllz\"\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for vowel in vowels:\n        word = word.replace(vowel, 'z')\n    return word\n\ndef g() -> str:\n    word = \"hello\"\n    return word\n\nassert f(g()) == \"hzllz\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(word: str) -> str:\n    \"\"\"\n    Given a string 'word', return the string with all vowels replaced by 'z'.\n\n    Example:\n    word = \"hello\"\n\n    Output: \"hzllz\"\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for vowel in vowels:\n        word = word.replace(vowel, 'z')\n    return word", "solution_func": "def g() -> str:\n    word = \"hello\"\n    return word", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word can be formed by concatenating\n    a subset of the words in the list, without any repeating characters.\n    \"\"\"\n    sorted_words = sorted(words, key=len)\n    sorted_words_set = set(sorted_words)\n    target_set = set(target)\n    \n    if target_set - set(\"\".join(words)):\n        return False\n    \n    for i in range(len(sorted_words)):\n        for j in range(i+1, len(sorted_words)):\n            if sorted_words[i] + sorted_words[j] == target:\n                return True\n    \n    return False\n\ndef g(words = [\"apple\", \"banana\", \"pear\", \"orange\"], target = \"applebanana\"):\n    return words, target\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 476, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(words: List[str], target: str) -> bool:\n    \"\"\"\n    Given a list of words and a target word, determine if the target word can be formed by concatenating\n    a subset of the words in the list, without any repeating characters.\n    \"\"\"\n    sorted_words = sorted(words, key=len)\n    sorted_words_set = set(sorted_words)\n    target_set = set(target)\n    \n    if target_set - set(\"\".join(words)):\n        return False\n    \n    for i in range(len(sorted_words)):\n        for j in range(i+1, len(sorted_words)):\n            if sorted_words[i] + sorted_words[j] == target:\n                return True\n    \n    return False", "solution_func": "def g(words = [\"apple\", \"banana\", \"pear\", \"orange\"], target = \"applebanana\"):\n    return words, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    # Initialize first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    # Initialize first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill the rest of the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 476, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    You can only move down or right in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    # Initialize first column\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    # Initialize first row\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    # Fill the rest of the dp table\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g(grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> List[List[str]]:\n    \"\"\"\n    Given an integer n, generate all possible valid parentheses combinations of length 2n.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n        \n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        \n        if right < left:\n            backtrack(s + ')', left, right + 1)\n    \n    combinations = []\n    backtrack('', 0, 0)\n    return combinations\n\ndef g(n = 3):\n    return n\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> List[List[str]]:\n    \"\"\"\n    Given an integer n, generate all possible valid parentheses combinations of length 2n.\n    \"\"\"\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            combinations.append(s)\n            return\n        \n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        \n        if right < left:\n            backtrack(s + ')', left, right + 1)\n    \n    combinations = []\n    backtrack('', 0, 0)\n    return combinations", "solution_func": "def g(n = 3):\n    return n", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of numbers and a target number, determine if it is possible to reach the target by moving only right or down in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[False] * (cols+1) for _ in range(rows+1)]\n    dp[0][1] = True\n    \n    for i in range(1, rows+1):\n        for j in range(1, cols+1):\n            dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[rows][cols] and target <= rows + cols\n\ndef g(grid: List[List[int]], target: int) -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a grid and a target number.\n    \"\"\"\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    target = 13\n    \n    return grid, target\n\nassert f(*g())\n", "emb": null, "idx_generation": 476, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(grid: List[List[int]], target: int) -> bool:\n    \"\"\"\n    Given a grid of numbers and a target number, determine if it is possible to reach the target by moving only right or down in the grid.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[False] * (cols+1) for _ in range(rows+1)]\n    dp[0][1] = True\n    \n    for i in range(1, rows+1):\n        for j in range(1, cols+1):\n            dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[rows][cols] and target <= rows + cols", "solution_func": "def g(grid: List[List[int]], target: int) -> Tuple[List[List[int]], int]:\n    \"\"\"\n    Generate a grid and a target number.\n    \"\"\"\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    target = 13\n    \n    return grid, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string and an integer k, find all possible substrings of length k that can be formed using the characters of the string.\n    \"\"\"\n    n = len(s)\n    substrings = []\n    for i in range(n-k+1):\n        substring = s[i:i+k]\n        substrings.append(substring)\n    return substrings\n\ndef g(s: str, k: int) -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    s = \"abcde\"\n    k = 3\n    return s, k\n\nassert f(*g()) == ['abc', 'bcd', 'cde']\n", "emb": null, "idx_generation": 476, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string and an integer k, find all possible substrings of length k that can be formed using the characters of the string.\n    \"\"\"\n    n = len(s)\n    substrings = []\n    for i in range(n-k+1):\n        substring = s[i:i+k]\n        substrings.append(substring)\n    return substrings", "solution_func": "def g(s: str, k: int) -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    s = \"abcde\"\n    k = 3\n    return s, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of numbers.\n    \"\"\"\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    \n    return grid\n\nassert f(g())\n", "emb": null, "idx_generation": 476, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of numbers, find the maximum sum of a path from the top-left corner to the bottom-right corner.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g(grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Generate a grid of numbers.\n    \"\"\"\n    grid = [[1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]]\n    \n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an N x N matrix, determine if it is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same.\n    \"\"\"\n    \n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True\n\ndef g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 476, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> bool:\n    \"\"\"\n    Given an N x N matrix, determine if it is a magic square.\n    A magic square is a square grid of numbers where the sums of the numbers in each row, each column, and both main diagonals are the same.\n    \"\"\"\n    \n    n = len(matrix)\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != target_sum:\n        return False\n    \n    return True", "solution_func": "def g(matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]):\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the odd elements in the list.\n\n    Return the product.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The odd elements in the list are [1, 3, 5].\n    The product of these elements is 1 * 3 * 5 = 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    product = 1\n\n    for num in arr:\n        if num % 2 != 0:\n            product *= num\n\n    return product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nassert f(g()) == 945\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the product of all the odd elements in the list.\n\n    Return the product.\n\n    Example:\n    arr = [1, 2, 3, 4, 5]\n\n    The odd elements in the list are [1, 3, 5].\n    The product of these elements is 1 * 3 * 5 = 15.\n\n    Therefore, the function should return 15.\n    \"\"\"\n    product = 1\n\n    for num in arr:\n        if num % 2 != 0:\n            product *= num\n\n    return product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for Puzzle 3.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9]", "map_ix": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all prime numbers less than or equal to n.\n\n    Return the sum.\n\n    Example:\n    n = 10\n\n    The prime numbers less than or equal to 10 are [2, 3, 5, 7].\n    The sum of these prime numbers is 2 + 3 + 5 + 7 = 17.\n\n    Therefore, the function should return 17.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_sum += i\n\n    return prime_sum\n\ndef g(n: int = 10):\n    return n\n\nassert f(g()) == 17\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the sum of all prime numbers less than or equal to n.\n\n    Return the sum.\n\n    Example:\n    n = 10\n\n    The prime numbers less than or equal to 10 are [2, 3, 5, 7].\n    The sum of these prime numbers is 2 + 3 + 5 + 7 = 17.\n\n    Therefore, the function should return 17.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n\n    for i in range(2, n + 1):\n        if is_prime(i):\n            prime_sum += i\n\n    return prime_sum", "solution_func": "def g(n: int = 10):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Return the number of paths.\n\n    Example:\n    n = 3\n\n    The grid is represented as follows:\n    1 1 1\n    1 1 1\n    1 1 1\n\n    There are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    paths = factorial(2 * (n - 1)) // (factorial(n - 1) ** 2)\n\n    return paths\n\ndef g(n: int = 3):\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n\n    Return the number of paths.\n\n    Example:\n    n = 3\n\n    The grid is represented as follows:\n    1 1 1\n    1 1 1\n    1 1 1\n\n    There are 6 unique paths from the top-left corner to the bottom-right corner.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * factorial(n - 1)\n\n    paths = factorial(2 * (n - 1)) // (factorial(n - 1) ** 2)\n\n    return paths", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n\n    The target value 8 is found at index 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n    return nums, target\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found, return -1.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n\n    The target value 8 is found at index 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> List[int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 8\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is the sum of [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 6, which is the sum of [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    \n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value 9, and their indices are 0 and 1 respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The numbers 2 and 7 add up to the target value 9, and their indices are 0 and 1 respectively.\n\n    Therefore, the function should return [0, 1].\n    \"\"\"\n    num_map = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The subarray with the maximum product is [2, 3], and the product is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_product = float('-inf')\n    current_max = 1\n    current_min = 1\n\n    for num in nums:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n\n        max_product = max(max_product, current_max)\n\n    return max_product\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, -2, 4]\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n\n    Example:\n    nums = [2, 3, -2, 4]\n\n    The subarray with the maximum product is [2, 3], and the product is 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_product = float('-inf')\n    current_max = 1\n    current_min = 1\n\n    for num in nums:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n\n        max_product = max(max_product, current_max)\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, -2, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", and the length is 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for i in range(len(s)):\n        if s[i] in seen and start <= seen[s[i]]:\n            start = seen[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        seen[s[i]] = i\n\n    return max_length\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, find the length of the longest substring without repeating characters.\n\n    Example:\n    s = \"abcabcbb\"\n\n    The longest substring without repeating characters is \"abc\", and the length is 3.\n\n    Therefore, the function should return 3.\n    \"\"\"\n    max_length = 0\n    start = 0\n    seen = {}\n\n    for i in range(len(s)):\n        if s[i] in seen and start <= seen[s[i]]:\n            start = seen[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        \n        seen[s[i]] = i\n\n    return max_length", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"abcabcbb\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], and the length is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 477, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    The longest increasing subsequence is [2, 3, 7, 101], and the length is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, find all subsets with a sum of 0.\n\n    Example:\n    Input: nums = [-1, 0, 1, 2, -1, -4]\n    Output: [[-1, 0, 1], [-1, -1, 2]]\n\n    Note:\n    - The solution set must not contain duplicate subsets.\n    - The order of subsets does not matter.\n    \"\"\"\n\n    def backtrack(start, path, curr_sum):\n        if curr_sum == 0:\n            result.append(path)\n            return\n        if curr_sum < 0:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i + 1, path + [nums[i]], curr_sum - nums[i])\n\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g(nums=[-1, 0, 1, 2, -1, -4]):\n    return [num for num in nums]\n\nassert f(g()) == [[-1, 0, 1], [-1, -1, 2]]\n", "emb": null, "idx_generation": 477, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers, find all subsets with a sum of 0.\n\n    Example:\n    Input: nums = [-1, 0, 1, 2, -1, -4]\n    Output: [[-1, 0, 1], [-1, -1, 2]]\n\n    Note:\n    - The solution set must not contain duplicate subsets.\n    - The order of subsets does not matter.\n    \"\"\"\n\n    def backtrack(start, path, curr_sum):\n        if curr_sum == 0:\n            result.append(path)\n            return\n        if curr_sum < 0:\n            return\n        for i in range(start, len(nums)):\n            backtrack(i + 1, path + [nums[i]], curr_sum - nums[i])\n\n    result = []\n    backtrack(0, [], 0)\n    return result", "solution_func": "def g(nums=[-1, 0, 1, 2, -1, -4]):\n    return [num for num in nums]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays that have a sum equal to 0.\n    \"\"\"\n\n    prefix_sum = 0\n    count = 0\n    sum_map = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in sum_map:\n            count += sum_map[prefix_sum]\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count\n\ndef g():\n    return [4, 2, -3, -1, 0, 4]\n\nassert f(g()) == 2\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subarrays that have a sum equal to 0.\n    \"\"\"\n\n    prefix_sum = 0\n    count = 0\n    sum_map = {0: 1}\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum in sum_map:\n            count += sum_map[prefix_sum]\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count", "solution_func": "def g():\n    return [4, 2, -3, -1, 0, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence in the list.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    return [10, 9, 2, 5, 3, 7, 101, 18]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a wall and 0 represents an empty space, find the minimum number of steps required to reach the target cell from the starting cell.\n    You can only move up, down, left, or right and cannot move through walls.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int, steps: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 1:\n            return\n\n        if row == rows - 1 and col == cols - 1:\n            nonlocal min_steps\n            min_steps = min(min_steps, steps)\n            return\n\n        grid[row][col] = 1\n\n        dfs(row - 1, col, steps + 1)\n        dfs(row + 1, col, steps + 1)\n        dfs(row, col - 1, steps + 1)\n        dfs(row, col + 1, steps + 1)\n\n        grid[row][col] = 0\n\n    min_steps = float('inf')\n    dfs(0, 0, 0)\n\n    return min_steps\n\ndef g():\n    return [[0, 1, 0, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 1 represents a wall and 0 represents an empty space, find the minimum number of steps required to reach the target cell from the starting cell.\n    You can only move up, down, left, or right and cannot move through walls.\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def dfs(row: int, col: int, steps: int) -> None:\n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 1:\n            return\n\n        if row == rows - 1 and col == cols - 1:\n            nonlocal min_steps\n            min_steps = min(min_steps, steps)\n            return\n\n        grid[row][col] = 1\n\n        dfs(row - 1, col, steps + 1)\n        dfs(row + 1, col, steps + 1)\n        dfs(row, col - 1, steps + 1)\n        dfs(row, col + 1, steps + 1)\n\n        grid[row][col] = 0\n\n    min_steps = float('inf')\n    dfs(0, 0, 0)\n\n    return min_steps", "solution_func": "def g():\n    return [[0, 1, 0, 0, 0],\n            [0, 1, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "import math\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine whether it is possible to arrange n distinct integers in a circle such that the absolute difference\n    between each pair of adjacent integers is divisible by k.\"\"\"\n    from math import gcd\n    \n    def dfs(visited, curr, k):\n        if len(visited) == n:\n            return True\n        \n        for i in range(n):\n            if i not in visited and gcd(curr, i) % k == 0:\n                visited.add(i)\n                if dfs(visited, i, k):\n                    return True\n                visited.remove(i)\n        \n        return False\n    \n    return dfs(set([0]), 0, k)\n\ndef g(n=4, k=2):\n    \"\"\"Generate a list of n distinct integers.\"\"\"\n    return [i for i in range(n)]\n\nassert f(g())\n", "emb": null, "idx_generation": 478, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "import math\nfrom typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine whether it is possible to arrange n distinct integers in a circle such that the absolute difference\n    between each pair of adjacent integers is divisible by k.\"\"\"\n    from math import gcd\n    \n    def dfs(visited, curr, k):\n        if len(visited) == n:\n            return True\n        \n        for i in range(n):\n            if i not in visited and gcd(curr, i) % k == 0:\n                visited.add(i)\n                if dfs(visited, i, k):\n                    return True\n                visited.remove(i)\n        \n        return False\n    \n    return dfs(set([0]), 0, k)", "solution_func": "def g(n=4, k=2):\n    \"\"\"Generate a list of n distinct integers.\"\"\"\n    return [i for i in range(n)]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine whether it is possible to arrange n distinct integers in a circle such that the absolute difference\n    between each pair of adjacent integers is divisible by k.\"\"\"\n    def count_valid_permutations(arr, k):\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] % k == 0 or k % arr[i] == 0:\n                count += 1\n        return count\n    \n    def backtrack(arr, k, idx):\n        if idx == len(arr):\n            return count_valid_permutations(arr, k) == len(arr)\n        \n        for i in range(idx, len(arr)):\n            arr[idx], arr[i] = arr[i], arr[idx]\n            if backtrack(arr, k, idx+1):\n                return True\n            arr[idx], arr[i] = arr[i], arr[idx]\n        \n        return False\n    \n    return backtrack(list(range(n)), k, 0)\n\ndef g(n=4, k=2):\n    \"\"\"Generate a list of n distinct integers.\"\"\"\n    return [i for i in range(n)]\n\nassert f(g())\n", "emb": null, "idx_generation": 478, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine whether it is possible to arrange n distinct integers in a circle such that the absolute difference\n    between each pair of adjacent integers is divisible by k.\"\"\"\n    def count_valid_permutations(arr, k):\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] % k == 0 or k % arr[i] == 0:\n                count += 1\n        return count\n    \n    def backtrack(arr, k, idx):\n        if idx == len(arr):\n            return count_valid_permutations(arr, k) == len(arr)\n        \n        for i in range(idx, len(arr)):\n            arr[idx], arr[i] = arr[i], arr[idx]\n            if backtrack(arr, k, idx+1):\n                return True\n            arr[idx], arr[i] = arr[i], arr[idx]\n        \n        return False\n    \n    return backtrack(list(range(n)), k, 0)", "solution_func": "def g(n=4, k=2):\n    \"\"\"Generate a list of n distinct integers.\"\"\"\n    return [i for i in range(n)]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine whether it is possible to arrange n distinct integers in a circle such that the absolute difference\n    between each pair of adjacent integers is divisible by k.\"\"\"\n    def count_valid_permutations(arr, k):\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] % k == 0 or k % arr[i] == 0:\n                count += 1\n        return count\n    \n    def dp(arr, k):\n        dp = [[False] * (n+1) for _ in range(n+1)]\n        dp[0][0] = True\n        \n        for i in range(1, n+1):\n            for j in range(1, i+1):\n                if arr[i-1] % k == 0 or k % arr[i-1] == 0:\n                    dp[i][j] |= dp[i-1][j-1]\n                dp[i][j] |= dp[i-1][j]\n        \n        return dp[n][n] == True\n    \n    return dp(list(range(n)), k)\n\ndef g(n=4, k=2):\n    \"\"\"Generate a list of n distinct integers.\"\"\"\n    return [i for i in range(n)]\n\nassert f(g())\n", "emb": null, "idx_generation": 478, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> bool:\n    \"\"\"Determine whether it is possible to arrange n distinct integers in a circle such that the absolute difference\n    between each pair of adjacent integers is divisible by k.\"\"\"\n    def count_valid_permutations(arr, k):\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] % k == 0 or k % arr[i] == 0:\n                count += 1\n        return count\n    \n    def dp(arr, k):\n        dp = [[False] * (n+1) for _ in range(n+1)]\n        dp[0][0] = True\n        \n        for i in range(1, n+1):\n            for j in range(1, i+1):\n                if arr[i-1] % k == 0 or k % arr[i-1] == 0:\n                    dp[i][j] |= dp[i-1][j-1]\n                dp[i][j] |= dp[i-1][j]\n        \n        return dp[n][n] == True\n    \n    return dp(list(range(n)), k)", "solution_func": "def g(n=4, k=2):\n    \"\"\"Generate a list of n distinct integers.\"\"\"\n    return [i for i in range(n)]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> Tuple[List[int], int]:\n    return [1, 3, 5, 7, 9, 11, 13], 7\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    return [1, 3, 5, 7, 9, 11, 13], 7", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique permutations of the digits of n.\n    \"\"\"\n    digits = list(str(n))\n    counts = [0] * 10\n    for digit in digits:\n        counts[int(digit)] += 1\n\n    total_permutations = factorial(len(digits))\n    for count in counts:\n        if count > 1:\n            total_permutations //= factorial(count)\n\n    return total_permutations\n\ndef factorial(n: int) -> int:\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef g() -> int:\n    return 1122\n\nassert f(g()) == 6\n", "emb": [0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, return the number of unique permutations of the digits of n.\n    \"\"\"\n    digits = list(str(n))\n    counts = [0] * 10\n    for digit in digits:\n        counts[int(digit)] += 1\n\n    total_permutations = factorial(len(digits))\n    for count in counts:\n        if count > 1:\n            total_permutations //= factorial(count)\n\n    return total_permutations\n\ndef factorial(n: int) -> int:\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result", "solution_func": "def g() -> int:\n    return 1122", "map_ix": [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    queue = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            queue.append(i)\n    if queue:\n        return queue.pop(0)\n    else:\n        return -1\n\ndef g() -> Tuple[List[int], int]:\n    return [4, 2, 8, 6, 3, 9, 1], 6\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 478, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, return the index of the target value in the list.\n    If the target value is not found in the list, return -1.\n    \"\"\"\n    queue = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            queue.append(i)\n    if queue:\n        return queue.pop(0)\n    else:\n        return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    return [4, 2, 8, 6, 3, 9, 1], 6", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, find the k most frequent words in the list.\n    Return the words in a list sorted by their frequency, with the most frequent word at the beginning.\n\n    Example:\n    Input: words = [\"cat\", \"cat\", \"dog\", \"dog\", \"dog\", \"mouse\"], k = 2\n    Output: [\"dog\", \"cat\"]\n\n    Explanation:\n    The word \"dog\" appears 3 times, which is the most frequent word.\n    The word \"cat\" appears 2 times, which is the second most frequent word.\n    Therefore, the output is [\"dog\", \"cat\"].\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    return sorted_words[:k]\n\ndef g() -> Tuple[List[str], int]:\n    \"\"\"\n    Generate a list of words and an integer k, where the k most frequent words can be found in the list.\n    \"\"\"\n    return ([\"cat\", \"cat\", \"dog\", \"dog\", \"dog\", \"mouse\"], 2)\n\nassert f(*g()) == [\"dog\", \"cat\"]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 478, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(words: List[str], k: int) -> List[str]:\n    \"\"\"\n    Given a list of words and an integer k, find the k most frequent words in the list.\n    Return the words in a list sorted by their frequency, with the most frequent word at the beginning.\n\n    Example:\n    Input: words = [\"cat\", \"cat\", \"dog\", \"dog\", \"dog\", \"mouse\"], k = 2\n    Output: [\"dog\", \"cat\"]\n\n    Explanation:\n    The word \"dog\" appears 3 times, which is the most frequent word.\n    The word \"cat\" appears 2 times, which is the second most frequent word.\n    Therefore, the output is [\"dog\", \"cat\"].\n    \"\"\"\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    sorted_words = sorted(word_count.keys(), key=lambda x: (-word_count[x], x))\n    return sorted_words[:k]", "solution_func": "def g() -> Tuple[List[str], int]:\n    \"\"\"\n    Generate a list of words and an integer k, where the k most frequent words can be found in the list.\n    \"\"\"\n    return ([\"cat\", \"cat\", \"dog\", \"dog\", \"dog\", \"mouse\"], 2)", "map_ix": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a subarray.\n\n    Sample Input:\n    nums = [1, -2, 3, -4, 5]\n\n    Sample Output:\n    6\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    return [1, -2, 3, -4, 5]\n\nassert f(g()) == 6\n", "emb": null, "idx_generation": 479, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a subarray.\n\n    Sample Input:\n    nums = [1, -2, 3, -4, 5]\n\n    Sample Output:\n    6\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    return [1, -2, 3, -4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the product of all the numbers except the current number at each index.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    [24, 12, 8, 6]\n    \"\"\"\n    n = len(nums)\n    products = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        products[i] *= left_product\n        left_product *= nums[i]\n\n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        products[i] *= right_product\n        right_product *= nums[i]\n\n    return products\n\ndef g():\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the product of all the numbers except the current number at each index.\n\n    Sample Input:\n    nums = [1, 2, 3, 4]\n\n    Sample Output:\n    [24, 12, 8, 6]\n    \"\"\"\n    n = len(nums)\n    products = [1] * n\n\n    left_product = 1\n    for i in range(n):\n        products[i] *= left_product\n        left_product *= nums[i]\n\n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        products[i] *= right_product\n        right_product *= nums[i]\n\n    return products", "solution_func": "def g():\n    return [1, 2, 3, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the count of pairs whose sum is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    7\n    \"\"\"\n    count = 0\n    remainder_counts = [0] * 3\n\n    for num in nums:\n        remainder = num % 3\n        remainder_counts[remainder] += 1\n\n    count += (remainder_counts[0] * (remainder_counts[0] - 1)) // 2  # count pairs with remainder 0\n    count += remainder_counts[1] * remainder_counts[2]  # count pairs with remainders 1 and 2\n\n    return count\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 479, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the count of pairs whose sum is divisible by 3.\n\n    Sample Input:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    Sample Output:\n    7\n    \"\"\"\n    count = 0\n    remainder_counts = [0] * 3\n\n    for num in nums:\n        remainder = num % 3\n        remainder_counts[remainder] += 1\n\n    count += (remainder_counts[0] * (remainder_counts[0] - 1)) // 2  # count pairs with remainder 0\n    count += remainder_counts[1] * remainder_counts[2]  # count pairs with remainders 1 and 2\n\n    return count", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, return True if there is a cycle in the graph, and False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    Output: True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False\n\ndef g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 479, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given a directed graph represented as an adjacency matrix, return True if there is a cycle in the graph, and False otherwise.\n\n    Example:\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    Output: True\n\n    Explanation:\n    The graph has a cycle: 0 -> 1 -> 2 -> 3 -> 0\n    \"\"\"\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1:\n                if not visited[neighbor]:\n                    if dfs(neighbor, visited, stack):\n                        return True\n                elif stack[neighbor]:\n                    return True\n\n        stack[node] = False\n        return False\n\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            if dfs(node, visited, stack):\n                return True\n\n    return False", "solution_func": "def g():\n    graph = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [1, 0, 0, 0]\n    ]\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall, return the minimum number of steps required to reach from the top-left corner to the bottom-right corner, considering only right and down movements. If it is not possible to reach the destination, return -1.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    Output: 5\n\n    Explanation:\n    The minimum number of steps required is 5: (0,0) -> (1,0) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (3,3)\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                continue\n\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n\n    return dp[rows-1][cols-1] if dp[rows-1][cols-1] != float('inf') else -1\n\ndef g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    return grid\n\nassert f(g()) == 5\n", "emb": null, "idx_generation": 479, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of 0s and 1s, where 0 represents an empty cell and 1 represents a wall, return the minimum number of steps required to reach from the top-left corner to the bottom-right corner, considering only right and down movements. If it is not possible to reach the destination, return -1.\n\n    Example:\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    Output: 5\n\n    Explanation:\n    The minimum number of steps required is 5: (0,0) -> (1,0) -> (1,1) -> (2,1) -> (3,1) -> (3,2) -> (3,3)\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                continue\n\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n\n    return dp[rows-1][cols-1] if dp[rows-1][cols-1] != float('inf') else -1", "solution_func": "def g():\n    grid = [\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [1, 0, 0, 1],\n        [0, 1, 0, 0]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest common prefix among them.\n\n    Example:\n    words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation:\n    The longest common prefix among the words is \"fl\".\n    \"\"\"\n    def common_prefix(str1, str2):\n        prefix = ''\n        i = 0\n\n        while i < len(str1) and i < len(str2) and str1[i] == str2[i]:\n            prefix += str1[i]\n            i += 1\n\n        return prefix\n\n    if not words:\n        return ''\n\n    prefix = words[0]\n\n    for i in range(1, len(words)):\n        prefix = common_prefix(prefix, words[i])\n\n        if not prefix:\n            return ''\n\n    return prefix\n\ndef g():\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words\n\nassert f(g()) == \"fl\"\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return the longest common prefix among them.\n\n    Example:\n    words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation:\n    The longest common prefix among the words is \"fl\".\n    \"\"\"\n    def common_prefix(str1, str2):\n        prefix = ''\n        i = 0\n\n        while i < len(str1) and i < len(str2) and str1[i] == str2[i]:\n            prefix += str1[i]\n            i += 1\n\n        return prefix\n\n    if not words:\n        return ''\n\n    prefix = words[0]\n\n    for i in range(1, len(words)):\n        prefix = common_prefix(prefix, words[i])\n\n        if not prefix:\n            return ''\n\n    return prefix", "solution_func": "def g():\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n\n    The function should return 20 since the maximum product is 4 * 5 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5]\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n\n    Example:\n    nums = [2, 3, 4, 5]\n\n    The function should return 20 since the maximum product is 4 * 5 = 20.\n    \"\"\"\n    nums.sort()\n    return nums[-1] * nums[-2]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [2, 3, 4, 5]", "map_ix": [1, 0, 0, 1, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list.\n\n    Example:\n    nums = [1, 2, 2, 3, 3, 3, 4, 5]\n    target = 3\n\n    The function should return 3 since the target value 3 appears 3 times in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n            i = mid + 1\n            while i < len(nums) and nums[i] == target:\n                count += 1\n                i += 1\n            return count\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return 0\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 2, 3, 3, 3, 4, 5]\n\nassert f(g(), 3) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the number of occurrences of the target value in the list.\n\n    Example:\n    nums = [1, 2, 2, 3, 3, 3, 4, 5]\n    target = 3\n\n    The function should return 3 since the target value 3 appears 3 times in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            count = 1\n            i = mid - 1\n            while i >= 0 and nums[i] == target:\n                count += 1\n                i -= 1\n            i = mid + 1\n            while i < len(nums) and nums[i] == target:\n                count += 1\n                i += 1\n            return count\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return 0", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 2, 2, 3, 3, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two sorted lists of integers, return a new sorted list that contains all the elements from both lists,\n    in ascending order.\n\n    Example:\n    nums1 = [1, 3, 5, 7]\n    nums2 = [2, 4, 6, 8]\n\n    The function should return [1, 2, 3, 4, 5, 6, 7, 8].\n    \"\"\"\n    merged = []\n    i, j = 0, 0\n\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n\n    while i < len(nums1):\n        merged.append(nums1[i])\n        i += 1\n\n    while j < len(nums2):\n        merged.append(nums2[j])\n        j += 1\n\n    return merged\n\ndef g() -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Generate two sorted lists of integers.\n    \"\"\"\n    return ([1, 3, 5, 7], [2, 4, 6, 8])\n\nassert f(*g()) == [1, 2, 3, 4, 5, 6, 7, 8]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums1: List[int], nums2: List[int]) -> List[int]:\n    \"\"\"\n    Given two sorted lists of integers, return a new sorted list that contains all the elements from both lists,\n    in ascending order.\n\n    Example:\n    nums1 = [1, 3, 5, 7]\n    nums2 = [2, 4, 6, 8]\n\n    The function should return [1, 2, 3, 4, 5, 6, 7, 8].\n    \"\"\"\n    merged = []\n    i, j = 0, 0\n\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            merged.append(nums1[i])\n            i += 1\n        else:\n            merged.append(nums2[j])\n            j += 1\n\n    while i < len(nums1):\n        merged.append(nums1[i])\n        i += 1\n\n    while j < len(nums2):\n        merged.append(nums2[j])\n        j += 1\n\n    return merged", "solution_func": "def g() -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Generate two sorted lists of integers.\n    \"\"\"\n    return ([1, 3, 5, 7], [2, 4, 6, 8])", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value of any two elements is required.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 479, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by XORing 5 and 25, which gives 28.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        target_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ target_xor) in prefixes:\n                max_xor = target_xor\n                break\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers where the maximum XOR value of any two elements is required.\n    \"\"\"\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all substrings of s of length k.\n\n    Example:\n    s = \"abcde\"\n    k = 3\n\n    Output:\n    [\"abc\", \"bcd\", \"cde\"]\n    \"\"\"\n    substrings = []\n    for i in range(len(s) - k + 1):\n        substrings.append(s[i:i+k])\n    return substrings\n\ndef g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer k.\n    \"\"\"\n    s = \"abcde\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"abc\", \"bcd\", \"cde\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, return a list of all substrings of s of length k.\n\n    Example:\n    s = \"abcde\"\n    k = 3\n\n    Output:\n    [\"abc\", \"bcd\", \"cde\"]\n    \"\"\"\n    substrings = []\n    for i in range(len(s) - k + 1):\n        substrings.append(s[i:i+k])\n    return substrings", "solution_func": "def g() -> Tuple[str, int]:\n    \"\"\"\n    Generate a string s and an integer k.\n    \"\"\"\n    s = \"abcde\"\n    k = 3\n    return s, k", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine the area of the largest square containing only 1s.\n\n    Example:\n    grid = [\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1]\n    ]\n\n    The function should return 9, as the largest square containing only 1s has an area of 9.\n\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_side = 0\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    grid = [\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1]\n    ]\n    return grid\n\nassert f(g()) == 9\n", "emb": null, "idx_generation": 480, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a 2D grid of 0s and 1s, determine the area of the largest square containing only 1s.\n\n    Example:\n    grid = [\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1]\n    ]\n\n    The function should return 9, as the largest square containing only 1s has an area of 9.\n\n    \"\"\"\n    if not grid:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n    max_side = 0\n\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(1, rows + 1):\n        for j in range(1, cols + 1):\n            if grid[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                max_side = max(max_side, dp[i][j])\n\n    return max_side * max_side", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a 2D grid of 0s and 1s.\n    \"\"\"\n    grid = [\n        [1, 0, 0, 1, 1],\n        [1, 1, 1, 1, 1],\n        [1, 1, 0, 0, 1],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are divisible by 3 or 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    The function should return 33, as 3 + 5 + 6 + 9 + 10 = 33.\n    \"\"\"\n    divisible_sum = 0\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            divisible_sum += num\n    return divisible_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 33\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all numbers that are divisible by 3 or 5.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    The function should return 33, as 3 + 5 + 6 + 9 + 10 = 33.\n    \"\"\"\n    divisible_sum = 0\n    for num in nums:\n        if num % 3 == 0 or num % 5 == 0:\n            divisible_sum += num\n    return divisible_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum absolute difference between any two elements in the list.\n\n    The maximum absolute difference is defined as the absolute value of the difference between two elements.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    The maximum absolute difference is |9 - 1| = 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    min_num = float('inf')\n    max_num = float('-inf')\n\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n\n    return abs(max_num - min_num)\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g()) == 8\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum absolute difference between any two elements in the list.\n\n    The maximum absolute difference is defined as the absolute value of the difference between two elements.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n\n    The maximum absolute difference is |9 - 1| = 8.\n\n    Therefore, the function should return 8.\n    \"\"\"\n\n    min_num = float('inf')\n    max_num = float('-inf')\n\n    for num in nums:\n        min_num = min(min_num, num)\n        max_num = max(max_num, num)\n\n    return abs(max_num - min_num)", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers\n    in the original list except for the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the numbers in the original list except for 1 is 2 * 3 * 4 = 24.\n    The product of all the numbers in the original list except for 2 is 1 * 3 * 4 = 12.\n    The product of all the numbers in the original list except for 3 is 1 * 2 * 4 = 8.\n    The product of all the numbers in the original list except for 4 is 1 * 2 * 3 = 6.\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n\n    n = len(nums)\n    product = 1\n    result = []\n\n    # Compute the product of all the numbers in the list\n    for num in nums:\n        product *= num\n\n    # Compute the product of all the numbers except for the corresponding element\n    for num in nums:\n        result.append(product // num)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]\n\nassert f(g()) == [24, 12, 8, 6]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the product of all the numbers\n    in the original list except for the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4]\n\n    The product of all the numbers in the original list except for 1 is 2 * 3 * 4 = 24.\n    The product of all the numbers in the original list except for 2 is 1 * 3 * 4 = 12.\n    The product of all the numbers in the original list except for 3 is 1 * 2 * 4 = 8.\n    The product of all the numbers in the original list except for 4 is 1 * 2 * 3 = 6.\n\n    Therefore, the function should return [24, 12, 8, 6].\n    \"\"\"\n\n    n = len(nums)\n    product = 1\n    result = []\n\n    # Compute the product of all the numbers in the list\n    for num in nums:\n        product *= num\n\n    # Compute the product of all the numbers except for the corresponding element\n    for num in nums:\n        result.append(product // num)\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    A subarray is a contiguous subsequence of the original list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 4 + (-1) + 2 + 1 = 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    A subarray is a contiguous subsequence of the original list.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum subarray sum is 4 + (-1) + 2 + 1 = 6.\n\n    Therefore, the function should return 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 1]\n    f(nums) => 4\n    Explanation: The subarray [2, 1] has the maximum sum of 4.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[-1]\n\n\ndef g():\n    return [1, 2, 3, 1]\n\n\nassert f(g()) == 4\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, 2, 3, 1]\n    f(nums) => 4\n    Explanation: The subarray [2, 1] has the maximum sum of 4.\n\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n\n    return dp[-1]", "solution_func": "def g():\n    return [1, 2, 3, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix filled with integers, return the values of the matrix in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(matrix) => [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\ndef g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n\nassert f(g()) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 480, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix filled with integers, return the values of the matrix in a clockwise spiral order.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    f(matrix) => [1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n    \"\"\"\n\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    top = 0\n    bottom = rows - 1\n    left = 0\n    right = cols - 1\n\n    while top <= bottom and left <= right:\n        # Traverse top row\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n\n        # Traverse right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # Traverse bottom row\n        if top <= bottom:\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n\n        # Traverse left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result", "solution_func": "def g():\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [1, 0, 0, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the string word by word.\n\n    Example:\n    s = \"the sky is blue\"\n    f(s) => \"blue is sky the\"\n\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n\n\ndef g():\n    return \"the sky is blue\"\n\n\nassert f(g()) == \"blue is sky the\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, reverse the string word by word.\n\n    Example:\n    s = \"the sky is blue\"\n    f(s) => \"blue is sky the\"\n\n    \"\"\"\n\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)", "solution_func": "def g():\n    return \"the sky is blue\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True\n    Explanation: The numbers 2 and 7 add up to 9.\n\n    Input: nums = [2, 7, 11, 15], target = 10\n    Output: False\n    Explanation: There are no two numbers in the list that add up to 10.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 12\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 480, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, determine if there are two numbers in the list that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: True\n    Explanation: The numbers 2 and 7 add up to 9.\n\n    Input: nums = [2, 7, 11, 15], target = 10\n    Output: False\n    Explanation: There are no two numbers in the list that add up to 10.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 12", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise AND is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] & arr[j] == n:\n                return True\n    return False\n\ndef g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise AND equal to n.\n    \"\"\"\n    for i in range(1, 100):\n        if i & (i+1) == 0:\n            arr.append(i)\n            arr.append(i+1)\n            return i\n    return 0\n\nassert f(g([])) == True\n", "emb": null, "idx_generation": 481, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise AND is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] & arr[j] == n:\n                return True\n    return False", "solution_func": "def g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise AND equal to n.\n    \"\"\"\n    for i in range(1, 100):\n        if i & (i+1) == 0:\n            arr.append(i)\n            arr.append(i+1)\n            return i\n    return 0", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise XOR is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == n:\n                return True\n    return False\n\ndef g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise XOR equal to n.\n    \"\"\"\n    arr.append(n)\n    arr.append(n+1)\n    return n\n\nn = 5\nassert f(g([]), [1, 2, 3, 4]) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise XOR is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == n:\n                return True\n    return False", "solution_func": "def g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise XOR equal to n.\n    \"\"\"\n    arr.append(n)\n    arr.append(n+1)\n    return n\n\nn = 5", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise OR is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] | arr[j] == n:\n                return True\n    return False\n\ndef g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise OR equal to n.\n    \"\"\"\n    arr.append(n)\n    arr.append(n+1)\n    return n\n\nn = 9\nassert f(g([]), [2, 3, 4, 5]) == True\n", "emb": null, "idx_generation": 481, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, arr: List[int]) -> bool:\n    \"\"\"\n    Check if there exists a pair of elements in the array such that their bitwise OR is equal to n.\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] | arr[j] == n:\n                return True\n    return False", "solution_func": "def g(arr: List[int]) -> int:\n    \"\"\"\n    Generate an array with elements such that there exists a pair with bitwise OR equal to n.\n    \"\"\"\n    arr.append(n)\n    arr.append(n+1)\n    return n\n\nn = 9", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value can be obtained by XORing the elements 5 and 25: 5 XOR 25 = 28.\n\n    Hint: Use the property of XOR operation to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value can be obtained by XORing the elements 5 and 25: 5 XOR 25 = 28.\n\n    Hint: Use the property of XOR operation to find the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    Input: n = 11\n    Output: 3\n    Explanation: The binary representation of 11 is \"1011\", which contains 3 1 bits.\n\n    Hint: Use bitwise operations to count the number of 1 bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef g(n: int = 11) -> int:\n    return n\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    Input: n = 11\n    Output: 3\n    Explanation: The binary representation of 11 is \"1011\", which contains 3 1 bits.\n\n    Hint: Use bitwise operations to count the number of 1 bits.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "solution_func": "def g(n: int = 11) -> int:\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"abca\"\n    Output: True\n    Explanation: By removing the character 'b', the string becomes \"aca\", which is a palindrome.\n\n    Hint: Use a two-pointer approach to check if the string is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    \n    return True\n\ndef g() -> str:\n    return \"abca\"\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 481, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, check if it is a palindrome after removing at most one character.\n\n    Example:\n    Input: \"abca\"\n    Output: True\n    Explanation: By removing the character 'b', the string becomes \"aca\", which is a palindrome.\n\n    Hint: Use a two-pointer approach to check if the string is a palindrome after removing at most one character.\n    \"\"\"\n    def is_palindrome(s: str, left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n    \n    left = 0\n    right = len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s, left+1, right) or is_palindrome(s, left, right-1)\n        left += 1\n        right -= 1\n    \n    return True", "solution_func": "def g() -> str:\n    return \"abca\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the sum of all the numbers that are divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 18\n    Explanation: The numbers divisible by 3 are 3, 6, and 9. The sum of these numbers is 18.\n    \"\"\"\n\n    def helper(nums, index, current_sum):\n        if index == len(nums):\n            if current_sum % 3 == 0:\n                return current_sum\n            else:\n                return 0\n\n        # Exclude the number at the current index\n        exclude_sum = helper(nums, index + 1, current_sum)\n\n        # Include the number at the current index\n        include_sum = helper(nums, index + 1, current_sum + nums[index])\n\n        return max(exclude_sum, include_sum)\n\n    return helper(nums, 0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums\n\nassert f(g()) == 18\n\n", "emb": null, "idx_generation": 481, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the sum of all the numbers that are divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    Output: 18\n    Explanation: The numbers divisible by 3 are 3, 6, and 9. The sum of these numbers is 18.\n    \"\"\"\n\n    def helper(nums, index, current_sum):\n        if index == len(nums):\n            if current_sum % 3 == 0:\n                return current_sum\n            else:\n                return 0\n\n        # Exclude the number at the current index\n        exclude_sum = helper(nums, index + 1, current_sum)\n\n        # Include the number at the current index\n        include_sum = helper(nums, index + 1, current_sum + nums[index])\n\n        return max(exclude_sum, include_sum)\n\n    return helper(nums, 0, 0)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray with the maximum sum is [4, -1, 2, 1], and its sum is 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the maximum sum of a subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray with the maximum sum is [4, -1, 2, 1], and its sum is 6.\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers 'nums', find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, find two distinct numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    The function should return True since 4 + 10 = 14.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value such that there exists two distinct numbers in the list whose sum is equal to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [2, 4, 6, 8, 10]\ntarget = 14\nassert f(*g(nums, target)) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 481, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, find two distinct numbers in the list such that their sum is equal to the target.\n    Return True if such a pair exists, and False otherwise.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    target = 14\n\n    The function should return True since 4 + 10 = 14.\n    \"\"\"\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers and a target value such that there exists two distinct numbers in the list whose sum is equal to the target.\n    \"\"\"\n    nums.sort()\n    return nums, target\n\n# Test case\nnums = [2, 4, 6, 8, 10]\ntarget = 14", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of an undirected graph, find the number of connected components in the graph.\n    A connected component is a subgraph in which there is a path between any two vertices.\n\n    Return the number of connected components in the graph.\n    \"\"\"\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor, visited)\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    count = 0\n    for node in range(num_nodes):\n        if not visited[node]:\n            dfs(node, visited)\n            count += 1\n    \n    return count\n\ndef g(graph: List[List[int]]):\n    return graph\n\nassert f(g([[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]])) == 2\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 482, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representation of an undirected graph, find the number of connected components in the graph.\n    A connected component is a subgraph in which there is a path between any two vertices.\n\n    Return the number of connected components in the graph.\n    \"\"\"\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and not visited[neighbor]:\n                dfs(neighbor, visited)\n    \n    num_nodes = len(graph)\n    visited = [False] * num_nodes\n    count = 0\n    for node in range(num_nodes):\n        if not visited[node]:\n            dfs(node, visited)\n            count += 1\n    \n    return count", "solution_func": "def g(graph: List[List[int]]):\n    return graph", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements in the array.\n\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        \n        potential_max = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ potential_max) in prefixes:\n                max_xor = potential_max\n                break\n    \n    return max_xor\n\ndef g(nums: List[int]):\n    return nums\n\nassert f(g([3, 10, 5, 25, 2, 8])) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum XOR value of any two elements in the array.\n\n    Return the maximum XOR value.\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n        \n        potential_max = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (prefix ^ potential_max) in prefixes:\n                max_xor = potential_max\n                break\n    \n    return max_xor", "solution_func": "def g(nums: List[int]):\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum sum of values along a path from the top-left cell to the bottom-right cell in a grid.\n    You can only move down or right. Each cell in the grid can only be visited once.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return grid[i][j]\n        if dp[i][j] != float('inf'):\n            return dp[i][j]\n\n        down_sum = float('inf')\n        right_sum = float('inf')\n\n        if i + 1 < rows:\n            down_sum = dfs(i + 1, j)\n        if j + 1 < cols:\n            right_sum = dfs(i, j + 1)\n\n        dp[i][j] = min(down_sum, right_sum) + grid[i][j]\n        return dp[i][j]\n\n    return dfs(0, 0)\n\ndef g(grid: List[List[int]]):\n    return grid\n\nassert f(g([[1, 3, 1], [1, 5, 1], [4, 2, 1]])) == 7\n", "emb": null, "idx_generation": 482, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Find the minimum sum of values along a path from the top-left cell to the bottom-right cell in a grid.\n    You can only move down or right. Each cell in the grid can only be visited once.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n\n    def dfs(i, j):\n        if i == rows - 1 and j == cols - 1:\n            return grid[i][j]\n        if dp[i][j] != float('inf'):\n            return dp[i][j]\n\n        down_sum = float('inf')\n        right_sum = float('inf')\n\n        if i + 1 < rows:\n            down_sum = dfs(i + 1, j)\n        if j + 1 < cols:\n            right_sum = dfs(i, j + 1)\n\n        dp[i][j] = min(down_sum, right_sum) + grid[i][j]\n        return dp[i][j]\n\n    return dfs(0, 0)", "solution_func": "def g(grid: List[List[int]]):\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find if there exists a subsequence of the list whose sum equals the target number.\n    Return True if such a subsequence exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n\n    # Create a 2D array to store the subproblem results\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    # Base cases\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 18\n\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target number, find if there exists a subsequence of the list whose sum equals the target number.\n    Return True if such a subsequence exists, otherwise return False.\n    \"\"\"\n    n = len(nums)\n\n    # Create a 2D array to store the subproblem results\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    # Base cases\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if j < nums[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n\n    return dp[n][target]", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    target = 18\n\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic subsequence of the string.\n    \"\"\"\n    n = len(string)\n\n    # Create a 2D array to store the subproblem results\n    dp = [[0] * n for _ in range(n)]\n\n    # Base cases\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the dp array\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if string[i] == string[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    # Reconstruct the longest palindromic subsequence\n    i, j = 0, n - 1\n    subsequence = \"\"\n    while i < j:\n        if string[i] == string[j]:\n            subsequence += string[i]\n            i += 1\n            j -= 1\n        elif dp[i][j] == dp[i + 1][j]:\n            i += 1\n        else:\n            j -= 1\n\n    if i == j:\n        subsequence += string[i]\n\n    return subsequence\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    string = \"babad\"\n\n    return string\n\nassert f(g()) == \"bab\"\n", "emb": null, "idx_generation": 482, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(string: str) -> str:\n    \"\"\"\n    Given a string, return the longest palindromic subsequence of the string.\n    \"\"\"\n    n = len(string)\n\n    # Create a 2D array to store the subproblem results\n    dp = [[0] * n for _ in range(n)]\n\n    # Base cases\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the dp array\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if string[i] == string[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    # Reconstruct the longest palindromic subsequence\n    i, j = 0, n - 1\n    subsequence = \"\"\n    while i < j:\n        if string[i] == string[j]:\n            subsequence += string[i]\n            i += 1\n            j -= 1\n        elif dp[i][j] == dp[i + 1][j]:\n            i += 1\n        else:\n            j -= 1\n\n    if i == j:\n        subsequence += string[i]\n\n    return subsequence", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    string = \"babad\"\n\n    return string", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the next greater element for each element in the list.\n    If there is no greater element, return -1.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n\n    for i in range(n):\n        while stack and nums[i] > nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [4, 2, 5, 7, 3, 1, 6]\n\n    return nums\n\nassert f(g()) == [5, 5, 7, -1, 6, 6, -1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 482, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return the next greater element for each element in the list.\n    If there is no greater element, return -1.\n    \"\"\"\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n\n    for i in range(n):\n        while stack and nums[i] > nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    nums = [4, 2, 5, 7, 3, 1, 6]\n\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n    Return the longest common prefix as a string.\n\n    Example:\n    Input: words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation: The longest common prefix among the given strings is \"fl\".\n    \"\"\"\n\n    if len(words) == 0:\n        return \"\"\n\n    prefix = words[0]\n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if prefix == \"\":\n                return \"\"\n    \n    return prefix\n\n\ndef g() -> List[str]:\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words\n\nassert f(g()) == \"fl\"\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among them.\n    Return the longest common prefix as a string.\n\n    Example:\n    Input: words = [\"flower\", \"flow\", \"flight\"]\n    Output: \"fl\"\n\n    Explanation: The longest common prefix among the given strings is \"fl\".\n    \"\"\"\n\n    if len(words) == 0:\n        return \"\"\n\n    prefix = words[0]\n    for word in words[1:]:\n        while word[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if prefix == \"\":\n                return \"\"\n    \n    return prefix", "solution_func": "def g() -> List[str]:\n    words = [\"flower\", \"flow\", \"flight\"]\n    return words", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value,\n    find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 6\n    Output: 2\n\n    Explanation: The target value 6 is found at index 2 in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 482, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers in ascending order and a target value,\n    find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 6\n    Output: 2\n\n    Explanation: The target value 6 is found at index 2 in the list.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 4, 6, 8, 10]\n    target = 6\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique paths from the top-left cell to the bottom-right cell of a grid of size n x n.\n    You can only move down or right.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation: There are 6 unique paths from the top-left cell to the bottom-right cell of a 3 x 3 grid.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]\n\n\ndef g() -> int:\n    n = 3\n    return n\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 482, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, calculate the number of unique paths from the top-left cell to the bottom-right cell of a grid of size n x n.\n    You can only move down or right.\n\n    Example:\n    Input: n = 3\n    Output: 6\n\n    Explanation: There are 6 unique paths from the top-left cell to the bottom-right cell of a 3 x 3 grid.\n    \"\"\"\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = 1\n        dp[0][i] = 1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[n-1][n-1]", "solution_func": "def g() -> int:\n    n = 3\n    return n", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target number, find the number of combinations from the array that add up to the target.\n    Each number in the array can be used multiple times.\n    \"\"\"\n    def helper(arr: List[int], target: int, memo: Dict[int, int]) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        count = 0\n        for num in arr:\n            count += helper(arr, target - num, memo)\n        \n        memo[target] = count\n        return count\n    \n    memo = {}\n    return helper(arr, target, memo)\n\ndef g() -> Tuple[List[int], int]:\n    return [2, 3, 5], 8\n\nassert f(*g()) == 14\n", "emb": null, "idx_generation": 482, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given an array of integers and a target number, find the number of combinations from the array that add up to the target.\n    Each number in the array can be used multiple times.\n    \"\"\"\n    def helper(arr: List[int], target: int, memo: Dict[int, int]) -> int:\n        if target == 0:\n            return 1\n        if target < 0:\n            return 0\n        if target in memo:\n            return memo[target]\n        \n        count = 0\n        for num in arr:\n            count += helper(arr, target - num, memo)\n        \n        memo[target] = count\n        return count\n    \n    memo = {}\n    return helper(arr, target, memo)", "solution_func": "def g() -> Tuple[List[int], int]:\n    return [2, 3, 5], 8", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list containing the strings in sorted order,\n    except group all the strings that begin with 'x' first.\n\n    Example:\n    Input: ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']\n    Output: ['xanadu', 'xyz', 'aardvark', 'apple', 'mix']\n\n    Explanation:\n    The strings that begin with 'x' are ['xanadu', 'xyz'].\n    The remaining strings are ['aardvark', 'apple', 'mix'].\n    Sorting the two groups separately and then combining them results in the output: \n    ['xanadu', 'xyz', 'aardvark', 'apple', 'mix'].\n    \"\"\"\n\n    x_words = sorted([word for word in words if word.startswith('x')])\n    other_words = sorted([word for word in words if not word.startswith('x')])\n\n    return x_words + other_words\n\ndef g() -> List[str]:\n    return ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']\n\nassert f(g()) == ['xanadu', 'xyz', 'aardvark', 'apple', 'mix']\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, return a new list containing the strings in sorted order,\n    except group all the strings that begin with 'x' first.\n\n    Example:\n    Input: ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']\n    Output: ['xanadu', 'xyz', 'aardvark', 'apple', 'mix']\n\n    Explanation:\n    The strings that begin with 'x' are ['xanadu', 'xyz'].\n    The remaining strings are ['aardvark', 'apple', 'mix'].\n    Sorting the two groups separately and then combining them results in the output: \n    ['xanadu', 'xyz', 'aardvark', 'apple', 'mix'].\n    \"\"\"\n\n    x_words = sorted([word for word in words if word.startswith('x')])\n    other_words = sorted([word for word in words if not word.startswith('x')])\n\n    return x_words + other_words", "solution_func": "def g() -> List[str]:\n    return ['mix', 'xyz', 'apple', 'xanadu', 'aardvark']", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible parentheses combinations with n pairs of parentheses.\n\n    Example:\n    Input: 3\n    Output: ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Explanation:\n    There are 5 possible combinations of parentheses pairs with 3 pairs of parentheses.\n    \"\"\"\n\n    def backtrack(s: str, left: int, right: int, result: List[str]) -> None:\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n\n        if left < n:\n            backtrack(s + '(', left + 1, right, result)\n        if right < left:\n            backtrack(s + ')', left, right + 1, result)\n\n    result = []\n    backtrack('', 0, 0, result)\n    return result\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible parentheses combinations with n pairs of parentheses.\n\n    Example:\n    Input: 3\n    Output: ['((()))', '(()())', '(())()', '()(())', '()()()']\n\n    Explanation:\n    There are 5 possible combinations of parentheses pairs with 3 pairs of parentheses.\n    \"\"\"\n\n    def backtrack(s: str, left: int, right: int, result: List[str]) -> None:\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n\n        if left < n:\n            backtrack(s + '(', left + 1, right, result)\n        if right < left:\n            backtrack(s + ')', left, right + 1, result)\n\n    result = []\n    backtrack('', 0, 0, result)\n    return result", "solution_func": "def g() -> int:\n    return 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all numbers that can be formed by starting at any cell\n    and moving either horizontally or vertically to a neighboring cell.\n\n    Example:\n    Input: [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 555\n\n    Explanation:\n    The possible numbers that can be formed are: 123, 124, 125, 126, 135, 145, 146, 156, 234, 235, 236, 245, 246, 256, 345, 346, 356, 456.\n    The sum of these numbers is 555.\n    \"\"\"\n\n    def dfs(i: int, j: int, num: int, visited: List[List[bool]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j]:\n            return 0\n\n        num = num * 10 + grid[i][j]\n        visited[i][j] = True\n\n        total = num + dfs(i + 1, j, num, visited) + dfs(i - 1, j, num, visited) + dfs(i, j + 1, num, visited) + dfs(i, j - 1, num, visited)\n\n        visited[i][j] = False\n\n        return total\n\n    total_sum = 0\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            total_sum += dfs(i, j, 0, visited)\n\n    return total_sum\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 555\n", "emb": null, "idx_generation": 483, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the sum of all numbers that can be formed by starting at any cell\n    and moving either horizontally or vertically to a neighboring cell.\n\n    Example:\n    Input: [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 555\n\n    Explanation:\n    The possible numbers that can be formed are: 123, 124, 125, 126, 135, 145, 146, 156, 234, 235, 236, 245, 246, 256, 345, 346, 356, 456.\n    The sum of these numbers is 555.\n    \"\"\"\n\n    def dfs(i: int, j: int, num: int, visited: List[List[bool]]) -> int:\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j]:\n            return 0\n\n        num = num * 10 + grid[i][j]\n        visited[i][j] = True\n\n        total = num + dfs(i + 1, j, num, visited) + dfs(i - 1, j, num, visited) + dfs(i, j + 1, num, visited) + dfs(i, j - 1, num, visited)\n\n        visited[i][j] = False\n\n        return total\n\n    total_sum = 0\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            total_sum += dfs(i, j, 0, visited)\n\n    return total_sum", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of valid parentheses strings of length 2*n.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: There are 5 valid parentheses strings of length 6: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\".\n\n    Note:\n    - A valid parentheses string is a string consisting of \"(\" and \")\" characters, such that every open parenthesis \"(\" has a matching closing parenthesis \")\".\n    - The length of the string is always an even number.\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    # Recursive function to generate valid parentheses strings\n    def generate_parentheses(left: int, right: int, s: str, result: List[str]):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            generate_parentheses(left - 1, right, s + '(', result)\n        if right > left:\n            generate_parentheses(left, right - 1, s + ')', result)\n\n    # Generate all valid parentheses strings of length 2*n\n    valid_parentheses = []\n    generate_parentheses(n, n, '', valid_parentheses)\n\n    return len(valid_parentheses) % (10**9 + 7)\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 5\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of valid parentheses strings of length 2*n.\n\n    Example:\n    Input: n = 3\n    Output: 5\n\n    Explanation: There are 5 valid parentheses strings of length 6: \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\".\n\n    Note:\n    - A valid parentheses string is a string consisting of \"(\" and \")\" characters, such that every open parenthesis \"(\" has a matching closing parenthesis \")\".\n    - The length of the string is always an even number.\n    - The answer may be large, so return it modulo 10^9 + 7.\n    \"\"\"\n\n    # Recursive function to generate valid parentheses strings\n    def generate_parentheses(left: int, right: int, s: str, result: List[str]):\n        if left == 0 and right == 0:\n            result.append(s)\n            return\n        if left > 0:\n            generate_parentheses(left - 1, right, s + '(', result)\n        if right > left:\n            generate_parentheses(left, right - 1, s + ')', result)\n\n    # Generate all valid parentheses strings of length 2*n\n    valid_parentheses = []\n    generate_parentheses(n, n, '', valid_parentheses)\n\n    return len(valid_parentheses) % (10**9 + 7)", "solution_func": "def g() -> int:\n    return 3", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct permutations of the digits 1 to n where no digit is at its original position.\n\n    Example:\n    Input: n = 3\n    Output: 2\n\n    Explanation: There are 2 distinct permutations of the digits 1 to 3 where no digit is at its original position: (2,3,1) and (3,1,2).\n\n    Note:\n    - The input number n will be at most 9.\n    \"\"\"\n\n    # Recursive function to generate permutations\n    def generate_permutations(nums: List[int], permutation: List[int], used: List[bool], result: List[List[int]]):\n        if len(permutation) == len(nums):\n            result.append(permutation[:])\n            return\n        for i in range(len(nums)):\n            if not used[i]:\n                if nums[i] != i + 1:\n                    permutation.append(nums[i])\n                    used[i] = True\n                    generate_permutations(nums, permutation, used, result)\n                    permutation.pop()\n                    used[i] = False\n\n    # Generate all permutations and count the ones where no digit is at its original position\n    nums = list(range(1, n + 1))\n    permutations = []\n    generate_permutations(nums, [], [False] * n, permutations)\n\n    count = 0\n    for permutation in permutations:\n        if all(permutation[i] != i + 1 for i in range(len(permutation))):\n            count += 1\n\n    return count\n\ndef g() -> int:\n    return 3\n\nassert f(g()) == 2\n", "emb": null, "idx_generation": 483, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct permutations of the digits 1 to n where no digit is at its original position.\n\n    Example:\n    Input: n = 3\n    Output: 2\n\n    Explanation: There are 2 distinct permutations of the digits 1 to 3 where no digit is at its original position: (2,3,1) and (3,1,2).\n\n    Note:\n    - The input number n will be at most 9.\n    \"\"\"\n\n    # Recursive function to generate permutations\n    def generate_permutations(nums: List[int], permutation: List[int], used: List[bool], result: List[List[int]]):\n        if len(permutation) == len(nums):\n            result.append(permutation[:])\n            return\n        for i in range(len(nums)):\n            if not used[i]:\n                if nums[i] != i + 1:\n                    permutation.append(nums[i])\n                    used[i] = True\n                    generate_permutations(nums, permutation, used, result)\n                    permutation.pop()\n                    used[i] = False\n\n    # Generate all permutations and count the ones where no digit is at its original position\n    nums = list(range(1, n + 1))\n    permutations = []\n    generate_permutations(nums, [], [False] * n, permutations)\n\n    count = 0\n    for permutation in permutations:\n        if all(permutation[i] != i + 1 for i in range(len(permutation))):\n            count += 1\n\n    return count", "solution_func": "def g() -> int:\n    return 3", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase with n steps.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation: There are 5 distinct ways to climb to the top of a staircase with 4 steps: 1-1-1-1, 1-1-2, 1-2-1, 2-1-1, 2-2.\n\n    Note:\n    - You can climb either 1 or 2 steps at a time.\n    \"\"\"\n\n    # Recursive function to count distinct ways to climb the staircase\n    def count_ways(n: int, memo: List[int]) -> int:\n        if n == 0:\n            return 1\n        if n < 0:\n            return 0\n        if memo[n] != -1:\n            return memo[n]\n        memo[n] = count_ways(n - 1, memo) + count_ways(n - 2, memo)\n        return memo[n]\n\n    # Use memoization to count distinct ways\n    memo = [-1] * (n + 1)\n    return count_ways(n, memo)\n\ndef g() -> int:\n    return 4\n\nassert f(g()) == 5\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the number of distinct ways to climb to the top of a staircase with n steps.\n\n    Example:\n    Input: n = 4\n    Output: 5\n\n    Explanation: There are 5 distinct ways to climb to the top of a staircase with 4 steps: 1-1-1-1, 1-1-2, 1-2-1, 2-1-1, 2-2.\n\n    Note:\n    - You can climb either 1 or 2 steps at a time.\n    \"\"\"\n\n    # Recursive function to count distinct ways to climb the staircase\n    def count_ways(n: int, memo: List[int]) -> int:\n        if n == 0:\n            return 1\n        if n < 0:\n            return 0\n        if memo[n] != -1:\n            return memo[n]\n        memo[n] = count_ways(n - 1, memo) + count_ways(n - 2, memo)\n        return memo[n]\n\n    # Use memoization to count distinct ways\n    memo = [-1] * (n + 1)\n    return count_ways(n, memo)", "solution_func": "def g() -> int:\n    return 4", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] + nums[1] = 2 + 7 = 9, which is the target value.\n    Therefore, the indices of the two numbers are [0, 1].\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation:\n    The sum of nums[0] + nums[1] = 2 + 7 = 9, which is the target value.\n    Therefore, the indices of the two numbers are [0, 1].\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    return ([2, 7, 11, 15], 9)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    The XOR value is the result of applying the XOR operation (^) to two numbers.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by taking the XOR of 5 and 25, which gives a result of 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor\n\ndef g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value between any two numbers in the list.\n    The XOR value is the result of applying the XOR operation (^) to two numbers.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation:\n    The maximum XOR value is achieved by taking the XOR of 5 and 25, which gives a result of 28.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    return [3, 10, 5, 25, 2, 8]", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next smallest element for each element in the list.\n    If no such element exists, return -1.\n\n    Example:\n    Input: [4, 2, 9, 5, 1]\n    Output: [2, 1, 5, 1, -1]\n\n    Explanation:\n    The next smallest element for 4 is 2.\n    The next smallest element for 2 is 1.\n    The next smallest element for 9 is 5.\n    The next smallest element for 5 is 1.\n    There is no next smallest element for 1, so the value is -1.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] < nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result\n\ndef g() -> List[int]:\n    return [4, 2, 9, 5, 1]\n\nassert f(g()) == [2, 1, 5, 1, -1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 483, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the next smallest element for each element in the list.\n    If no such element exists, return -1.\n\n    Example:\n    Input: [4, 2, 9, 5, 1]\n    Output: [2, 1, 5, 1, -1]\n\n    Explanation:\n    The next smallest element for 4 is 2.\n    The next smallest element for 2 is 1.\n    The next smallest element for 9 is 5.\n    The next smallest element for 5 is 1.\n    There is no next smallest element for 1, so the value is -1.\n    \"\"\"\n\n    stack = []\n    result = [-1] * len(nums)\n\n    for i in range(len(nums)):\n        while stack and nums[i] < nums[stack[-1]]:\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n\n    return result", "solution_func": "def g() -> List[int]:\n    return [4, 2, 9, 5, 1]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return a list of the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n    The output should be [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n\n    Return the list of indices as the result.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 483, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find two numbers in the list that add up to the target.\n    Return a list of the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15], target = 9\n    The output should be [0, 1], since nums[0] + nums[1] = 2 + 7 = 9.\n\n    Return the list of indices as the result.\n    \"\"\"\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a list of integers and a target number.\n    \"\"\"\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7] since 2 + 7 = 9.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [2, 7]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted array of integers, find two numbers such that they add up to a specific target.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The function should return [2, 7] since 2 + 7 = 9.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise XOR value between any two numbers.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The function should return 28 since the maximum XOR value is between 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        current_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (current_xor ^ prefix) in prefixes:\n                max_xor = current_xor\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum bitwise XOR value between any two numbers.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    The function should return 28 since the maximum XOR value is between 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n        for num in nums:\n            prefixes.add(num & mask)\n\n        current_xor = max_xor | (1 << i)\n        for prefix in prefixes:\n            if (current_xor ^ prefix) in prefixes:\n                max_xor = current_xor\n                break\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7 (1 + 3 + 1 + 1 + 1).\n\n    Therefore, the function should return 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + grid[0][i]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid\n\nassert f(g()) == 7\n", "emb": [1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top left to the bottom right.\n\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7 (1 + 3 + 1 + 1 + 1).\n\n    Therefore, the function should return 7.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + grid[0][i]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    return grid", "map_ix": [1, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if it is possible to select exactly k numbers from the list whose sum is equal to the target.\n    \"\"\"\n    def count_combinations(arr: List[int], target: int, k: int, index: int, count: int, current_sum: int) -> bool:\n        if count == k:\n            return current_sum == target\n        if index >= len(arr) or current_sum > target:\n            return False\n        \n        # Select the current number\n        if count_combinations(arr, target, k, index+1, count+1, current_sum+arr[index]):\n            return True\n        \n        # Skip the current number\n        if count_combinations(arr, target, k, index+1, count, current_sum):\n            return True\n        \n        return False\n    \n    return count_combinations(arr, target, k, 0, 0, 0)\n\ndef g(arr: List[int], target: int, k: int) -> Tuple[List[int], int, int]:\n    \"\"\"\n    Generate a list of integers, a target integer, and k.\n    \"\"\"\n    return arr, target, k\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 484, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int, k: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target integer, determine if it is possible to select exactly k numbers from the list whose sum is equal to the target.\n    \"\"\"\n    def count_combinations(arr: List[int], target: int, k: int, index: int, count: int, current_sum: int) -> bool:\n        if count == k:\n            return current_sum == target\n        if index >= len(arr) or current_sum > target:\n            return False\n        \n        # Select the current number\n        if count_combinations(arr, target, k, index+1, count+1, current_sum+arr[index]):\n            return True\n        \n        # Skip the current number\n        if count_combinations(arr, target, k, index+1, count, current_sum):\n            return True\n        \n        return False\n    \n    return count_combinations(arr, target, k, 0, 0, 0)", "solution_func": "def g(arr: List[int], target: int, k: int) -> Tuple[List[int], int, int]:\n    \"\"\"\n    Generate a list of integers, a target integer, and k.\n    \"\"\"\n    return arr, target, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(graph: List[List[int]], visited: List[bool], current_node: int) -> bool:\n        if visited[current_node]:\n            return True\n        \n        visited[current_node] = True\n        for neighbor in range(len(graph[current_node])):\n            if graph[current_node][neighbor] == 1 and has_cycle(graph, visited, neighbor):\n                return True\n        \n        visited[current_node] = False\n        return False\n    \n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if has_cycle(graph, visited, node):\n            return True\n    \n    return False\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> bool:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine if there is a cycle in the graph.\n    \"\"\"\n    def has_cycle(graph: List[List[int]], visited: List[bool], current_node: int) -> bool:\n        if visited[current_node]:\n            return True\n        \n        visited[current_node] = True\n        for neighbor in range(len(graph[current_node])):\n            if graph[current_node][neighbor] == 1 and has_cycle(graph, visited, neighbor):\n                return True\n        \n        visited[current_node] = False\n        return False\n    \n    visited = [False] * len(graph)\n    for node in range(len(graph)):\n        if has_cycle(graph, visited, node):\n            return True\n    \n    return False", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate an adjacency matrix representing a directed graph.\n    \"\"\"\n    return [[0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]]", "map_ix": [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string and an integer, determine if it is possible to split the string into n equal parts such that each part is a palindrome.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    if len(s) % n != 0:\n        return False\n    \n    part_length = len(s) // n\n    for i in range(0, len(s), part_length):\n        if not is_palindrome(s[i:i+part_length]):\n            return False\n    \n    return True\n\ndef g(s: str, n: int) -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return s, n\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 484, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, n: int) -> bool:\n    \"\"\"\n    Given a string and an integer, determine if it is possible to split the string into n equal parts such that each part is a palindrome.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    if len(s) % n != 0:\n        return False\n    \n    part_length = len(s) // n\n    for i in range(0, len(s), part_length):\n        if not is_palindrome(s[i:i+part_length]):\n            return False\n    \n    return True", "solution_func": "def g(s: str, n: int) -> Tuple[str, int]:\n    \"\"\"\n    Generate a string and an integer.\n    \"\"\"\n    return s, n", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine if the target value is present in the list.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: True\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return False\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\ndef g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, use binary search to determine if the target value is present in the list.\n\n    You must write an algorithm with O(log n) runtime complexity.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 5\n    Output: True\n    \"\"\"\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return False\n        \n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)", "solution_func": "def g(arr=[1, 3, 5, 7, 9], target=5):\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    Input: 11\n    Output: 3\n    Explanation: The binary representation of 11 is \"1011\", which contains 3 ones.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count\n\ndef g(n=11):\n    return n\n\nassert f(g()) == 3\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of 1 bits in its binary representation.\n\n    Example:\n    Input: 11\n    Output: 3\n    Explanation: The binary representation of 11 is \"1011\", which contains 3 ones.\n    \"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n\n    return count", "solution_func": "def g(n=11):\n    return n", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: From the top-left corner, there are a total of 6 unique paths to the bottom-right corner.\n    \"\"\"\n    def unique_paths_helper(i, j, m, n, memo):\n        if i == m - 1 and j == n - 1:\n            return 1\n        if i >= m or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n\n        right = unique_paths_helper(i, j + 1, m, n, memo)\n        down = unique_paths_helper(i + 1, j, m, n, memo)\n        memo[i][j] = right + down\n\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, n, memo)\n\ndef g(n=3):\n    return n\n\nassert f(g()) == 6\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a non-negative integer n, return the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid.\n    You can only move either down or right at any point in time.\n\n    Example:\n    Input: 3\n    Output: 6\n    Explanation: From the top-left corner, there are a total of 6 unique paths to the bottom-right corner.\n    \"\"\"\n    def unique_paths_helper(i, j, m, n, memo):\n        if i == m - 1 and j == n - 1:\n            return 1\n        if i >= m or j >= n:\n            return 0\n        if memo[i][j] != -1:\n            return memo[i][j]\n\n        right = unique_paths_helper(i, j + 1, m, n, memo)\n        down = unique_paths_helper(i + 1, j, m, n, memo)\n        memo[i][j] = right + down\n\n        return memo[i][j]\n\n    memo = [[-1] * n for _ in range(n)]\n    return unique_paths_helper(0, 0, n, n, memo)", "solution_func": "def g(n=3):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given list.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\n\ndef g():\n    nums = [2, -3, 5, -2, 1, 7, -10]\n    return nums\n\nassert f(g()) == 11\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 484, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Find the maximum sum of a subarray in the given list.\n    Return the maximum sum.\n    \"\"\"\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum", "solution_func": "def g():\n    nums = [2, -3, 5, -2, 1, 7, -10]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)\n\nassert f(*g()) == [0, 1]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a target integer, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n    The function should return [0, 1] since nums[0] + nums[1] = 2 + 7 = 9.\n    \"\"\"\n\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return (nums, target)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, generate all possible subsets of the list.\n    Return a list of lists representing the subsets.\n\n    Example:\n    nums = [1, 2, 3]\n    The function should return [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]].\n    \"\"\"\n\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n\n    return subsets\n\ndef g():\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 485, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums, generate all possible subsets of the list.\n    Return a list of lists representing the subsets.\n\n    Example:\n    nums = [1, 2, 3]\n    The function should return [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]].\n    \"\"\"\n\n    subsets = [[]]\n    for num in nums:\n        subsets += [subset + [num] for subset in subsets]\n\n    return subsets", "solution_func": "def g():\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subsequence within the list.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, -2, 3, 10, -4, 7, 2, -5]\n    The function should return 18 since the maximum sum is obtained from the subsequence [3, 10, 7, 2].\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g():\n    nums = [1, -2, 3, 10, -4, 7, 2, -5]\n    return nums\n\nassert f(g()) == 18\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 485, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum sum of a subsequence within the list.\n    A subsequence is a sequence that can be derived from another sequence by deleting some or no elements\n    without changing the order of the remaining elements.\n    Return the maximum sum.\n\n    Example:\n    nums = [1, -2, 3, 10, -4, 7, 2, -5]\n    The function should return 18 since the maximum sum is obtained from the subsequence [3, 10, 7, 2].\n    \"\"\"\n\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g():\n    nums = [1, -2, 3, 10, -4, 7, 2, -5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all elements in the grid. Each element in the grid represents the height of a building.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    \"\"\"\n\n    total_sum = 0\n\n    for row in grid:\n        for element in row:\n            total_sum += element\n\n    return total_sum\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 45\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the sum of all elements in the grid. Each element in the grid represents the height of a building.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    45\n\n    \"\"\"\n\n    total_sum = 0\n\n    for row in grid:\n        for element in row:\n            total_sum += element\n\n    return total_sum", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum sum of a path from the top-left corner to the bottom-right corner. \n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 21\n\n", "emb": null, "idx_generation": 485, "target_skills": [0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the maximum sum of a path from the top-left corner to the bottom-right corner. \n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n    Explanation: The maximum sum path is 1 -> 4 -> 7 -> 8 -> 9.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the minimum sum of a path from the top-left corner to the bottom-right corner. \n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n    Explanation: The minimum sum path is 1 -> 2 -> 3 -> 6 -> 9.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid\n\nassert f(g()) == 21\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, return the minimum sum of a path from the top-left corner to the bottom-right corner. \n    You can only move down or right.\n\n    Example:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\n    Output:\n    21\n    Explanation: The minimum sum path is 1 -> 2 -> 3 -> 6 -> 9.\n\n    \"\"\"\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return grid", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 29\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 25 and 2, which is equal to 29.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 29\n", "emb": null, "idx_generation": 485, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 29\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 25 and 2, which is equal to 29.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum XOR value of any two numbers in the list that is greater than or equal to the target.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1], target = 6\n    Output: 3\n\n    Explanation: The minimum XOR value greater than or equal to 6 is obtained by taking the XOR of 4 and 5, which is equal to 3.\n    \"\"\"\n\n    min_xor = float('inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val >= target and xor_val < min_xor:\n                min_xor = xor_val\n\n    if min_xor == float('inf'):\n        return -1\n\n    return min_xor\n\ndef g() -> List[int]:\n    nums = [4, 7, 2, 9, 5, 1]\n    target = 6\n    return nums, target\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 485, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of integers and a target value, find the minimum XOR value of any two numbers in the list that is greater than or equal to the target.\n\n    Example:\n    Input: nums = [4, 7, 2, 9, 5, 1], target = 6\n    Output: 3\n\n    Explanation: The minimum XOR value greater than or equal to 6 is obtained by taking the XOR of 4 and 5, which is equal to 3.\n    \"\"\"\n\n    min_xor = float('inf')\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_val = nums[i] ^ nums[j]\n            if xor_val >= target and xor_val < min_xor:\n                min_xor = xor_val\n\n    if min_xor == float('inf'):\n        return -1\n\n    return min_xor", "solution_func": "def g() -> List[int]:\n    nums = [4, 7, 2, 9, 5, 1]\n    target = 6\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any three numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 31\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 25, 2, and 4, which is equal to 31.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                xor_val = nums[i] ^ nums[j] ^ nums[k]\n                if xor_val > max_xor:\n                    max_xor = xor_val\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 31\n", "emb": [1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum XOR value of any three numbers in the list.\n\n    Example:\n    Input: nums = [3, 10, 5, 25, 2, 8]\n    Output: 31\n\n    Explanation: The maximum XOR value is obtained by taking the XOR of 25, 2, and 4, which is equal to 31.\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            for k in range(j+1, len(nums)):\n                xor_val = nums[i] ^ nums[j] ^ nums[k]\n                if xor_val > max_xor:\n                    max_xor = xor_val\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a valid arithmetic progression.\n\n    An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    The difference between consecutive terms is 2, so this is a valid arithmetic progression.\n\n    Return True if the list is a valid arithmetic progression, False otherwise.\n    \"\"\"\n    if len(nums) < 2:\n        return True\n\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n\n    return True\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the arithmetic progression.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 485, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if it is a valid arithmetic progression.\n\n    An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant.\n\n    Example:\n    nums = [2, 4, 6, 8, 10]\n    The difference between consecutive terms is 2, so this is a valid arithmetic progression.\n\n    Return True if the list is a valid arithmetic progression, False otherwise.\n    \"\"\"\n    if len(nums) < 2:\n        return True\n\n    diff = nums[1] - nums[0]\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] != diff:\n            return False\n\n    return True", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers for the arithmetic progression.\n    \"\"\"\n    nums = [2, 4, 6, 8, 10]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is achieved by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n\n    return max_xor\n\ndef g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum bitwise XOR value between any two numbers in the list.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n\n    Explanation: The maximum XOR value is achieved by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    max_xor = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            xor_value = nums[i] ^ nums[j]\n            max_xor = max(max_xor, xor_value)\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    n = len(s)\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(n):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\ndef g() -> str:\n    s = \"abcabcbb\"\n    return s\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string s, return the length of the longest substring without repeating characters.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Explanation: The longest substring without repeating characters is \"abc\", which has a length of 3.\n    \"\"\"\n\n    n = len(s)\n    max_length = 0\n    start = 0\n    char_map = {}\n\n    for end in range(n):\n        if s[end] in char_map:\n            start = max(start, char_map[s[end]] + 1)\n\n        char_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length", "solution_func": "def g() -> str:\n    s = \"abcabcbb\"\n    return s", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The maximum subarray sum is achieved by the subarray [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum subarray sum.\n\n    Example:\n    Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n\n    Explanation: The maximum subarray sum is achieved by the subarray [4, -1, 2, 1], which has a sum of 6.\n    \"\"\"\n\n    n = len(nums)\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of the previous two elements in the original list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 2, 3, 4, 5, 7, 9, 12, 16, 21]\n\n    Input: nums = [1, 1, 1, 1, 1]\n    Output: [1, 1, 1, 1, 1, 2, 3, 5, 8, 13]\n    \"\"\"\n    result = nums.copy()\n    \n    for i in range(len(nums)-1):\n        result.append(nums[i] + nums[i+1])\n\n    return result\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5, 7, 9, 12, 16, 21]\n", "emb": null, "idx_generation": 486, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where each element is the sum of the previous two elements in the original list.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: [1, 2, 3, 4, 5, 7, 9, 12, 16, 21]\n\n    Input: nums = [1, 1, 1, 1, 1]\n    Output: [1, 1, 1, 1, 1, 2, 3, 5, 8, 13]\n    \"\"\"\n    result = nums.copy()\n    \n    for i in range(len(nums)-1):\n        result.append(nums[i] + nums[i+1])\n\n    return result", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n\n    Example:\n    Input: s = \"anagram\", t = \"nagaram\"\n    Output: True\n\n    Input: s = \"rat\", t = \"car\"\n    Output: False\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_count = [0] * 26\n\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n\n    for char in t:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n    \n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return \"anagram\", \"nagaram\"\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n\n    Example:\n    Input: s = \"anagram\", t = \"nagaram\"\n    Output: True\n\n    Input: s = \"rat\", t = \"car\"\n    Output: False\n    \"\"\"\n    if len(s) != len(t):\n        return False\n\n    char_count = [0] * 26\n\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n\n    for char in t:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n    \n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return \"anagram\", \"nagaram\"", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Input: nums = [1]\n    Output: 1\n    \"\"\"\n    curr_max = nums[0]\n    max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        curr_max = max(nums[i], curr_max + nums[i])\n        max_sum = max(max_sum, curr_max)\n\n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 486, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray.\n\n    Example:\n    Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n    Output: 6\n    Explanation: The subarray [4, -1, 2, 1] has the maximum sum of 6.\n\n    Input: nums = [1]\n    Output: 1\n    \"\"\"\n    curr_max = nums[0]\n    max_sum = nums[0]\n\n    for i in range(1, len(nums)):\n        curr_max = max(nums[i], curr_max + nums[i])\n        max_sum = max(max_sum, curr_max)\n\n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the product of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [2, 3] has a sum of 5, which is equal to the product of its elements (2 * 3 = 5).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    product = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        product ^= num\n\n        if prefix_sum - product in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the product of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [2, 3] has a sum of 5, which is equal to the product of its elements (2 * 3 = 5).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    product = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        product ^= num\n\n        if prefix_sum - product in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the XOR of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [1, 2, 3] has a sum of 6, which is equal to the XOR of its elements (1 ^ 2 ^ 3 = 6).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    xor_sum = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        xor_sum ^= num\n\n        if prefix_sum - xor_sum in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 486, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the XOR of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [1, 2, 3] has a sum of 6, which is equal to the XOR of its elements (1 ^ 2 ^ 3 = 6).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    xor_sum = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        xor_sum ^= num\n\n        if prefix_sum - xor_sum in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": [0, 0, 0, 1, 1, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the bitwise OR of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [3, 4] has a sum of 7, which is equal to the bitwise OR of its elements (3 | 4 = 7).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    or_sum = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        or_sum |= num\n\n        if prefix_sum - or_sum in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False\n\ndef g(nums=[1, 2, 3, 4, 5]):\n    return nums\n\nassert f(g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 486, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, check if there is a subarray with a sum equal to the bitwise OR of its elements.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The subarray [3, 4] has a sum of 7, which is equal to the bitwise OR of its elements (3 | 4 = 7).\n\n    Therefore, the function should return True.\n\n    Hint: Use a prefix sum and bitwise operations.\n    \"\"\"\n    prefix_sum = 0\n    or_sum = 0\n    prefix_sum_set = {0}\n\n    for num in nums:\n        prefix_sum += num\n        or_sum |= num\n\n        if prefix_sum - or_sum in prefix_sum_set:\n            return True\n\n        prefix_sum_set.add(prefix_sum)\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 4, 5]):\n    return nums", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two distinct numbers in nums.\n    Return the maximum XOR value.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max ^ prefix) in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for finding the maximum XOR value.\n    \"\"\"\n    return [2, 6, 9, 13, 15, 17, 19, 21, 23]\n\nassert f(g()) == 28\n", "emb": null, "idx_generation": 486, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the maximum XOR value between two distinct numbers in nums.\n    Return the maximum XOR value.\n\n    Example:\n    Input: [3, 10, 5, 25, 2, 8]\n    Output: 28\n    Explanation: The maximum XOR value is obtained by XORing 5 and 25 (5 XOR 25 = 28).\n    \"\"\"\n\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefix_set = set()\n\n        for num in nums:\n            prefix_set.add(num & mask)\n\n        temp_max = max_xor | (1 << i)\n\n        for prefix in prefix_set:\n            if (temp_max ^ prefix) in prefix_set:\n                max_xor = temp_max\n                break\n\n    return max_xor", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers for finding the maximum XOR value.\n    \"\"\"\n    return [2, 6, 9, 13, 15, 17, 19, 21, 23]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the first occurrence of the target in the list.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 2, 3, 3, 4, 4, 5, 6]\n    target = 3\n    return [nums, target]\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target value, find the first occurrence of the target in the list.\n    If the target is not found, return -1.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            if mid == 0 or nums[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 2, 3, 3, 4, 4, 5, 6]\n    target = 3\n    return [nums, target]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a positive integer k, rotate the list to the right by k steps.\n    \"\"\"\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    k = 2\n    return [nums, k]\n\nassert f(*g()) == [4, 5, 1, 2, 3]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Given a list of integers nums and a positive integer k, rotate the list to the right by k steps.\n    \"\"\"\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    k = 2\n    return [nums, k]", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence (LIS) in the list.\n    Return the LIS in ascending order.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)\n    lis = []\n    curr_length = max_length\n\n    for i in range(n - 1, -1, -1):\n        if dp[i] == curr_length:\n            lis.append(nums[i])\n            curr_length -= 1\n\n    lis.reverse()\n    return lis\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return [nums]\n\nassert f(*g()) == [2, 3, 7, 18]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, find the longest increasing subsequence (LIS) in the list.\n    Return the LIS in ascending order.\n    \"\"\"\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_length = max(dp)\n    lis = []\n    curr_length = max_length\n\n    for i in range(n - 1, -1, -1):\n        if dp[i] == curr_length:\n            lis.append(nums[i])\n            curr_length -= 1\n\n    lis.reverse()\n    return lis", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return [nums]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, split the string into k-sized chunks and return a list of the chunks.\n\n    Example:\n    Input:\n    s = \"abcdefghi\"\n    k = 3\n\n    Output:\n    [\"abc\", \"def\", \"ghi\"]\n    \"\"\"\n    chunks = []\n    for i in range(0, len(s), k):\n        chunk = s[i:i+k]\n        chunks.append(chunk)\n    return chunks\n\ndef g():\n    s = \"abcdefghi\"\n    k = 3\n    return s, k\n\nassert f(*g()) == [\"abc\", \"def\", \"ghi\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, k: int) -> List[str]:\n    \"\"\"\n    Given a string s and an integer k, split the string into k-sized chunks and return a list of the chunks.\n\n    Example:\n    Input:\n    s = \"abcdefghi\"\n    k = 3\n\n    Output:\n    [\"abc\", \"def\", \"ghi\"]\n    \"\"\"\n    chunks = []\n    for i in range(0, len(s), k):\n        chunk = s[i:i+k]\n        chunks.append(chunk)\n    return chunks", "solution_func": "def g():\n    s = \"abcdefghi\"\n    k = 3\n    return s, k", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a grid represented by a 2D list of integers and a target value,\n    return a new grid where all occurrences of the target value are replaced by 0.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n\n    Output:\n    [\n        [1, 2, 3],\n        [4, 0, 6],\n        [7, 8, 9]\n    ]\n    \"\"\"\n    new_grid = []\n    for row in grid:\n        new_row = []\n        for num in row:\n            if num == target:\n                new_row.append(0)\n            else:\n                new_row.append(num)\n        new_grid.append(new_row)\n    return new_grid\n\ndef g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target\n\nassert f(*g()) == [\n    [1, 2, 3],\n    [4, 0, 6],\n    [7, 8, 9]\n]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a grid represented by a 2D list of integers and a target value,\n    return a new grid where all occurrences of the target value are replaced by 0.\n\n    Example:\n    Input:\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n\n    Output:\n    [\n        [1, 2, 3],\n        [4, 0, 6],\n        [7, 8, 9]\n    ]\n    \"\"\"\n    new_grid = []\n    for row in grid:\n        new_row = []\n        for num in row:\n            if num == target:\n                new_row.append(0)\n            else:\n                new_row.append(num)\n        new_grid.append(new_row)\n    return new_grid", "solution_func": "def g():\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    target = 5\n    return grid, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a specific character.\n\n    Example:\n    Input:\n    grid = [\n        ['A', 'B', 'C'],\n        ['D', 'E', 'F'],\n        ['G', 'H', 'I']\n    ]\n    target = 'A'\n\n    Output: 1\n    \"\"\"\n    count = 0\n    for row in grid:\n        for char in row:\n            if char == target:\n                count += 1\n    return count\n\ndef g():\n    grid = [\n        ['A', 'B', 'C'],\n        ['D', 'E', 'F'],\n        ['G', 'H', 'I']\n    ]\n    return grid\n\nassert f(g()) == 1\n", "emb": null, "idx_generation": 487, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, count the number of occurrences of a specific character.\n\n    Example:\n    Input:\n    grid = [\n        ['A', 'B', 'C'],\n        ['D', 'E', 'F'],\n        ['G', 'H', 'I']\n    ]\n    target = 'A'\n\n    Output: 1\n    \"\"\"\n    count = 0\n    for row in grid:\n        for char in row:\n            if char == target:\n                count += 1\n    return count", "solution_func": "def g():\n    grid = [\n        ['A', 'B', 'C'],\n        ['D', 'E', 'F'],\n        ['G', 'H', 'I']\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product can be obtained by multiplying 4 and 5, which gives 20.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product\n\ndef g() -> List[int]:\n    return [1, 2, 3, 4, 5]\n\nassert f(g()) == 20\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any two distinct numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n    Output: 20\n    Explanation: The maximum product can be obtained by multiplying 4 and 5, which gives 20.\n    \"\"\"\n\n    max_product = float('-inf')\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            product = nums[i] * nums[j]\n            if product > max_product:\n                max_product = product\n\n    return max_product", "solution_func": "def g() -> List[int]:\n    return [1, 2, 3, 4, 5]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n    Explanation: The sum of all elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    total_sum = 0\n\n    for row in matrix:\n        for num in row:\n            total_sum += num\n\n    return total_sum\n\ndef g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n\nassert f(g()) == 45\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, return the sum of all elements in the matrix.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 45\n    Explanation: The sum of all elements in the matrix is 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45.\n    \"\"\"\n\n    total_sum = 0\n\n    for row in matrix:\n        for num in row:\n            total_sum += num\n\n    return total_sum", "solution_func": "def g() -> List[List[int]]:\n    return [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates from the list and return the modified list.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n\n    return unique_nums\n\ndef g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]\n\nassert f(g()) == [1, 2, 3, 4, 5]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, remove all duplicates from the list and return the modified list.\n\n    Example:\n    nums = [1, 2, 2, 3, 4, 4, 5]\n    Output: [1, 2, 3, 4, 5]\n    \"\"\"\n\n    unique_nums = []\n\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n\n    return unique_nums", "solution_func": "def g() -> List[int]:\n    return [1, 2, 2, 3, 4, 4, 5]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2 since the target number 5 is at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]\n\nassert f(g(), target=5) == 2\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 487, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list using binary search.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2 since the target number 5 is at index 2 in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a sorted list of integers.\n    \"\"\"\n    return [1, 3, 5, 7, 9]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers in the list that add up to the target.\n    Return a list of lists containing the combinations.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    \"\"\"\n\n    def backtrack(start, target, path, combinations):\n        if target == 0:\n            combinations.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(nums)):\n            backtrack(i, target - nums[i], path + [nums[i]], combinations)\n    \n    combinations = []\n    backtrack(0, target, [], combinations)\n    return combinations\n\ndef g() -> Tuple[List[int], int]:\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target\n\nassert f(*g()) == [[2, 2, 3], [7]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target number, find all combinations of numbers in the list that add up to the target.\n    Return a list of lists containing the combinations.\n\n    Example:\n    Input: nums = [2, 3, 6, 7], target = 7\n    Output: [[2, 2, 3], [7]]\n    \"\"\"\n\n    def backtrack(start, target, path, combinations):\n        if target == 0:\n            combinations.append(path)\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(nums)):\n            backtrack(i, target - nums[i], path + [nums[i]], combinations)\n    \n    combinations = []\n    backtrack(0, target, [], combinations)\n    return combinations", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [2, 3, 6, 7]\n    target = 7\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (a, b) such that a + b = target.\n    Return the count of unique pairs.\n\n    Example:\n    Input: nums = [1, 1, 2, 3, 4, 5], target = 6\n    Output: 3\n    Explanation: There are 3 unique pairs that add up to the target: (1, 5), (2, 4), (3, 3).\n    \"\"\"\n\n    count = 0\n    num_set = set()\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            count += 1\n        num_set.add(num)\n    \n    return count\n\ndef g() -> List[int]:\n    nums = [1, 1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 3\n", "emb": null, "idx_generation": 488, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique pairs (a, b) such that a + b = target.\n    Return the count of unique pairs.\n\n    Example:\n    Input: nums = [1, 1, 2, 3, 4, 5], target = 6\n    Output: 3\n    Explanation: There are 3 unique pairs that add up to the target: (1, 5), (2, 4), (3, 3).\n    \"\"\"\n\n    count = 0\n    num_set = set()\n    \n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            count += 1\n        num_set.add(num)\n    \n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the length of the longest increasing subsequence.\n    Return the length of the longest increasing subsequence.\n\n    Example:\n    Input: nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g() -> List[int]:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        max_xor_candidate = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ max_xor_candidate in prefixes:\n                max_xor = max_xor_candidate\n                break\n\n    return max_xor\n\ndef g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums\n\nassert f(g()) == 28\n", "emb": [1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of positive integers, find the maximum XOR value of any two elements in the list.\n\n    Example:\n    nums = [3, 10, 5, 25, 2, 8]\n\n    Output:\n    28\n    \"\"\"\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = set()\n\n        for num in nums:\n            prefixes.add(num & mask)\n\n        max_xor_candidate = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ max_xor_candidate in prefixes:\n                max_xor = max_xor_candidate\n                break\n\n    return max_xor", "solution_func": "def g():\n    nums = [3, 10, 5, 25, 2, 8]\n    return nums", "map_ix": [1, 1, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the amount of water that can be trapped between the buildings.\n    \n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    \n    Output:\n    6\n    \"\"\"\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - heights[i]\n    \n    return water\n\ndef g():\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return heights\n\nassert f(g()) == 6\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the amount of water that can be trapped between the buildings.\n    \n    Example:\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    \n    Output:\n    6\n    \"\"\"\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], heights[i])\n    \n    right_max[n-1] = heights[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], heights[i])\n    \n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - heights[i]\n    \n    return water", "solution_func": "def g():\n    heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\n    return heights", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle that can be formed by connecting adjacent buildings.\n    \n    Example:\n    heights = [2, 4, 1, 3, 5, 6, 2, 1]\n    \n    Output:\n    10\n    \"\"\"\n    n = len(heights)\n    stack = []\n    max_area = 0\n    \n    for i in range(n):\n        while stack and heights[stack[-1]] >= heights[i]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area\n\ndef g():\n    heights = [2, 4, 1, 3, 5, 6, 2, 1]\n    return heights\n\nassert f(g()) == 10\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 488, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle that can be formed by connecting adjacent buildings.\n    \n    Example:\n    heights = [2, 4, 1, 3, 5, 6, 2, 1]\n    \n    Output:\n    10\n    \"\"\"\n    n = len(heights)\n    stack = []\n    max_area = 0\n    \n    for i in range(n):\n        while stack and heights[stack[-1]] >= heights[i]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    while stack:\n        height = heights[stack.pop()]\n        width = n if not stack else n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area", "solution_func": "def g():\n    heights = [2, 4, 1, 3, 5, 6, 2, 1]\n    return heights", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that have an even length and start with a vowel.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n\n    The words that meet the criteria are: \"apple\" and \"orange\"\n    Therefore, the function should return [\"apple\", \"orange\"].\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = []\n    \n    for word in words:\n        if len(word) % 2 == 0 and word[0] in vowels:\n            result.append(word)\n    \n    return result\n\n\ndef g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n    return words\n\nassert f(g()) == [\"apple\", \"orange\"]\n\n", "emb": null, "idx_generation": 488, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list containing only the words that have an even length and start with a vowel.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n\n    The words that meet the criteria are: \"apple\" and \"orange\"\n    Therefore, the function should return [\"apple\", \"orange\"].\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = []\n    \n    for word in words:\n        if len(word) % 2 == 0 and word[0] in vowels:\n            result.append(word)\n    \n    return result", "solution_func": "def g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n    return words", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine the number of nodes that have an outgoing edge.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The nodes with outgoing edges are: 0, 2, 3\n    Therefore, the function should return 3.\n    \"\"\"\n    outgoing_nodes = 0\n    \n    for row in matrix:\n        if sum(row) > 0:\n            outgoing_nodes += 1\n    \n    return outgoing_nodes\n\n\ndef g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix\n\nassert f(g()) == 3\n\n", "emb": null, "idx_generation": 488, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given an adjacency matrix representing a directed graph, determine the number of nodes that have an outgoing edge.\n\n    Example:\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n\n    The nodes with outgoing edges are: 0, 2, 3\n    Therefore, the function should return 3.\n    \"\"\"\n    outgoing_nodes = 0\n    \n    for row in matrix:\n        if sum(row) > 0:\n            outgoing_nodes += 1\n    \n    return outgoing_nodes", "solution_func": "def g():\n    matrix = [[0, 1, 0, 0],\n              [1, 0, 0, 0],\n              [0, 0, 0, 1],\n              [0, 0, 1, 0]]\n    return matrix", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, return the total number of vowels in all the words.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n\n    The total number of vowels in the words is: 11\n    Therefore, the function should return 11.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for word in words:\n        for char in word:\n            if char in vowels:\n                count += 1\n    \n    return count\n\n\ndef g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n    return words\n\nassert f(g()) == 11\n\n", "emb": null, "idx_generation": 488, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> int:\n    \"\"\"\n    Given a list of words, return the total number of vowels in all the words.\n\n    Example:\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n\n    The total number of vowels in the words is: 11\n    Therefore, the function should return 11.\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    \n    for word in words:\n        for char in word:\n            if char in vowels:\n                count += 1\n    \n    return count", "solution_func": "def g():\n    words = [\"apple\", \"banana\", \"orange\", \"kiwi\", \"melon\"]\n    return words", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9, 11], target = 7\n    Output: 3\n    Explanation: The target value 7 is found at index 3 in the list.\n\n    Note:\n    - The input list will be sorted in ascending order.\n    \"\"\"\n\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)\n\n\ndef g():\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return arr, target\n\n\nassert f(*g()) == 3\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 488, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, find the index of the target value in the list using binary search.\n    If the target value is not found in the list, return -1.\n\n    Example:\n    Input: arr = [1, 3, 5, 7, 9, 11], target = 7\n    Output: 3\n    Explanation: The target value 7 is found at index 3 in the list.\n\n    Note:\n    - The input list will be sorted in ascending order.\n    \"\"\"\n\n    def binary_search(arr, target, low, high):\n        if low > high:\n            return -1\n\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            return binary_search(arr, target, mid + 1, high)\n        else:\n            return binary_search(arr, target, low, mid - 1)\n\n    return binary_search(arr, target, 0, len(arr) - 1)", "solution_func": "def g():\n    arr = [1, 3, 5, 7, 9, 11]\n    target = 7\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> str:\n    \"\"\"\n    Given two integers n and k, return the kth lexicographically smallest string of length n consisting of lowercase English letters.\n\n    Example:\n    n = 3, k = 5\n    Output: \"aab\"\n\n    n = 4, k = 10\n    Output: \"abcc\"\n    \"\"\"\n    result = []\n    for i in range(n):\n        result.append(chr((k % 26) + ord('a')))\n        k = k // 26\n    return \"\".join(result[::-1])\n\ndef g(n: int = 3, k: int = 5):\n    return n, k\n\nassert f(*g()) == \"aab\"\n", "emb": null, "idx_generation": 489, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> str:\n    \"\"\"\n    Given two integers n and k, return the kth lexicographically smallest string of length n consisting of lowercase English letters.\n\n    Example:\n    n = 3, k = 5\n    Output: \"aab\"\n\n    n = 4, k = 10\n    Output: \"abcc\"\n    \"\"\"\n    result = []\n    for i in range(n):\n        result.append(chr((k % 26) + ord('a')))\n        k = k // 26\n    return \"\".join(result[::-1])", "solution_func": "def g(n: int = 3, k: int = 5):\n    return n, k", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the sum of elements in the combination is equal to target.\n    Each number in nums may only be used once in the combination.\n    Note: The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    nums = [2, 5, 2, 1, 2], target = 5\n    Output: [[1, 2, 2], [5]]\n    \"\"\"\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            result.append(path[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path, curr_sum + nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], 0)\n    return result\n\ndef g(nums: List[int] = [10, 1, 2, 7, 6, 1, 5], target: int = 8):\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 489, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array nums of n integers and an integer target, find all unique combinations in nums where the sum of elements in the combination is equal to target.\n    Each number in nums may only be used once in the combination.\n    Note: The solution set must not contain duplicate combinations.\n\n    Example:\n    nums = [10, 1, 2, 7, 6, 1, 5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    nums = [2, 5, 2, 1, 2], target = 5\n    Output: [[1, 2, 2], [5]]\n    \"\"\"\n    def backtrack(start, path, curr_sum):\n        if curr_sum == target:\n            result.append(path[:])\n            return\n        if curr_sum > target:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path, curr_sum + nums[i])\n            path.pop()\n\n    nums.sort()\n    result = []\n    backtrack(0, [], 0)\n    return result", "solution_func": "def g(nums: List[int] = [10, 1, 2, 7, 6, 1, 5], target: int = 8):\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\n    Example:\n    s = \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    s = \"race a car\"\n    Output: False\n    \"\"\"\n    cleaned_s = ''.join(e.lower() for e in s if e.isalnum())\n    return cleaned_s == cleaned_s[::-1]\n\ndef g(s: str = \"A man, a plan, a canal: Panama\"):\n    return s\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 489, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\n    Example:\n    s = \"A man, a plan, a canal: Panama\"\n    Output: True\n\n    s = \"race a car\"\n    Output: False\n    \"\"\"\n    cleaned_s = ''.join(e.lower() for e in s if e.isalnum())\n    return cleaned_s == cleaned_s[::-1]", "solution_func": "def g(s: str = \"A man, a plan, a canal: Panama\"):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from n items without repetition.\n    \"\"\"\n\n    if k == 0 or k == n:\n        return 1\n    if k > n:\n        return 0\n\n    return f(n-1, k-1) + f(n-1, k)\n\ndef g(n=5, k=2):\n    return n, k\n\nassert f(*g()) == 10\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(n: int, k: int) -> int:\n    \"\"\"\n    Given two integers n and k, return the number of ways to choose k items from n items without repetition.\n    \"\"\"\n\n    if k == 0 or k == n:\n        return 1\n    if k > n:\n        return 0\n\n    return f(n-1, k-1) + f(n-1, k)", "solution_func": "def g(n=5, k=2):\n    return n, k", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    return f(n-1) + f(n-2)\n\ndef g(n=6):\n    return n\n\nassert f(g()) == 8\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the nth Fibonacci number.\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    return f(n-1) + f(n-2)", "solution_func": "def g(n=6):\n    return n", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Given two integers m and n, return the number of unique paths to reach the bottom-right corner of a m x n grid\n    starting from the top-left corner. You can only move down or right.\n\n    Example:\n    f(3, 2) => 3\n    \"\"\"\n\n    if m == 1 or n == 1:\n        return 1\n\n    return f(m-1, n) + f(m, n-1)\n\ndef g(m=3, n=2):\n    return m, n\n\nassert f(*g()) == 3\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(m: int, n: int) -> int:\n    \"\"\"\n    Given two integers m and n, return the number of unique paths to reach the bottom-right corner of a m x n grid\n    starting from the top-left corner. You can only move down or right.\n\n    Example:\n    f(3, 2) => 3\n    \"\"\"\n\n    if m == 1 or n == 1:\n        return 1\n\n    return f(m-1, n) + f(m, n-1)", "solution_func": "def g(m=3, n=2):\n    return m, n", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers contains a Pythagorean triplet.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    bool: True if the list contains a Pythagorean triplet, False otherwise.\n    \"\"\"\n    squares = [num * num for num in nums]\n    squares.sort()\n\n    for i in range(len(squares) - 1, 1, -1):\n        c = squares[i]\n        left = 0\n        right = i - 1\n\n        while left < right:\n            a = squares[left]\n            b = squares[right]\n\n            if a + b == c:\n                return True\n            elif a + b < c:\n                left += 1\n            else:\n                right -= 1\n\n    return False\n\ndef g():\n    return [3, 1, 4, 5, 6, 8, 10]\n\nassert f(g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Check if the given list of integers contains a Pythagorean triplet.\n\n    Args:\n    nums (List[int]): The list of integers.\n\n    Returns:\n    bool: True if the list contains a Pythagorean triplet, False otherwise.\n    \"\"\"\n    squares = [num * num for num in nums]\n    squares.sort()\n\n    for i in range(len(squares) - 1, 1, -1):\n        c = squares[i]\n        left = 0\n        right = i - 1\n\n        while left < right:\n            a = squares[left]\n            b = squares[right]\n\n            if a + b == c:\n                return True\n            elif a + b < c:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "solution_func": "def g():\n    return [3, 1, 4, 5, 6, 8, 10]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Args:\n    n (int): The position of the Fibonacci number.\n\n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]\n\ndef g():\n    return 8\n\nassert f(g()) == 21\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 489, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n\n    Args:\n    n (int): The position of the Fibonacci number.\n\n    Returns:\n    int: The nth Fibonacci number.\n    \"\"\"\n    if n <= 1:\n        return n\n\n    fib = [0, 1]\n    for i in range(2, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    return fib[n]", "solution_func": "def g():\n    return 8", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid palindrome after removing at most one character.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    bool: True if the string is a valid palindrome, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"\n        Check if a string is a palindrome.\n\n        Args:\n        s (str): The string to check.\n\n        Returns:\n        bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    if is_palindrome(s):\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n\n    return True\n\ndef g():\n    return \"level\"\n\nassert f(g()) == False\n", "emb": null, "idx_generation": 489, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid palindrome after removing at most one character.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    bool: True if the string is a valid palindrome, False otherwise.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"\n        Check if a string is a palindrome.\n\n        Args:\n        s (str): The string to check.\n\n        Returns:\n        bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    if is_palindrome(s):\n        return True\n\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1])\n        left += 1\n        right -= 1\n\n    return True", "solution_func": "def g():\n    return \"level\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target if it is found. \n    If the target is not in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2, since 5 is found at index 2 in the list.\n\n    If the target is not in the list:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    The function should return -1, since 12 is not found in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\ndef g() -> List[int, int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target\n\nassert f(*g()) == 2\n", "emb": null, "idx_generation": 489, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target value, return the index of the target if it is found. \n    If the target is not in the list, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2, since 5 is found at index 2 in the list.\n\n    If the target is not in the list:\n    nums = [2, 4, 6, 8, 10]\n    target = 12\n\n    The function should return -1, since 12 is not found in the list.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1", "solution_func": "def g() -> List[int, int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return nums, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    All occurrences of a character must be replaced with another character while preserving the order of characters.\n    No two characters may map to the same character, but a character may map to itself.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n\n        if char_s in char_map:\n            if char_map[char_s] != char_t:\n                return False\n        else:\n            if char_t in used_chars:\n                return False\n\n            char_map[char_s] = char_t\n            used_chars.add(char_t)\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return (\"egg\", \"add\")\n\nassert f(*g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if they are isomorphic.\n\n    Two strings are isomorphic if the characters in s can be replaced to get t.\n\n    All occurrences of a character must be replaced with another character while preserving the order of characters.\n    No two characters may map to the same character, but a character may map to itself.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    char_map = {}\n    used_chars = set()\n\n    for i in range(len(s)):\n        char_s = s[i]\n        char_t = t[i]\n\n        if char_s in char_map:\n            if char_map[char_s] != char_t:\n                return False\n        else:\n            if char_t in used_chars:\n                return False\n\n            char_map[char_s] = char_t\n            used_chars.add(char_t)\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return (\"egg\", \"add\")", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(words: List[str], order: str) -> bool:\n    \"\"\"\n    Given a list of words and a string order representing the order of the letters in an alien language, determine if the words are sorted lexicographically in this alien language.\n\n    The order of the letters in the alien language is given by the string order. If a and b are two words and a[i] and b[i] are two letters in the given order, where 0 \u2264 i < min(len(a), len(b)), then a comes before b in the alien language.\n\n    If the order of the letters is inconsistent, return False.\n    \"\"\"\n\n    char_order = {}\n    for i in range(len(order)):\n        char_order[order[i]] = i\n\n    for i in range(1, len(words)):\n        word1 = words[i - 1]\n        word2 = words[i]\n\n        if not compare_words(word1, word2, char_order):\n            return False\n\n    return True\n\ndef compare_words(word1: str, word2: str, char_order: Dict[str, int]) -> bool:\n    len1 = len(word1)\n    len2 = len(word2)\n\n    for i in range(min(len1, len2)):\n        char1 = word1[i]\n        char2 = word2[i]\n\n        if char_order[char1] < char_order[char2]:\n            return True\n        elif char_order[char1] > char_order[char2]:\n            return False\n\n    return len1 <= len2\n\n\ndef g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate a list of words and a string order.\n    \"\"\"\n    return ([\"word\", \"world\", \"hello\", \"hey\"], \"abcdefghijklmnopqrstuvwxyz\")\n\nassert f(*g()) == True\n\n", "emb": null, "idx_generation": 490, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(words: List[str], order: str) -> bool:\n    \"\"\"\n    Given a list of words and a string order representing the order of the letters in an alien language, determine if the words are sorted lexicographically in this alien language.\n\n    The order of the letters in the alien language is given by the string order. If a and b are two words and a[i] and b[i] are two letters in the given order, where 0 \u2264 i < min(len(a), len(b)), then a comes before b in the alien language.\n\n    If the order of the letters is inconsistent, return False.\n    \"\"\"\n\n    char_order = {}\n    for i in range(len(order)):\n        char_order[order[i]] = i\n\n    for i in range(1, len(words)):\n        word1 = words[i - 1]\n        word2 = words[i]\n\n        if not compare_words(word1, word2, char_order):\n            return False\n\n    return True\n\ndef compare_words(word1: str, word2: str, char_order: Dict[str, int]) -> bool:\n    len1 = len(word1)\n    len2 = len(word2)\n\n    for i in range(min(len1, len2)):\n        char1 = word1[i]\n        char2 = word2[i]\n\n        if char_order[char1] < char_order[char2]:\n            return True\n        elif char_order[char1] > char_order[char2]:\n            return False\n\n    return len1 <= len2", "solution_func": "def g() -> Tuple[List[str], str]:\n    \"\"\"\n    Generate a list of words and a string order.\n    \"\"\"\n    return ([\"word\", \"world\", \"hello\", \"hey\"], \"abcdefghijklmnopqrstuvwxyz\")", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    char_count = [0] * 26\n\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n\n    for char in t:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n\n    return True\n\ndef g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return (\"listen\", \"silent\")\n\nassert f(*g()) == True\n\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, determine if t is an anagram of s.\n\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n    \"\"\"\n\n    if len(s) != len(t):\n        return False\n\n    char_count = [0] * 26\n\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n\n    for char in t:\n        char_count[ord(char) - ord('a')] -= 1\n        if char_count[ord(char) - ord('a')] < 0:\n            return False\n\n    return True", "solution_func": "def g() -> Tuple[str, str]:\n    \"\"\"\n    Generate two strings.\n    \"\"\"\n    return (\"listen\", \"silent\")", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique subsets that can be formed from the integers such that\n    the sum of each subset is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The unique subsets that can be formed are: [1, 2, 3], [1, 2, 3, 4, 5], [2, 3, 4], [2, 3, 5], [4, 5]\n\n    Therefore, the function should return 5.\n    \"\"\"\n    def helper(nums, index, sum, memo):\n        if index == len(nums):\n            if sum % 3 == 0:\n                return 1\n            else:\n                return 0\n\n        if (index, sum) in memo:\n            return memo[(index, sum)]\n\n        count = helper(nums, index + 1, sum + nums[index], memo) + helper(nums, index + 1, sum, memo)\n\n        memo[(index, sum)] = count\n\n        return count\n\n    return helper(nums, 0, 0, {})\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 5\n\n", "emb": null, "idx_generation": 490, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique subsets that can be formed from the integers such that\n    the sum of each subset is divisible by 3.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The unique subsets that can be formed are: [1, 2, 3], [1, 2, 3, 4, 5], [2, 3, 4], [2, 3, 5], [4, 5]\n\n    Therefore, the function should return 5.\n    \"\"\"\n    def helper(nums, index, sum, memo):\n        if index == len(nums):\n            if sum % 3 == 0:\n                return 1\n            else:\n                return 0\n\n        if (index, sum) in memo:\n            return memo[(index, sum)]\n\n        count = helper(nums, index + 1, sum + nums[index], memo) + helper(nums, index + 1, sum, memo)\n\n        memo[(index, sum)] = count\n\n        return count\n\n    return helper(nums, 0, 0, {})", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations that can be formed from the integers such that\n    the product of each permutation is a perfect square.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The unique permutations that can be formed are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def is_perfect_square(n):\n        return int(n**0.5)**2 == n\n\n    def helper(nums, index, count):\n        if index == len(nums):\n            product = 1\n            for num in nums:\n                product *= num\n            if is_perfect_square(product):\n                return count + 1\n            else:\n                return count\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            count = helper(nums, index + 1, count)\n            nums[index], nums[i] = nums[i], nums[index]\n\n        return count\n\n    return helper(nums, 0, 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 490, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique permutations that can be formed from the integers such that\n    the product of each permutation is a perfect square.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The unique permutations that can be formed are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def is_perfect_square(n):\n        return int(n**0.5)**2 == n\n\n    def helper(nums, index, count):\n        if index == len(nums):\n            product = 1\n            for num in nums:\n                product *= num\n            if is_perfect_square(product):\n                return count + 1\n            else:\n                return count\n\n        for i in range(index, len(nums)):\n            nums[index], nums[i] = nums[i], nums[index]\n            count = helper(nums, index + 1, count)\n            nums[index], nums[i] = nums[i], nums[index]\n\n        return count\n\n    return helper(nums, 0, 0)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that can be formed from the integers such that\n    the concatenation of each combination is a palindrome.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The unique combinations that can be formed are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def helper(nums, index, path, count):\n        if index == len(nums):\n            if is_palindrome(''.join(path)):\n                return count + 1\n            else:\n                return count\n\n        count = helper(nums, index + 1, path + [str(nums[index])], count)\n        count = helper(nums, index + 1, path, count)\n\n        return count\n\n    return helper(nums, 0, [], 0)\n\ndef g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": null, "idx_generation": 490, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of unique combinations that can be formed from the integers such that\n    the concatenation of each combination is a palindrome.\n\n    Example:\n    nums = [1, 2, 3]\n\n    The unique combinations that can be formed are: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\n\n    Therefore, the function should return 6.\n    \"\"\"\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def helper(nums, index, path, count):\n        if index == len(nums):\n            if is_palindrome(''.join(path)):\n                return count + 1\n            else:\n                return count\n\n        count = helper(nums, index + 1, path + [str(nums[index])], count)\n        count = helper(nums, index + 1, path, count)\n\n        return count\n\n    return helper(nums, 0, [], 0)", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, a: List[int], b: List[int]) -> bool:\n    \"\"\"\n    Given two lists of integers a and b, check if there exists a pair (x, y) where x is from list a and y is from list b,\n    such that x ^ y = n, where ^ represents the bitwise XOR operation.\n    \"\"\"\n    for x in a:\n        for y in b:\n            if x ^ y == n:\n                return True\n    return False\n\ndef g(n: int, a: List[int], b: List[int]):\n    return n, a, b\n\nn = 10\na = [1, 2, 3]\nb = [4, 5, 6]\nassert f(*g(n, a, b))\n", "emb": null, "idx_generation": 490, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int, a: List[int], b: List[int]) -> bool:\n    \"\"\"\n    Given two lists of integers a and b, check if there exists a pair (x, y) where x is from list a and y is from list b,\n    such that x ^ y = n, where ^ represents the bitwise XOR operation.\n    \"\"\"\n    for x in a:\n        for y in b:\n            if x ^ y == n:\n                return True\n    return False", "solution_func": "def g(n: int, a: List[int], b: List[int]):\n    return n, a, b\n\nn = 10\na = [1, 2, 3]\nb = [4, 5, 6]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible balanced parentheses combinations of length n.\n    \"\"\"\n    result = []\n    \n    def backtrack(s: str, open_count: int, close_count: int):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        \n        if open_count < n:\n            backtrack(s + '(', open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(s + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n\ndef g(n: int):\n    return n\n\nn = 3\nassert f(g(n)) == ['((()))', '(()())', '(())()', '()(())', '()()()']\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 490, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(n: int) -> List[str]:\n    \"\"\"\n    Given an integer n, generate all possible balanced parentheses combinations of length n.\n    \"\"\"\n    result = []\n    \n    def backtrack(s: str, open_count: int, close_count: int):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        \n        if open_count < n:\n            backtrack(s + '(', open_count + 1, close_count)\n        \n        if close_count < open_count:\n            backtrack(s + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result", "solution_func": "def g(n: int):\n    return n\n\nn = 3", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the sum of the first n Fibonacci numbers.\n    \"\"\"\n    fib_sum = 0\n    \n    def fibonacci(n: int) -> int:\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    for i in range(n):\n        fib_sum += fibonacci(i)\n    \n    return fib_sum\n\ndef g(n: int):\n    return n\n\nn = 5\nassert f(g(n)) == 12\n", "emb": null, "idx_generation": 490, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Find the sum of the first n Fibonacci numbers.\n    \"\"\"\n    fib_sum = 0\n    \n    def fibonacci(n: int) -> int:\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n-1) + fibonacci(n-2)\n    \n    for i in range(n):\n        fib_sum += fibonacci(i)\n    \n    return fib_sum", "solution_func": "def g(n: int):\n    return n\n\nn = 5", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target value.\n\n    Return True if there exists a pair of numbers that sum up to the target, and False otherwise.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6], target = 9\n    Output: True\n    Explanation: There exists a pair (3, 6) in the list that sums up to 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 490, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers, determine if there are two numbers in the list that sum up to the target value.\n\n    Return True if there exists a pair of numbers that sum up to the target, and False otherwise.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6], target = 9\n    Output: True\n    Explanation: There exists a pair (3, 6) in the list that sums up to 9.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5, 6]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct combinations that sum up to a target value.\n    Return the count of distinct combinations.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    The distinct combinations that sum up to 5 are [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 4], [2, 3], [5].\n    Therefore, the function should return 6.\n    \"\"\"\n    def count_combinations(nums, target, idx, memo):\n        if target == 0:\n            return 1\n        if target < 0 or idx >= len(nums):\n            return 0\n        if (idx, target) in memo:\n            return memo[(idx, target)]\n        \n        count = count_combinations(nums, target - nums[idx], idx, memo) + count_combinations(nums, target, idx + 1, memo)\n        memo[(idx, target)] = count\n        \n        return count\n    \n    memo = {}\n    return count_combinations(nums, 5, 0, memo)\n\ndef g():\n    nums = [1, 2, 3, 4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of distinct combinations that sum up to a target value.\n    Return the count of distinct combinations.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    target = 5\n\n    The distinct combinations that sum up to 5 are [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 4], [2, 3], [5].\n    Therefore, the function should return 6.\n    \"\"\"\n    def count_combinations(nums, target, idx, memo):\n        if target == 0:\n            return 1\n        if target < 0 or idx >= len(nums):\n            return 0\n        if (idx, target) in memo:\n            return memo[(idx, target)]\n        \n        count = count_combinations(nums, target - nums[idx], idx, memo) + count_combinations(nums, target, idx + 1, memo)\n        memo[(idx, target)] = count\n        \n        return count\n    \n    memo = {}\n    return count_combinations(nums, 5, 0, memo)", "solution_func": "def g():\n    nums = [1, 2, 3, 4]\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the shortest path between two nodes.\n    Return the minimum distance between the two nodes.\n\n    Example:\n    graph = [\n        [0, 2, 4, 0, 0],\n        [2, 0, 1, 5, 0],\n        [4, 1, 0, 3, 6],\n        [0, 5, 3, 0, 2],\n        [0, 0, 6, 2, 0]\n    ]\n    start = 0\n    end = 4\n\n    The shortest path between node 0 and node 4 is [0, 2, 3, 4].\n    Therefore, the function should return 9.\n    \"\"\"\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        distances = [float('inf')] * n\n        distances[start] = 0\n        visited = [False] * n\n        \n        for _ in range(n):\n            min_dist = float('inf')\n            min_idx = -1\n            \n            for i in range(n):\n                if not visited[i] and distances[i] < min_dist:\n                    min_dist = distances[i]\n                    min_idx = i\n            \n            visited[min_idx] = True\n            \n            for j in range(n):\n                if not visited[j] and graph[min_idx][j] > 0:\n                    new_dist = distances[min_idx] + graph[min_idx][j]\n                    if new_dist < distances[j]:\n                        distances[j] = new_dist\n        \n        return distances[end]\n    \n    return dijkstra(graph, 0, 4)\n\ndef g():\n    graph = [\n        [0, 2, 4, 0, 0],\n        [2, 0, 1, 5, 0],\n        [4, 1, 0, 3, 6],\n        [0, 5, 3, 0, 2],\n        [0, 0, 6, 2, 0]\n    ]\n    return graph\n\nassert f(g()) == 9\n\n", "emb": null, "idx_generation": 491, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(graph: List[List[int]]) -> int:\n    \"\"\"\n    Given a graph represented as an adjacency matrix, find the shortest path between two nodes.\n    Return the minimum distance between the two nodes.\n\n    Example:\n    graph = [\n        [0, 2, 4, 0, 0],\n        [2, 0, 1, 5, 0],\n        [4, 1, 0, 3, 6],\n        [0, 5, 3, 0, 2],\n        [0, 0, 6, 2, 0]\n    ]\n    start = 0\n    end = 4\n\n    The shortest path between node 0 and node 4 is [0, 2, 3, 4].\n    Therefore, the function should return 9.\n    \"\"\"\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        distances = [float('inf')] * n\n        distances[start] = 0\n        visited = [False] * n\n        \n        for _ in range(n):\n            min_dist = float('inf')\n            min_idx = -1\n            \n            for i in range(n):\n                if not visited[i] and distances[i] < min_dist:\n                    min_dist = distances[i]\n                    min_idx = i\n            \n            visited[min_idx] = True\n            \n            for j in range(n):\n                if not visited[j] and graph[min_idx][j] > 0:\n                    new_dist = distances[min_idx] + graph[min_idx][j]\n                    if new_dist < distances[j]:\n                        distances[j] = new_dist\n        \n        return distances[end]\n    \n    return dijkstra(graph, 0, 4)", "solution_func": "def g():\n    graph = [\n        [0, 2, 4, 0, 0],\n        [2, 0, 1, 5, 0],\n        [4, 1, 0, 3, 6],\n        [0, 5, 3, 0, 2],\n        [0, 0, 6, 2, 0]\n    ]\n    return graph", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of three numbers is 60, which corresponds to 4 * 5 * 3.\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort(reverse=True)\n    return max(nums[0] * nums[1] * nums[2], nums[0] * nums[-1] * nums[-2])\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 60\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n    Return the maximum product.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The maximum product of three numbers is 60, which corresponds to 4 * 5 * 3.\n    Therefore, the function should return 60.\n    \"\"\"\n    nums.sort(reverse=True)\n    return max(nums[0] * nums[1] * nums[2], nums[0] * nums[-1] * nums[-2])", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\nimport heapq\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    Output: 5\n\n    Explanation: The second largest element in the list is 5.\n\n    Note:\n    - You may assume k is always valid, 1 \u2264 k \u2264 array's length.\n    \"\"\"\n\n    pq = []\n\n    for num in nums:\n        heapq.heappush(pq, num)\n        if len(pq) > k:\n            heapq.heappop(pq)\n\n    return heapq.heappop(pq)\n\ndef g(nums=[3, 2, 1, 5, 6, 4], k=2):\n    return nums, k\n\nassert f(*g()) == 5\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 491, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\nimport heapq\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers and an integer k, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 2, 1, 5, 6, 4]\n    k = 2\n    Output: 5\n\n    Explanation: The second largest element in the list is 5.\n\n    Note:\n    - You may assume k is always valid, 1 \u2264 k \u2264 array's length.\n    \"\"\"\n\n    pq = []\n\n    for num in nums:\n        heapq.heappush(pq, num)\n        if len(pq) > k:\n            heapq.heappop(pq)\n\n    return heapq.heappop(pq)", "solution_func": "def g(nums=[3, 2, 1, 5, 6, 4], k=2):\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: 24\n\n    Explanation: The maximum product can be achieved by multiplying 2, 3, and 4.\n\n    Note:\n    - The length of the list will be at least 3.\n    - The list will only contain integers.\n    \"\"\"\n\n    max1 = max2 = max3 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for num in nums:\n        if num > max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max3 = max2\n            max2 = num\n        elif num > max3:\n            max3 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    return max(max1 * max2 * max3, min1 * min2 * max1)\n\ndef g(nums=[1, 2, 3, 4]):\n    return nums\n\nassert f(*g()) == 24\n\n", "emb": null, "idx_generation": 491, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum product of any three numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4]\n    Output: 24\n\n    Explanation: The maximum product can be achieved by multiplying 2, 3, and 4.\n\n    Note:\n    - The length of the list will be at least 3.\n    - The list will only contain integers.\n    \"\"\"\n\n    max1 = max2 = max3 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for num in nums:\n        if num > max1:\n            max3 = max2\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max3 = max2\n            max2 = num\n        elif num > max3:\n            max3 = num\n\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n\n    return max(max1 * max2 * max3, min1 * min2 * max1)", "solution_func": "def g(nums=[1, 2, 3, 4]):\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Note:\n    - The list can be empty.\n    - The list can contain negative numbers.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums\n\nassert f(*g()) == 4\n\n", "emb": null, "idx_generation": 491, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the longest increasing subsequence (LIS) in the list.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n\n    Note:\n    - The list can be empty.\n    - The list can contain negative numbers.\n    \"\"\"\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g(nums=[10, 9, 2, 5, 3, 7, 101, 18]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and an integer k, determine if there exists a subarray with a sum divisible by k.\n\n    Example:\n    nums = [4, 7, 2, 3, 1, 8, 9]\n    k = 5\n\n    The subarray [7, 2, 3, 1] has a sum of 13, which is divisible by 5.\n\n    Therefore, the function should return True.\n    \"\"\"\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append((prefix_sums[-1] + num) % k)\n    \n    remainder_counts = {}\n    for prefix_sum in prefix_sums:\n        if prefix_sum in remainder_counts:\n            return True\n        remainder_counts[prefix_sum] = 1\n    \n    return False\n\ndef g():\n    nums = [4, 7, 2, 3, 1, 8, 9]\n    k = 5\n    return nums, k\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and an integer k, determine if there exists a subarray with a sum divisible by k.\n\n    Example:\n    nums = [4, 7, 2, 3, 1, 8, 9]\n    k = 5\n\n    The subarray [7, 2, 3, 1] has a sum of 13, which is divisible by 5.\n\n    Therefore, the function should return True.\n    \"\"\"\n    prefix_sums = [0]\n    for num in nums:\n        prefix_sums.append((prefix_sums[-1] + num) % k)\n    \n    remainder_counts = {}\n    for prefix_sum in prefix_sums:\n        if prefix_sum in remainder_counts:\n            return True\n        remainder_counts[prefix_sum] = 1\n    \n    return False", "solution_func": "def g():\n    nums = [4, 7, 2, 3, 1, 8, 9]\n    k = 5\n    return nums, k", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where every element is the product of all the elements in the original list except for the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The product of all elements in the list is 1 * 2 * 3 * 4 * 5 = 120.\n\n    The new list should be [120, 60, 40, 30, 24], where each element is the product of all elements except for the corresponding element.\n\n    Therefore, the function should return [120, 60, 40, 30, 24].\n    \"\"\"\n    n = len(nums)\n    products = [1] * n\n    \n    left_product = 1\n    for i in range(n):\n        products[i] *= left_product\n        left_product *= nums[i]\n    \n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        products[i] *= right_product\n        right_product *= nums[i]\n    \n    return products\n\ndef g():\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == [120, 60, 40, 30, 24]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, return a new list where every element is the product of all the elements in the original list except for the corresponding element.\n\n    Example:\n    nums = [1, 2, 3, 4, 5]\n\n    The product of all elements in the list is 1 * 2 * 3 * 4 * 5 = 120.\n\n    The new list should be [120, 60, 40, 30, 24], where each element is the product of all elements except for the corresponding element.\n\n    Therefore, the function should return [120, 60, 40, 30, 24].\n    \"\"\"\n    n = len(nums)\n    products = [1] * n\n    \n    left_product = 1\n    for i in range(n):\n        products[i] *= left_product\n        left_product *= nums[i]\n    \n    right_product = 1\n    for i in range(n - 1, -1, -1):\n        products[i] *= right_product\n        right_product *= nums[i]\n    \n    return products", "solution_func": "def g():\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n\n    Example:\n    nums = [2, 7, 9, 3, 1]\n\n    The maximum sum of a subarray with the given constraint is 12, which can be achieved by selecting the subarray [2, 9, 1].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    if n == 1:\n        return nums[0]\n    \n    max_sum = max(nums[0], nums[1])\n    prev_2_sum = nums[0]\n    prev_1_sum = max_sum\n    \n    for i in range(2, n):\n        current_sum = max(prev_2_sum + nums[i], prev_1_sum)\n        max_sum = max(max_sum, current_sum)\n        prev_2_sum, prev_1_sum = prev_1_sum, current_sum\n    \n    return max_sum\n\ndef g():\n    nums = [2, 7, 9, 3, 1]\n    return nums\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent.\n\n    Example:\n    nums = [2, 7, 9, 3, 1]\n\n    The maximum sum of a subarray with the given constraint is 12, which can be achieved by selecting the subarray [2, 9, 1].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    if n == 1:\n        return nums[0]\n    \n    max_sum = max(nums[0], nums[1])\n    prev_2_sum = nums[0]\n    prev_1_sum = max_sum\n    \n    for i in range(2, n):\n        current_sum = max(prev_2_sum + nums[i], prev_1_sum)\n        max_sum = max(max_sum, current_sum)\n        prev_2_sum, prev_1_sum = prev_1_sum, current_sum\n    \n    return max_sum", "solution_func": "def g():\n    nums = [2, 7, 9, 3, 1]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the closest element to the target.\n\n    Example:\n    nums = [1, 2, 4, 6, 8]\n    target = 5\n    Output: 4\n\n    nums = [-2, 0, 5, 9, 12]\n    target = 10\n    Output: 9\n\n    Note:\n    - The input list nums is sorted in ascending order.\n    - The length of the input list nums will be at most 10^4.\n    - The target integer can be any integer.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return nums[mid]\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if abs(nums[left] - target) < abs(nums[right] - target):\n        return nums[left]\n    else:\n        return nums[right]\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers nums and a target integer.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 4\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 491, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums and a target integer, find the closest element to the target.\n\n    Example:\n    nums = [1, 2, 4, 6, 8]\n    target = 5\n    Output: 4\n\n    nums = [-2, 0, 5, 9, 12]\n    target = 10\n    Output: 9\n\n    Note:\n    - The input list nums is sorted in ascending order.\n    - The length of the input list nums will be at most 10^4.\n    - The target integer can be any integer.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return nums[mid]\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if abs(nums[left] - target) < abs(nums[right] - target):\n        return nums[left]\n    else:\n        return nums[right]", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers nums and a target integer.\n    \"\"\"\n    return [1, 3, 5, 7, 9], 4", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct ways to climb to the top of the stairs.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]\n\ndef g(n: int = 3):\n    return n\n\nassert f(*g()) == 3\n", "emb": null, "idx_generation": 492, "target_skills": [0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(n: int) -> int:\n    \"\"\"\n    Given an integer n, return the number of distinct ways to climb to the top of the stairs.\n    You can climb either 1 or 2 steps at a time.\n\n    Example:\n    n = 3\n    Output: 3\n    Explanation: There are three ways to climb to the top: 1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    dp[2] = 2\n\n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n\n    return dp[n]", "solution_func": "def g(n: int = 3):\n    return n", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n\n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 492, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence.\n\n    Example:\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    Output: 4\n    Explanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n    \"\"\"\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n\n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return the kth permutation sequence of the numbers from 1 to n.\n\n    Example:\n    n = 4, k = 9\n    Output: [2, 1, 4, 3]\n    \"\"\"\n    def backtrack(nums, path, used, n, k):\n        if len(path) == n:\n            return path\n\n        for i in range(1, n+1):\n            if not used[i]:\n                used[i] = True\n                path.append(i)\n                if f(nums, path, used, n, k):\n                    return path\n                used[i] = False\n                path.pop()\n\n    nums = [str(i) for i in range(1, n+1)]\n    path = []\n    used = [False] * (n+1)\n    return backtrack(nums, path, used, n, k)\n\ndef g(n: int = 4, k: int = 9):\n    return n, k\n\nassert f(*g()) == [2, 1, 4, 3]\n", "emb": null, "idx_generation": 492, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(n: int, k: int) -> List[int]:\n    \"\"\"\n    Given two integers n and k, return the kth permutation sequence of the numbers from 1 to n.\n\n    Example:\n    n = 4, k = 9\n    Output: [2, 1, 4, 3]\n    \"\"\"\n    def backtrack(nums, path, used, n, k):\n        if len(path) == n:\n            return path\n\n        for i in range(1, n+1):\n            if not used[i]:\n                used[i] = True\n                path.append(i)\n                if f(nums, path, used, n, k):\n                    return path\n                used[i] = False\n                path.pop()\n\n    nums = [str(i) for i in range(1, n+1)]\n    path = []\n    used = [False] * (n+1)\n    return backtrack(nums, path, used, n, k)", "solution_func": "def g(n: int = 4, k: int = 9):\n    return n, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string, return a list of its characters sorted in alphabetical order.\n\n    Example:\n    s = \"programming\"\n\n    The characters in the string are ['a', 'g', 'i', 'm', 'm', 'n', 'o', 'p', 'r'].\n\n    Therefore, the function should return ['a', 'g', 'i', 'm', 'm', 'n', 'o', 'p', 'r'].\n    \"\"\"\n    return sorted(s)\n\ndef g():\n    return \"programming\"\n\nassert f(g()) == ['a', 'g', 'i', 'm', 'm', 'n', 'o', 'p', 'r']\n\n", "emb": null, "idx_generation": 492, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> List[str]:\n    \"\"\"\n    Given a string, return a list of its characters sorted in alphabetical order.\n\n    Example:\n    s = \"programming\"\n\n    The characters in the string are ['a', 'g', 'i', 'm', 'm', 'n', 'o', 'p', 'r'].\n\n    Therefore, the function should return ['a', 'g', 'i', 'm', 'm', 'n', 'o', 'p', 'r'].\n    \"\"\"\n    return sorted(s)", "solution_func": "def g():\n    return \"programming\"", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The even numbers in the list are [2, 4, 6].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)\n\ndef g():\n    return [1, 2, 3, 4, 5, 6]\n\nassert f(g()) == 12\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, return the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6]\n\n    The even numbers in the list are [2, 4, 6].\n\n    Therefore, the function should return 12.\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix (2D list), return a list of the maximum elements in each row.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The maximum elements in each row are [3, 6, 9].\n\n    Therefore, the function should return [3, 6, 9].\n    \"\"\"\n    return [max(row) for row in matrix]\n\ndef g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [3, 6, 9]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix (2D list), return a list of the maximum elements in each row.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n\n    The maximum elements in each row are [3, 6, 9].\n\n    Therefore, the function should return [3, 6, 9].\n    \"\"\"\n    return [max(row) for row in matrix]", "solution_func": "def g():\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(edges: List[Tuple[str, str]], target: str) -> bool:\n    \"\"\"\n    Given a list of edges representing a directed graph, determine if there exists a path from the start node to the target node.\n    \"\"\"\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n    \n    visited = set()\n    stack = [target]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node in graph:\n            for neighbor in graph[node]:\n                if neighbor == target:\n                    return True\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return False\n\ndef g(edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'F'), ('F', 'G'), ('G', 'H'), ('H', 'I')], target = 'I'):\n    \"\"\"\n    Generate a directed graph with the given edges, and return the graph and the target node.\n    \"\"\"\n    return edges, target\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 492, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\ndef f(edges: List[Tuple[str, str]], target: str) -> bool:\n    \"\"\"\n    Given a list of edges representing a directed graph, determine if there exists a path from the start node to the target node.\n    \"\"\"\n    graph = {}\n    for edge in edges:\n        u, v = edge\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n    \n    visited = set()\n    stack = [target]\n    \n    while stack:\n        node = stack.pop()\n        visited.add(node)\n        if node in graph:\n            for neighbor in graph[node]:\n                if neighbor == target:\n                    return True\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return False", "solution_func": "def g(edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'F'), ('F', 'G'), ('G', 'H'), ('H', 'I')], target = 'I'):\n    \"\"\"\n    Generate a directed graph with the given edges, and return the graph and the target node.\n    \"\"\"\n    return edges, target", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Determine if it is possible to split the given string into k non-empty substrings, such that each substring is a palindrome.\n    \"\"\"\n    def is_palindrome(substring):\n        return substring == substring[::-1]\n    \n    n = len(s)\n    dp = [[False] * (n+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][i] = True\n    \n    for l in range(2, n+1):\n        for i in range(n-l+1):\n            j = i + l - 1\n            if l == 2:\n                dp[i][j] = (s[i] == s[j])\n            else:\n                dp[i][j] = (s[i] == s[j] and dp[i+1][j-1])\n    \n    cuts = [float('inf')] * (n+1)\n    cuts[0] = 0\n    \n    for i in range(1, n+1):\n        for j in range(i):\n            if dp[j][i-1]:\n                cuts[i] = min(cuts[i], cuts[j] + 1)\n    \n    return cuts[n] == k\n\ndef g(s = 'level', k = 2):\n    \"\"\"\n    Generate a string and the number of cuts required to split the string into k palindromic substrings.\n    \"\"\"\n    return s, k\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 492, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> bool:\n    \"\"\"\n    Determine if it is possible to split the given string into k non-empty substrings, such that each substring is a palindrome.\n    \"\"\"\n    def is_palindrome(substring):\n        return substring == substring[::-1]\n    \n    n = len(s)\n    dp = [[False] * (n+1) for _ in range(n+1)]\n    \n    for i in range(n+1):\n        dp[i][i] = True\n    \n    for l in range(2, n+1):\n        for i in range(n-l+1):\n            j = i + l - 1\n            if l == 2:\n                dp[i][j] = (s[i] == s[j])\n            else:\n                dp[i][j] = (s[i] == s[j] and dp[i+1][j-1])\n    \n    cuts = [float('inf')] * (n+1)\n    cuts[0] = 0\n    \n    for i in range(1, n+1):\n        for j in range(i):\n            if dp[j][i-1]:\n                cuts[i] = min(cuts[i], cuts[j] + 1)\n    \n    return cuts[n] == k", "solution_func": "def g(s = 'level', k = 2):\n    \"\"\"\n    Generate a string and the number of cuts required to split the string into k palindromic substrings.\n    \"\"\"\n    return s, k", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Determine if the given two strings are isomorphic, meaning that characters in one string can be replaced to get the other string.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    mapping = {}\n    used = set()\n    \n    for c1, c2 in zip(s1, s2):\n        if c1 in mapping:\n            if mapping[c1] != c2:\n                return False\n        else:\n            if c2 in used:\n                return False\n            mapping[c1] = c2\n            used.add(c2)\n    \n    return True\n\ndef g(s1 = 'paper', s2 = 'title'):\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return s1, s2\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 492, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s1: str, s2: str) -> bool:\n    \"\"\"\n    Determine if the given two strings are isomorphic, meaning that characters in one string can be replaced to get the other string.\n    \"\"\"\n    if len(s1) != len(s2):\n        return False\n    \n    mapping = {}\n    used = set()\n    \n    for c1, c2 in zip(s1, s2):\n        if c1 in mapping:\n            if mapping[c1] != c2:\n                return False\n        else:\n            if c2 in used:\n                return False\n            mapping[c1] = c2\n            used.add(c2)\n    \n    return True", "solution_func": "def g(s1 = 'paper', s2 = 'title'):\n    \"\"\"\n    Generate two isomorphic strings.\n    \"\"\"\n    return s1, s2", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target sum, find all unique combinations in nums where the candidate numbers sum to target.\n\n    Each number in nums may only be used once in the combination.\n\n    Note:\n    - All numbers (including target) will be positive integers.\n    - The solution set must not contain duplicate combinations.\n\n    Example:\n    Input: nums = [10,1,2,7,6,1,5], target = 8\n    Output: [[1,1,6],[1,2,5],[1,7],[2,6]]\n    \"\"\"\n\n    def backtrack(start, path, target):\n        if target == 0:\n            res.append(path)\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i+1, path+[nums[i]], target-nums[i])\n\n    nums.sort()\n    res = []\n    backtrack(0, [], target)\n    return res\n\ndef g() -> Tuple[List[int], int]:\n    nums = [10,1,2,7,6,1,5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1,1,6],[1,2,5],[1,7],[2,6]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 492, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given an array of integers nums and a target sum, find all unique combinations in nums where the candidate numbers sum to target.\n\n    Each number in nums may only be used once in the combination.\n\n    Note:\n    - All numbers (including target) will be positive integers.\n    - The solution set must not contain duplicate combinations.\n\n    Example:\n    Input: nums = [10,1,2,7,6,1,5], target = 8\n    Output: [[1,1,6],[1,2,5],[1,7],[2,6]]\n    \"\"\"\n\n    def backtrack(start, path, target):\n        if target == 0:\n            res.append(path)\n            return\n        if target < 0:\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            backtrack(i+1, path+[nums[i]], target-nums[i])\n\n    nums.sort()\n    res = []\n    backtrack(0, [], target)\n    return res", "solution_func": "def g() -> Tuple[List[int], int]:\n    nums = [10,1,2,7,6,1,5]\n    target = 8\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n    The subarray must contain at least one number.\n\n    Example:\n    Input: nums = [2,3,-2,4]\n    Output: 6\n\n    Explanation: The subarray [2,3] has the maximum product of 6.\n    \"\"\"\n\n    max_product = float('-inf')  # Initialize the maximum product to negative infinity\n\n    for i in range(len(nums)):\n        current_product = 1\n\n        for j in range(i, len(nums)):\n            current_product *= nums[j]  # Multiply the current element to the current product\n\n            if current_product > max_product:\n                max_product = current_product  # Update the maximum product if the current product is greater\n\n    return max_product\n\ndef g():\n    nums = [2,3,-2,4]\n    return nums\n\nassert f(g()) == 6\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "idx_generation": 493, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers nums, find the maximum product of a subarray.\n    The subarray must contain at least one number.\n\n    Example:\n    Input: nums = [2,3,-2,4]\n    Output: 6\n\n    Explanation: The subarray [2,3] has the maximum product of 6.\n    \"\"\"\n\n    max_product = float('-inf')  # Initialize the maximum product to negative infinity\n\n    for i in range(len(nums)):\n        current_product = 1\n\n        for j in range(i, len(nums)):\n            current_product *= nums[j]  # Multiply the current element to the current product\n\n            if current_product > max_product:\n                max_product = current_product  # Update the maximum product if the current product is greater\n\n    return max_product", "solution_func": "def g():\n    nums = [2,3,-2,4]\n    return nums", "map_ix": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the sum of all the previous elements in the list.\n\n    Example:\n    Input: nums = [1,2,3,4,5]\n    Output: [1, 3, 6, 10, 15]\n\n    Explanation: The sum of the previous elements for each element in the list is [1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5] = [1, 3, 6, 10, 15].\n    \"\"\"\n\n    prefix_sum = []\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        prefix_sum.append(current_sum)\n\n    return prefix_sum\n\ndef g():\n    nums = [1,2,3,4,5]\n    return nums\n\nassert f(g()) == [1, 3, 6, 10, 15]\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 493, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers nums, return a new list where each element is the sum of all the previous elements in the list.\n\n    Example:\n    Input: nums = [1,2,3,4,5]\n    Output: [1, 3, 6, 10, 15]\n\n    Explanation: The sum of the previous elements for each element in the list is [1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5] = [1, 3, 6, 10, 15].\n    \"\"\"\n\n    prefix_sum = []\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        prefix_sum.append(current_sum)\n\n    return prefix_sum", "solution_func": "def g():\n    nums = [1,2,3,4,5]\n    return nums", "map_ix": [1, 1, 0, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return all possible combinations of numbers that add up to the target.\n    Each number in nums may only be used once in each combination.\n\n    Example:\n    Input: nums = [10,1,2,7,6,1,5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation:\n    1 + 1 + 6 = 8\n    1 + 2 + 5 = 8\n    1 + 7 = 8\n    2 + 6 = 8\n    \"\"\"\n\n    def backtrack(start, current_sum, current_combination):\n        if current_sum == target:\n            combinations.append(current_combination[:])\n            return\n        if current_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i], current_combination)\n            current_combination.pop()\n\n    nums.sort()\n    combinations = []\n    backtrack(0, 0, [])\n    return combinations\n\ndef g():\n    nums = [10,1,2,7,6,1,5]\n    target = 8\n    return nums, target\n\nassert f(*g()) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 493, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[List[int]]:\n    \"\"\"\n    Given a list of integers nums and a target integer, return all possible combinations of numbers that add up to the target.\n    Each number in nums may only be used once in each combination.\n\n    Example:\n    Input: nums = [10,1,2,7,6,1,5], target = 8\n    Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n\n    Explanation:\n    1 + 1 + 6 = 8\n    1 + 2 + 5 = 8\n    1 + 7 = 8\n    2 + 6 = 8\n    \"\"\"\n\n    def backtrack(start, current_sum, current_combination):\n        if current_sum == target:\n            combinations.append(current_combination[:])\n            return\n        if current_sum > target:\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            current_combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i], current_combination)\n            current_combination.pop()\n\n    nums.sort()\n    combinations = []\n    backtrack(0, 0, [])\n    return combinations", "solution_func": "def g():\n    nums = [10,1,2,7,6,1,5]\n    target = 8\n    return nums, target", "map_ix": [0, 1, 0, 0, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of two numbers that are adjacent in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n\n    Hint: Sort the list in ascending order and find the maximum product of adjacent numbers.\n    \"\"\"\n\n    nums.sort()\n    max_product = float('-inf')\n\n    for i in range(1, len(nums)):\n        product = nums[i] * nums[i-1]\n        max_product = max(max_product, product)\n\n    return max_product\n\ndef g():\n    return [1, 2, 3, 4, 5]\n\nassert f(*g()) == 20\n\n", "emb": null, "idx_generation": 493, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of numbers, find the maximum product of two numbers that are adjacent in the list.\n    Return the maximum product.\n\n    Example:\n    Input: [1, 2, 3, 4, 5]\n    Output: 20\n\n    Hint: Sort the list in ascending order and find the maximum product of adjacent numbers.\n    \"\"\"\n\n    nums.sort()\n    max_product = float('-inf')\n\n    for i in range(1, len(nums)):\n        product = nums[i] * nums[i-1]\n        max_product = max(max_product, product)\n\n    return max_product", "solution_func": "def g():\n    return [1, 2, 3, 4, 5]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Hint: Use a sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n\n    if len(s) == 0:\n        return 0\n\n    max_length = 0\n    start = 0\n    visited = {}\n\n    for end in range(len(s)):\n        if s[end] in visited and start <= visited[s[end]]:\n            start = visited[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n\n        visited[s[end]] = end\n\n    return max_length\n\ndef g():\n    return \"abcabcbb\"\n\nassert f(*g()) == 3\n\n", "emb": null, "idx_generation": 493, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> int:\n    \"\"\"\n    Given a string, find the length of the longest substring without repeating characters.\n    Return the length of the longest substring.\n\n    Example:\n    Input: \"abcabcbb\"\n    Output: 3\n\n    Hint: Use a sliding window approach to find the longest substring without repeating characters.\n    \"\"\"\n\n    if len(s) == 0:\n        return 0\n\n    max_length = 0\n    start = 0\n    visited = {}\n\n    for end in range(len(s)):\n        if s[end] in visited and start <= visited[s[end]]:\n            start = visited[s[end]] + 1\n        else:\n            max_length = max(max_length, end - start + 1)\n\n        visited[s[end]] = end\n\n    return max_length", "solution_func": "def g():\n    return \"abcabcbb\"", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    Return the maximum sum.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 8\n\n    Hint: Use dynamic programming to calculate the maximum sum of a path at each cell.\n    \"\"\"\n\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]\n\ndef g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(*g()) == 8\n\n", "emb": null, "idx_generation": 493, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of non-negative integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    Return the maximum sum.\n\n    Example:\n    Input:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n    Output: 8\n\n    Hint: Use dynamic programming to calculate the maximum sum of a path at each cell.\n    \"\"\"\n\n    if len(grid) == 0 or len(grid[0]) == 0:\n        return 0\n\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[rows-1][cols-1]", "solution_func": "def g():\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that XOR to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    arr (List[int]): The list of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that XOR to the target value.\n    \"\"\"\n\n    xor_values = {}\n    for i, num in enumerate(arr):\n        xor_value = target ^ num\n        if xor_value in xor_values:\n            return [xor_values[xor_value], i]\n        xor_values[num] = i\n\n    return []\n\ndef g():\n    arr = [2, 7, 9, 3, 5]\n    target = 14\n    return arr, target\n\nassert f(*g()) == [2, 3]\n", "emb": null, "idx_generation": 493, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that XOR to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    arr (List[int]): The list of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that XOR to the target value.\n    \"\"\"\n\n    xor_values = {}\n    for i, num in enumerate(arr):\n        xor_value = target ^ num\n        if xor_value in xor_values:\n            return [xor_values[xor_value], i]\n        xor_values[num] = i\n\n    return []", "solution_func": "def g():\n    arr = [2, 7, 9, 3, 5]\n    target = 14\n    return arr, target", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among all strings.\n\n    Args:\n    strings (List[str]): The list of strings.\n\n    Returns:\n    str: The longest common prefix among all strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n    prefix = \"\"\n    for i in range(min_length):\n        char = strings[0][i]\n        if all(s[i] == char for s in strings):\n            prefix += char\n        else:\n            break\n\n    return prefix\n\ndef g():\n    strings = [\"flower\", \"flow\", \"flight\"]\n    return strings\n\nassert f(g()) == \"fl\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(strings: List[str]) -> str:\n    \"\"\"\n    Given a list of strings, find the longest common prefix among all strings.\n\n    Args:\n    strings (List[str]): The list of strings.\n\n    Returns:\n    str: The longest common prefix among all strings.\n    \"\"\"\n    if not strings:\n        return \"\"\n\n    min_length = min(len(s) for s in strings)\n    prefix = \"\"\n    for i in range(min_length):\n        char = strings[0][i]\n        if all(s[i] == char for s in strings):\n            prefix += char\n        else:\n            break\n\n    return prefix", "solution_func": "def g():\n    strings = [\"flower\", \"flow\", \"flight\"]\n    return strings", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    nums (List[int]): The list of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target value.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []\n\ndef g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a list of integers and a target value, find two numbers in the list that add up to the target value.\n    Return the indices of the two numbers in ascending order.\n\n    Args:\n    nums (List[int]): The list of integers.\n    target (int): The target value.\n\n    Returns:\n    List[int]: The indices of the two numbers that add up to the target value.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n\n    return []", "solution_func": "def g():\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n\n    The target element 9 is found at index 4.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n    return nums, target\n\nassert f(*g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 493, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target element using binary search.\n    If the target element is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n\n    The target element 9 is found at index 4.\n    Therefore, the function should return 4.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9, 11, 13]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with the words sorted in lexicographic order.\n\n    Example:\n    Input:\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n\n    Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\"]\n    \"\"\"\n    return sorted(words)\n\ndef g():\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n    return words\n\nassert f(g()) == [\"apple\", \"banana\", \"cherry\", \"date\"]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return a new list with the words sorted in lexicographic order.\n\n    Example:\n    Input:\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n\n    Output:\n    [\"apple\", \"banana\", \"cherry\", \"date\"]\n    \"\"\"\n    return sorted(words)", "solution_func": "def g():\n    words = [\"banana\", \"apple\", \"cherry\", \"date\"]\n    return words", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    Example:\n    Input:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n    \"\"\"\n    return sorted(s) == sorted(t)\n\ndef g():\n    s = \"listen\"\n    t = \"silent\"\n    return s, t\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str, t: str) -> bool:\n    \"\"\"\n    Given two strings s and t, check if t is an anagram of s.\n\n    Example:\n    Input:\n    s = \"listen\"\n    t = \"silent\"\n\n    Output:\n    True\n    \"\"\"\n    return sorted(s) == sorted(t)", "solution_func": "def g():\n    s = \"listen\"\n    t = \"silent\"\n    return s, t", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list with words that start with the given prefix.\n\n    Example:\n    Input:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n\n    Output:\n    [\"banana\"]\n    \"\"\"\n    return [word for word in words if word.startswith(prefix)]\n\ndef g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n    return words, prefix\n\nassert f(*g()) == [\"banana\"]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Given a list of words and a prefix, return a new list with words that start with the given prefix.\n\n    Example:\n    Input:\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n\n    Output:\n    [\"banana\"]\n    \"\"\"\n    return [word for word in words if word.startswith(prefix)]", "solution_func": "def g():\n    words = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    prefix = \"b\"\n    return words, prefix", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers in ascending order, determine if there are two numbers in the array that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 10\n    The function should return True since 1 + 9 = 10.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\ndef g():\n    arr = [1, 3, 5, 7, 9]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted array of integers in ascending order, determine if there are two numbers in the array that add up to the target.\n    Return True if such numbers exist, otherwise return False.\n\n    Example:\n    arr = [1, 3, 5, 7, 9]\n    target = 10\n    The function should return True since 1 + 9 = 10.\n    \"\"\"\n\n    left = 0\n    right = len(arr) - 1\n\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return True\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g():\n    arr = [1, 3, 5, 7, 9]\n    target = 10\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the sum of each row.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The function should return [6, 15, 24] since the sum of each row is [1+2+3, 4+5+6, 7+8+9].\n    \"\"\"\n\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n\n    return row_sums\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [6, 15, 24]\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the sum of each row.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    The function should return [6, 15, 24] since the sum of each row is [1+2+3, 4+5+6, 7+8+9].\n    \"\"\"\n\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n\n    return row_sums", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(string: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, reverse the order of the words in the string.\n    Return the modified string.\n\n    Example:\n    string = \"hello world\"\n    The function should return \"world hello\" since the words are reversed.\n    \"\"\"\n\n    words = string.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string\n\ndef g():\n    string = \"hello world\"\n    k = 3\n    return string, k\n\nassert f(*g()) == \"world hello\"\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom typing import List\n\ndef f(string: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, reverse the order of the words in the string.\n    Return the modified string.\n\n    Example:\n    string = \"hello world\"\n    The function should return \"world hello\" since the words are reversed.\n    \"\"\"\n\n    words = string.split()\n    reversed_words = words[::-1]\n    reversed_string = \" \".join(reversed_words)\n\n    return reversed_string", "solution_func": "def g():\n    string = \"hello world\"\n    k = 3\n    return string, k", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 1, 5, 2, 4]\n    k = 2\n\n    The second largest element in the list is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]\n\ndef g() -> List[int, int]:\n    \"\"\"\n    Generate a list of integers and the value of k.\n    \"\"\"\n    return [3, 1, 5, 2, 4], 2\n\nassert f(*g()) == 4\n", "emb": null, "idx_generation": 494, "target_skills": [0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], k: int) -> int:\n    \"\"\"\n    Given a list of integers, find the kth largest element in the list.\n\n    Example:\n    nums = [3, 1, 5, 2, 4]\n    k = 2\n\n    The second largest element in the list is 4.\n\n    Therefore, the function should return 4.\n    \"\"\"\n    nums.sort(reverse=True)\n    return nums[k-1]", "solution_func": "def g() -> List[int, int]:\n    \"\"\"\n    Generate a list of integers and the value of k.\n    \"\"\"\n    return [3, 1, 5, 2, 4], 2", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, reverse the order of the first k characters in the string.\n\n    Example:\n    s = \"abcdefg\"\n    k = 3\n\n    Reverse the first 3 characters: \"cba\".\n    The remaining characters are \"defg\".\n\n    Therefore, the function should return \"cbaefdg\".\n    \"\"\"\n    return s[:k][::-1] + s[k:]\n\ndef g() -> List[str, int]:\n    \"\"\"\n    Generate a string and the value of k.\n    \"\"\"\n    return \"abcdefg\", 3\n\nassert f(*g()) == \"cbaefdg\"\n", "emb": null, "idx_generation": 494, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\ndef f(s: str, k: int) -> str:\n    \"\"\"\n    Given a string and an integer k, reverse the order of the first k characters in the string.\n\n    Example:\n    s = \"abcdefg\"\n    k = 3\n\n    Reverse the first 3 characters: \"cba\".\n    The remaining characters are \"defg\".\n\n    Therefore, the function should return \"cbaefdg\".\n    \"\"\"\n    return s[:k][::-1] + s[k:]", "solution_func": "def g() -> List[str, int]:\n    \"\"\"\n    Generate a string and the value of k.\n    \"\"\"\n    return \"abcdefg\", 3", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of numbers in the list that add up to the target value.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to 9 are 2 and 7.\n\n    Therefore, the function should return True.\n    \"\"\"\n    num_set = set()\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return True\n        num_set.add(num)\n    return False\n\ndef g() -> List[int, int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 494, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of integers and a target value, check if there exists a pair of numbers in the list that add up to the target value.\n\n    Example:\n    nums = [2, 7, 11, 15]\n    target = 9\n\n    The two numbers that add up to 9 are 2 and 7.\n\n    Therefore, the function should return True.\n    \"\"\"\n    num_set = set()\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return True\n        num_set.add(num)\n    return False", "solution_func": "def g() -> List[int, int]:\n    \"\"\"\n    Generate a list of integers and a target value.\n    \"\"\"\n    return [2, 7, 11, 15], 9", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, return True if the target number is present in the list, \n    and False otherwise. Use binary search to optimize the search process.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11, 13, 15], target = 7\n    Output: True\n\n    Explanation:\n    The target number 7 is present in the list [1, 3, 5, 7, 9, 11, 13, 15], hence the output is True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\ndef g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]\n\nassert f(g(), 7)\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 494, "target_skills": [0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target number, return True if the target number is present in the list, \n    and False otherwise. Use binary search to optimize the search process.\n\n    Example:\n    Input: nums = [1, 3, 5, 7, 9, 11, 13, 15], target = 7\n    Output: True\n\n    Explanation:\n    The target number 7 is present in the list [1, 3, 5, 7, 9, 11, 13, 15], hence the output is True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False", "solution_func": "def g() -> List[int]:\n    return [1, 3, 5, 7, 9, 11, 13, 15]", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29 (1 -> 4 -> 7 -> 8 -> 9)\n\n    matrix = [\n        [-1, 2, 3],\n        [4, -5, 6],\n        [7, 8, 9]\n    ]\n    Output: 17 (-1 -> 4 -> -5 -> 6 -> 9)\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]\n\ndef g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix\n\nassert f(g()) == 29\n\n", "emb": [1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 495, "target_skills": [0, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> int:\n    \"\"\"\n    Given a matrix of integers, find the maximum sum of a path from the top-left cell to the bottom-right cell.\n    The path can only move down or right.\n\n    Example:\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    Output: 29 (1 -> 4 -> 7 -> 8 -> 9)\n\n    matrix = [\n        [-1, 2, 3],\n        [4, -5, 6],\n        [7, 8, 9]\n    ]\n    Output: 17 (-1 -> 4 -> -5 -> 6 -> 9)\n    \"\"\"\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    return dp[rows - 1][cols - 1]", "solution_func": "def g(matrix: List[List[int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):\n    return matrix", "map_ix": [1, 1, 1, 1, 0, 1, 0, 1, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    Example:\n    s = \"babad\"\n    Output: \"bab\" or \"aba\"\n\n    s = \"cbbd\"\n    Output: \"bb\"\n    \"\"\"\n    if not s:\n        return \"\"\n\n    n = len(s)\n    start = 0\n    end = 0\n\n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    for i in range(n):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        length = max(len1, len2)\n        if length > end - start:\n            start = i - (length - 1) // 2\n            end = i + length // 2\n\n    return s[start:end + 1]\n\ndef g(s: str = \"babad\"):\n    return s\n\nassert f(g()) == \"bab\"\n\n", "emb": null, "idx_generation": 495, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string s, return the longest palindromic substring in s.\n\n    Example:\n    s = \"babad\"\n    Output: \"bab\" or \"aba\"\n\n    s = \"cbbd\"\n    Output: \"bb\"\n    \"\"\"\n    if not s:\n        return \"\"\n\n    n = len(s)\n    start = 0\n    end = 0\n\n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    for i in range(n):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        length = max(len1, len2)\n        if length > end - start:\n            start = i - (length - 1) // 2\n            end = i + length // 2\n\n    return s[start:end + 1]", "solution_func": "def g(s: str = \"babad\"):\n    return s", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a collection of integers that might contain duplicates, return all possible unique permutations.\n\n    Example:\n    nums = [1, 1, 2]\n    Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n    \"\"\"\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result\n\ndef g(nums: List[int] = [1, 1, 2]):\n    return nums\n\nassert f(g()) == [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n\n", "emb": [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a collection of integers that might contain duplicates, return all possible unique permutations.\n\n    Example:\n    nums = [1, 1, 2]\n    Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n    \"\"\"\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result", "solution_func": "def g(nums: List[int] = [1, 1, 2]):\n    return nums", "map_ix": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray is 6, which corresponds to the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nassert f(g()) == 6\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0], "idx_generation": 495, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of any subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The maximum sum of a subarray is 6, which corresponds to the subarray [4, -1, 2, 1].\n\n    Therefore, the function should return 6.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [-2, 1, -3, 4, -1, 2, 1, -5, 4]", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 1]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n\n    Example:\n    s = \"hello world\"\n\n    The reversed order of the words is \"world hello\".\n\n    Therefore, the function should return \"world hello\".\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_s = ' '.join(reversed_words)\n    \n    return reversed_s\n\ndef g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello world\"\n\nassert f(g()) == \"world hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(s: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string.\n\n    Example:\n    s = \"hello world\"\n\n    The reversed order of the words is \"world hello\".\n\n    Therefore, the function should return \"world hello\".\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_s = ' '.join(reversed_words)\n    \n    return reversed_s", "solution_func": "def g() -> str:\n    \"\"\"\n    Generate a string.\n    \"\"\"\n    return \"hello world\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7, which corresponds to the path 1 -> 3 -> 1 -> 1 -> 1.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initialize the DP array\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Fill in the DP array\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner.\n    You can only move down or right at any point in time.\n\n    Example:\n    grid = [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]\n\n    The minimum path sum is 7, which corresponds to the path 1 -> 3 -> 1 -> 1 -> 1.\n\n    Therefore, the function should return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Initialize the DP array\n    dp = [[0] * cols for _ in range(rows)]\n    \n    # Fill in the DP array\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + grid[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a grid of integers.\n    \"\"\"\n    return [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]", "map_ix": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target integer, determine if there are two numbers in the array that add up to the target.\n\n    Example:\n    Input: arr = [2, 4, 6, 8], target = 10\n    Output: True\n    Explanation: 2 + 8 = 10\n\n    Input: arr = [3, 5, 7, 9], target = 12\n    Output: False\n    Explanation: No two numbers add up to 12.\n    \"\"\"\n    complement_set = set()\n    for num in arr:\n        if num in complement_set:\n            return True\n        complement = target - num\n        complement_set.add(complement)\n    return False\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target integer.\n    \"\"\"\n    arr = [2, 4, 6, 8]\n    target = 10\n    return arr, target\n\nassert f(*g()) == True\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Given an array of integers and a target integer, determine if there are two numbers in the array that add up to the target.\n\n    Example:\n    Input: arr = [2, 4, 6, 8], target = 10\n    Output: True\n    Explanation: 2 + 8 = 10\n\n    Input: arr = [3, 5, 7, 9], target = 12\n    Output: False\n    Explanation: No two numbers add up to 12.\n    \"\"\"\n    complement_set = set()\n    for num in arr:\n        if num in complement_set:\n            return True\n        complement = target - num\n        complement_set.add(complement)\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate an array of integers and a target integer.\n    \"\"\"\n    arr = [2, 4, 6, 8]\n    target = 10\n    return arr, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, replace every element that is even with the sum of all the odd elements in the array.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: [9, 9, 9, 9, 9, 9]\n    Explanation: The sum of all odd elements is 9. All even elements are replaced by 9.\n\n    Input: nums = [2, 4, 6, 8]\n    Output: [0, 0, 0, 0]\n    Explanation: There are no odd elements, so all even elements are replaced by 0.\n    \"\"\"\n    odd_sum = sum([num for num in nums if num % 2 != 0])\n    return [odd_sum if num % 2 == 0 else num for num in nums]\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums\n\nassert f(g()) == [9, 9, 9, 9, 9, 9]\n", "emb": null, "idx_generation": 495, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given an array of integers, replace every element that is even with the sum of all the odd elements in the array.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5, 6]\n    Output: [9, 9, 9, 9, 9, 9]\n    Explanation: The sum of all odd elements is 9. All even elements are replaced by 9.\n\n    Input: nums = [2, 4, 6, 8]\n    Output: [0, 0, 0, 0]\n    Explanation: There are no odd elements, so all even elements are replaced by 0.\n    \"\"\"\n    odd_sum = sum([num for num in nums if num % 2 != 0])\n    return [odd_sum if num % 2 == 0 else num for num in nums]", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate an array of integers.\n    \"\"\"\n    nums = [1, 2, 3, 4, 5, 6]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it by 90 degrees clockwise.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Input: matrix = [[1, 2], [3, 4]]\n    Output: [[3, 1], [4, 2]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix\n\ndef g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix, rotate it by 90 degrees clockwise.\n\n    Example:\n    Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Input: matrix = [[1, 2], [3, 4]]\n    Output: [[3, 1], [4, 2]]\n    \"\"\"\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n    return matrix", "solution_func": "def g() -> List[List[int]]:\n    \"\"\"\n    Generate a matrix.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if there are two numbers in the list that add up to the target, and False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14\n    Output: True\n\n    Explanation:\n    The numbers 4 and 10 add up to the target value of 14.\n    Hence, the output is True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\n\ndef g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where there are two numbers in the list that add up to the target.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14\n\nassert f(*g()) == True\n\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 495, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a sorted list of integers and a target value, return True if there are two numbers in the list that add up to the target, and False otherwise.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 14\n    Output: True\n\n    Explanation:\n    The numbers 4 and 10 add up to the target value of 14.\n    Hence, the output is True.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return True\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return False", "solution_func": "def g() -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value where there are two numbers in the list that add up to the target.\n    \"\"\"\n    return [2, 4, 6, 8, 10], 14", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix 90 degrees clockwise in-place.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    After rotating the matrix 90 degrees clockwise, the new matrix should be:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Return the rotated matrix.\n\n    Hint: Use the transpose and reverse row operations.\n    \"\"\"\n    n = len(matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n\n    return matrix\n\ndef g():\n    \"\"\"\n    Generate an n x n matrix.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix\n\nassert f(g()) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given an n x n matrix, rotate the matrix 90 degrees clockwise in-place.\n\n    Example:\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    After rotating the matrix 90 degrees clockwise, the new matrix should be:\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    Return the rotated matrix.\n\n    Hint: Use the transpose and reverse row operations.\n    \"\"\"\n    n = len(matrix)\n\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # Reverse each row\n    for i in range(n):\n        matrix[i] = matrix[i][::-1]\n\n    return matrix", "solution_func": "def g():\n    \"\"\"\n    Generate an n x n matrix.\n    \"\"\"\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    return matrix", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], and the sum is 6.\n\n    Return the maximum sum.\n\n    Hint: Use Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums\n\nassert f(g()) == 6\n\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 496, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the maximum sum of any contiguous subarray.\n\n    Example:\n    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n    The contiguous subarray with the maximum sum is [4, -1, 2, 1], and the sum is 6.\n\n    Return the maximum sum.\n\n    Hint: Use Kadane's algorithm.\n    \"\"\"\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum", "solution_func": "def g(nums=[-2, 1, -3, 4, -1, 2, 1, -5, 4]):\n    return nums", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subsequence that forms an arithmetic progression.\n\n    Example:\n    nums = [1, 2, 3, 5, 8, 13]\n\n    The subsequence [1, 3, 8] forms an arithmetic progression, with a common difference of 2.\n\n    Therefore, the function should return True.\n\n    Hint: Use a set to store the differences between consecutive elements.\n    \"\"\"\n    diffs = set()\n\n    for i in range(len(nums) - 1):\n        diff = nums[i+1] - nums[i]\n        if diff in diffs:\n            return True\n        diffs.add(diff)\n\n    return False\n\ndef g(nums=[1, 2, 3, 5, 8, 13]):\n    return nums\n\nassert f(g()) == True\n\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> bool:\n    \"\"\"\n    Given a list of integers, determine if there exists a subsequence that forms an arithmetic progression.\n\n    Example:\n    nums = [1, 2, 3, 5, 8, 13]\n\n    The subsequence [1, 3, 8] forms an arithmetic progression, with a common difference of 2.\n\n    Therefore, the function should return True.\n\n    Hint: Use a set to store the differences between consecutive elements.\n    \"\"\"\n    diffs = set()\n\n    for i in range(len(nums) - 1):\n        diff = nums[i+1] - nums[i]\n        if diff in diffs:\n            return True\n        diffs.add(diff)\n\n    return False", "solution_func": "def g(nums=[1, 2, 3, 5, 8, 13]):\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group the anagrams together and return the grouped anagrams.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n    The anagrams in the list are:\n    [\"eat\", \"tea\", \"ate\"]\n    [\"tan\", \"nat\"]\n    [\"bat\"]\n\n    Therefore, the function should return:\n    [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n    \"\"\"\n    anagrams = {}\n    \n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        \n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n    \n    return list(anagrams.values())\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group the anagrams together and return the grouped anagrams.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n    The anagrams in the list are:\n    [\"eat\", \"tea\", \"ate\"]\n    [\"tan\", \"nat\"]\n    [\"bat\"]\n\n    Therefore, the function should return:\n    [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n    \"\"\"\n    anagrams = {}\n    \n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        \n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n    \n    return list(anagrams.values())", "solution_func": "def g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of islands.\n    An island is formed by connecting adjacent lands horizontally or vertically.\n    Assume all grid cells are either '0' (water) or '1' (land).\n\n    Example:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n\n    The grid represents the following islands:\n    1 1 0 0 0\n    1 1 0 0 0\n    0 0 1 0 0\n    0 0 0 1 1\n\n    Therefore, the function should return 3.\n    \"\"\"\n    def dfs(i, j, grid):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'\n        \n        dfs(i+1, j, grid)\n        dfs(i-1, j, grid)\n        dfs(i, j+1, grid)\n        dfs(i, j-1, grid)\n    \n    count = 0\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(i, j, grid)\n                count += 1\n    \n    return count\n\ndef g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n    return grid\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0], "idx_generation": 496, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[str]]) -> int:\n    \"\"\"\n    Given a grid of characters, determine the number of islands.\n    An island is formed by connecting adjacent lands horizontally or vertically.\n    Assume all grid cells are either '0' (water) or '1' (land).\n\n    Example:\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n\n    The grid represents the following islands:\n    1 1 0 0 0\n    1 1 0 0 0\n    0 0 1 0 0\n    0 0 0 1 1\n\n    Therefore, the function should return 3.\n    \"\"\"\n    def dfs(i, j, grid):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'\n        \n        dfs(i+1, j, grid)\n        dfs(i-1, j, grid)\n        dfs(i, j+1, grid)\n        dfs(i, j-1, grid)\n    \n    count = 0\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(i, j, grid)\n                count += 1\n    \n    return count", "solution_func": "def g():\n    grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1']\n    ]\n    return grid", "map_ix": [0, 0, 1, 0, 0, 0, 1, 1, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses string.\n    A valid parentheses string is one in which each open parenthesis '(' is followed\n    by a corresponding closing parenthesis ')'.\n\n    Example:\n    s = \"((()))\"\n\n    The string is a valid parentheses string.\n\n    Therefore, the function should return True.\n    \"\"\"\n    stack = []\n    \n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\ndef g():\n    s = \"((()))\"\n    return s\n\nassert f(g())", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 496, "target_skills": [0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a valid parentheses string.\n    A valid parentheses string is one in which each open parenthesis '(' is followed\n    by a corresponding closing parenthesis ')'.\n\n    Example:\n    s = \"((()))\"\n\n    The string is a valid parentheses string.\n\n    Therefore, the function should return True.\n    \"\"\"\n    stack = []\n    \n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0", "solution_func": "def g():\n    s = \"((()))\"\n    return s", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] and nums[1] is equal to the target 9.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target\n\nassert f(*g()) == [0, 1]\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 496, "target_skills": [0, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target number, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in ascending order.\n\n    Example:\n    Input: nums = [2, 7, 11, 15], target = 9\n    Output: [0, 1]\n\n    Explanation: The sum of nums[0] and nums[1] is equal to the target 9.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g() -> List[int]:\n    nums = [2, 7, 11, 15]\n    target = 9\n    return nums, target", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose sum is divisible by 3.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 16\n\n    Explanation: There are 16 subsets whose sum is divisible by 3: [], [1], [2], [1, 2], [4], [1, 4], [2, 4], [1, 2, 4], [5], [1, 5], [2, 5], [1, 2, 5], [4, 5], [1, 4, 5], [2, 4, 5], [1, 2, 4, 5].\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(1, 2 ** n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += nums[j]\n        if subset_sum % 3 == 0:\n            count += 1\n\n    return count\n\ndef g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums\n\nassert f(g()) == 16\n\n", "emb": null, "idx_generation": 496, "target_skills": [0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the number of subsets whose sum is divisible by 3.\n\n    Example:\n    Input: nums = [1, 2, 3, 4, 5]\n    Output: 16\n\n    Explanation: There are 16 subsets whose sum is divisible by 3: [], [1], [2], [1, 2], [4], [1, 4], [2, 4], [1, 2, 4], [5], [1, 5], [2, 5], [1, 2, 5], [4, 5], [1, 4, 5], [2, 4, 5], [1, 2, 4, 5].\n    \"\"\"\n\n    count = 0\n    n = len(nums)\n\n    for i in range(1, 2 ** n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += nums[j]\n        if subset_sum % 3 == 0:\n            count += 1\n\n    return count", "solution_func": "def g() -> List[int]:\n    nums = [1, 2, 3, 4, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value between any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 7, 11, 15]\n    Output: 4\n\n    Explanation: The minimum XOR value is obtained by taking the XOR of 3 and 7, which is equal to 4.\n    \"\"\"\n\n    min_xor = float('inf')\n\n    nums.sort()\n\n    for i in range(len(nums) - 1):\n        xor_val = nums[i] ^ nums[i+1]\n        min_xor = min(min_xor, xor_val)\n\n    return min_xor\n\ndef g() -> List[int]:\n    nums = [3, 7, 11, 15]\n    return nums\n\nassert f(g()) == 4\n\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the minimum XOR value between any two numbers in the list.\n\n    Example:\n    Input: nums = [3, 7, 11, 15]\n    Output: 4\n\n    Explanation: The minimum XOR value is obtained by taking the XOR of 3 and 7, which is equal to 4.\n    \"\"\"\n\n    min_xor = float('inf')\n\n    nums.sort()\n\n    for i in range(len(nums) - 1):\n        xor_val = nums[i] ^ nums[i+1]\n        min_xor = min(min_xor, xor_val)\n\n    return min_xor", "solution_func": "def g() -> List[int]:\n    nums = [3, 7, 11, 15]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if it is possible to divide the given list of integers into two non-empty sublists,\n    such that the sum of their elements is equal to the target.\n    \"\"\"\n    def dp(i: int, curr_sum: int, target: int) -> bool:\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n        if (i, curr_sum) in memo:\n            return memo[(i, curr_sum)]\n        memo[(i, curr_sum)] = dp(i + 1, curr_sum + nums[i], target) or dp(i + 1, curr_sum, target)\n        return memo[(i, curr_sum)]\n\n    memo = {}\n    return dp(0, 0, target)\n\ndef g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be divided into two non-empty sublists,\n    such that the sum of their elements is equal to the target.\n    \"\"\"\n    def generate_list(target: int) -> List[int]:\n        if target <= 0:\n            return []\n        return [target // 2] + generate_list(target // 2)\n\n    return generate_list(target) + nums + generate_list(target)\n\nassert f(g([1, 2, 3], 2), 2)\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 496, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Determine if it is possible to divide the given list of integers into two non-empty sublists,\n    such that the sum of their elements is equal to the target.\n    \"\"\"\n    def dp(i: int, curr_sum: int, target: int) -> bool:\n        if curr_sum == target:\n            return True\n        if i == len(nums) or curr_sum > target:\n            return False\n        if (i, curr_sum) in memo:\n            return memo[(i, curr_sum)]\n        memo[(i, curr_sum)] = dp(i + 1, curr_sum + nums[i], target) or dp(i + 1, curr_sum, target)\n        return memo[(i, curr_sum)]\n\n    memo = {}\n    return dp(0, 0, target)", "solution_func": "def g(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Generate a list of integers that can be divided into two non-empty sublists,\n    such that the sum of their elements is equal to the target.\n    \"\"\"\n    def generate_list(target: int) -> List[int]:\n        if target <= 0:\n            return []\n        return [target // 2] + generate_list(target // 2)\n\n    return generate_list(target) + nums + generate_list(target)", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    Input: 10\n    Output: 23\n    Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6 and 9. Their sum is 23.\n    \"\"\"\n\n    result = 0\n\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n\n    return result\n\ndef g():\n    return 10\n\nassert f(g()) == 23\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the sum of all the multiples of 3 or 5 below n.\n\n    Example:\n    Input: 10\n    Output: 23\n    Explanation: The multiples of 3 or 5 below 10 are 3, 5, 6 and 9. Their sum is 23.\n    \"\"\"\n\n    result = 0\n\n    for i in range(1, n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n\n    return result", "solution_func": "def g():\n    return 10", "map_ix": [1, 1, 0, 1, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n    Explanation: \"racecar\" is a palindrome.\n\n    Input: \"hello\"\n    Output: False\n    Explanation: \"hello\" is not a palindrome.\n    \"\"\"\n\n    def is_palindrome(left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s)-1)\n\ndef g():\n    return \"racecar\"\n\nassert f(g()) == True\n\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\n\ndef f(s: str) -> bool:\n    \"\"\"\n    Given a string s, determine if it is a palindrome.\n\n    Example:\n    Input: \"racecar\"\n    Output: True\n    Explanation: \"racecar\" is a palindrome.\n\n    Input: \"hello\"\n    Output: False\n    Explanation: \"hello\" is not a palindrome.\n    \"\"\"\n\n    def is_palindrome(left: int, right: int) -> bool:\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return is_palindrome(0, len(s)-1)", "solution_func": "def g():\n    return \"racecar\"", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)\n\ndef g():\n    return 6\n\nassert f(g()) == 8\n\n", "emb": [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find the nth Fibonacci number.\n\n    Example:\n    Input: 6\n    Output: 8\n    Explanation: The 6th Fibonacci number is 8 (0, 1, 1, 2, 3, 5, 8).\n    \"\"\"\n\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        return fibonacci(n-1) + fibonacci(n-2)\n\n    return fibonacci(n)", "solution_func": "def g():\n    return 6", "map_ix": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return (sorted(nums), target)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 497, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given a sorted list of integers and a target value, find two numbers in the list that add up to the target.\n    Return the indices of the two numbers in the list.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        curr_sum = nums[left] + nums[right]\n\n        if curr_sum == target:\n            return [left, right]\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return []", "solution_func": "def g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return (sorted(nums), target)", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    A subarray is a contiguous part of an array. The maximum subarray sum is the sum of the largest possible subarray within the given list.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\ndef g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums\n\nassert f(g()) == True\n", "emb": null, "idx_generation": 497, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum subarray sum.\n\n    A subarray is a contiguous part of an array. The maximum subarray sum is the sum of the largest possible subarray within the given list.\n    \"\"\"\n\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum", "solution_func": "def g(nums: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return nums", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    If the target value is not found in the list, return -1.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return (sorted(nums), target)\n\nassert f(*g()) == True\n", "emb": null, "idx_generation": 497, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers, find the index of the target value using binary search.\n\n    If the target value is not found in the list, return -1.\n    \"\"\"\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g(nums: List[int], target: int) -> Tuple[List[int], int]:\n    \"\"\"\n    Generate a sorted list of integers and a target value.\n    \"\"\"\n    return (sorted(nums), target)", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums, find the index of the target value using binary search.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 8\n    Output: 3\n    Explanation: The target value 8 is found at index 3 in the list.\n\n    Note:\n    - You may assume that the list is sorted in ascending order.\n    - If the target value is not found, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    return [2, 4, 6, 8, 10], 8\n\nassert f(*g()) == 3\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [0, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers nums, find the index of the target value using binary search.\n\n    Example:\n    Input: nums = [2, 4, 6, 8, 10], target = 8\n    Output: 3\n    Explanation: The target value 8 is found at index 3 in the list.\n\n    Note:\n    - You may assume that the list is sorted in ascending order.\n    - If the target value is not found, return -1.\n    \"\"\"\n\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    return [2, 4, 6, 8, 10], 8", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to travel through that cell,\n    find the minimum cost to travel from the top-left corner to the bottom-right corner.\n\n    You can only move down or right at each step.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Note:\n    - You can assume that the grid is rectangular and has at least one cell.\n    - The cost of traveling through a cell will be a positive integer.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n\ndef g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers where each cell represents the cost to travel through that cell,\n    find the minimum cost to travel from the top-left corner to the bottom-right corner.\n\n    You can only move down or right at each step.\n\n    Example:\n    Input: grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n    Output: 7\n    Explanation: The minimum cost path is 1 -> 3 -> 1 -> 1 -> 1, which has a total cost of 7.\n\n    Note:\n    - You can assume that the grid is rectangular and has at least one cell.\n    - The cost of traveling through a cell will be a positive integer.\n    \"\"\"\n\n    m = len(grid)\n    n = len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]", "solution_func": "def g():\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle\n    that can be formed by connecting adjacent buildings.\n\n    Example:\n    Input: heights = [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The maximum area rectangle can be formed by connecting the buildings with heights 5 and 6.\n\n    Note:\n    - The widths of the buildings are all equal to 1.\n    - The list of heights will have at least one building.\n    \"\"\"\n\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area\n\ndef g():\n    return [2, 1, 5, 6, 2, 3]\n\nassert f(g()) == 10\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0], "idx_generation": 497, "target_skills": [4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(heights: List[int]) -> int:\n    \"\"\"\n    Given a list of integers representing the heights of buildings, find the maximum area of a rectangle\n    that can be formed by connecting adjacent buildings.\n\n    Example:\n    Input: heights = [2, 1, 5, 6, 2, 3]\n    Output: 10\n    Explanation: The maximum area rectangle can be formed by connecting the buildings with heights 5 and 6.\n\n    Note:\n    - The widths of the buildings are all equal to 1.\n    - The list of heights will have at least one building.\n    \"\"\"\n\n    stack = [-1]\n    max_area = 0\n\n    for i in range(len(heights)):\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            h = heights[stack.pop()]\n            w = i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        h = heights[stack.pop()]\n        w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n\n    return max_area", "solution_func": "def g():\n    return [2, 1, 5, 6, 2, 3]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list.\n    If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2, since the target number 5 is at index 2.\n\n    If the target number is not found in the list, for example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    The function should return -1, since the target number 10 is not found in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\ndef g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return (nums, target)\n\nassert f(*g()) == 2\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 497, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a sorted list of integers and a target number, find the index of the target number in the list.\n    If the target number is not found, return -1.\n\n    Example:\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n\n    The function should return 2, since the target number 5 is at index 2.\n\n    If the target number is not found in the list, for example:\n    nums = [2, 4, 6, 8]\n    target = 10\n\n    The function should return -1, since the target number 10 is not found in the list.\n    \"\"\"\n    left = 0\n    right = len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1", "solution_func": "def g():\n    nums = [1, 3, 5, 7, 9]\n    target = 5\n    return (nums, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a collection of distinct integers, return all possible subsets (the power set).\n\n    Example:\n    Input: [1, 2, 3]\n    Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n    def backtrack(start, subset):\n        result.append(subset[:])\n        for i in range(start, len(nums)):\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n\n    result = []\n    backtrack(0, [])\n    return result\n\ndef g(nums: List[int] = [1, 2, 3]):\n    return nums\n\nassert f(g()) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "emb": null, "idx_generation": 498, "target_skills": [0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[List[int]]:\n    \"\"\"\n    Given a collection of distinct integers, return all possible subsets (the power set).\n\n    Example:\n    Input: [1, 2, 3]\n    Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n    def backtrack(start, subset):\n        result.append(subset[:])\n        for i in range(start, len(nums)):\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n\n    result = []\n    backtrack(0, [])\n    return result", "solution_func": "def g(nums: List[int] = [1, 2, 3]):\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine the number of unique combinations\n    of numbers in the list that sum up to the target. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n\n    Explanation:\n    The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == 7\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> int:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine the number of unique combinations\n    of numbers in the list that sum up to the target. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output: 7\n\n    Explanation:\n    The possible combinations are: [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [1, 3], [2, 1, 1], [2, 2], [3, 1]\n    \"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n\n    return dp[target]", "solution_func": "def g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target", "map_ix": [1, 1, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine if it is possible to reach the target\n    by repeatedly adding or subtracting any number in the list. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output: True\n\n    Explanation:\n    1 + 1 + 1 + 1 = 4\n    \"\"\"\n    def backtrack(start, current_sum):\n        if current_sum == target:\n            return True\n        for i in range(start, len(nums)):\n            if current_sum + nums[i] <= target:\n                if backtrack(i, current_sum + nums[i]):\n                    return True\n            if current_sum - nums[i] >= target:\n                if backtrack(i, current_sum - nums[i]):\n                    return True\n        return False\n\n    return backtrack(0, 0)\n\ndef g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target\n\nassert f(*g()) == True\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Given a list of non-negative integers and a target integer, determine if it is possible to reach the target\n    by repeatedly adding or subtracting any number in the list. Each number in the list can be used multiple times.\n\n    Example:\n    Input:\n    nums = [1, 2, 3]\n    target = 4\n    Output: True\n\n    Explanation:\n    1 + 1 + 1 + 1 = 4\n    \"\"\"\n    def backtrack(start, current_sum):\n        if current_sum == target:\n            return True\n        for i in range(start, len(nums)):\n            if current_sum + nums[i] <= target:\n                if backtrack(i, current_sum + nums[i]):\n                    return True\n            if current_sum - nums[i] >= target:\n                if backtrack(i, current_sum - nums[i]):\n                    return True\n        return False\n\n    return backtrack(0, 0)", "solution_func": "def g(nums: List[int] = [1, 2, 3], target: int = 4):\n    return nums, target", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are both odd and prime.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return sum(num for num in nums if num % 2 != 0 and is_prime(num))\n\ndef g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 12\n", "emb": null, "idx_generation": 498, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the numbers that are both odd and prime.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return sum(num for num in nums if num % 2 != 0 and is_prime(num))", "solution_func": "def g():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": null}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that contain the letter 'a' and have a length of at least 5 characters.\n    \"\"\"\n    return [word for word in words if 'a' in word and len(word) >= 5]\n\ndef g():\n    return ['apple', 'banana', 'pear', 'kiwi', 'grape']\n\nassert f(g()) == ['apple', 'banana']\n\n", "emb": null, "idx_generation": 498, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(words: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of words, return all the words that contain the letter 'a' and have a length of at least 5 characters.\n    \"\"\"\n    return [word for word in words if 'a' in word and len(word) >= 5]", "solution_func": "def g():\n    return ['apple', 'banana', 'pear', 'kiwi', 'grape']", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, return a new matrix where each element is the bitwise XOR of its row and column index.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    result = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            result[i][j] = i ^ j\n\n    return result\n\ndef g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix\n\nassert f(g()) == [[0, 1, 2], [1, 0, 3], [2, 3, 0]]\n", "emb": [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 0, 0, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Given a matrix of integers, return a new matrix where each element is the bitwise XOR of its row and column index.\n    \"\"\"\n    n = len(matrix)\n    m = len(matrix[0])\n    result = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            result[i][j] = i ^ j\n\n    return result", "solution_func": "def g():\n    matrix = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    return matrix", "map_ix": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent to each other.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[-1]\n\ndef g():\n    nums = [1, 2, 3, 1, 5]\n    return nums\n\nassert f(g()) == 8\n", "emb": null, "idx_generation": 498, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the maximum sum of a subarray with the constraint that no two numbers in the subarray are adjacent to each other.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n    if n == 2:\n        return max(nums[0], nums[1])\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n    \n    return dp[-1]", "solution_func": "def g():\n    nums = [1, 2, 3, 1, 5]\n    return nums", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous) in the list.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\ndef g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums\n\nassert f(g()) == 4\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 0, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the length of the longest increasing subsequence (not necessarily contiguous) in the list.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "solution_func": "def g():\n    nums = [10, 9, 2, 5, 3, 7, 101, 18]\n    return nums", "map_ix": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the Quick Sort algorithm.\n    \"\"\"\n    def partition(arr, low, high):\n        i = (low - 1)\n        pivot = arr[high]\n    \n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i = i + 1\n                arr[i], arr[j] = arr[j], arr[i]\n    \n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n    \n    def quickSort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n    \n            quickSort(arr, low, pi - 1)\n            quickSort(arr, pi + 1, high)\n    \n    n = len(nums)\n    quickSort(nums, 0, n - 1)\n    return nums\n\ndef g():\n    nums = [64, 34, 25, 12, 22, 11, 90]\n    return nums\n\nassert f(g()) == [11, 12, 22, 25, 34, 64, 90]\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [0, 0, 0, 0, 0, 0, 0, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> List[int]:\n    \"\"\"\n    Given a list of integers, sort the list in ascending order using the Quick Sort algorithm.\n    \"\"\"\n    def partition(arr, low, high):\n        i = (low - 1)\n        pivot = arr[high]\n    \n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i = i + 1\n                arr[i], arr[j] = arr[j], arr[i]\n    \n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n    \n    def quickSort(arr, low, high):\n        if low < high:\n            pi = partition(arr, low, high)\n    \n            quickSort(arr, low, pi - 1)\n            quickSort(arr, pi + 1, high)\n    \n    n = len(nums)\n    quickSort(nums, 0, n - 1)\n    return nums", "solution_func": "def g():\n    nums = [64, 34, 25, 12, 22, 11, 90]\n    return nums", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    The function should return 30, as the sum of all the even numbers in the list is 30 (2 + 4 + 6 + 8 + 10).\n\n    Note:\n    - The list may contain negative numbers.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum\n\ndef g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nassert f(g()) == 30\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 498, "target_skills": [0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(nums: List[int]) -> int:\n    \"\"\"\n    Given a list of integers, find the sum of all the even numbers in the list.\n\n    Example:\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    The function should return 30, as the sum of all the even numbers in the list is 30 (2 + 4 + 6 + 8 + 10).\n\n    Note:\n    - The list may contain negative numbers.\n    \"\"\"\n    even_sum = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_sum += num\n\n    return even_sum", "solution_func": "def g() -> List[int]:\n    \"\"\"\n    Generate a list of integers.\n    \"\"\"\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (LIS).\n    A subsequence is a sequence that can be derived from an array by deleting some or no elements\n    without changing the order of the remaining elements.\n\n    Example:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    The function should return 4, as the longest increasing subsequence is [2, 3, 7, 101].\n\n    Note:\n    The LIS does not need to be contiguous.\n    \"\"\"\n    dp = [1] * len(arr)\n\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\ndef g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr\n\nassert f(g()) == 4\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\ndef f(arr: List[int]) -> int:\n    \"\"\"\n    Given an array of integers, find the length of the longest increasing subsequence (LIS).\n    A subsequence is a sequence that can be derived from an array by deleting some or no elements\n    without changing the order of the remaining elements.\n\n    Example:\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    The function should return 4, as the longest increasing subsequence is [2, 3, 7, 101].\n\n    Note:\n    The LIS does not need to be contiguous.\n    \"\"\"\n    dp = [1] * len(arr)\n\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "solution_func": "def g():\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n    return arr", "map_ix": [1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import *\nfrom collections import defaultdict\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them together based on their anagrams.\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n    Return a list of lists where each inner list contains words that are anagrams of each other.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    The function should return [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]].\n\n    Note:\n    The order of the output does not matter.\n    \"\"\"\n    anagram_map = defaultdict(list)\n\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        anagram_map[sorted_word].append(word)\n\n    return list(anagram_map.values())\n\ndef g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words\n\nassert f(g()) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n", "emb": [1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import defaultdict\n\ndef f(words: List[str]) -> List[List[str]]:\n    \"\"\"\n    Given a list of words, group them together based on their anagrams.\n    An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n    Return a list of lists where each inner list contains words that are anagrams of each other.\n\n    Example:\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    The function should return [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]].\n\n    Note:\n    The order of the output does not matter.\n    \"\"\"\n    anagram_map = defaultdict(list)\n\n    for word in words:\n        sorted_word = \"\".join(sorted(word))\n        anagram_map[sorted_word].append(word)\n\n    return list(anagram_map.values())", "solution_func": "def g():\n    words = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n    return words", "map_ix": [1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum steps required to reach the target position (denoted by 2)\n    from the starting position (denoted by 1), only moving vertically or horizontally.\n    You cannot pass through obstacles (denoted by -1).\n    If it is not possible to reach the target position, return -1.\n\n    Example:\n    grid = [\n        [1, 0, 0],\n        [0, 0, 0],\n        [0, 0, 2]\n    ]\n    The function should return 4, as the minimum steps required are: down, right, right, up.\n\n    Note:\n    - The grid will always contain a starting position (1) and a target position (2).\n    - The grid may contain obstacles (-1) that cannot be passed through.\n    - You can assume that there is a path from the starting position to the target position.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    queue = deque()\n    queue.append((0, 0, 0))  # (row, col, steps)\n\n    while queue:\n        row, col, steps = queue.popleft()\n\n        if grid[row][col] == 2:\n            return steps\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != -1:\n                queue.append((new_row, new_col, steps + 1))\n                grid[new_row][new_col] = -1\n\n    return -1\n\ndef g():\n    grid = [\n        [1, 0, 0],\n        [0, 0, 0],\n        [0, 0, 2]\n    ]\n    return grid\n\nassert f(g()) == 4\n", "emb": null, "idx_generation": 499, "target_skills": [4607182418800017408, 0, 0, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import *\nfrom collections import deque\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the minimum steps required to reach the target position (denoted by 2)\n    from the starting position (denoted by 1), only moving vertically or horizontally.\n    You cannot pass through obstacles (denoted by -1).\n    If it is not possible to reach the target position, return -1.\n\n    Example:\n    grid = [\n        [1, 0, 0],\n        [0, 0, 0],\n        [0, 0, 2]\n    ]\n    The function should return 4, as the minimum steps required are: down, right, right, up.\n\n    Note:\n    - The grid will always contain a starting position (1) and a target position (2).\n    - The grid may contain obstacles (-1) that cannot be passed through.\n    - You can assume that there is a path from the starting position to the target position.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    queue = deque()\n    queue.append((0, 0, 0))  # (row, col, steps)\n\n    while queue:\n        row, col, steps = queue.popleft()\n\n        if grid[row][col] == 2:\n            return steps\n\n        for dx, dy in directions:\n            new_row = row + dx\n            new_col = col + dy\n\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != -1:\n                queue.append((new_row, new_col, steps + 1))\n                grid[new_row][new_col] = -1\n\n    return -1", "solution_func": "def g():\n    grid = [\n        [1, 0, 0],\n        [0, 0, 0],\n        [0, 0, 2]\n    ]\n    return grid", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the sum of each row in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    The sum of each row is [6, 15, 24].\n    Return [6, 15, 24].\n    \"\"\"\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums\n\ndef g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nassert f(g()) == [6, 15, 24]\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a matrix of integers, return the sum of each row in the matrix.\n\n    Example:\n    matrix = [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n    The sum of each row is [6, 15, 24].\n    Return [6, 15, 24].\n    \"\"\"\n    row_sums = []\n    for row in matrix:\n        row_sum = sum(row)\n        row_sums.append(row_sum)\n    return row_sums", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "map_ix": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, sort the strings lexicographically in descending order.\n\n    Example:\n    arr = ['cat', 'dog', 'apple', 'banana']\n    After sorting, the list becomes ['dog', 'cat', 'banana', 'apple'].\n    Return ['dog', 'cat', 'banana', 'apple'].\n    \"\"\"\n    sorted_arr = sorted(arr, reverse=True)\n    return sorted_arr\n\ndef g() -> List[str]:\n    return ['cat', 'dog', 'apple', 'banana']\n\nassert f(g()) == ['dog', 'cat', 'banana', 'apple']\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [0, 0, 0, 0, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(arr: List[str]) -> List[str]:\n    \"\"\"\n    Given a list of strings, sort the strings lexicographically in descending order.\n\n    Example:\n    arr = ['cat', 'dog', 'apple', 'banana']\n    After sorting, the list becomes ['dog', 'cat', 'banana', 'apple'].\n    Return ['dog', 'cat', 'banana', 'apple'].\n    \"\"\"\n    sorted_arr = sorted(arr, reverse=True)\n    return sorted_arr", "solution_func": "def g() -> List[str]:\n    return ['cat', 'dog', 'apple', 'banana']", "map_ix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": -Infinity, "program_str": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of values along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    The maximum sum of values along a path is 7 (1 + 3 + 1 + 1 + 1).\n    Return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\ndef g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\n\nassert f(g()) == 7\n", "emb": null, "idx_generation": 499, "target_skills": [0, 0, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a grid of integers, find the maximum sum of values along a path from the top-left corner to the bottom-right corner.\n    You can only move down or right.\n\n    Example:\n    grid = [[1, 3, 1],\n            [1, 5, 1],\n            [4, 2, 1]]\n    The maximum sum of values along a path is 7 (1 + 3 + 1 + 1 + 1).\n    Return 7.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]", "solution_func": "def g() -> List[List[int]]:\n    return [[1, 3, 1], [1, 5, 1], [4, 2, 1]]", "map_ix": null}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the indices of two numbers such that they add up to the target.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    The function should return (0, 1) since arr[0] + arr[1] = 2 + 7 = 9.\n    \"\"\"\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return (-1, -1)\n\ndef g() -> Tuple[List[int], int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return (arr, target)\n\nassert f(*g()) == (0, 1)\n", "emb": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [0, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List, Tuple\n\ndef f(arr: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a sorted array of integers and a target value, return the indices of two numbers such that they add up to the target.\n\n    Example:\n    arr = [2, 7, 11, 15]\n    target = 9\n\n    The function should return (0, 1) since arr[0] + arr[1] = 2 + 7 = 9.\n    \"\"\"\n\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return (left, right)\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n    return (-1, -1)", "solution_func": "def g() -> Tuple[List[int], int]:\n    arr = [2, 7, 11, 15]\n    target = 9\n    return (arr, target)", "map_ix": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, convert it to its binary representation and count the number of bits that are set to 1.\n\n    Example:\n    num = 13\n\n    The binary representation of 13 is 1101, and it contains 3 bits that are set to 1.\n    Therefore, the function should return 3.\n    \"\"\"\n    binary = bin(num)[2:]\n    count = 0\n\n    for bit in binary:\n        if bit == '1':\n            count += 1\n\n    return count\n\ndef g() -> int:\n    num = 13\n    return num\n\nassert f(g()) == 3\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 0, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(num: int) -> int:\n    \"\"\"\n    Given a positive integer num, convert it to its binary representation and count the number of bits that are set to 1.\n\n    Example:\n    num = 13\n\n    The binary representation of 13 is 1101, and it contains 3 bits that are set to 1.\n    Therefore, the function should return 3.\n    \"\"\"\n    binary = bin(num)[2:]\n    count = 0\n\n    for bit in binary:\n        if bit == '1':\n            count += 1\n\n    return count", "solution_func": "def g() -> int:\n    num = 13\n    return num", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(text: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string while preserving the whitespace between them.\n\n    Example:\n    text = \"hello world\"\n\n    The function should return \"world hello\".\n    \"\"\"\n    words = text.split()\n    reversed_text = ' '.join(reversed(words))\n    return reversed_text\n\ndef g() -> str:\n    text = \"hello world\"\n    return text\n\nassert f(g()) == \"world hello\"\n", "emb": [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0], "idx_generation": 499, "target_skills": [4607182418800017408, 0, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0, 4607182418800017408, 4607182418800017408, 0], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(text: str) -> str:\n    \"\"\"\n    Given a string, reverse the order of the words in the string while preserving the whitespace between them.\n\n    Example:\n    text = \"hello world\"\n\n    The function should return \"world hello\".\n    \"\"\"\n    words = text.split()\n    reversed_text = ' '.join(reversed(words))\n    return reversed_text", "solution_func": "def g() -> str:\n    text = \"hello world\"\n    return text", "map_ix": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}, {"fitness": 1.0, "program_str": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count\n\ndef g() -> int:\n    n = 10\n    return n\n\nassert f(g()) == 2\n\n", "emb": [1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0], "idx_generation": 499, "target_skills": [4607182418800017408, 4607182418800017408, 0, 0, 4607182418800017408, 0, 0, 4607182418800017408, 0, 4607182418800017408], "problem_func": "from typing import*\nfrom typing import List\n\ndef f(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, count the number of trailing zeros in n!.\n\n    Example:\n    n = 5\n\n    Output:\n    1\n\n    Explanation:\n    5! = 120, which has 1 trailing zero.\n    \"\"\"\n\n    count = 0\n    i = 5\n\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    return count", "solution_func": "def g() -> int:\n    n = 10\n    return n", "map_ix": [1, 1, 0, 1, 0, 0, 0, 1, 1, 0]}]
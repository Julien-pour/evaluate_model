[
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find a string with 1000 'o's but no two adjacent 'o's.\"\"\"\n    return s.count('o') == 1000 and s.count('oo') == 0\ndef g():\n    return ('h' + 'o') * 1000\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998.\"\"\"\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9.\"\"\"\n    return all([li.count(i) == i for i in range(10)])\ndef g():\n    return [i for i in range(10) for j in range(i)]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888.\"\"\"\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3\ndef g():\n    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"\n    Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to get\n    the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\n    mappings.\n    \"\"\"\n    return ['The quick brown fox jumps over the lazy dog'[i] for i in li] == list('The five boxing wizards jump quickly')\ndef g():\n    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(ls: List[str]) -> bool:\n    \"\"\"\n    Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\n    and is equal to the lexicographically smallest element.\n    \"\"\"\n    return min(ls) == max(ls) == str(len(ls))\ndef g():\n    return ['1']\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float) -> bool:\n    \"\"\"Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456.\"\"\"\n    return str(x - 3.1415).startswith('123.456')\ndef g():\n    return 123.456 + 3.1415\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19.\"\"\"\n    return all((sum(li[:i]) == 2 ** i - 1 for i in range(20)))\ndef g():\n    return [(2 ** i) for i in range(20)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int) -> bool:\n    \"\"\"Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001.\"\"\"\n    return len(str(i + 1000)) > len(str(i + 1001))\ndef g():\n    return -1001\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"\n    Find a list of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    That is find L such that, { i + j | i, j in L } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    \"\"\"\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"\n    Find a list integers containing exactly three distinct values, such that no integer repeats\n    twice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)\n    \"\"\"\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3\ndef g():\n    return list(range(3)) * 10\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            0.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(ls: List[str]) -> bool:\n    \"\"\"\n    Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.\n    \"\"\"\n    return tuple(ls) in zip('dee', 'doo', 'dah!')\ndef g():\n    return list(next(zip('dee', 'doo', 'dah!')))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find a permutation of the string 'Permute me true' which is a palindrome.\"\"\"\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]\ndef g():\n    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int]) -> bool:\n    \"\"\"\n    Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\n    v the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\n    share the same great-grandchildren. Represented this digraph by the list of children indices.\n    \"\"\"\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]\ndef g():\n    return [1, 2, 3, 3]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(l: List[int]) -> bool:\n    \"\"\"\n    Find a list of more than 995 distinct integers between 0 and 999, inclusive, such that each pair of integers\n    have squares that differ by at least 10.\n    \"\"\"\n    return all((i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j)) and len(set(l)) > 995\ndef g():\n    return [0, 4] + list(range(6, 1000))\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(hands: List[int], target_angle=45) -> bool:\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 45):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(hands: List[int], target_angle=39) -> bool:\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 39):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(hands: List[int], target_angle=133) -> bool:\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 133):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(hands: List[int], target_angle=138) -> bool:\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 138):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(hands: List[int], target_angle=68) -> bool:\n    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 68):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int) -> bool:\n    \"\"\"\n    Find the number of coconuts to solve the following riddle:\n        There is a pile of coconuts, owned by five men. One man divides the pile into five equal piles, giving the\n        one left over coconut to a passing monkey, and takes away his own share. The second man then repeats the\n        procedure, dividing the remaining pile into five and taking away his share, as do the third, fourth, and\n        fifth, each of them finding one coconut left over when dividing the pile by five, and giving it to a monkey.\n        Finally, the group divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n        How many coconuts were there in the original pile?\n                                          Quoted from https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts\n    \"\"\"\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(coords: List[List[int]], side=10, num_points=20) -> bool:\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points\ndef g(side = 10, num_points = 20):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(coords: List[List[int]], side=0, num_points=0) -> bool:\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points\ndef g(side = 0, num_points = 0):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(coords: List[List[int]], side=1, num_points=1) -> bool:\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points\ndef g(side = 1, num_points = 1):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(coords: List[List[int]], side=2, num_points=4) -> bool:\n    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points\ndef g(side = 2, num_points = 4):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(stamps: List[int], target=80, max_stamps=4, options=[10, 32, 8]) -> bool:\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 80, max_stamps = 4, options = [10, 32, 8]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]) -> bool:\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 271, max_stamps = 8, options = [37, 37, 12, 87, 39]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(stamps: List[int], target=3, max_stamps=3, options=[18, 1, 43, 81]) -> bool:\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 3, max_stamps = 3, options = [18, 1, 43, 81]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(stamps: List[int], target=19, max_stamps=2, options=[19, 14, 81]) -> bool:\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 19, max_stamps = 2, options = [19, 14, 81]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(stamps: List[int], target=56, max_stamps=1, options=[25, 22, 8, 84, 60, 56, 54, 7, 8]) -> bool:\n    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 56, max_stamps = 1, options = [25, 22, 8, 84, 60, 56, 54, 7, 8]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(xy_sides: List[List[int]]) -> bool:\n    \"\"\"\n    Partition a square into smaller squares with unique side lengths. A perfect squared path has distinct sides.\n    xy_sides is a List of (x, y, side)\n    \"\"\"\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2\ndef g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, lace='bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb') -> bool:\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'bbrbrbbbbbbrrrrrrrbrrrrbbbrbrrbbbrbrrrbrrbrrbrbbrrrrrbrbbbrrrbbbrbbrbbbrbrbb'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, lace='rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr') -> bool:\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'rbbrrbbrbrbbbrrrbbrbrbrrbbrbbbbbbrrrrrrrrbrrrbbrbrrbbbrbbrrrbbrbbrrbrrbrbbrbbbbbbrbbbrbrbrrbrbbrbrrbbrrbrrbrrbrrbrbrbrrrbbrbrbbrrbbbbrrrrrbbrbrbrrbr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, lace='brrrbrrbrbbbbbrrbbrr') -> bool:\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'brrrbrrbrbbbbbrrbbrr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, lace='bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr') -> bool:\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'bbbbrrbbbbrrbbrrrbbrrbbrrrrrrrbrbrbbbrrbrrrbbbbbbbrbrbrbbbbbbbrrbbrbbrbrrbrbrrbbbrrrrrbrrbbrrrbbrbrrrbbbbrbbbrrrrbrbrrbbrbrbrbbrrbrrrbrbrrbbbbbbrbrrrrbbrbbbrbrrbrbbrbrrbbbbrrrrrbrrrbbrrrrrrbrrrbrbbbrbbbrrrbbr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, lace='brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr') -> bool:\n    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'brrbbbrbbrrbrrbbrrbrrrbbrbbrrrbrbrbrrrrbbrrrbrrbbbbrbbbrrbbrrrbbrbrbbbbbrrbrrbbr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int) -> bool:\n    \"\"\"Find an integer whose square has all digits 0-9 once.\"\"\"\n    s = str(n * n)\n    for i in '0123456789':\n        assert s.count(i) == 1\n    return True\ndef g():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find a formula using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find an expression using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"\n    return set(s) <= set('18-+*/') and s.count('8') == 3 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1**8\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], capacities=[8, 5, 3], init=[8, 0, 0], goal=[4, 4, 0]) -> bool:\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [8, 5, 3], init = [8, 0, 0], goal = [4, 4, 0]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], capacities=[357, 298, 492], init=[8, 284, 72], goal=[0, 0, 364]) -> bool:\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [357, 298, 492], init = [8, 284, 72], goal = [0, 0, 364]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], capacities=[511, 625, 553], init=[472, 153, 127], goal=[97, 625, 30]) -> bool:\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [511, 625, 553], init = [472, 153, 127], goal = [97, 625, 30]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], capacities=[86, 259, 281], init=[47, 18, 35], goal=[35, 0, 65]) -> bool:\n    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [86, 259, 281], init = [47, 18, 35], goal = [35, 0, 65]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='antidisestablishmentarianism', max_len=10) -> bool:\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'antidisestablishmentarianism', max_len = 10):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='pawuzorythalirinasubyg', max_len=12) -> bool:\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'pawuzorythalirinasubyg', max_len = 12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='jomodosigezyfulach', max_len=5) -> bool:\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'jomodosigezyfulach', max_len = 5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='bybakichop', max_len=12) -> bool:\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'bybakichop', max_len = 12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='wywaxizodetextonigijalate', max_len=5) -> bool:\n    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'wywaxizodetextonigijalate', max_len = 5):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(corners: List[List[int]], m=10, n=9, a=5, target=4) -> bool:\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 10, n = 9, a = 5, target = 4):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(corners: List[List[int]], m=22, n=129, a=9, target=45) -> bool:\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 22, n = 129, a = 9, target = 45):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(corners: List[List[int]], m=6, n=849, a=10, target=89) -> bool:\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 6, n = 849, a = 10, target = 89):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(corners: List[List[int]], m=89, n=554, a=6, target=1397) -> bool:\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 89, n = 554, a = 6, target = 1397):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lb: List[bool], trips=[[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]) -> bool:\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[1, 1, 0], [1, 0, 0], [0, 0, 0], [0, 1, 1], [0, 1, 1], [1, 1, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lb: List[bool], trips=[[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 0]]) -> bool:\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 0]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lb: List[bool], trips=[[0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]) -> bool:\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [1, 0, 0], [0, 1, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lb: List[bool], trips=[[0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 1, 1]]) -> bool:\n    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 1, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, scores=[32, 32, 31, 30, 25, 25, 21, 20, 17, 17, 16, 15, 15, 14, 11, 2, 0], k=4) -> bool:\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [32, 32, 31, 30, 25, 25, 21, 20, 17, 17, 16, 15, 15, 14, 11, 2, 0], k = 4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, scores=[44, 42, 41, 41, 40, 40, 39, 38, 38, 38, 37, 33, 32, 31, 31, 31, 30, 29, 28, 26, 25, 24, 24, 23, 23, 22, 20, 20, 20, 18, 17, 17, 16, 16, 12, 9, 9, 7, 6, 5, 4, 2], k=1) -> bool:\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [44, 42, 41, 41, 40, 40, 39, 38, 38, 38, 37, 33, 32, 31, 31, 31, 30, 29, 28, 26, 25, 24, 24, 23, 23, 22, 20, 20, 20, 18, 17, 17, 16, 16, 12, 9, 9, 7, 6, 5, 4, 2], k = 1):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, scores=[36, 27, 24, 19, 15, 15, 8, 8, 5], k=4) -> bool:\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [36, 27, 24, 19, 15, 15, 8, 8, 5], k = 4):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, scores=[20, 19, 17, 13, 12, 11, 10, 6], k=2) -> bool:\n    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [20, 19, 17, 13, 12, 11, 10, 6], k = 2):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(t: str, s='Problems') -> bool:\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'Problems'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='VahOjaquAlYMEcubidePYwApawAtonE') -> bool:\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'VahOjaquAlYMEcubidePYwApawAtonE'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL') -> bool:\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='NOxADaNIMiReZoTeXtODUtHulyTHETextojoLeQuaNutEXtE') -> bool:\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'NOxADaNIMiReZoTeXtODUtHulyTHETextojoLeQuaNutEXtE'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='MEkUWonymYNAQUypEcIv') -> bool:\n    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'MEkUWonymYNAQUypEcIv'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=10, n=5, target=50) -> bool:\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 10, n = 5, target = 50):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=30, n=12, target=360) -> bool:\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 30, n = 12, target = 360):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=34, n=25, target=850) -> bool:\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 34, n = 25, target = 850):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=35, n=46, target=1610) -> bool:\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 35, n = 46, target = 1610):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=41, n=12, target=492) -> bool:\n    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 41, n = 12, target = 492):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, ops=['x++', '--x', '--x'], target=19143212) -> bool:\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in ['++x', 'x++']:\n            n += 1\n        else:\n            assert op in ['--x', 'x--']\n            n -= 1\n    return n == target\ndef g(ops = ['x++', '--x', '--x'], target = 19143212):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, ops=['x--', 'x++', '++x', '--x', 'x++', '--x', 'x--'], target=61813) -> bool:\n    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"\n    for op in ops:\n        if op in ['++x', 'x++']:\n            n += 1\n        else:\n            assert op in ['--x', 'x--']\n            n -= 1\n    return n == target\ndef g(ops = ['x--', 'x++', '++x', '--x', 'x++', '--x', 'x--'], target = 61813):\n    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, s='aaAab', t='aAaaB') -> bool:\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'aaAab', t = 'aAaaB'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, s='JyNuTexTETiGAVIC', t='JynUTEXTetigAViC') -> bool:\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'JyNuTexTETiGAVIC', t = 'JynUTEXTetigAViC'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, s='tExTYtOHahekomArof', t='TExTYTohaHeKomryGUSeteXTUrYgir') -> bool:\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'tExTYtOHahekomArof', t = 'TExTYTohaHeKomryGUSeteXTUrYgir'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, s='RObAQuYK', t='robaQUYKkuLY') -> bool:\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'RObAQuYK', t = 'robaQUYKkuLY'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, s='DUTeX', t='dutdE') -> bool:\n    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'DUTeX', t = 'dutdE'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='konjac') -> bool:\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'konjac'):\n    return word[0].upper() + word[1:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='nojapoxe') -> bool:\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'nojapoxe'):\n    return word[0].upper() + word[1:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='silon') -> bool:\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'silon'):\n    return word[0].upper() + word[1:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='fekovo') -> bool:\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'fekovo'):\n    return word[0].upper() + word[1:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, word='mo') -> bool:\n    \"\"\"Capitalize the first letter of word\"\"\"\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'mo'):\n    return word[0].upper() + word[1:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='abbbcabbac', target=7) -> bool:\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'abbbcabbac', target = 7):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa', target=43) -> bool:\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'cbbbbbcbbbbbbbaccacacaacbbcaaacbbaacbabacabccbbbcaacbbacaabcabbaacbbaa', target = 43):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='bcb', target=3) -> bool:\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'bcb', target = 3):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='c', target=1) -> bool:\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'c', target = 1):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='bcbcabba', target=7) -> bool:\n    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'bcbcabba', target = 7):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(delta: List[int], nums=[[1, 2, 3], [9, -2, 8], [17, 2, 50]]) -> bool:\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[1, 2, 3], [9, -2, 8], [17, 2, 50]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(delta: List[int], nums=[[-48, -64, 10], [-6, 46, 95], [89, 95, 20], [-96, 45, 74], [-78, 19, 47], [-6, -69, 55]]) -> bool:\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[-48, -64, 10], [-6, 46, 95], [89, 95, 20], [-96, 45, 74], [-78, 19, 47], [-6, -69, 55]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(delta: List[int], nums=[[-17, -87, 34], [-8, -47, -68], [92, -14, -18], [18, 89, 85], [52, 89, -56], [-38, -19, -53], [-78, -25, -34]]) -> bool:\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[-17, -87, 34], [-8, -47, -68], [92, -14, -18], [18, 89, 85], [52, 89, -56], [-38, -19, -53], [-78, -25, -34]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(delta: List[int], nums=[[-16, 53, 37], [-54, -85, 65], [-46, 49, -81], [88, -47, -35], [53, -82, 4], [45, 94, 39], [72, -57, 27], [40, 35, -44], [-15, 32, 21]]) -> bool:\n    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[-16, 53, 37], [-54, -85, 65], [-46, 49, -81], [88, -47, -35], [53, -82, 4], [45, 94, 39], [72, -57, 27], [40, 35, -44], [-15, 32, 21]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=17, b=100, c=20) -> bool:\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 17, b = 100, c = 20):\n    return -a + sum([b * i for i in range(c)])\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=62, b=92, c=24) -> bool:\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 62, b = 92, c = 24):\n    return -a + sum([b * i for i in range(c)])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=14, b=50, c=47) -> bool:\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 14, b = 50, c = 47):\n    return -a + sum([b * i for i in range(c)])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(n: int, a=62, b=63, c=13) -> bool:\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 62, b = 63, c = 13):\n    return -a + sum([b * i for i in range(c)])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=5, b=31, c=37) -> bool:\n    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 5, b = 31, c = 37):\n    return -a + sum([b * i for i in range(c)])\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, v=17, w=100) -> bool:\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 17, w = 100):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, v=75129500, w=979292947) -> bool:\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 75129500, w = 979292947):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, v=609909721, w=872375011) -> bool:\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, v=313946483, w=806690290) -> bool:\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 313946483, w = 806690290):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, v=54888266, w=670740803) -> bool:\n    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 54888266, w = 670740803):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(res: int, m=1234578987654321, n=4) -> bool:\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 1234578987654321, n = 4):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(res: int, m=52891398375817839454, n=3) -> bool:\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 52891398375817839454, n = 3):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(res: int, m=23602903522227899062, n=2) -> bool:\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 23602903522227899062, n = 2):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(res: int, m=27368816582234104063, n=4) -> bool:\n    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 27368816582234104063, n = 4):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, pairs=[[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]) -> bool:\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\\\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\\\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success\ndef g(pairs = [[3, 0], [17, 1], [9254359, 19], [123, 9254359], [0, 123]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]) -> bool:\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\\\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\\\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success\ndef g(pairs = [[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, pairs=[[0, 0]]) -> bool:\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\\\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\\\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success\ndef g(pairs = [[0, 0]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, pairs=[[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]) -> bool:\n    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\\\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\\\sum_{i=1}^t p_i - m_i\n    \"\"\"\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success\ndef g(pairs = [[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s_case: str, s='CanYouTellIfItHASmoreCAPITALS') -> bool:\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'CanYouTellIfItHASmoreCAPITALS'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s_case: str, s='ThUcynICHiHIc') -> bool:\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'ThUcynICHiHIc'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s_case: str, s='riziP') -> bool:\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'riziP'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s_case: str, s='KANExAjoHiBotipomyVOkATuMY') -> bool:\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'KANExAjoHiBotipomyVOkATuMY'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s_case: str, s='rAC') -> bool:\n    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'rAC'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], string='enlightenment') -> bool:\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = 'enlightenment'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], string='inntGetlige') -> bool:\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = 'inntGetlige'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], string='gteliikeenGgqIHent') -> bool:\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = 'gteliikeenGgqIHent'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], string='xaGliigNntJfeeSm  nnEyt') -> bool:\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = 'xaGliigNntJfeeSm  nnEyt'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], string='  einliJSgeteq ne CAlti') -> bool:\n    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = '  einliJSgeteq ne CAlti'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(d: int, n=123456789) -> bool:\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 123456789):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(d: int, n=659104579100082212) -> bool:\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 659104579100082212):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(d: int, n=476988101965) -> bool:\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 476988101965):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(d: int, n=3169877099077541094754) -> bool:\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 3169877099077541094754):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(d: int, n=707) -> bool:\n    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 707):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='reverse me', reverse=True) -> bool:\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse\ndef g(target = 'reverse me', reverse = True):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='thubonyna', reverse=True) -> bool:\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse\ndef g(target = 'thubonyna', reverse = True):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='nivosypetextyzavalag', reverse=False) -> bool:\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse\ndef g(target = 'nivosypetextyzavalag', reverse = False):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='l', reverse=False) -> bool:\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse\ndef g(target = 'l', reverse = False):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='rechawewivetextovy', reverse=True) -> bool:\n    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"\n    return (s[::-1] == target) == reverse\ndef g(target = 'rechawewivetextovy', reverse = True):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a=5129, d=17) -> bool:\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 5129, d = 17):\n    return \"a\" * a + \"d\" * d\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a=5798, d=1873) -> bool:\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 5798, d = 1873):\n    return \"a\" * a + \"d\" * d\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(s: str, a=2645, d=1270) -> bool:\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 2645, d = 1270):\n    return \"a\" * a + \"d\" * d\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a=2996, d=6808) -> bool:\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 2996, d = 6808):\n    return \"a\" * a + \"d\" * d\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a=4763, d=8408) -> bool:\n    \"\"\"Find a string with a given number of a's and d's\"\"\"\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 4763, d = 8408):\n    return \"a\" * a + \"d\" * d\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], a=100, b=1000, count=648) -> bool:\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 100, b = 1000, count = 648):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], a=79, b=169, count=67) -> bool:\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 79, b = 169, count = 67):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], a=31, b=105, count=66) -> bool:\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 31, b = 105, count = 66):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], a=52, b=95, count=40) -> bool:\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 52, b = 95, count = 40):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], a=136, b=176, count=34) -> bool:\n    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 136, b = 176, count = 34):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17) -> bool:\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [2, 8, 25, 18, 99, 11, 17, 16], thresh = 17):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tot: int, nums=[60, 63, 11], thresh=99) -> bool:\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [60, 63, 11], thresh = 99):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tot: int, nums=[32, 24, 19, 88, 6, 33, 13], thresh=33) -> bool:\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [32, 24, 19, 88, 6, 33, 13], thresh = 33):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tot: int, nums=[60, 72, 32, 29, 90, 9, 39, 67, 31, 71, 68, 72, 28, 85, 75, 60, 42, 66, 4, 71, 57, 45, 88, 20, 66, 97, 33, 43, 48], thresh=30) -> bool:\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [60, 72, 32, 29, 90, 9, 39, 67, 31, 71, 68, 72, 28, 85, 75, 60, 42, 66, 4, 71, 57, 45, 88, 20, 66, 97, 33, 43, 48], thresh = 30):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tot: int, nums=[61, 98, 33, 32, 4, 99, 91, 63, 76, 83, 52, 0, 19, 49, 85, 5, 54, 71, 41, 93, 54, 78, 92], thresh=91) -> bool:\n    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [61, 98, 33, 32, 4, 99, 91, 63, 76, 83, 52, 0, 19, 49, 85, 5, 54, 71, 41, 93, 54, 78, 92], thresh = 91):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(ans: List[List[int]], target=17) -> bool:\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 17):\n    return [[0, 2]] * target\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(ans: List[List[int]], target=0) -> bool:\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 0):\n    return [[0, 2]] * target\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(ans: List[List[int]], target=1) -> bool:\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 1):\n    return [[0, 2]] * target\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(ans: List[List[int]], target=2) -> bool:\n    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 2):\n    return [[0, 2]] * target\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=7012) -> bool:\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 7012):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=0) -> bool:\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 0):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=1) -> bool:\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 1):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(s: str, n=2) -> bool:\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=3) -> bool:\n    \"\"\"What are the last two digits of 5^n?\"\"\"\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 3):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='424', combo='778', target_len=12) -> bool:\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '424', combo = '778', target_len = 12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='77872', combo='43506', target_len=16) -> bool:\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '77872', combo = '43506', target_len = 16):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='268', combo='180', target_len=4) -> bool:\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '268', combo = '180', target_len = 4):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='4675159714', combo='9758013840', target_len=27) -> bool:\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '4675159714', combo = '9758013840', target_len = 27):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='242716', combo='891245', target_len=18) -> bool:\n    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '242716', combo = '891245', target_len = 18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='424', combo='778', target_len=12) -> bool:\n    \"\"\"Figure out what this does only from the code\"\"\"\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '424', combo = '778', target_len = 12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='50', combo='59', target_len=0) -> bool:\n    \"\"\"Figure out what this does only from the code\"\"\"\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '50', combo = '59', target_len = 0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='23', combo='12', target_len=1) -> bool:\n    \"\"\"Figure out what this does only from the code\"\"\"\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '23', combo = '12', target_len = 1):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='4', combo='3', target_len=0) -> bool:\n    \"\"\"Figure out what this does only from the code\"\"\"\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '4', combo = '3', target_len = 0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(states: List[str], start='2184377', combo='7002994', target_len=18) -> bool:\n    \"\"\"Figure out what this does only from the code\"\"\"\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '2184377', combo = '7002994', target_len = 18):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='hello are you there?') -> bool:\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'hello are you there?'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot') -> bool:\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'xapypakygatextifyth divufyjacof cecuchuquypo sulechukijocharapad hych mugemi re binivot'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='mujychenyzo') -> bool:\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'mujychenyzo'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu') -> bool:\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'quethoruchyrugyz wemywuconuthisiquu kachogechehuz pulybyri quuby thatextak tychuzymuxuzazylyk neruzesithipecytoqu'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='thyjytex cequolichitextotho bymoxokepy jyvumywefoc') -> bool:\n    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'thyjytex cequolichitextotho bymoxokepy jyvumywefoc'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4) -> bool:\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    (a, b) = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True\ndef g(items = [5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length = 4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(lists: List[List[int]], items=[5, 3, 2, 1, 0, 1, 4, 2, 5, 4, 6, 7, 8], length=2) -> bool:\n    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"\n    (a, b) = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True\ndef g(items = [5, 3, 2, 1, 0, 1, 4, 2, 5, 4, 6, 7, 8], length = 2):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(seq: List[int], n=10000, length=5017) -> bool:\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 10000, length = 5017):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(seq: List[int], n=867, length=785) -> bool:\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 867, length = 785):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(seq: List[int], n=0, length=0) -> bool:\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 0, length = 0):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(seq: List[int], n=4, length=2) -> bool:\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 4, length = 2):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(seq: List[int], n=5514, length=4310) -> bool:\n    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 5514, length = 4310):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=3, upper=6, seq=[17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 3, upper = 6, seq = [17, 1, 2, 65, 18, 91, -30, 100, 3, 1, 2]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=3, upper=-238, seq=[34, -9, -41, -62, -99, -58, -81, 66, -51, 90, -8, -56, -80, -66, -50, -74, -4, -47, 63, -86, 66, 72, 38, -3, 9, 92, 25, -77, 86, -24, -23, 9, 10, 36, -82, -48, -74, -1, -80, 55, -2, -86, 95, -52, -14, -87]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 3, upper = -238, seq = [34, -9, -41, -62, -99, -58, -81, 66, -51, 90, -8, -56, -80, -66, -50, -74, -4, -47, 63, -86, 66, 72, 38, -3, 9, 92, 25, -77, 86, -24, -23, 9, 10, 36, -82, -48, -74, -1, -80, 55, -2, -86, 95, -52, -14, -87]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=8, upper=-75, seq=[17, -90, 61, -29, 57, 7, -45, -37, 1, 69]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 8, upper = -75, seq = [17, -90, 61, -29, 57, 7, -45, -37, 1, 69]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=8, upper=-4, seq=[-17, 55, 6, -2, -14, -19, 86, -4, -8, -49, 40, 82]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 8, upper = -4, seq = [-17, 55, 6, -2, -14, -19, 86, -4, -8, -49, 40, 82]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\ndef g(k = 3, lower = 150, seq = [3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=9, lower=-183, seq=[44, -94, 25, -63, -39, -71, -34, 84, -35]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\ndef g(k = 9, lower = -183, seq = [44, -94, 25, -63, -39, -71, -34, 84, -35]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=3, lower=86, seq=[19, 82, -24, -9, -92, 50, -89, -15, 45, 56, -64]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\ndef g(k = 3, lower = 86, seq = [19, 82, -24, -9, -92, 50, -89, -15, 45, 56, -64]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=1, lower=-36, seq=[-36]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\ndef g(k = 1, lower = -36, seq = [-36]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=3, lower=100000, seq=[91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 3, lower = 100000, seq = [91, 1, 2, 64, 18, 91, -30, 100, 3, 65, 18]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(start: int, k=8, lower=774420991987500, seq=[-50, -99, -99, -65, -69, -87, 90, 45]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 8, lower = 774420991987500, seq = [-50, -99, -99, -65, -69, -87, 90, 45]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=2, lower=5589, seq=[8, -66, 75, 74, 40, 14, -81, -69, 99, 27, -18]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 2, lower = 5589, seq = [8, -66, 75, 74, 40, 14, -81, -69, 99, 27, -18]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], tot=12345, n=5) -> bool:\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 12345, n = 5):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], tot=1819, n=3) -> bool:\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 1819, n = 3):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], tot=37729, n=73) -> bool:\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 37729, n = 73):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], tot=5359, n=11) -> bool:\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], tot=36505, n=73) -> bool:\n    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 36505, n = 73):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(rotations: List[int], target='wonderful', upper=69) -> bool:\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'wonderful', upper = 69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(rotations: List[int], target='tubolele', upper=52) -> bool:\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'tubolele', upper = 52):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(rotations: List[int], target='soquogisawah', upper=67) -> bool:\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'soquogisawah', upper = 67):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(rotations: List[int], target='jacepa', upper=44) -> bool:\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'jacepa', upper = 44):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(rotations: List[int], target='miwykucehexo', upper=84) -> bool:\n    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'miwykucehexo', upper = 84):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bills: List[int], denominations=[1, 25, 35, 84], n=980, max_len=14) -> bool:\n    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 25, 35, 84], n = 980, max_len = 14):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bills: List[int], denominations=[1, 5, 7, 11], n=29377, max_len=2671) -> bool:\n    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 5, 7, 11], n = 29377, max_len = 2671):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bills: List[int], denominations=[1, 25, 29], n=537, max_len=21) -> bool:\n    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 25, 29], n = 537, max_len = 21):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bills: List[int], denominations=[1, 10, 23, 49], n=74, max_len=4) -> bool:\n    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 10, 23, 49], n = 74, max_len = 4):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    \"\"\"\n    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,\n     where each side length is in options\n    \"\"\"\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(sides: List[int], options=[2, 8, 64, 256], n=3885337784451458141838923813647037813284813678104279042503624819477808570410416996352, max_dim=36) -> bool:\n    \"\"\"\n    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,\n     where each side length is in options\n    \"\"\"\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 8, 64, 256], n = 3885337784451458141838923813647037813284813678104279042503624819477808570410416996352, max_dim = 36):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, coeffs=[2.5, 1.3, -0.5]) -> bool:\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [2.5, 1.3, -0.5]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, coeffs=[0.2622487694588566, 0.48521166316030495, -41.749384651642444]) -> bool:\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.2622487694588566, 0.48521166316030495, -41.749384651642444]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, coeffs=[145.72190605632582, 0.027358325157428014, -5.149342624051854]) -> bool:\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [145.72190605632582, 0.027358325157428014, -5.149342624051854]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, coeffs=[1.1222556871110754, -0.007015312913509468, -309237.6867547677]) -> bool:\n    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [1.1222556871110754, -0.007015312913509468, -309237.6867547677]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(roots: List[float], coeffs=[1.3, -0.5]) -> bool:\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [1.3, -0.5]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(roots: List[float], coeffs=[-1.468548989307175, -0.9453828447181172]) -> bool:\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [-1.468548989307175, -0.9453828447181172]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(roots: List[float], coeffs=[-2.0230245559088815, -0.23831699388987454]) -> bool:\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [-2.0230245559088815, -0.23831699388987454]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(roots: List[float], coeffs=[-33.7903719275386, -5.03161654339928]) -> bool:\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [-33.7903719275386, -5.03161654339928]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]) -> bool:\n    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [9.155105839032705, -0.9467446341738642]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=679) -> bool:\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])\ndef g(s = 679):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=40427) -> bool:\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])\ndef g(s = 40427):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=8071) -> bool:\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])\ndef g(s = 8071):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=86120) -> bool:\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])\ndef g(s = 86120):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=26785) -> bool:\n    \"\"\"Find a number that its digits sum to a specific value.\"\"\"\n    return s == sum([int(d) for d in x])\ndef g(s = 26785):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(z: float, v=9, d=0.0001) -> bool:\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v\ndef g(v = 9, d = 0.0001):\n    return v * d\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(z: float, v=1, d=1e-17) -> bool:\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v\ndef g(v = 1, d = 1e-17):\n    return v * d\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(z: float, v=9, d=1e+83) -> bool:\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v\ndef g(v = 9, d = 1e+83):\n    return v * d\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(z: float, v=5, d=1e-18) -> bool:\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v\ndef g(v = 5, d = 1e-18):\n    return v * d\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(z: float, v=5, d=1e+90) -> bool:\n    \"\"\"Create a float with a specific decimal.\"\"\"\n    return int(z * 1 / d % 10) == v\ndef g(v = 5, d = 1e+90):\n    return v * d\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], a=7, s=5, e=200) -> bool:\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = 7, s = 5, e = 200):\n    return list(range(a, e + 1, s))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], a=43536, s=3795, e=417606) -> bool:\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = 43536, s = 3795, e = 417606):\n    return list(range(a, e + 1, s))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], a=-70138, s=4868, e=498910) -> bool:\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = -70138, s = 4868, e = 498910):\n    return list(range(a, e + 1, s))\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], a=55980, s=7402, e=155818) -> bool:\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = 55980, s = 7402, e = 155818):\n    return list(range(a, e + 1, s))\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], a=-44635, s=5046, e=503563) -> bool:\n    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = -44635, s = 5046, e = 503563):\n    return list(range(a, e + 1, s))\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(e: List[int], a=2, b=-1, c=1, d=2021) -> bool:\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = 2, b = -1, c = 1, d = 2021):\n    return [d - b, a - c]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(e: List[int], a=-77698407, b=-31793716, c=-10799659, d=89278024) -> bool:\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = -77698407, b = -31793716, c = -10799659, d = 89278024):\n    return [d - b, a - c]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(e: List[int], a=89600582, b=-47657198, c=95101265, d=-52126265) -> bool:\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = 89600582, b = -47657198, c = 95101265, d = -52126265):\n    return [d - b, a - c]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(e: List[int], a=-11422303, b=-57150416, c=-59162339, d=-37428439) -> bool:\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = -11422303, b = -57150416, c = -59162339, d = -37428439):\n    return [d - b, a - c]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(e: List[int], a=-18517001, b=-13662763, c=-11156613, d=9271005) -> bool:\n    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = -18517001, b = -13662763, c = -11156613, d = 9271005):\n    return [d - b, a - c]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=253532, b=1230200) -> bool:\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 253532, b = 1230200):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=22, b=-84904666) -> bool:\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 22, b = -84904666):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=10, b=74723522) -> bool:\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 10, b = 74723522):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=66, b=-39109407) -> bool:\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 66, b = -39109407):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=24, b=18773099) -> bool:\n    \"\"\"Satisfy a simple if statement with an or clause\"\"\"\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 24, b = 18773099):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=4, b=54368639) -> bool:\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = 4, b = 54368639):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-4, b=-83354930) -> bool:\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -4, b = -83354930):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-3, b=71965664) -> bool:\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=2, b=36068130) -> bool:\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = 2, b = 36068130):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-3, b=14385903) -> bool:\n    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 14385903):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=5, s=19) -> bool:\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 5, s = 19):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=6241, s=54594969) -> bool:\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 6241, s = 54594969):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=8427, s=33081884) -> bool:\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 8427, s = 33081884):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=3363, s=67595319) -> bool:\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 3363, s = 67595319):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=9909, s=88140438) -> bool:\n    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 9909, s = 88140438):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=4, s=2021) -> bool:\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 4, s = 2021):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=124, s=2603089) -> bool:\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 124, s = 2603089):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=823, s=8609609) -> bool:\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 823, s = 8609609):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=796, s=86694751) -> bool:\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 796, s = 86694751):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], n=225, s=38417364) -> bool:\n    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 225, s = 38417364):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=['a', 'b', 'c', 'd', 'e', 'f'], n=4) -> bool:\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['a', 'b', 'c', 'd', 'e', 'f'], n = 4):\n    return ''.join([s[i] for i in range(n)])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=['I', '&', 'W', '&', 'p', 'c', '-', 'U', '(', ' ', 'A', '(', 'S', 'W', 'R', '#', 'm', 'v', '@', '8', '%', 'a', '.', 'K', 'O', '[', '[', '#', 'q', 'k', 'K'], n=16) -> bool:\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['I', '&', 'W', '&', 'p', 'c', '-', 'U', '(', ' ', 'A', '(', 'S', 'W', 'R', '#', 'm', 'v', '@', '8', '%', 'a', '.', 'K', 'O', '[', '[', '#', 'q', 'k', 'K'], n = 16):\n    return ''.join([s[i] for i in range(n)])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=['L', 'C', 'b', 'r', 't', 'V', 'R', '%', 'R', '8', 'V', '#', '<', '!', 'U', 'y', 'x'], n=13) -> bool:\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['L', 'C', 'b', 'r', 't', 'V', 'R', '%', 'R', '8', 'V', '#', '<', '!', 'U', 'y', 'x'], n = 13):\n    return ''.join([s[i] for i in range(n)])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=['-', '&', ')', '&', 'c', 'l', '/', 'H', '1', 'j', 'z', 'o', 'E', '|', '8', '&', '0', '&', 'y', '!', 'r', 'H', 'S', 'P', '5'], n=8) -> bool:\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['-', '&', ')', '&', 'c', 'l', '/', 'H', '1', 'j', 'z', 'o', 'E', '|', '8', '&', '0', '&', 'y', '!', 'r', 'H', 'S', 'P', '5'], n = 8):\n    return ''.join([s[i] for i in range(n)])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16) -> bool:\n    \"\"\"Concatenate the list of characters in s\"\"\"\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n = 16):\n    return ''.join([s[i] for i in range(n)])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=677, a=43, e=125, s=10) -> bool:\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 677, a = 43, e = 125, s = 10):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=44475424, a=93, e=8496, s=6) -> bool:\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 44475424, a = 93, e = 8496, s = 6):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=2183536, a=36, e=8450, s=1) -> bool:\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 2183536, a = 36, e = 8450, s = 1):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=1196610, a=15, e=4376, s=3) -> bool:\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 1196610, a = 15, e = 4376, s = 3):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=6165697, a=47, e=3830, s=2) -> bool:\n    \"\"\"Sum values of sublist by range specifications\"\"\"\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 6165697, a = 47, e = 3830, s = 2):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=50, n=10) -> bool:\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 50, n = 10):\n    return [1] * n + [t]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=364928431, n=1088) -> bool:\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 364928431, n = 1088):\n    return [1] * n + [t]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=7978940451, n=5932) -> bool:\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 7978940451, n = 5932):\n    return [1] * n + [t]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=4545622399, n=1009) -> bool:\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 4545622399, n = 1009):\n    return [1] * n + [t]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int], t=4917027557, n=4815) -> bool:\n    \"\"\"Find how many values have cumulative sum less than target\"\"\"\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 4917027557, n = 4815):\n    return [1] * n + [t]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, s1='a', s2='b', count1=50, count2=30) -> bool:\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 'a', s2 = 'b', count1 = 50, count2 = 30):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, s1='t', s2='qu', count1=86, count2=83) -> bool:\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 't', s2 = 'qu', count1 = 86, count2 = 83):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, s1='kuc', s2='qu', count1=63, count2=58) -> bool:\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 'kuc', s2 = 'qu', count1 = 63, count2 = 58):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, s1='te', s2='tex', count1=97, count2=53) -> bool:\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 'te', s2 = 'tex', count1 = 97, count2 = 53):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, s1='hot', s2='n', count1=48, count2=92) -> bool:\n    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 'hot', s2 = 'n', count1 = 48, count2 = 92):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['foo', 'bar', 'baz', 'oddball']) -> bool:\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['foo', 'bar', 'baz', 'oddball']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['quifelota', 'chyhimyvemene', 'ge']) -> bool:\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['quifelota', 'chyhimyvemene', 'ge']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['kitytextiritex', 'cumathoxaz', 'rebute', 'rocor']) -> bool:\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['kitytextiritex', 'cumathoxaz', 'rebute', 'rocor']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['te', 'wusyc']) -> bool:\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['te', 'wusyc']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['cute', 'rysucajaxuno']) -> bool:\n    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['cute', 'rysucajaxuno']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['foo', 'bar', 'baz']) -> bool:\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['foo', 'bar', 'baz']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['kepijilufuwisejyzat', 'lechogyvonaxegitex']) -> bool:\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['kepijilufuwisejyzat', 'lechogyvonaxegitex']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['ripihuquyrenytu', 'quosafyji', 'chyguzocuzuqu', 'futhixequyb']) -> bool:\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['ripihuquyrenytu', 'quosafyji', 'chyguzocuzuqu', 'futhixequyb']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['thacovatukoliva', 'maquyfezisothizyp', 'ka', 'benegiquememif']) -> bool:\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['thacovatukoliva', 'maquyfezisothizyp', 'ka', 'benegiquememif']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, substrings=['t', 'vochemachylit', 'vutextynydakelopi', 'fazapydomozamochug']) -> bool:\n    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['t', 'vochemachylit', 'vutextynydakelopi', 'fazapydomozamochug']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']) -> bool:\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[-2]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['ryzapychybykydege', 'mivowepe', 'sovywos', 'chanyrorybynid', 'vafechajufo', 'nokymocymoxac', 'jahejafuquoduk', 'gogy', 'bytothice', 'ruminuvixixutudigom']) -> bool:\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['ryzapychybykydege', 'mivowepe', 'sovywos', 'chanyrorybynid', 'vafechajufo', 'nokymocymoxac', 'jahejafuquoduk', 'gogy', 'bytothice', 'ruminuvixixutudigom']):\n    return sorted(strings)[-2]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['mipelavychekecy', 'pythujutisoxofe', 'diliwagacivychinofiw', 'na', 'dobynaramithibolo', 'cugupyfytextofoxat', 'gyfokebo', 'bymitextitextizoc', 'rekimuk', 'bepumyxitubachek']) -> bool:\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['mipelavychekecy', 'pythujutisoxofe', 'diliwagacivychinofiw', 'na', 'dobynaramithibolo', 'cugupyfytextofoxat', 'gyfokebo', 'bymitextitextizoc', 'rekimuk', 'bepumyxitubachek']):\n    return sorted(strings)[-2]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['hunuvarufefikaq', 'xejegu', 'minoc', 'puthyvyc', 'xyzeryberi', 'tyl', 'thyvojyvijazetonowa', 'jahygywuchitho', 'quuvuvigy', 'zuhechywituthexe']) -> bool:\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['hunuvarufefikaq', 'xejegu', 'minoc', 'puthyvyc', 'xyzeryberi', 'tyl', 'thyvojyvijazetonowa', 'jahygywuchitho', 'quuvuvigy', 'zuhechywituthexe']):\n    return sorted(strings)[-2]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['wesolotelunyzecemexi', 'pociquuwygocysahef', 'lequusigipitexti', 'quojuxaq', 'fyt', 'm', 'bavalepynoza', 'zihath', 'lodomijibuxoju', 'xasuwytextochypuli']) -> bool:\n    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['wesolotelunyzecemexi', 'pociquuwygocysahef', 'lequusigipitexti', 'quojuxaq', 'fyt', 'm', 'bavalepynoza', 'zihath', 'lodomijibuxoju', 'xasuwytextochypuli']):\n    return sorted(strings)[-2]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']) -> bool:\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[1][::-1]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['rawithelen', 'que', 'pikuf', 'koze', 'zehyquorofyxytextef', 'text', 'jezebox', 'zychopucebychokyz', 'pyzyxatevafugedix', 'buzogehabojyb']) -> bool:\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['rawithelen', 'que', 'pikuf', 'koze', 'zehyquorofyxytextef', 'text', 'jezebox', 'zychopucebychokyz', 'pyzyxatevafugedix', 'buzogehabojyb']):\n    return sorted(strings)[1][::-1]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']) -> bool:\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return sorted(strings)[1][::-1]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['habicynanikadifovac', 'bozehathyfoz', 'hud', 'textudunachuxarise', 'hewohahatazabab', 'lutumelimevabutha', 'wocher', 'wacifufixudizon', 'tazibedo', 'xytu']) -> bool:\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['habicynanikadifovac', 'bozehathyfoz', 'hud', 'textudunachuxarise', 'hewohahatazabab', 'lutumelimevabutha', 'wocher', 'wacifufixudizon', 'tazibedo', 'xytu']):\n    return sorted(strings)[1][::-1]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, strings=['vekykothumygochuth', 'xujatajazisiqu', 'vapyvymobymethotexto', 'tygope', 'g', 'ripalotextaj', 'tecehuthojodogucivaj', 'xyjulecometihesej', 'ribo', 'gutachowagexatoset']) -> bool:\n    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['vekykothumygochuth', 'xujatajazisiqu', 'vapyvymobymethotexto', 'tygope', 'g', 'ripalotextaj', 'tecehuthojodogucivaj', 'xyjulecometihesej', 'ribo', 'gutachowagexatoset']):\n    return sorted(strings)[1][::-1]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='foobarbazwow', length=6) -> bool:\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'foobarbazwow', length = 6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='rujus', length=1) -> bool:\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'rujus', length = 1):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='bulu', length=4) -> bool:\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'bulu', length = 4):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='defojuhujuwilumec', length=7) -> bool:\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'defojuhujuwilumec', length = 7):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, target='tenuhije', length=6) -> bool:\n    \"\"\"Find a substring of the given length centered within the target string.\"\"\"\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'tenuhije', length = 6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substring: str, string='moooboooofasd', count=2) -> bool:\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count\ndef g(string = 'moooboooofasd', count = 2):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substring: str, string='nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme', count=4) -> bool:\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count\ndef g(string = 'nyvyfytibuquyquuchudemixyzychumanachozyquiquowutextyvomyzychyme', count = 4):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substring: str, string='cokomoquiwythyluwamymothynihythenyfeteth', count=4) -> bool:\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count\ndef g(string = 'cokomoquiwythyluwamymothynihythenyfeteth', count = 4):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substring: str, string='cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count=3) -> bool:\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count\ndef g(string = 'cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count = 3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substring: str, string='modacequytextytextilaleguthovamipehywaciripetext', count=3) -> bool:\n    \"\"\"Find a substring with a certain count in a given string\"\"\"\n    return string.count(substring) == count\ndef g(string = 'modacequytextytextilaleguthovamipehywaciripetext', count = 3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='))(Add)some))parens()to()(balance(()(()(me!)((((') -> bool:\n    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = '))(Add)some))parens()to()(balance(()(()(me!)(((('):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='(po)(())kf((((cy()))((tex()())(') -> bool:\n    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = '(po)(())kf((((cy()))((tex()())('):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='yf)()(()))hik()t(((') -> bool:\n    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = 'yf)()(()))hik()t((('):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s=')((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k') -> bool:\n    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = ')((le(()()chu)())nol))((sic(((da)()ty((()te))xy(())))))k'):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(t: str, s='))())l') -> bool:\n    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = '))())l'):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=8, n=8) -> bool:\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 8, n = 8):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=9, n=6) -> bool:\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=59, n=4) -> bool:\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 59, n = 4):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=38, n=8) -> bool:\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 38, n = 8):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(squares: List[List[int]], m=9, n=4) -> bool:\n    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 4):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(tour: List[List[int]], m=8, n=8) -> bool:\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 8, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tour: List[List[int]], m=9, n=9) -> bool:\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 9, n = 9):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tour: List[List[int]], m=7, n=7) -> bool:\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 7):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tour: List[List[int]], m=6, n=6) -> bool:\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 6, n = 6):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(tour: List[List[int]], m=7, n=8) -> bool:\n    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], initial_state=[4, 1, 8, 0, 5, 9, 2, 0]) -> bool:\n    \"\"\"\n    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn\n    removing one or more objects from a single non-empty heap. The player who takes the last object wins.\n    - initial_state is list of numbers of objects in each heap\n    - moves is a list of your moves: [heap, number of objects to take]\n    - you play first\n    \"\"\"\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [4, 1, 8, 0, 5, 9, 2, 0]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], initial_state=[2, 5, 3, 7, 0]) -> bool:\n    \"\"\"\n    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn\n    removing one or more objects from a single non-empty heap. The player who takes the last object wins.\n    - initial_state is list of numbers of objects in each heap\n    - moves is a list of your moves: [heap, number of objects to take]\n    - you play first\n    \"\"\"\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [2, 5, 3, 7, 0]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n    \"\"\"\n    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn\n    removing one or more objects from a single non-empty heap. The player who takes the last object wins.\n    - initial_state is list of numbers of objects in each heap\n    - moves is a list of your moves: [heap, number of objects to take]\n    - you play first\n    \"\"\"\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(moves: List[List[int]], initial_state=[5, 8, 3, 0]) -> bool:\n    \"\"\"\n    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn\n    removing one or more objects from a single non-empty heap. The player who takes the last object wins.\n    - initial_state is list of numbers of objects in each heap\n    - moves is a list of your moves: [heap, number of objects to take]\n    - you play first\n    \"\"\"\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [5, 8, 3, 0]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(probs: List[float]) -> bool:\n    \"\"\"Find optimal probabilities for playing Rock-Paper-Scissors zero-sum game, with best worst-case guarantee\"\"\"\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-06\n    return max((probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3))) < 1e-06\ndef g():\n    return [1 / 3] * 3\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tri: List[int], edges=[[8, 0], [2, 7], [1, 2], [4, 5], [2, 1], [7, 1], [5, 6], [6, 3], [3, 8], [3, 4], [0, 1], [6, 6], [4, 0], [2, 8], [1, 5], [4, 2]]) -> bool:\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[8, 0], [2, 7], [1, 2], [4, 5], [2, 1], [7, 1], [5, 6], [6, 3], [3, 8], [3, 4], [0, 1], [6, 6], [4, 0], [2, 8], [1, 5], [4, 2]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(tri: List[int], edges=[[4, 4], [5, 5], [3, 5], [3, 1], [0, 1], [4, 0], [3, 2], [5, 3], [1, 3], [2, 5], [2, 0]]) -> bool:\n    \"\"\"Find any triangle in the given directed graph.\"\"\"\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[4, 4], [5, 5], [3, 5], [3, 1], [0, 1], [4, 0], [3, 2], [5, 3], [1, 3], [2, 5], [2, 0]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], weights=[{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound=11) -> bool:\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and (sum((weights[a][b] for (a, b) in zip(path, path[1:]))) <= bound)\ndef g(weights = [{1: 20, 2: 1}, {2: 2, 3: 5}, {1: 10}], bound = 11):\n    # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], weights=[{3: 210, 0: 513, 1: 66, 5: 612}, {0: 794, 1: 111, 3: 598}, {4: 295, 0: 601}, {}, {3: 452, 0: 689, 5: 124, 1: 406}, {2: 289, 5: 660, 3: 498}], bound=66) -> bool:\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and (sum((weights[a][b] for (a, b) in zip(path, path[1:]))) <= bound)\ndef g(weights = [{3: 210, 0: 513, 1: 66, 5: 612}, {0: 794, 1: 111, 3: 598}, {4: 295, 0: 601}, {}, {3: 452, 0: 689, 5: 124, 1: 406}, {2: 289, 5: 660, 3: 498}], bound = 66):\n    # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], weights=[{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound=239) -> bool:\n    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"\n    return path[0] == 0 and path[-1] == 1 and (sum((weights[a][b] for (a, b) in zip(path, path[1:]))) <= bound)\ndef g(weights = [{1: 239}, {0: 602, 2: 280}, {2: 293, 0: 816, 3: 925}, {}], bound = 239):\n    # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u=0, v=33, bound=3) -> bool:\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all(([i, j] in edges for (i, j) in zip(path, path[1:])))\n    return len(path) <= bound\ndef g(edges = [[0, 11], [0, 7], [7, 5], [0, 22], [11, 22], [11, 33], [22, 33]], u = 0, v = 33, bound = 3):\n    # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[1, 1], [2, 0], [1, 0], [2, 2]], u=1, v=1, bound=1) -> bool:\n    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == u and path[-1] == v and all(([i, j] in edges for (i, j) in zip(path, path[1:])))\n    return len(path) <= bound\ndef g(edges = [[1, 1], [2, 0], [1, 0], [2, 2]], u = 1, v = 1, bound = 1):\n    # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[0, 0]]) -> bool:\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[3, 5], [2, 1], [4, 5], [3, 6], [6, 7], [5, 3], [4, 3], [6, 2], [5, 2], [7, 0], [3, 4], [0, 5], [0, 0], [1, 0], [0, 2], [3, 1]]) -> bool:\n    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[3, 5], [2, 1], [4, 5], [3, 6], [6, 7], [5, 3], [4, 3], [6, 2], [5, 2], [7, 0], [3, 4], [0, 5], [0, 0], [1, 0], [0, 2], [3, 1]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(path: List[int], edges=[[3, 2], [2, 1], [0, 2], [1, 0], [2, 2], [2, 3], [2, 0]]) -> bool:\n    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[3, 2], [2, 1], [0, 2], [1, 0], [2, 2], [2, 3], [2, 0]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(p: List[int], edges=[[1, 6], [2, 3], [2, 7], [0, 8], [7, 8], [7, 2], [1, 5], [8, 7], [7, 0], [0, 0], [8, 1], [5, 7], [4, 7], [6, 1], [4, 4], [7, 4]]) -> bool:\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[1, 6], [2, 3], [2, 7], [0, 8], [7, 8], [7, 2], [1, 5], [8, 7], [7, 0], [0, 0], [8, 1], [5, 7], [4, 7], [6, 1], [4, 4], [7, 4]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(p: List[int], edges=[[4, 8], [7, 6], [2, 0], [3, 2], [6, 3], [4, 5], [11, 5], [11, 0], [1, 5], [12, 12], [12, 1], [4, 11], [3, 3], [2, 10], [10, 6], [0, 7], [2, 7], [6, 11], [2, 9], [7, 7], [8, 9], [2, 1], [4, 6], [9, 4]]) -> bool:\n    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[4, 8], [7, 6], [2, 0], [3, 2], [6, 3], [4, 5], [11, 5], [11, 0], [1, 5], [12, 12], [12, 1], [4, 11], [3, 3], [2, 10], [10, 6], [0, 7], [2, 7], [6, 11], [2, 9], [7, 7], [8, 9], [2, 1], [4, 6], [9, 4]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bi: List[int], g1=[[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2=[[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]) -> bool:\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for (i, j) in g1} == {(bi[i], bi[j]) for (i, j) in g2}\ndef g(g1 = [[0, 1], [1, 2], [2, 3], [3, 4], [2, 5]], g2 = [[0, 4], [1, 5], [4, 1], [1, 2], [2, 3]]):\n    # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\"\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(bi: List[int], g1=[[1, 0], [1, 1], [1, 2], [2, 1]], g2=[[0, 2], [2, 2], [2, 0], [2, 1]]) -> bool:\n    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"\n    return len(bi) == len(set(bi)) and {(i, j) for (i, j) in g1} == {(bi[i], bi[j]) for (i, j) in g2}\ndef g(g1 = [[1, 0], [1, 1], [1, 2], [2, 1]], g2 = [[0, 2], [2, 2], [2, 0], [2, 1]]):\n    # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\"\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(cut_position: int, ring='MvI', lower=0) -> bool:\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= 1 if matches[c] > 0 else len(line)\n        else:\n            matches[c.lower()] += 1\n    return sum((i == 0 for i in matches.values())) >= lower\ndef g(ring = 'MvI', lower = 0):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(cut_position: int, ring='s', lower=0) -> bool:\n    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= 1 if matches[c] > 0 else len(line)\n        else:\n            matches[c.lower()] += 1\n    return sum((i == 0 for i in matches.values())) >= lower\ndef g(ring = 's', lower = 0):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(indices: List[int], a0=123) -> bool:\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 123):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(indices: List[int], a0=2827347) -> bool:\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2827347):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(indices: List[int], a0=2362263) -> bool:\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(indices: List[int], a0=1703235) -> bool:\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 1703235):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(indices: List[int], a0=962856) -> bool:\n    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 962856):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], n=18) -> bool:\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 18):\n    return [-1, -1, 2] * (n // 3)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(li: List[int], n=3) -> bool:\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 3):\n    return [-1, -1, 2] * (n // 3)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(li: List[int], n=6) -> bool:\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 6):\n    return [-1, -1, 2] * (n // 3)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], n=9) -> bool:\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 9):\n    return [-1, -1, 2] * (n // 3)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(li: List[int], n=12) -> bool:\n    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 12):\n    return [-1, -1, 2] * (n // 3)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]) -> bool:\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:\n    $\\\\sum_{i \\\\in S} x_i = 1 (mod 2)$\n    \"\"\"\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [169, 203, 409, 50, 37, 479, 370, 133, 53, 159, 161, 367, 474, 107, 82, 447, 385]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:\n    $\\\\sum_{i \\\\in S} x_i = 1 (mod 2)$\n    \"\"\"\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[5, 6, 9, 55, 6, 31, 6, 16, 24, 41, 48, 28, 52, 23, 27]) -> bool:\n    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:\n    $\\\\sum_{i \\\\in S} x_i = 1 (mod 2)$\n    \"\"\"\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [5, 6, 9, 55, 6, 31, 6, 16, 24, 41, 48, 28, 52, 23, 27]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]) -> bool:\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\\\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [26, 5, 32, 3, 15, 18, 31, 13, 24, 25, 34, 5, 15, 24, 16, 13, 0, 27, 37]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\\\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[378, 819, 695, 649, 492, 277, 471, 241, 159, 733, 625, 355, 300, 241, 683, 445, 769, 167, 985, 346, 243, 546, 851, 476, 309]) -> bool:\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\\\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [378, 819, 695, 649, 492, 277, 471, 241, 159, 733, 625, 355, 300, 241, 683, 445, 769, 167, 985, 346, 243, 546, 851, 476, 309]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], vecs=[5, 7, 4, 5, 4, 3, 6, 5, 5, 0, 7]) -> bool:\n    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\\\in S} x_i = 1 (mod 2)$$\n    \"\"\"\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [5, 7, 4, 5, 4, 3, 6, 5, 5, 0, 7]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=15482, b=23223, lower_bound=5) -> bool:\n    \"\"\"Find a large common divisor of two integers.\"\"\"\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 15482, b = 23223, lower_bound = 5):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=9, b=9, lower_bound=6) -> bool:\n    \"\"\"Find a large common divisor of two integers.\"\"\"\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 9, b = 9, lower_bound = 6):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=232610, b=3131721474, lower_bound=15000) -> bool:\n    \"\"\"Find a large common divisor of two integers.\"\"\"\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 232610, b = 3131721474, lower_bound = 15000):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537) -> bool:\n    \"\"\"Find a large common divisor of two integers.\"\"\"\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 247586288427023352, b = 372021520735824432, lower_bound = 1709054537):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=8797233, b=2370036150831, lower_bound=8364173) -> bool:\n    \"\"\"Find a large common divisor of two integers.\"\"\"\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 8797233, b = 2370036150831, lower_bound = 8364173):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    \"\"\"Find a large common divisor of the list of integers.\"\"\"\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[14, 551755893, 902110495], lower_bound=1) -> bool:\n    \"\"\"Find a large common divisor of the list of integers.\"\"\"\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [14, 551755893, 902110495], lower_bound = 1):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[287260676668, 33263981357337, 47314720, 295717, 2957170], lower_bound=98647) -> bool:\n    \"\"\"Find a large common divisor of the list of integers.\"\"\"\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [287260676668, 33263981357337, 47314720, 295717, 2957170], lower_bound = 98647):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[452452, 111673658096, 83221402264, 5027670648, 61177116, 154154, 116116, 1508784124848, 17036343324, 29091062, 100726626], lower_bound=977) -> bool:\n    \"\"\"Find a large common divisor of the list of integers.\"\"\"\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [452452, 111673658096, 83221402264, 5027670648, 61177116, 154154, 116116, 1508784124848, 17036343324, 29091062, 100726626], lower_bound = 977):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[8154539588421190, 128861795], lower_bound=64216730) -> bool:\n    \"\"\"Find a large common divisor of the list of integers.\"\"\"\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [8154539588421190, 128861795], lower_bound = 64216730):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=15, b=27, upper_bound=150) -> bool:\n    \"\"\"Find a small common multiple of two integers.\"\"\"\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 15, b = 27, upper_bound = 150):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=41234205765, b=597597185, upper_bound=73349253728) -> bool:\n    \"\"\"Find a small common multiple of two integers.\"\"\"\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 41234205765, b = 597597185, upper_bound = 73349253728):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=7601351956456, b=2974663988, upper_bound=389421039754872576) -> bool:\n    \"\"\"Find a small common multiple of two integers.\"\"\"\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 7601351956456, b = 2974663988, upper_bound = 389421039754872576):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=201717041833890, b=3585167190, upper_bound=731493653565433) -> bool:\n    \"\"\"Find a small common multiple of two integers.\"\"\"\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 201717041833890, b = 3585167190, upper_bound = 731493653565433):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=79680, b=661339968, upper_bound=410128528659) -> bool:\n    \"\"\"Find a small common multiple of two integers.\"\"\"\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 79680, b = 661339968, upper_bound = 410128528659):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[15, 27, 102], upper_bound=5000) -> bool:\n    \"\"\"Find a small common multiple of a list of integers.\"\"\"\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [15, 27, 102], upper_bound = 5000):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    \"\"\"Find a small common multiple of a list of integers.\"\"\"\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[55040126016, 4373970014334], upper_bound=219074883886936) -> bool:\n    \"\"\"Find a small common multiple of a list of integers.\"\"\"\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [55040126016, 4373970014334], upper_bound = 219074883886936):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[9140, 4882496600, 119119770064, 107772494796, 102424668, 3656, 1188591500932, 116992, 14700627932, 997397016], upper_bound=238661269929569213628364588516267312050595558326272) -> bool:\n    \"\"\"Find a small common multiple of a list of integers.\"\"\"\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [9140, 4882496600, 119119770064, 107772494796, 102424668, 3656, 1188591500932, 116992, 14700627932, 997397016], upper_bound = 238661269929569213628364588516267312050595558326272):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, nums=[173261568, 4270662976], upper_bound=17025943527197098) -> bool:\n    \"\"\"Find a small common multiple of a list of integers.\"\"\"\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [173261568, 4270662976], upper_bound = 17025943527197098):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], n=12345) -> bool:\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], n=1) -> bool:\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 1):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(nums: List[int], n=0) -> bool:\n    \"\"\"Find four integers whose squares sum to n\"\"\"\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 0):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], k=5) -> bool:\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))\ndef g(k = 5):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], k=6) -> bool:\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))\ndef g(k = 6):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], k=7) -> bool:\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))\ndef g(k = 7):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(li: List[int], k=8) -> bool:\n    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))\ndef g(k = 8):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, t=197, upper=20) -> bool:\n    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper\ndef g(t = 197, upper = 20):\n    # Faster solution for simultaneously solving multiple problems is of course possible\n    bound = t + 10\n    while True:\n        bound *= 2\n        prev = {1}\n        seen = set()\n        for delay in range(t):\n            seen.update(prev)\n            curr = {2 * n for n in prev}\n            curr.update({(n - 1) // 3 for n in prev if n % 6 == 4})\n            prev = {n for n in curr if n <= bound} - seen\n        if prev:\n            return min(prev)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int) -> bool:\n    \"\"\"Find n  such that 2^n mod n = 3\"\"\"\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, year_len=365) -> bool:\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 365):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(n: int, year_len=60182) -> bool:\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 60182):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, year_len=2) -> bool:\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, year_len=3) -> bool:\n    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 3):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(counts: List[int], target_prob=0.5) -> bool:\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.5):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(counts: List[int], target_prob=0.1791044776119403) -> bool:\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.1791044776119403):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(counts: List[int], target_prob=0.03125) -> bool:\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.03125):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(counts: List[int], target_prob=0.5803571428571429) -> bool:\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.5803571428571429):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(st: str, a='world', b='Hello world') -> bool:\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b\ndef g(a = 'world', b = 'Hello world'):\n    return b[:len(b) - len(a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(st: str, a='zine', b='cerofilimybazine') -> bool:\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b\ndef g(a = 'zine', b = 'cerofilimybazine'):\n    return b[:len(b) - len(a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(st: str, a='id', b='xakid') -> bool:\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b\ndef g(a = 'id', b = 'xakid'):\n    return b[:len(b) - len(a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(st: str, a='dyr', b='dyr') -> bool:\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b\ndef g(a = 'dyr', b = 'dyr'):\n    return b[:len(b) - len(a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(st: str, a='s', b='tos') -> bool:\n    \"\"\"Solve simple string addition problem.\"\"\"\n    return st + a == b\ndef g(a = 's', b = 'tos'):\n    return b[:len(b) - len(a)]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=1000) -> bool:\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n\ndef g(n = 1000):\n    return 'a' * n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=39) -> bool:\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n\ndef g(n = 39):\n    return 'a' * n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=790) -> bool:\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n\ndef g(n = 790):\n    return 'a' * n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=485) -> bool:\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n\ndef g(n = 485):\n    return 'a' * n\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, n=4031) -> bool:\n    \"\"\"Find a string of length n\"\"\"\n    return len(s) == n\ndef g(n = 4031):\n    return 'a' * n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], s='hello world', target='do') -> bool:\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'hello world', target = 'do'):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], s='ninykofiwimninykofiwim', target='') -> bool:\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'ninykofiwimninykofiwim', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], s='limerybinylimerybiny', target='n') -> bool:\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'limerybinylimerybiny', target = 'n'):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], s='fyzihurothevirechahfyzihurothevirechah', target='') -> bool:\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'fyzihurothevirechahfyzihurothevirechah', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], s='kibozekiboze', target='') -> bool:\n    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'kibozekiboze', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, big_str='foobar', index=2) -> bool:\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index\ndef g(big_str = 'foobar', index = 2):\n    return big_str[index:]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, big_str='fukulagatextuj', index=10) -> bool:\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index\ndef g(big_str = 'fukulagatextuj', index = 10):\n    return big_str[index:]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, big_str='nunalurejijunopyrewithocukopojot', index=12) -> bool:\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index\ndef g(big_str = 'nunalurejijunopyrewithocukopojot', index = 12):\n    return big_str[index:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, big_str='fu', index=1) -> bool:\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index\ndef g(big_str = 'fu', index = 1):\n    return big_str[index:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, big_str='fatextemedyrotichipicecojon', index=24) -> bool:\n    \"\"\"Find a string whose *first* index in big_str is index\"\"\"\n    return big_str.index(s) == index\ndef g(big_str = 'fatextemedyrotichipicecojon', index = 24):\n    return big_str[index:]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(big_str: str, sub_str='foobar', index=2) -> bool:\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'foobar', index = 2):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(big_str: str, sub_str='quadox', index=75) -> bool:\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'quadox', index = 75):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(big_str: str, sub_str='votextymuvethic', index=880) -> bool:\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'votextymuvethic', index = 880):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(big_str: str, sub_str='pyrumymasekalihochyvibisamaquythifedetextityvath', index=0) -> bool:\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'pyrumymasekalihochyvibisamaquythifedetextityvath', index = 0):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(big_str: str, sub_str='nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index=185) -> bool:\n    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index = 185):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a='hello', b='yellow', length=4) -> bool:\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'hello', b = 'yellow', length = 4):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a='vuzogaguzechicowejeguthemeralic', b='kybyjifidoquifwejeguthemelihitextodeju', length=11) -> bool:\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'vuzogaguzechicowejeguthemeralic', b = 'kybyjifidoquifwejeguthemelihitextodeju', length = 11):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a='kehorithxyfurexatextoxivuquunusethawatextebu', b='pxyfurexatextoxivuquuwynicixo', length=20) -> bool:\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'kehorithxyfurexatextoxivuquunusethawatextebu', b = 'pxyfurexatextoxivuquuwynicixo', length = 20):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a='bafywihequyjicivicharyquynikixuhinyqu', b='syrapetagecvicharyquynirorazecheth', length=12) -> bool:\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'bafywihequyjicivicharyquynikixuhinyqu', b = 'syrapetagecvicharyquynirorazecheth', length = 12):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a='diquatextaxubowafucevyhuquuthexitacavobychajexytextug', b='thachevolatvyhuquuthexitacavobyjokobuchudymal', length=20) -> bool:\n    \"\"\"Find a string of length length that is in both strings a and b\"\"\"\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'diquatextaxubowafucevyhuquuthexitacavobychajexytextug', b = 'thachevolatvyhuquuthexitacavobyjokobuchudymal', length = 20):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substrings: List[str], s='hello', count=15) -> bool:\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'hello', count = 15):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substrings: List[str], s='rywixekugagethathulisitextanyp', count=451) -> bool:\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'rywixekugagethathulisitextanyp', count = 451):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substrings: List[str], s='xetyvezitajithiban', count=165) -> bool:\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'xetyvezitajithiban', count = 165):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substrings: List[str], s='rofegakusaquybemydomimibyzodycetextunoce', count=799) -> bool:\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'rofegakusaquybemydomimibyzodycetextunoce', count = 799):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(substrings: List[str], s='thacyt', count=21) -> bool:\n    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'thacyt', count = 21):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(string: str, substring='a', count=10, length=100) -> bool:\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'a', count = 10, length = 100):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(string: str, substring='ky', count=66, length=133) -> bool:\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'ky', count = 66, length = 133):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(string: str, substring='jepy', count=87, length=650) -> bool:\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'jepy', count = 87, length = 650):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(string: str, substring='hothyfyt', count=3, length=417) -> bool:\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'hothyfyt', count = 3, length = 417):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(string: str, substring='moz', count=70, length=210) -> bool:\n    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'moz', count = 70, length = 210):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, parts=['I!!', '!love', 'dumplings', '!', ''], string='I!!!!!love!!dumplings!!!!!') -> bool:\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string\ndef g(parts = ['I!!', '!love', 'dumplings', '!', ''], string = 'I!!!!!love!!dumplings!!!!!'):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, parts=['tatext'], string='tatext') -> bool:\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string\ndef g(parts = ['tatext'], string = 'tatext'):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, parts=[], string='') -> bool:\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string\ndef g(parts = [], string = ''):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, parts=['ruquug'], string='ruquug') -> bool:\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string\ndef g(parts = ['ruquug'], string = 'ruquug'):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: str, parts=['numegixuly', 'koxyfihimurukothasyl'], string='numegixulypyjetkoxyfihimurukothasyl') -> bool:\n    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"\n    return x.join(parts) == string\ndef g(parts = ['numegixuly', 'koxyfihimurukothasyl'], string = 'numegixulypyjetkoxyfihimurukothasyl'):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(parts: List[str], sep='!!', string='I!!!!!love!!dumplings!!!!!') -> bool:\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = '!!', string = 'I!!!!!love!!dumplings!!!!!'):\n    return string.split(sep)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(parts: List[str], sep='jachasurobithu', string='watalachyquujachasurobithuba') -> bool:\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = 'jachasurobithu', string = 'watalachyquujachasurobithuba'):\n    return string.split(sep)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(parts: List[str], sep='xusoquyvamathila', string='bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji') -> bool:\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = 'xusoquyvamathila', string = 'bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji'):\n    return string.split(sep)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(parts: List[str], sep='chixachal', string='') -> bool:\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = 'chixachal', string = ''):\n    return string.split(sep)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(parts: List[str], sep='lochuv', string='biflochuvzulothanodugedusilochuvlilochuvhobegikofero') -> bool:\n    \"\"\"Find parts that when joined give a specific string.\"\"\"\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = 'lochuv', string = 'biflochuvzulothanodugedusilochuvlilochuvhobegikofero'):\n    return string.split(sep)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], dups=42155) -> bool:\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups\ndef g(dups = 42155):\n    return [1] * (dups + 1)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], dups=18793) -> bool:\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups\ndef g(dups = 18793):\n    return [1] * (dups + 1)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], dups=70976) -> bool:\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups\ndef g(dups = 70976):\n    return [1] * (dups + 1)\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], dups=23476) -> bool:\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], dups=17633) -> bool:\n    \"\"\"Find a list with a certain number of duplicate items\"\"\"\n    return len(set(li)) == len(li) - dups\ndef g(dups = 17633):\n    return [1] * (dups + 1)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], target=[17, 9, -1, 17, 9, -1], n=2) -> bool:\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target\ndef g(target = [17, 9, -1, 17, 9, -1], n = 2):\n    if n == 0:\n        return []\n    return target[:len(target) // n]\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], target=[-69358, -69358, -69358, -69358, -69358, -69358, -69358], n=7) -> bool:\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target\ndef g(target = [-69358, -69358, -69358, -69358, -69358, -69358, -69358], n = 7):\n    if n == 0:\n        return []\n    return target[:len(target) // n]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(li: List[int], target=[], n=0) -> bool:\n    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"\n    return li * n == target\ndef g(target = [], n = 0):\n    if n == 0:\n        return []\n    return target[:len(target) // n]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[-62, -29, 73, -21, -45, -20, -74, -69, 30, -25, 16, 82, -31, 93, -20, 75, 68, 86], target=73) -> bool:\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target\ndef g(li = [-62, -29, 73, -21, -45, -20, -74, -69, 30, -25, 16, 82, -31, 93, -20, 75, 68, 86], target = 73):\n    return li.index(target)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[99, 51, -28, -69, -90, -15, 7, -67], target=51) -> bool:\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target\ndef g(li = [99, 51, -28, -69, -90, -15, 7, -67], target = 51):\n    return li.index(target)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[-68, 81, 13, -5, 81, 75, -3, -73, -89, 72], target=13) -> bool:\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target\ndef g(li = [-68, 81, 13, -5, 81, 75, -3, -73, -89, 72], target = 13):\n    return li.index(target)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[51, -68, -57, 8, 77, -80, -28, -24, 11, 40, 57, 60, 53], target=11) -> bool:\n    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"\n    return li[i] == target\ndef g(li = [51, -68, -57, 8, 77, -80, -28, -24, 11, 40, 57, 60, 53], target = 11):\n    return li.index(target)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=91) -> bool:\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 91):\n    return li.index(target) - len(li)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[78, 91, -67, -5, 30, -42, 68, 32, 96, -55, -39, -46, 90], target=-39) -> bool:\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0\ndef g(li = [78, 91, -67, -5, 30, -42, 68, 32, 96, -55, -39, -46, 90], target = -39):\n    return li.index(target) - len(li)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42) -> bool:\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0\ndef g(li = [-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target = -42):\n    return li.index(target) - len(li)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[41, -52, -40, -35, 53, -98, 83, 63, -18, 74, -8, -93, -3, 22, 30], target=53) -> bool:\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0\ndef g(li = [41, -52, -40, -35, 53, -98, 83, 63, -18, 74, -8, -93, -3, 22, 30], target = 53):\n    return li.index(target) - len(li)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(i: int, li=[95, 51, 76, 63, -97, -32], target=-32) -> bool:\n    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"\n    return li[i] == target and i < 0\ndef g(li = [95, 51, 76, 63, -97, -32], target = -32):\n    return li.index(target) - len(li)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], li=[42, 18, 21, 103, -2, 11], target=[-2, 21, 42]) -> bool:\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [42, 18, 21, 103, -2, 11], target = [-2, 21, 42]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], li=[-11, 92, 42, 18, -83, 55, 13, 14, -67, -58, -41], target=[-67]) -> bool:\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [-11, 92, 42, 18, -83, 55, 13, 14, -67, -58, -41], target = [-67]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], li=[-53, -81, -92, 22, -67], target=[-53, -81, -92]) -> bool:\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [-53, -81, -92, 22, -67], target = [-53, -81, -92]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]) -> bool:\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [-72, 70, 50, -41, 94, -82, -74, 8, -23], target = [-82]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(inds: List[int], li=[26, -25, -18, -53, 18, -71, -82, 20, -100, -84, -85], target=[-25]) -> bool:\n    \"\"\"Find three slice indices to achieve a given list slice\"\"\"\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [26, -25, -18, -53, 18, -71, -82, 20, -100, -84, -85], target = [-25]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a=['cat', 'dot', 'bird'], b=['tree', 'fly', 'dot']) -> bool:\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b\ndef g(a = ['cat', 'dot', 'bird'], b = ['tree', 'fly', 'dot']):\n    return next(s for s in b if s in a)\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str, a=['quisolu', 'nixyquigaseq', 'fawaholafojelaxud', 'cuxoniso', 'defejaz', 'mytext', 'gochavowetheva', 'xijehychojexat', 'duthagobejudozi', 'thiquijuquorybu'], b=['cys', 'zatext', 'cifihihechujozimo', 'jycichithetyk', 'becitonamuhuligyv', 'sadak', 'hochavinapatanapiz', 'fiwidifop', 'funidosikeput', 'fewat', 'mypyhalevituvit', 'quytynuthothy', 'c', 'zydecodul', 'vahychuke', 'wy', 'mytext', 'tex', 'quevasowodique', 'hythiquunymychilyl', 'luxivyvocuwa']) -> bool:\n    \"\"\"Find an item that is in both lists a and b\"\"\"\n    return s in a and s in b\ndef g(a = ['quisolu', 'nixyquigaseq', 'fawaholafojelaxud', 'cuxoniso', 'defejaz', 'mytext', 'gochavowetheva', 'xijehychojexat', 'duthagobejudozi', 'thiquijuquorybu'], b = ['cys', 'zatext', 'cifihihechujozimo', 'jycichithetyk', 'becitonamuhuligyv', 'sadak', 'hochavinapatanapiz', 'fiwidifop', 'funidosikeput', 'fewat', 'mypyhalevituvit', 'quytynuthothy', 'c', 'zydecodul', 'vahychuke', 'wy', 'mytext', 'tex', 'quevasowodique', 'hythiquunymychilyl', 'luxivyvocuwa']):\n    return next(s for s in b if s in a)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=93252338) -> bool:\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a\ndef g(a = 93252338):\n    return - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-7788910835979672) -> bool:\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a\ndef g(a = -7788910835979672):\n    return - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=6734672221833987) -> bool:\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a\ndef g(a = 6734672221833987):\n    return - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-6405550227918699) -> bool:\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a\ndef g(a = -6405550227918699):\n    return - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-5741705983914418) -> bool:\n    \"\"\"Solve a unary negation problem\"\"\"\n    return -x == a\ndef g(a = -5741705983914418):\n    return - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=1073258, b=72352549) -> bool:\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b\ndef g(a = 1073258, b = 72352549):\n    return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=7176599374880969, b=1013347182263591) -> bool:\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b\ndef g(a = 7176599374880969, b = 1013347182263591):\n    return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-6408240447142191, b=7741323537672506) -> bool:\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b\ndef g(a = -6408240447142191, b = 7741323537672506):\n    return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=1918969259925371, b=3648647147996329) -> bool:\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b\ndef g(a = 1918969259925371, b = 3648647147996329):\n    return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=6476308373242647, b=-1096573562602401) -> bool:\n    \"\"\"Solve a sum problem\"\"\"\n    return a + x == b\ndef g(a = 6476308373242647, b = -1096573562602401):\n    return b - a\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-382, b=14546310) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b\ndef g(a = -382, b = 14546310):\n    return a + b\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=4461955033869751, b=-3951840325269410) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b\ndef g(a = 4461955033869751, b = -3951840325269410):\n    return a + b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=9688203125538303, b=-293093369321912) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b\ndef g(a = 9688203125538303, b = -293093369321912):\n    return a + b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-8057207922876252, b=-3934955257447294) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b\ndef g(a = -8057207922876252, b = -3934955257447294):\n    return a + b\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-5902383651753979, b=304676399871652) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return x - a == b\ndef g(a = -5902383651753979, b = 304676399871652):\n    return a + b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=8665464, b=-93206) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b\ndef g(a = 8665464, b = -93206):\n    return a - b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=1954051265970332, b=1312727165482691) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b\ndef g(a = 1954051265970332, b = 1312727165482691):\n    return a - b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-1159353965692778, b=4654551691407885) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b\ndef g(a = -1159353965692778, b = 4654551691407885):\n    return a - b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=7793575617602525, b=-4351726326349125) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b\ndef g(a = 7793575617602525, b = -4351726326349125):\n    return a - b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=-8783800228130606, b=-508993556991975) -> bool:\n    \"\"\"Solve a subtraction problem\"\"\"\n    return a - x == b\ndef g(a = -8783800228130606, b = -508993556991975):\n    return a - b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=14302, b=5) -> bool:\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + a % b == a\ndef g(a = 14302, b = 5):\n    return a // b\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            1.0
        ]
    },
    {
        "program_str": "def f(n: int, a=-646156, b=-63) -> bool:\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + a % b == a\ndef g(a = -646156, b = -63):\n    return a // b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=159568, b=59) -> bool:\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + a % b == a\ndef g(a = 159568, b = 59):\n    return a // b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=-141336, b=72) -> bool:\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + a % b == a\ndef g(a = -141336, b = 72):\n    return a // b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=855955, b=33) -> bool:\n    \"\"\"Solve a multiplication problem\"\"\"\n    return b * n + a % b == a\ndef g(a = 855955, b = 33):\n    return a // b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=3, b=23463462) -> bool:\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a\ndef g(a = 3, b = 23463462):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=-1, b=1594400229362061) -> bool:\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a\ndef g(a = -1, b = 1594400229362061):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=12, b=-9988218457242775) -> bool:\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a\ndef g(a = 12, b = -9988218457242775):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=0, b=-1230085432451862) -> bool:\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a\ndef g(a = 0, b = -1230085432451862):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=1, b=9554566410382856) -> bool:\n    \"\"\"Solve a division problem\"\"\"\n    return b // n == a\ndef g(a = 1, b = 9554566410382856):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=345346363, b=10) -> bool:\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a\ndef g(a = 345346363, b = 10):\n    return a * b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=-3411193412414137, b=-9070455318026063) -> bool:\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a\ndef g(a = -3411193412414137, b = -9070455318026063):\n    return a * b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=-1950797984487873, b=6211965468307518) -> bool:\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a\ndef g(a = -1950797984487873, b = 6211965468307518):\n    return a * b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=1186580710227962, b=5023840456205809) -> bool:\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a\ndef g(a = 1186580710227962, b = 5023840456205809):\n    return a * b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int, a=6976962948831358, b=7353202892973126) -> bool:\n    \"\"\"Find n that when divided by b is a\"\"\"\n    return n // b == a\ndef g(a = 6976962948831358, b = 7353202892973126):\n    return a * b\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=10201202001) -> bool:\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a\ndef g(a = 10201202001):\n    return int(a ** 0.5)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=2617350631613713636) -> bool:\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a\ndef g(a = 2617350631613713636):\n    return int(a ** 0.5)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=100703210763886864) -> bool:\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a\ndef g(a = 100703210763886864):\n    return int(a ** 0.5)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=12515426721927424) -> bool:\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a\ndef g(a = 12515426721927424):\n    return int(a ** 0.5)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: int, a=717898768141464900) -> bool:\n    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"\n    return x ** 2 == a\ndef g(a = 717898768141464900):\n    return int(a ** 0.5)\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=1020) -> bool:\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 1020):\n    return a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=6173281296) -> bool:\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 6173281296):\n    return a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=7987622700) -> bool:\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 7987622700):\n    return a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=2732656229) -> bool:\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 2732656229):\n    return a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=1873585696) -> bool:\n    \"\"\"Find a number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 1873585696):\n    return a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=1020) -> bool:\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1020):\n    return -a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=2681275499) -> bool:\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 2681275499):\n    return -a ** 0.5\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=1363713245) -> bool:\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1363713245):\n    return -a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=3858703402) -> bool:\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 3858703402):\n    return -a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: float, a=3804892221) -> bool:\n    \"\"\"Find a negative number that when squared is close to a.\"\"\"\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 3804892221):\n    return -a ** 0.5\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0
        ]
    },
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return 'Hello ' + s == 'Hello world'\ndef g():\n    return \"world\"\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: str) -> bool:\n    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"\n    return 'Hello ' + s[::-1] == 'Hello world'\ndef g():\n    return \"world\"[::-1]\nassert f(g())",
        "emb": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(x: List[int]) -> bool:\n    \"\"\"Find a list of two integers whose sum is 3.\"\"\"\n    return len(x) == 2 and sum(x) == 3\ndef g():\n    return [1, 2]\nassert f(g())",
        "emb": [
            1.0,
            1.0,
            0.0,
            0.0,
            0.0,
            1.0,
            0.0,
            1.0,
            1.0,
            0.0
        ]
    },
    {
        "program_str": "def f(s: List[str]) -> bool:\n    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"\n    return len(set(s)) == 1000 and all((x.count('a') > x.count('b') and 'b' in x for x in s))\ndef g():\n    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]\nassert f(g())",
        "emb": [
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    },
    {
        "program_str": "def f(n: int) -> bool:\n    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"\n    return str(n * n).startswith('123456789')\ndef g():\n    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1\nassert f(g())",
        "emb": [
            1.0,
            0.0,
            1.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
        ]
    }
]